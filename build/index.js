
(function(l, i, v, e) { v = l.createElement(i); v.async = 1; v.src = '//' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; e = l.getElementsByTagName(i)[0]; e.parentNode.insertBefore(v, e)})(document, 'script');
function toArray(objectOrArray) {
  objectOrArray = objectOrArray || [];
  return Array.isArray(objectOrArray) ? objectOrArray : [objectOrArray];
}

function log(msg) {
  return `[Vaadin.Router] ${msg}`;
}

function logValue(value) {
  if (typeof value !== 'object') {
    return String(value);
  }

  const stringType = Object.prototype.toString.call(value).match(/ (.*)\]$/)[1];

  if (stringType === 'Object' || stringType === 'Array') {
    return `${stringType} ${JSON.stringify(value)}`;
  } else {
    return stringType;
  }
}

const MODULE = 'module';
const NOMODULE = 'nomodule';
const bundleKeys = [MODULE, NOMODULE];

function ensureBundle(src) {
  if (!src.match(/.+\.[m]?js$/)) {
    throw new Error(log(`Unsupported type for bundle "${src}": .js or .mjs expected.`));
  }
}

function ensureRoute(route) {
  if (!route || !isString(route.path)) {
    throw new Error(log(`Expected route config to be an object with a "path" string property, or an array of such objects`));
  }

  const bundle = route.bundle;
  const stringKeys = ['component', 'redirect', 'bundle'];

  if (!isFunction(route.action) && !Array.isArray(route.children) && !isFunction(route.children) && !isObject(bundle) && !stringKeys.some(key => isString(route[key]))) {
    throw new Error(log(`Expected route config "${route.path}" to include either "${stringKeys.join('", "')}" ` + `or "action" function but none found.`));
  }

  if (bundle) {
    if (isString(bundle)) {
      ensureBundle(bundle);
    } else if (!bundleKeys.some(key => key in bundle)) {
      throw new Error(log('Expected route bundle to include either "' + NOMODULE + '" or "' + MODULE + '" keys, or both'));
    } else {
      bundleKeys.forEach(key => key in bundle && ensureBundle(bundle[key]));
    }
  }

  if (route.redirect) {
    ['bundle', 'component'].forEach(overriddenProp => {
      if (overriddenProp in route) {
        console.warn(log(`Route config "${route.path}" has both "redirect" and "${overriddenProp}" properties, ` + `and "redirect" will always override the latter. Did you mean to only use "${overriddenProp}"?`));
      }
    });
  }
}

function ensureRoutes(routes) {
  toArray(routes).forEach(route => ensureRoute(route));
}

function loadScript(src, key) {
  let script = document.head.querySelector('script[src="' + src + '"][async]');

  if (!script) {
    script = document.createElement('script');
    script.setAttribute('src', src);

    if (key === MODULE) {
      script.setAttribute('type', MODULE);
    } else if (key === NOMODULE) {
      script.setAttribute(NOMODULE, '');
    }

    script.async = true;
  }

  return new Promise((resolve, reject) => {
    script.onreadystatechange = script.onload = e => {
      script.__dynamicImportLoaded = true;
      resolve(e);
    };

    script.onerror = e => {
      if (script.parentNode) {
        script.parentNode.removeChild(script);
      }

      reject(e);
    };

    if (script.parentNode === null) {
      document.head.appendChild(script);
    } else if (script.__dynamicImportLoaded) {
      resolve();
    }
  });
}

function loadBundle(bundle) {
  if (isString(bundle)) {
    return loadScript(bundle);
  } else {
    return Promise.race(bundleKeys.filter(key => key in bundle).map(key => loadScript(bundle[key], key)));
  }
}

function fireRouterEvent(type, detail) {
  return !window.dispatchEvent(new CustomEvent(`vaadin-router-${type}`, {
    cancelable: type === 'go',
    detail
  }));
}

function isObject(o) {
  // guard against null passing the typeof check
  return typeof o === 'object' && !!o;
}

function isFunction(f) {
  return typeof f === 'function';
}

function isString(s) {
  return typeof s === 'string';
}

function getNotFoundError(context) {
  const error = new Error(log(`Page not found (${context.pathname})`));
  error.context = context;
  error.code = 404;
  return error;
}

const notFoundResult = new class NotFoundResult {}();
/* istanbul ignore next: coverage is calculated in Chrome, this code is for IE */

function getAnchorOrigin(anchor) {
  // IE11: on HTTP and HTTPS the default port is not included into
  // window.location.origin, so won't include it here either.
  const port = anchor.port;
  const protocol = anchor.protocol;
  const defaultHttp = protocol === 'http:' && port === '80';
  const defaultHttps = protocol === 'https:' && port === '443';
  const host = defaultHttp || defaultHttps ? anchor.hostname // does not include the port number (e.g. www.example.org)
  : anchor.host; // does include the port number (e.g. www.example.org:80)

  return `${protocol}//${host}`;
} // The list of checks is not complete:
//  - SVG support is missing
//  - the 'rel' attribute is not considered


function vaadinRouterGlobalClickHandler(event) {
  // ignore the click if the default action is prevented
  if (event.defaultPrevented) {
    return;
  } // ignore the click if not with the primary mouse button


  if (event.button !== 0) {
    return;
  } // ignore the click if a modifier key is pressed


  if (event.shiftKey || event.ctrlKey || event.altKey || event.metaKey) {
    return;
  } // find the <a> element that the click is at (or within)


  let anchor = event.target;
  const path = event.composedPath ? event.composedPath() : event.path || []; // FIXME(web-padawan): `Symbol.iterator` used by webcomponentsjs is broken for arrays
  // example to check: `for...of` loop here throws the "Not yet implemented" error

  for (let i = 0; i < path.length; i++) {
    const target = path[i];

    if (target.nodeName && target.nodeName.toLowerCase() === 'a') {
      anchor = target;
      break;
    }
  }

  while (anchor && anchor.nodeName.toLowerCase() !== 'a') {
    anchor = anchor.parentNode;
  } // ignore the click if not at an <a> element


  if (!anchor || anchor.nodeName.toLowerCase() !== 'a') {
    return;
  } // ignore the click if the <a> element has a non-default target


  if (anchor.target && anchor.target.toLowerCase() !== '_self') {
    return;
  } // ignore the click if the <a> element has the 'download' attribute


  if (anchor.hasAttribute('download')) {
    return;
  } // ignore the click if the target URL is a fragment on the current page


  if (anchor.pathname === window.location.pathname && anchor.hash !== '') {
    return;
  } // ignore the click if the target is external to the app
  // In IE11 HTMLAnchorElement does not have the `origin` property


  const origin = anchor.origin || getAnchorOrigin(anchor);

  if (origin !== window.location.origin) {
    return;
  } // if none of the above, convert the click into a navigation event


  if (fireRouterEvent('go', {
    pathname: anchor.pathname
  })) {
    event.preventDefault();
  }
}
/**
 * A navigation trigger for Vaadin Router that translated clicks on `<a>` links
 * into Vaadin Router navigation events.
 *
 * Only regular clicks on in-app links are translated (primary mouse button, no
 * modifier keys, the target href is within the app's URL space).
 *
 * @memberOf Vaadin.Router.Triggers
 * @type {NavigationTrigger}
 */


const CLICK = {
  activate() {
    window.document.addEventListener('click', vaadinRouterGlobalClickHandler);
  },

  inactivate() {
    window.document.removeEventListener('click', vaadinRouterGlobalClickHandler);
  }

}; // PopStateEvent constructor shim

const isIE = /Trident/.test(navigator.userAgent);
/* istanbul ignore next: coverage is calculated in Chrome, this code is for IE */

if (isIE && !isFunction(window.PopStateEvent)) {
  window.PopStateEvent = function (inType, params) {
    params = params || {};
    var e = document.createEvent('Event');
    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
    e.state = params.state || null;
    return e;
  };

  window.PopStateEvent.prototype = window.Event.prototype;
}

function vaadinRouterGlobalPopstateHandler(event) {
  if (event.state === 'vaadin-router-ignore') {
    return;
  }

  fireRouterEvent('go', {
    pathname: window.location.pathname
  });
}
/**
 * A navigation trigger for Vaadin Router that translates popstate events into
 * Vaadin Router navigation events.
 *
 * @memberOf Vaadin.Router.Triggers
 * @type {NavigationTrigger}
 */


const POPSTATE = {
  activate() {
    window.addEventListener('popstate', vaadinRouterGlobalPopstateHandler);
  },

  inactivate() {
    window.removeEventListener('popstate', vaadinRouterGlobalPopstateHandler);
  }

};
/**
 * Expose `pathToRegexp`.
 */

var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;
/**
 * Default configs.
 */

var DEFAULT_DELIMITER = '/';
var DEFAULT_DELIMITERS = './';
/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */

var PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)', // Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined]
'(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'].join('|'), 'g');
/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */

function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || DEFAULT_DELIMITER;
  var delimiters = options && options.delimiters || DEFAULT_DELIMITERS;
  var pathEscaped = false;
  var res;

  while ((res = PATH_REGEXP.exec(str)) !== null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length; // Ignore already escaped sequences.

    if (escaped) {
      path += escaped[1];
      pathEscaped = true;
      continue;
    }

    var prev = '';
    var next = str[index];
    var name = res[2];
    var capture = res[3];
    var group = res[4];
    var modifier = res[5];

    if (!pathEscaped && path.length) {
      var k = path.length - 1;

      if (delimiters.indexOf(path[k]) > -1) {
        prev = path[k];
        path = path.slice(0, k);
      }
    } // Push the current path onto the tokens.


    if (path) {
      tokens.push(path);
      path = '';
      pathEscaped = false;
    }

    var partial = prev !== '' && next !== undefined && next !== prev;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = prev || defaultDelimiter;
    var pattern = capture || group;
    tokens.push({
      name: name || key++,
      prefix: prev,
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'
    });
  } // Push any remaining characters.


  if (path || index < str.length) {
    tokens.push(path + str.substr(index));
  }

  return tokens;
}
/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */


function compile(str, options) {
  return tokensToFunction(parse(str, options));
}
/**
 * Expose a method for transforming tokens into the path function.
 */


function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length); // Compile all the patterns before compilation.

  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (data, options) {
    var path = '';
    var encode = options && options.encode || encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;
        continue;
      }

      var value = data ? data[token.name] : undefined;
      var segment;

      if (Array.isArray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but got array');
        }

        if (value.length === 0) {
          if (token.optional) continue;
          throw new TypeError('Expected "' + token.name + '" to not be empty');
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j], token);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
        segment = encode(String(value), token);

        if (!matches[i].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
        }

        path += token.prefix + segment;
        continue;
      }

      if (token.optional) {
        // Prepend partial segment prefixes.
        if (token.partial) path += token.prefix;
        continue;
      }

      throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? 'an array' : 'a string'));
    }

    return path;
  };
}
/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */


function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
}
/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */


function escapeGroup(group) {
  return group.replace(/([=!:$/()])/g, '\\$1');
}
/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */


function flags(options) {
  return options && options.sensitive ? '' : 'i';
}
/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {Array=}  keys
 * @return {!RegExp}
 */


function regexpToRegexp(path, keys) {
  if (!keys) return path; // Use a negative lookahead to match only capturing groups.

  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        pattern: null
      });
    }
  }

  return path;
}
/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */


function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  return new RegExp('(?:' + parts.join('|') + ')', flags(options));
}
/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */


function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}  tokens
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */


function tokensToRegExp(tokens, keys, options) {
  options = options || {};
  var strict = options.strict;
  var end = options.end !== false;
  var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);
  var delimiters = options.delimiters || DEFAULT_DELIMITERS;
  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');
  var route = '';
  var isEndDelimited = tokens.length === 0; // Iterate over the tokens and create our regexp string.

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
      isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1;
    } else {
      var prefix = escapeString(token.prefix);
      var capture = token.repeat ? '(?:' + token.pattern + ')(?:' + prefix + '(?:' + token.pattern + '))*' : token.pattern;
      if (keys) keys.push(token);

      if (token.optional) {
        if (token.partial) {
          route += prefix + '(' + capture + ')?';
        } else {
          route += '(?:' + prefix + '(' + capture + '))?';
        }
      } else {
        route += prefix + '(' + capture + ')';
      }
    }
  }

  if (end) {
    if (!strict) route += '(?:' + delimiter + ')?';
    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';
  } else {
    if (!strict) route += '(?:' + delimiter + '(?=' + endsWith + '))?';
    if (!isEndDelimited) route += '(?=' + delimiter + '|' + endsWith + ')';
  }

  return new RegExp('^' + route, flags(options));
}
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {Array=}                keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */


function pathToRegexp(path, keys, options) {
  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys);
  }

  if (Array.isArray(path)) {
    return arrayToRegexp(
    /** @type {!Array} */
    path, keys, options);
  }

  return stringToRegexp(
  /** @type {string} */
  path, keys, options);
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;
/**
 * Universal Router (https://www.kriasoft.com/universal-router/)
 *
 * Copyright (c) 2015-present Kriasoft.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

const {
  hasOwnProperty
} = Object.prototype;
const cache = new Map(); // see https://github.com/pillarjs/path-to-regexp/issues/148

cache.set('|false', {
  keys: [],
  pattern: /(?:)/
});

function decodeParam(val) {
  try {
    return decodeURIComponent(val);
  } catch (err) {
    return val;
  }
}

function matchPath(routepath, path, exact, parentKeys, parentParams) {
  exact = !!exact;
  const cacheKey = `${routepath}|${exact}`;
  let regexp = cache.get(cacheKey);

  if (!regexp) {
    const keys = [];
    regexp = {
      keys,
      pattern: pathToRegexp_1(routepath, keys, {
        end: exact,
        strict: routepath === ''
      })
    };
    cache.set(cacheKey, regexp);
  }

  const m = regexp.pattern.exec(path);

  if (!m) {
    return null;
  }

  const params = Object.assign({}, parentParams);

  for (let i = 1; i < m.length; i++) {
    const key = regexp.keys[i - 1];
    const prop = key.name;
    const value = m[i];

    if (value !== undefined || !hasOwnProperty.call(params, prop)) {
      if (key.repeat) {
        params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];
      } else {
        params[prop] = value ? decodeParam(value) : value;
      }
    }
  }

  return {
    path: m[0],
    keys: (parentKeys || []).concat(regexp.keys),
    params
  };
}
/**
 * Universal Router (https://www.kriasoft.com/universal-router/)
 *
 * Copyright (c) 2015-present Kriasoft.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

/**
 * Traverses the routes tree and matches its nodes to the given pathname from
 * the root down to the leaves. Each match consumes a part of the pathname and
 * the matching process continues for as long as there is a matching child
 * route for the remaining part of the pathname.
 *
 * The returned value is a lazily evaluated iterator.
 *
 * The leading "/" in a route path matters only for the root of the routes
 * tree (or if all parent routes are ""). In all other cases a leading "/" in
 * a child route path has no significance.
 *
 * The trailing "/" in a _route path_ matters only for the leaves of the
 * routes tree. A leaf route with a trailing "/" matches only a pathname that
 * also has a trailing "/".
 *
 * The trailing "/" in a route path does not affect matching of child routes
 * in any way.
 *
 * The trailing "/" in a _pathname_ generally does not matter (except for
 * the case of leaf nodes described above).
 *
 * The "" and "/" routes have special treatment:
 *  1. as a single route
 *     the "" and "/" routes match only the "" and "/" pathnames respectively
 *  2. as a parent in the routes tree
 *     the "" route matches any pathname without consuming any part of it
 *     the "/" route matches any absolute pathname consuming its leading "/"
 *  3. as a leaf in the routes tree
 *     the "" and "/" routes match only if the entire pathname is consumed by
 *         the parent routes chain. In this case "" and "/" are equivalent.
 *  4. several directly nested "" or "/" routes
 *     - directly nested "" or "/" routes are 'squashed' (i.e. nesting two
 *       "/" routes does not require a double "/" in the pathname to match)
 *     - if there are only "" in the parent routes chain, no part of the
 *       pathname is consumed, and the leading "/" in the child routes' paths
 *       remains significant
 *
 * Side effect:
 *   - the routes tree { path: '' } matches only the '' pathname
 *   - the routes tree { path: '', children: [ { path: '' } ] } matches any
 *     pathname (for the tree root)
 *
 * Prefix matching can be enabled also by `children: true`.
 */


function matchRoute(route, pathname, ignoreLeadingSlash, parentKeys, parentParams) {
  let match;
  let childMatches;
  let childIndex = 0;
  let routepath = route.path || '';

  if (routepath.charAt(0) === '/') {
    if (ignoreLeadingSlash) {
      routepath = routepath.substr(1);
    }

    ignoreLeadingSlash = true;
  }

  return {
    next(routeToSkip) {
      if (route === routeToSkip) {
        return {
          done: true
        };
      }

      const children = route.__children = route.__children || route.children;

      if (!match) {
        match = matchPath(routepath, pathname, !children, parentKeys, parentParams);

        if (match) {
          return {
            done: false,
            value: {
              route,
              keys: match.keys,
              params: match.params,
              path: match.path
            }
          };
        }
      }

      if (match && children) {
        while (childIndex < children.length) {
          if (!childMatches) {
            const childRoute = children[childIndex];
            childRoute.parent = route;
            let matchedLength = match.path.length;

            if (matchedLength > 0 && pathname.charAt(matchedLength) === '/') {
              matchedLength += 1;
            }

            childMatches = matchRoute(childRoute, pathname.substr(matchedLength), ignoreLeadingSlash, match.keys, match.params);
          }

          const childMatch = childMatches.next(routeToSkip);

          if (!childMatch.done) {
            return {
              done: false,
              value: childMatch.value
            };
          }

          childMatches = null;
          childIndex++;
        }
      }

      return {
        done: true
      };
    }

  };
}
/**
 * Universal Router (https://www.kriasoft.com/universal-router/)
 *
 * Copyright (c) 2015-present Kriasoft.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */


function resolveRoute(context) {
  if (isFunction(context.route.action)) {
    return context.route.action(context);
  }

  return undefined;
}
/**
 * Universal Router (https://www.kriasoft.com/universal-router/)
 *
 * Copyright (c) 2015-present Kriasoft.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */


function isChildRoute(parentRoute, childRoute) {
  let route = childRoute;

  while (route) {
    route = route.parent;

    if (route === parentRoute) {
      return true;
    }
  }

  return false;
}

function generateErrorMessage(currentContext) {
  let errorMessage = `Path '${currentContext.pathname}' is not properly resolved due to an error.`;
  const routePath = (currentContext.route || {}).path;

  if (routePath) {
    errorMessage += ` Resolution had failed on route: '${routePath}'`;
  }

  return errorMessage;
}

function addRouteToChain(context, match) {
  const {
    route,
    path
  } = match;

  function shouldDiscardOldChain(oldChain, route) {
    return !route.parent || !oldChain || !oldChain.length || oldChain[oldChain.length - 1].route !== route.parent;
  }

  if (route && !route.__synthetic) {
    const item = {
      path,
      route
    };

    if (shouldDiscardOldChain(context.chain, route)) {
      context.chain = [item];
    } else {
      context.chain.push(item);
    }
  }
}
/**
 * @memberof Vaadin
 */


class Resolver {
  constructor(routes, options = {}) {
    if (Object(routes) !== routes) {
      throw new TypeError('Invalid routes');
    }

    this.baseUrl = options.baseUrl || '';
    this.errorHandler = options.errorHandler;
    this.resolveRoute = options.resolveRoute || resolveRoute;
    this.context = Object.assign({
      resolver: this
    }, options.context);
    this.root = Array.isArray(routes) ? {
      path: '',
      __children: routes,
      parent: null,
      __synthetic: true
    } : routes;
    this.root.parent = null;
  }
  /**
   * Returns the current list of routes (as a shallow copy). Adding / removing
   * routes to / from the returned array does not affect the routing config,
   * but modifying the route objects does.
   *
   * @return {!Array<!Route>}
   */


  getRoutes() {
    return [...this.root.__children];
  }
  /**
   * Sets the routing config (replacing the existing one).
   *
   * @param {!Array<!Route>|!Route} routes a single route or an array of those
   *    (the array is shallow copied)
   */


  setRoutes(routes) {
    ensureRoutes(routes);
    const newRoutes = [...toArray(routes)];
    this.root.__children = newRoutes;
  }
  /**
   * Appends one or several routes to the routing config and returns the
   * effective routing config after the operation.
   *
   * @param {!Array<!Route>|!Route} routes a single route or an array of those
   *    (the array is shallow copied)
   * @return {!Array<!Route>}
   * @protected
   */


  addRoutes(routes) {
    ensureRoutes(routes);

    this.root.__children.push(...toArray(routes));

    return this.getRoutes();
  }
  /**
   * Removes all existing routes from the routing config.
   */


  removeRoutes() {
    this.setRoutes([]);
  }
  /**
   * Asynchronously resolves the given pathname, i.e. finds all routes matching
   * the pathname and tries resolving them one after another in the order they
   * are listed in the routes config until the first non-null result.
   *
   * Returns a promise that is fulfilled with the return value of an object that consists of the first
   * route handler result that returns something other than `null` or `undefined` and context used to get this result.
   *
   * If no route handlers return a non-null result, or if no route matches the
   * given pathname the returned promise is rejected with a 'page not found'
   * `Error`.
   *
   * @param {!string|!{pathname: !string}} pathnameOrContext the pathname to
   *    resolve or a context object with a `pathname` property and other
   *    properties to pass to the route resolver functions.
   * @return {!Promise<any>}
   */


  resolve(pathnameOrContext) {
    const context = Object.assign({}, this.context, isString(pathnameOrContext) ? {
      pathname: pathnameOrContext
    } : pathnameOrContext);
    const match = matchRoute(this.root, this.__normalizePathname(context.pathname), this.baseUrl);
    const resolve = this.resolveRoute;
    let matches = null;
    let nextMatches = null;
    let currentContext = context;

    function next(resume, parent = matches.value.route, prevResult) {
      const routeToSkip = prevResult === null && matches.value.route;
      matches = nextMatches || match.next(routeToSkip);
      nextMatches = null;

      if (!resume) {
        if (matches.done || !isChildRoute(parent, matches.value.route)) {
          nextMatches = matches;
          return Promise.resolve(notFoundResult);
        }
      }

      if (matches.done) {
        return Promise.reject(getNotFoundError(context));
      }

      addRouteToChain(context, matches.value);
      currentContext = Object.assign({}, context, matches.value);
      return Promise.resolve(resolve(currentContext)).then(resolution => {
        if (resolution !== null && resolution !== undefined && resolution !== notFoundResult) {
          currentContext.result = resolution.result || resolution;
          return currentContext;
        }

        return next(resume, parent, resolution);
      });
    }

    context.next = next;
    return Promise.resolve().then(() => next(true, this.root)).catch(error => {
      const errorMessage = generateErrorMessage(currentContext);

      if (!error) {
        error = new Error(errorMessage);
      } else {
        console.warn(errorMessage);
      }

      error.context = error.context || currentContext; // DOMException has its own code which is read-only

      if (!(error instanceof DOMException)) {
        error.code = error.code || 500;
      }

      if (this.errorHandler) {
        currentContext.result = this.errorHandler(error);
        return currentContext;
      }

      throw error;
    });
  }
  /**
   * URL constructor polyfill hook. Creates and returns an URL instance.
   */


  static __createUrl(url, base) {
    return new URL(url, base);
  }
  /**
   * If the baseUrl property is set, transforms the baseUrl and returns the full
   * actual `base` string for using in the `new URL(path, base);` and for
   * prepernding the paths with. The returned base ends with a trailing slash.
   *
   * Otherwise, returns empty string.
   */


  get __effectiveBaseUrl() {
    return this.baseUrl ? this.constructor.__createUrl(this.baseUrl, document.baseURI || document.URL).href.replace(/[^\/]*$/, '') : '';
  }
  /**
   * If the baseUrl is set, matches the pathname with the router’s baseUrl,
   * and returns the local pathname with the baseUrl stripped out.
   *
   * If the pathname does not match the baseUrl, returns undefined.
   *
   * If the `baseUrl` is not set, returns the unmodified pathname argument.
   */


  __normalizePathname(pathname) {
    if (!this.baseUrl) {
      // No base URL, no need to transform the pathname.
      return pathname;
    }

    const base = this.__effectiveBaseUrl;

    const normalizedUrl = this.constructor.__createUrl(pathname, base).href;

    if (normalizedUrl.slice(0, base.length) === base) {
      return normalizedUrl.slice(base.length);
    }
  }

}

Resolver.pathToRegexp = pathToRegexp_1;
/**
 * Universal Router (https://www.kriasoft.com/universal-router/)
 *
 * Copyright (c) 2015-present Kriasoft.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

const {
  pathToRegexp: pathToRegexp$1
} = Resolver;
const cache$1 = new Map();

function cacheRoutes(routesByName, route, routes) {
  const name = route.name || route.component;

  if (name) {
    if (routesByName.has(name)) {
      routesByName.get(name).push(route);
    } else {
      routesByName.set(name, [route]);
    }
  }

  if (Array.isArray(routes)) {
    for (let i = 0; i < routes.length; i++) {
      const childRoute = routes[i];
      childRoute.parent = route;
      cacheRoutes(routesByName, childRoute, childRoute.__children || childRoute.children);
    }
  }
}

function getRouteByName(routesByName, routeName) {
  const routes = routesByName.get(routeName);

  if (routes && routes.length > 1) {
    throw new Error(`Duplicate route with name "${routeName}".` + ` Try seting unique 'name' route properties.`);
  }

  return routes && routes[0];
}

function getRoutePath(route) {
  let path = route.path;
  path = Array.isArray(path) ? path[0] : path;
  return path !== undefined ? path : '';
}

function generateUrls(router, options = {}) {
  if (!(router instanceof Resolver)) {
    throw new TypeError('An instance of Resolver is expected');
  }

  const routesByName = new Map();
  return (routeName, params) => {
    let route = getRouteByName(routesByName, routeName);

    if (!route) {
      routesByName.clear(); // clear cache

      cacheRoutes(routesByName, router.root, router.root.__children);
      route = getRouteByName(routesByName, routeName);

      if (!route) {
        throw new Error(`Route "${routeName}" not found`);
      }
    }

    let regexp = cache$1.get(route.fullPath);

    if (!regexp) {
      let fullPath = getRoutePath(route);
      let rt = route.parent;

      while (rt) {
        const path = getRoutePath(rt);

        if (path) {
          fullPath = path.replace(/\/$/, '') + '/' + fullPath.replace(/^\//, '');
        }

        rt = rt.parent;
      }

      const tokens = pathToRegexp$1.parse(fullPath);
      const toPath = pathToRegexp$1.tokensToFunction(tokens);
      const keys = Object.create(null);

      for (let i = 0; i < tokens.length; i++) {
        if (!isString(tokens[i])) {
          keys[tokens[i].name] = true;
        }
      }

      regexp = {
        toPath,
        keys
      };
      cache$1.set(fullPath, regexp);
      route.fullPath = fullPath;
    }

    let url = regexp.toPath(params, options) || '/';

    if (options.stringifyQueryParams && params) {
      const queryParams = {};
      const keys = Object.keys(params);

      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];

        if (!regexp.keys[key]) {
          queryParams[key] = params[key];
        }
      }

      const query = options.stringifyQueryParams(queryParams);

      if (query) {
        url += query.charAt(0) === '?' ? query : `?${query}`;
      }
    }

    return url;
  };
}
/**
 * @typedef NavigationTrigger
 * @type {object}
 * @property {function()} activate
 * @property {function()} inactivate
 */

/** @type {Array<NavigationTrigger>} */


let triggers = [];

function setNavigationTriggers(newTriggers) {
  triggers.forEach(trigger => trigger.inactivate());
  newTriggers.forEach(trigger => trigger.activate());
  triggers = newTriggers;
}

const willAnimate = elem => {
  const name = getComputedStyle(elem).getPropertyValue('animation-name');
  return name && name !== 'none';
};

const waitForAnimation = (elem, cb) => {
  const listener = () => {
    elem.removeEventListener('animationend', listener);
    cb();
  };

  elem.addEventListener('animationend', listener);
};

function animate(elem, className) {
  elem.classList.add(className);
  return new Promise(resolve => {
    if (willAnimate(elem)) {
      const rect = elem.getBoundingClientRect();
      const size = `height: ${rect.bottom - rect.top}px; width: ${rect.right - rect.left}px`;
      elem.setAttribute('style', `position: absolute; ${size}`);
      waitForAnimation(elem, () => {
        elem.classList.remove(className);
        elem.removeAttribute('style');
        resolve();
      });
    } else {
      elem.classList.remove(className);
      resolve();
    }
  });
}

const MAX_REDIRECT_COUNT = 256;

function isResultNotEmpty(result) {
  return result !== null && result !== undefined;
}

function copyContextWithoutNext(context) {
  const copy = Object.assign({}, context);
  delete copy.next;
  return copy;
}

function createLocation({
  pathname = '',
  chain = [],
  params = {},
  redirectFrom,
  resolver
}, route) {
  const routes = chain.map(item => item.route);
  return {
    baseUrl: resolver && resolver.baseUrl || '',
    pathname,
    routes,
    route: route || routes.length && routes[routes.length - 1] || null,
    params,
    redirectFrom,
    getUrl: (userParams = {}) => getPathnameForRouter(Router.pathToRegexp.compile(getMatchedPath(routes))(Object.assign({}, params, userParams)), resolver)
  };
}

function createRedirect(context, pathname) {
  const params = Object.assign({}, context.params);
  return {
    redirect: {
      pathname,
      from: context.pathname,
      params
    }
  };
}

function renderComponent(context, component) {
  const element = document.createElement(component);
  element.location = createLocation(context);
  const index = context.chain.map(item => item.route).indexOf(context.route);
  context.chain[index].element = element;
  return element;
}

function runCallbackIfPossible(callback, args, thisArg) {
  if (isFunction(callback)) {
    return callback.apply(thisArg, args);
  }
}

function amend(amendmentFunction, args, element) {
  return amendmentResult => {
    if (amendmentResult && (amendmentResult.cancel || amendmentResult.redirect)) {
      return amendmentResult;
    }

    if (element) {
      return runCallbackIfPossible(element[amendmentFunction], args, element);
    }
  };
}

function processNewChildren(newChildren, route) {
  if (!Array.isArray(newChildren) && !isObject(newChildren)) {
    throw new Error(log(`Incorrect "children" value for the route ${route.path}: expected array or object, but got ${newChildren}`));
  }

  route.__children = [];
  const childRoutes = toArray(newChildren);

  for (let i = 0; i < childRoutes.length; i++) {
    ensureRoute(childRoutes[i]);

    route.__children.push(childRoutes[i]);
  }
}

function removeDomNodes(nodes) {
  if (nodes && nodes.length) {
    const parent = nodes[0].parentNode;

    for (let i = 0; i < nodes.length; i++) {
      parent.removeChild(nodes[i]);
    }
  }
}

function getPathnameForRouter(pathname, router) {
  const base = router.__effectiveBaseUrl;
  return base ? router.constructor.__createUrl(pathname.replace(/^\//, ''), base).pathname : pathname;
}

function getMatchedPath(chain) {
  return chain.map(item => item.path).reduce((a, b) => {
    if (b.length) {
      return a.replace(/\/$/, '') + '/' + b.replace(/^\//, '');
    }

    return a;
  }, '');
}
/**
 * A simple client-side router for single-page applications. It uses
 * express-style middleware and has a first-class support for Web Components and
 * lazy-loading. Works great in Polymer and non-Polymer apps.
 *
 * Use `new Router(outlet, options)` to create a new Router instance.
 *
 * * The `outlet` parameter is a reference to the DOM node to render
 *   the content into.
 *
 * * The `options` parameter is an optional object with options. The following
 *   keys are supported:
 *   * `baseUrl` — the initial value for [
 *     the `baseUrl` property
 *   ](#/classes/Vaadin.Router#property-baseUrl)
 *
 * The Router instance is automatically subscribed to navigation events
 * on `window`.
 *
 * See [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html) for the detailed usage demo and code snippets.
 *
 * See also detailed API docs for the following methods, for the advanced usage:
 *
 * * [setOutlet](#/classes/Vaadin.Router#method-setOutlet) – should be used to configure the outlet.
 * * [setTriggers](#/classes/Vaadin.Router#method-setTriggers) – should be used to configure the navigation events.
 * * [setRoutes](#/classes/Vaadin.Router#method-setRoutes) – should be used to configure the routes.
 *
 * Only `setRoutes` has to be called manually, others are automatically invoked when creating a new instance.
 *
 * @memberof Vaadin
 * @extends Vaadin.Resolver
 * @demo demo/index.html
 * @summary JavaScript class that renders different DOM content depending on
 *    a given path. It can re-render when triggered or automatically on
 *    'popstate' and / or 'click' events.
 */


class Router extends Resolver {
  /**
   * Creates a new Router instance with a given outlet, and
   * automatically subscribes it to navigation events on the `window`.
   * Using a constructor argument or a setter for outlet is equivalent:
   *
   * ```
   * const router = new Vaadin.Router();
   * router.setOutlet(outlet);
   * ```
   * @param {?Node} outlet
   * @param {?RouterOptions} options
   */
  constructor(outlet, options) {
    const baseElement = document.head.querySelector('base');
    super([], Object.assign({
      // Default options
      baseUrl: baseElement && baseElement.getAttribute('href')
    }, options));

    this.resolveRoute = context => this.__resolveRoute(context);

    const triggers = Router.NavigationTrigger;
    Router.setTriggers.apply(Router, Object.keys(triggers).map(key => triggers[key]));
    /**
     * The base URL for all routes in the router instance. By default,
     * takes the `<base href>` attribute value if the base element exists
     * in the `<head>`.
     *
     * @public
     * @type {string}
     */

    this.baseUrl;
    /**
     * A promise that is settled after the current render cycle completes. If
     * there is no render cycle in progress the promise is immediately settled
     * with the last render cycle result.
     *
     * @public
     * @type {!Promise<!Vaadin.Router.Location>}
     */

    this.ready;
    this.ready = Promise.resolve(outlet);
    /**
     * Contains read-only information about the current router location:
     * pathname, active routes, parameters. See the
     * [Location type declaration](#/classes/Vaadin.Router.Location)
     * for more details.
     *
     * @public
     * @type {!Vaadin.Router.Location}
     */

    this.location;
    this.location = createLocation({
      resolver: this
    });
    this.__lastStartedRenderId = 0;
    this.__navigationEventHandler = this.__onNavigationEvent.bind(this);
    this.setOutlet(outlet);
    this.subscribe();
  }

  __resolveRoute(context) {
    const route = context.route;
    let callbacks = Promise.resolve();

    if (isFunction(route.children)) {
      callbacks = callbacks.then(() => route.children(copyContextWithoutNext(context))).then(children => {
        // The route.children() callback might have re-written the
        // route.children property instead of returning a value
        if (!isResultNotEmpty(children) && !isFunction(route.children)) {
          children = route.children;
        }

        processNewChildren(children, route);
      });
    }

    const commands = {
      redirect: path => createRedirect(context, path),
      component: component => renderComponent(context, component)
    };
    return callbacks.then(() => runCallbackIfPossible(route.action, [context, commands], route)).then(result => {
      if (isResultNotEmpty(result)) {
        // Actions like `() => import('my-view.js')` are not expected to
        // end the resolution, despite the result is not empty. Checking
        // the result with a whitelist of values that end the resulution.
        if (result instanceof HTMLElement || result.redirect || result === notFoundResult) {
          return result;
        }
      }

      if (isString(route.redirect)) {
        return commands.redirect(route.redirect);
      }

      if (route.bundle) {
        return loadBundle(route.bundle).then(() => {}, () => {
          throw new Error(log(`Bundle not found: ${route.bundle}. Check if the file name is correct`));
        });
      }
    }).then(result => {
      if (isResultNotEmpty(result)) {
        return result;
      }

      if (isString(route.component)) {
        return commands.component(route.component);
      }
    });
  }
  /**
   * Sets the router outlet (the DOM node where the content for the current
   * route is inserted). Any content pre-existing in the router outlet is
   * removed at the end of each render pass.
   *
   * NOTE: this method is automatically invoked first time when creating a new Router instance.
   *
   * @param {?Node} outlet the DOM node where the content for the current route
   *     is inserted.
   */


  setOutlet(outlet) {
    if (outlet) {
      this.__ensureOutlet(outlet);
    }

    this.__outlet = outlet;
  }
  /**
   * Returns the current router outlet. The initial value is `undefined`.
   *
   * @return {?Node} the current router outlet (or `undefined`)
   */


  getOutlet() {
    return this.__outlet;
  }
  /**
   * Sets the routing config (replacing the existing one) and triggers a
   * navigation event so that the router outlet is refreshed according to the
   * current `window.location` and the new routing config.
   *
   * Each route object may have the following properties, listed here in the processing order:
   * * `path` – the route path (relative to the parent route if any) in the
   * [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths").
   *
   * * `children` – an array of nested routes or a function that provides this
   * array at the render time. The function can be synchronous or asynchronous:
   * in the latter case the render is delayed until the returned promise is
   * resolved. The `children` function is executed every time when this route is
   * being rendered. This allows for dynamic route structures (e.g. backend-defined),
   * but it might have a performance impact as well. In order to avoid calling
   * the function on subsequent renders, you can override the `children` property
   * of the route object and save the calculated array there
   * (via `context.route.children = [ route1, route2, ...];`).
   * Parent routes are fully resolved before resolving the children. Children
   * 'path' values are relative to the parent ones.
   *
   * * `action` – the action that is executed before the route is resolved.
   * The value for this property should be a function, accepting `context`
   * and `commands` parameters described below. If present, this function is
   * always invoked first, disregarding of the other properties' presence.
   * The action can return a result directly or within a `Promise`, which
   * resolves to the result. If the action result is an `HTMLElement` instance,
   * a `commands.component(name)` result, a `commands.redirect(path)` result,
   * or a `context.next()` result, the current route resolution is finished,
   * and other route config properties are ignored.
   * See also **Route Actions** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).
   *
   * * `redirect` – other route's path to redirect to. Passes all route parameters to the redirect target.
   * The target route should also be defined.
   * See also **Redirects** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).
   *
   * * `bundle` – string containing the path to `.js` or `.mjs` bundle to load before resolving the route,
   * or the object with "module" and "nomodule" keys referring to different bundles.
   * Each bundle is only loaded once. If "module" and "nomodule" are set, only one bundle is loaded,
   * depending on whether the browser supports ES modules or not.
   * The property is ignored when either an `action` returns the result or `redirect` property is present.
   * Any error, e.g. 404 while loading bundle will cause route resolution to throw.
   * See also **Code Splitting** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).
   *
   * * `component` – the tag name of the Web Component to resolve the route to.
   * The property is ignored when either an `action` returns the result or `redirect` property is present.
   * If route contains the `component` property (or an action that return a component)
   * and its child route also contains the `component` property, child route's component
   * will be rendered as a light dom child of a parent component.
   *
   * * `name` – the string name of the route to use in the
   * [`router.urlForName(name, params)`](#/classes/Vaadin.Router#method-urlForName)
   * navigation helper method.
   *
   * For any route function (`action`, `children`) defined, the corresponding `route` object is available inside the callback
   * through the `this` reference. If you need to access it, make sure you define the callback as a non-arrow function
   * because arrow functions do not have their own `this` reference.
   *
   * `context` object that is passed to `action` function holds the following properties:
   * * `context.pathname` – string with the pathname being resolved
   *
   * * `context.params` – object with route parameters
   *
   * * `context.route` – object that holds the route that is currently being rendered.
   *
   * * `context.next()` – function for asynchronously getting the next route
   * contents from the resolution chain (if any)
   *
   * `commands` object that is passed to `action` function has
   * the following methods:
   *
   * * `commands.redirect(path)` – function that creates a redirect data
   * for the path specified.
   *
   * * `commands.component(component)` – function that creates a new HTMLElement
   * with current context
   *
   * @param {!Array<!Object>|!Object} routes a single route or an array of those
   */


  setRoutes(routes) {
    this.__urlForName = undefined;
    super.setRoutes(routes);

    this.__onNavigationEvent();
  }
  /**
   * Asynchronously resolves the given pathname and renders the resolved route
   * component into the router outlet. If no router outlet is set at the time of
   * calling this method, or at the time when the route resolution is completed,
   * a `TypeError` is thrown.
   *
   * Returns a promise that is fulfilled with the router outlet DOM Node after
   * the route component is created and inserted into the router outlet, or
   * rejected if no route matches the given path.
   *
   * If another render pass is started before the previous one is completed, the
   * result of the previous render pass is ignored.
   *
   * @param {!string|!{pathname: !string}} pathnameOrContext the pathname to
   *    render or a context object with a `pathname` property and other
   *    properties to pass to the resolver.
   * @return {!Promise<!Node>}
   */


  render(pathnameOrContext, shouldUpdateHistory) {
    const renderId = ++this.__lastStartedRenderId;
    const pathname = pathnameOrContext.pathname || pathnameOrContext; // Find the first route that resolves to a non-empty result

    this.ready = this.resolve(pathnameOrContext) // Process the result of this.resolve() and handle all special commands:
    // (redirect / prevent / component). If the result is a 'component',
    // then go deeper and build the entire chain of nested components matching
    // the pathname. Also call all 'on before' callbacks along the way.
    .then(context => this.__fullyResolveChain(context)).then(context => {
      if (renderId === this.__lastStartedRenderId) {
        const previousContext = this.__previousContext; // Check if the render was prevented and make an early return in that case

        if (context === previousContext) {
          return this.location;
        }

        this.location = createLocation(context);
        fireRouterEvent('location-changed', {
          router: this,
          location: this.location
        });

        if (shouldUpdateHistory) {
          this.__updateBrowserHistory(context.pathname, context.redirectFrom);
        }

        this.__addAppearingContent(context, previousContext);

        const animationDone = this.__animateIfNeeded(context);

        this.__runOnAfterEnterCallbacks(context);

        this.__runOnAfterLeaveCallbacks(context, previousContext);

        return animationDone.then(() => {
          if (renderId === this.__lastStartedRenderId) {
            // If there is another render pass started after this one,
            // the 'disappearing content' would be removed when the other
            // render pass calls `this.__addAppearingContent()`
            this.__removeDisappearingContent();

            this.__previousContext = context;
            return this.location;
          }
        });
      }
    }).catch(error => {
      if (renderId === this.__lastStartedRenderId) {
        if (shouldUpdateHistory) {
          this.__updateBrowserHistory(pathname);
        }

        removeDomNodes(this.__outlet && this.__outlet.children);
        this.location = createLocation({
          pathname,
          resolver: this
        });
        fireRouterEvent('error', {
          router: this,
          error,
          pathname
        });
        throw error;
      }
    });
    return this.ready;
  }

  __fullyResolveChain(originalContext, currentContext = originalContext) {
    return this.__amendWithResolutionResult(currentContext).then(amendedContext => {
      const initialContext = amendedContext !== currentContext ? amendedContext : originalContext;
      return amendedContext.next().then(nextContext => {
        if (nextContext === null || nextContext === notFoundResult) {
          const matchedPath = getPathnameForRouter(getMatchedPath(amendedContext.chain), amendedContext.resolver);

          if (matchedPath !== amendedContext.pathname) {
            throw getNotFoundError(initialContext);
          }
        }

        return nextContext && nextContext !== notFoundResult ? this.__fullyResolveChain(initialContext, nextContext) : this.__amendWithOnBeforeCallbacks(initialContext);
      });
    });
  }

  __amendWithResolutionResult(context) {
    const result = context.result;

    if (result instanceof HTMLElement) {
      return Promise.resolve(context);
    } else if (result.redirect) {
      return this.__redirect(result.redirect, context.__redirectCount).then(context => this.__amendWithResolutionResult(context));
    } else if (result instanceof Error) {
      return Promise.reject(result);
    } else {
      return Promise.reject(new Error(log(`Invalid route resolution result for path "${context.pathname}". ` + `Expected redirect object or HTML element, but got: "${logValue(result)}". ` + `Double check the action return value for the route.`)));
    }
  }

  __amendWithOnBeforeCallbacks(contextWithFullChain) {
    return this.__runOnBeforeCallbacks(contextWithFullChain).then(amendedContext => {
      if (amendedContext === this.__previousContext || amendedContext === contextWithFullChain) {
        return amendedContext;
      }

      return this.__fullyResolveChain(amendedContext);
    });
  }

  __runOnBeforeCallbacks(newContext) {
    const previousContext = this.__previousContext || {};
    const previousChain = previousContext.chain || [];
    const newChain = newContext.chain;
    let callbacks = Promise.resolve();

    const prevent = () => ({
      cancel: true
    });

    const redirect = pathname => createRedirect(newContext, pathname);

    newContext.__divergedChainIndex = 0;

    if (previousChain.length) {
      for (let i = 0; i < Math.min(previousChain.length, newChain.length); i = ++newContext.__divergedChainIndex) {
        if (previousChain[i].route !== newChain[i].route || previousChain[i].path !== newChain[i].path || (previousChain[i].element && previousChain[i].element.localName) !== (newChain[i].element && newChain[i].element.localName)) {
          break;
        }
      }

      for (let i = previousChain.length - 1; i >= newContext.__divergedChainIndex; i--) {
        const location = createLocation(newContext);
        callbacks = callbacks.then(amend('onBeforeLeave', [location, {
          prevent
        }, this], previousChain[i].element)).then(result => {
          if (!(result || {}).redirect) {
            return result;
          }
        });
      }
    }

    for (let i = newContext.__divergedChainIndex; i < newChain.length; i++) {
      const location = createLocation(newContext, newChain[i].route);
      callbacks = callbacks.then(amend('onBeforeEnter', [location, {
        prevent,
        redirect
      }, this], newChain[i].element));
    }

    return callbacks.then(amendmentResult => {
      if (amendmentResult) {
        if (amendmentResult.cancel) {
          return this.__previousContext;
        }

        if (amendmentResult.redirect) {
          return this.__redirect(amendmentResult.redirect, newContext.__redirectCount);
        }
      }

      return newContext;
    });
  }

  __redirect(redirectData, counter) {
    if (counter > MAX_REDIRECT_COUNT) {
      throw new Error(log(`Too many redirects when rendering ${redirectData.from}`));
    }

    return this.resolve({
      pathname: this.urlForPath(redirectData.pathname, redirectData.params),
      redirectFrom: redirectData.from,
      __redirectCount: (counter || 0) + 1
    });
  }

  __ensureOutlet(outlet = this.__outlet) {
    if (!(outlet instanceof Node)) {
      throw new TypeError(log(`Expected router outlet to be a valid DOM Node (but got ${outlet})`));
    }
  }

  __updateBrowserHistory(pathname, replace) {
    if (window.location.pathname !== pathname) {
      const changeState = replace ? 'replaceState' : 'pushState';
      window.history[changeState](null, document.title, pathname);
      window.dispatchEvent(new PopStateEvent('popstate', {
        state: 'vaadin-router-ignore'
      }));
    }
  }

  __addAppearingContent(context, previousContext) {
    this.__ensureOutlet(); // If the previous 'entering' animation has not completed yet,
    // stop it and remove that content from the DOM before adding new one.


    this.__removeAppearingContent(); // Find the deepest common parent between the last and the new component
    // chains. Update references for the unchanged elements in the new chain


    let deepestCommonParent = this.__outlet;

    for (let i = 0; i < context.__divergedChainIndex; i++) {
      const unchangedElement = previousContext && previousContext.chain[i].element;

      if (unchangedElement) {
        if (unchangedElement.parentNode === deepestCommonParent) {
          context.chain[i].element = unchangedElement;
          deepestCommonParent = unchangedElement;
        } else {
          break;
        }
      }
    } // Keep two lists of DOM elements:
    //  - those that should be removed once the transition animation is over
    //  - and those that should remain


    this.__disappearingContent = Array.from(deepestCommonParent.children);
    this.__appearingContent = []; // Add new elements (starting after the deepest common parent) to the DOM.
    // That way only the components that are actually different between the two
    // locations are added to the DOM (and those that are common remain in the
    // DOM without first removing and then adding them again).

    let parentElement = deepestCommonParent;

    for (let i = context.__divergedChainIndex; i < context.chain.length; i++) {
      const elementToAdd = context.chain[i].element;

      if (elementToAdd) {
        parentElement.appendChild(elementToAdd);

        if (parentElement === deepestCommonParent) {
          this.__appearingContent.push(elementToAdd);
        }

        parentElement = elementToAdd;
      }
    }
  }

  __removeDisappearingContent() {
    if (this.__disappearingContent) {
      removeDomNodes(this.__disappearingContent);
    }

    this.__disappearingContent = null;
    this.__appearingContent = null;
  }

  __removeAppearingContent() {
    if (this.__disappearingContent && this.__appearingContent) {
      removeDomNodes(this.__appearingContent);
      this.__disappearingContent = null;
      this.__appearingContent = null;
    }
  }

  __runOnAfterLeaveCallbacks(currentContext, targetContext) {
    if (!targetContext) {
      return;
    } // REVERSE iteration: from Z to A


    for (let i = targetContext.chain.length - 1; i >= currentContext.__divergedChainIndex; i--) {
      const currentComponent = targetContext.chain[i].element;

      if (!currentComponent) {
        continue;
      }

      try {
        const location = createLocation(currentContext);
        runCallbackIfPossible(currentComponent.onAfterLeave, [location, {}, targetContext.resolver], currentComponent);
      } finally {
        removeDomNodes(currentComponent.children);
      }
    }
  }

  __runOnAfterEnterCallbacks(currentContext) {
    // forward iteration: from A to Z
    for (let i = currentContext.__divergedChainIndex; i < currentContext.chain.length; i++) {
      const currentComponent = currentContext.chain[i].element || {};
      const location = createLocation(currentContext, currentContext.chain[i].route);
      runCallbackIfPossible(currentComponent.onAfterEnter, [location, {}, currentContext.resolver], currentComponent);
    }
  }

  __animateIfNeeded(context) {
    const from = (this.__disappearingContent || [])[0];
    const to = (this.__appearingContent || [])[0];
    const promises = [];
    const chain = context.chain;
    let config;

    for (let i = chain.length; i > 0; i--) {
      if (chain[i - 1].route.animate) {
        config = chain[i - 1].route.animate;
        break;
      }
    }

    if (from && to && config) {
      const leave = isObject(config) && config.leave || 'leaving';
      const enter = isObject(config) && config.enter || 'entering';
      promises.push(animate(from, leave));
      promises.push(animate(to, enter));
    }

    return Promise.all(promises).then(() => context);
  }
  /**
   * Subscribes this instance to navigation events on the `window`.
   *
   * NOTE: beware of resource leaks. For as long as a router instance is
   * subscribed to navigation events, it won't be garbage collected.
   */


  subscribe() {
    window.addEventListener('vaadin-router-go', this.__navigationEventHandler);
  }
  /**
   * Removes the subscription to navigation events created in the `subscribe()`
   * method.
   */


  unsubscribe() {
    window.removeEventListener('vaadin-router-go', this.__navigationEventHandler);
  }

  __onNavigationEvent(event) {
    const pathname = event ? event.detail.pathname : window.location.pathname;

    if (isString(this.__normalizePathname(pathname))) {
      if (event && event.preventDefault) {
        event.preventDefault();
      }

      this.render(pathname, true);
    }
  }
  /**
   * Configures what triggers Vaadin.Router navigation events:
   *  - `POPSTATE`: popstate events on the current `window`
   *  - `CLICK`: click events on `<a>` links leading to the current page
   *
   * This method is invoked with the pre-configured values when creating a new Router instance.
   * By default, both `POPSTATE` and `CLICK` are enabled. This setup is expected to cover most of the use cases.
   *
   * See the `router-config.js` for the default navigation triggers config. Based on it, you can
   * create the own one and only import the triggers you need, instead of pulling in all the code,
   * e.g. if you want to handle `click` differently.
   *
   * See also **Navigation Triggers** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).
   *
   * @param {...NavigationTrigger} triggers
   */


  static setTriggers(...triggers) {
    setNavigationTriggers(triggers);
  }
  /**
   * Generates a URL for the route with the given name, optionally performing
   * substitution of parameters.
   *
   * The route is searched in all the Vaadin.Router instances subscribed to
   * navigation events.
   *
   * **Note:** For child route names, only array children are considered.
   * It is not possible to generate URLs using a name for routes set with
   * a children function.
   *
   * @function urlForName
   * @param {!string} name the route name or the route’s `component` name.
   * @param {?Object} params Optional object with route path parameters.
   * Named parameters are passed by name (`params[name] = value`), unnamed
   * parameters are passed by index (`params[index] = value`).
   *
   * @return {string}
   */


  urlForName(name, params) {
    if (!this.__urlForName) {
      this.__urlForName = generateUrls(this);
    }

    return getPathnameForRouter(this.__urlForName(name, params), this);
  }
  /**
   * Generates a URL for the given route path, optionally performing
   * substitution of parameters.
   *
   * @param {!string} path string route path declared in [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths").
   * @param {?Object} params Optional object with route path parameters.
   * Named parameters are passed by name (`params[name] = value`), unnamed
   * parameters are passed by index (`params[index] = value`).
   *
   * @return {string}
   */


  urlForPath(path, params) {
    return getPathnameForRouter(Router.pathToRegexp.compile(path)(params), this);
  }
  /**
   * Triggers navigation to a new path. Returns a boolean without waiting until
   * the navigation is complete. Returns `true` if at least one `Vaadin.Router`
   * has handled the navigation (was subscribed and had `baseUrl` matching
   * the `pathname` argument), otherwise returns `false`.
   *
   * @param {!string} pathname a new in-app path
   * @return {boolean}
   */


  static go(pathname) {
    return fireRouterEvent('go', {
      pathname
    });
  }

}

const DEV_MODE_CODE_REGEXP = /\/\*\*\s+vaadin-dev-mode:start([\s\S]*)vaadin-dev-mode:end\s+\*\*\//i;

function isMinified() {
  function test() {
    /** vaadin-dev-mode:start
    return false;
    vaadin-dev-mode:end **/
    return true;
  }

  return uncommentAndRun(test);
}

function isDevelopmentMode() {
  try {
    return isForcedDevelopmentMode() || isLocalhost() && !isMinified() && !isFlowProductionMode();
  } catch (e) {
    // Some error in this code, assume production so no further actions will be taken
    return false;
  }
}

function isForcedDevelopmentMode() {
  return localStorage.getItem("vaadin.developmentmode.force");
}

function isLocalhost() {
  return ["localhost", "127.0.0.1"].indexOf(window.location.hostname) >= 0;
}

function isFlowProductionMode() {
  if (window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients) {
    const productionModeApps = Object.keys(window.Vaadin.Flow.clients).map(key => window.Vaadin.Flow.clients[key]).filter(client => client.productionMode);

    if (productionModeApps.length > 0) {
      return true;
    }
  }

  return false;
}

function uncommentAndRun(callback, args) {
  if (typeof callback !== 'function') {
    return;
  }

  const match = DEV_MODE_CODE_REGEXP.exec(callback.toString());

  if (match) {
    try {
      // requires CSP: script-src 'unsafe-eval'
      callback = new Function(match[1]);
    } catch (e) {
      // eat the exception
      console.log('vaadin-development-mode-detector: uncommentAndRun() failed', e);
    }
  }

  return callback(args);
} // A guard against polymer-modulizer removing the window.Vaadin
// initialization above.


window['Vaadin'] = window['Vaadin'] || {};
/**
 * Inspects the source code of the given `callback` function for
 * specially-marked _commented_ code. If such commented code is found in the
 * callback source, uncomments and runs that code instead of the callback
 * itself. Otherwise runs the callback as is.
 *
 * The optional arguments are passed into the callback / uncommented code,
 * the result is returned.
 *
 * See the `isMinified()` function source code in this file for an example.
 *
 */

const runIfDevelopmentMode = function (callback, args) {
  if (window.Vaadin.developmentMode) {
    return uncommentAndRun(callback, args);
  }
};

if (window.Vaadin.developmentMode === undefined) {
  window.Vaadin.developmentMode = isDevelopmentMode();
}
/* This file is autogenerated from src/vaadin-usage-statistics.tpl.html */


function maybeGatherAndSendStats() {
  /** vaadin-dev-mode:start
  (function () {
  'use strict';
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
  } : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
  };
  var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
   return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
  }();
  var getPolymerVersion = function getPolymerVersion() {
  return window.Polymer && window.Polymer.version;
  };
  var StatisticsGatherer = function () {
  function StatisticsGatherer(logger) {
    classCallCheck(this, StatisticsGatherer);
     this.now = new Date().getTime();
    this.logger = logger;
  }
   createClass(StatisticsGatherer, [{
    key: 'frameworkVersionDetectors',
    value: function frameworkVersionDetectors() {
      return {
        'Flow': function Flow() {
          if (window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients) {
            var flowVersions = Object.keys(window.Vaadin.Flow.clients).map(function (key) {
              return window.Vaadin.Flow.clients[key];
            }).filter(function (client) {
              return client.getVersionInfo;
            }).map(function (client) {
              return client.getVersionInfo().flow;
            });
            if (flowVersions.length > 0) {
              return flowVersions[0];
            }
          }
        },
        'Vaadin Framework': function VaadinFramework() {
          if (window.vaadin && window.vaadin.clients) {
            var frameworkVersions = Object.values(window.vaadin.clients).filter(function (client) {
              return client.getVersionInfo;
            }).map(function (client) {
              return client.getVersionInfo().vaadinVersion;
            });
            if (frameworkVersions.length > 0) {
              return frameworkVersions[0];
            }
          }
        },
        'AngularJs': function AngularJs() {
          if (window.angular && window.angular.version && window.angular.version) {
            return window.angular.version.full;
          }
        },
        'Angular': function Angular() {
          if (window.ng) {
            var tags = document.querySelectorAll("[ng-version]");
            if (tags.length > 0) {
              return tags[0].getAttribute("ng-version");
            }
            return "Unknown";
          }
        },
        'Backbone.js': function BackboneJs() {
          if (window.Backbone) {
            return window.Backbone.VERSION;
          }
        },
        'React': function React() {
          var reactSelector = '[data-reactroot], [data-reactid]';
          if (!!document.querySelector(reactSelector)) {
            // React does not publish the version by default
            return "unknown";
          }
        },
        'Ember': function Ember() {
          if (window.Em && window.Em.VERSION) {
            return window.Em.VERSION;
          } else if (window.Ember && window.Ember.VERSION) {
            return window.Ember.VERSION;
          }
        },
        'jQuery': function (_jQuery) {
          function jQuery() {
            return _jQuery.apply(this, arguments);
          }
           jQuery.toString = function () {
            return _jQuery.toString();
          };
           return jQuery;
        }(function () {
          if (typeof jQuery === 'function' && jQuery.prototype.jquery !== undefined) {
            return jQuery.prototype.jquery;
          }
        }),
        'Polymer': function Polymer() {
          var version = getPolymerVersion();
          if (version) {
            return version;
          }
        },
        'Vue.js': function VueJs() {
          if (window.Vue) {
            return window.Vue.version;
          }
        }
      };
    }
  }, {
    key: 'getUsedVaadinElements',
    value: function getUsedVaadinElements(elements) {
      var version = getPolymerVersion();
      var elementClasses = void 0;
      if (version && version.indexOf('2') === 0) {
        // Polymer 2: components classes are stored in window.Vaadin
        elementClasses = Object.keys(window.Vaadin).map(function (c) {
          return window.Vaadin[c];
        }).filter(function (c) {
          return c.is;
        });
      } else {
        // Polymer 3: components classes are stored in window.Vaadin.registrations
        elementClasses = window.Vaadin.registrations || [];
      }
      elementClasses.forEach(function (klass) {
        var version = klass.version ? klass.version : "0.0.0";
        elements[klass.is] = { version: version };
      });
    }
  }, {
    key: 'getUsedVaadinThemes',
    value: function getUsedVaadinThemes(themes) {
      ['Lumo', 'Material'].forEach(function (themeName) {
        var theme;
        var version = getPolymerVersion();
        if (version && version.indexOf('2') === 0) {
          // Polymer 2: themes are stored in window.Vaadin
          theme = window.Vaadin[themeName];
        } else {
          // Polymer 3: themes are stored in custom element registry
          theme = customElements.get('vaadin-' + themeName.toLowerCase() + '-styles');
        }
        if (theme && theme.version) {
          themes[themeName] = { version: theme.version };
        }
      });
    }
  }, {
    key: 'getFrameworks',
    value: function getFrameworks(frameworks) {
      var detectors = this.frameworkVersionDetectors();
      Object.keys(detectors).forEach(function (framework) {
        var detector = detectors[framework];
        try {
          var version = detector();
          if (version) {
            frameworks[framework] = { "version": version };
          }
        } catch (e) {}
      });
    }
  }, {
    key: 'gather',
    value: function gather(storage) {
      var storedStats = storage.read();
      var gatheredStats = {};
      var types = ["elements", "frameworks", "themes"];
       types.forEach(function (type) {
        gatheredStats[type] = {};
        if (!storedStats[type]) {
          storedStats[type] = {};
        }
      });
       var previousStats = JSON.stringify(storedStats);
       this.getUsedVaadinElements(gatheredStats.elements);
      this.getFrameworks(gatheredStats.frameworks);
      this.getUsedVaadinThemes(gatheredStats.themes);
       var now = this.now;
      types.forEach(function (type) {
        var keys = Object.keys(gatheredStats[type]);
        keys.forEach(function (key) {
          if (!storedStats[type][key] || _typeof(storedStats[type][key]) != _typeof({})) {
            storedStats[type][key] = { "firstUsed": now };
          }
          // Discards any previously logged version numebr
          storedStats[type][key].version = gatheredStats[type][key].version;
          storedStats[type][key].lastUsed = now;
        });
      });
       var newStats = JSON.stringify(storedStats);
      storage.write(newStats);
      if (newStats != previousStats && Object.keys(storedStats).length > 0) {
        this.logger.debug("New stats: " + newStats);
      }
    }
  }]);
  return StatisticsGatherer;
  }();
  var StatisticsStorage = function () {
  function StatisticsStorage(key) {
    classCallCheck(this, StatisticsStorage);
     this.key = key;
  }
   createClass(StatisticsStorage, [{
    key: 'read',
    value: function read() {
      var localStorageStatsString = localStorage.getItem(this.key);
      try {
        return JSON.parse(localStorageStatsString ? localStorageStatsString : '{}');
      } catch (e) {
        return {};
      }
    }
  }, {
    key: 'write',
    value: function write(data) {
      localStorage.setItem(this.key, data);
    }
  }, {
    key: 'clear',
    value: function clear() {
      localStorage.removeItem(this.key);
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      var storedStats = this.read();
      var empty = true;
      Object.keys(storedStats).forEach(function (key) {
        if (Object.keys(storedStats[key]).length > 0) {
          empty = false;
        }
      });
       return empty;
    }
  }]);
  return StatisticsStorage;
  }();
  var StatisticsSender = function () {
  function StatisticsSender(url, logger) {
    classCallCheck(this, StatisticsSender);
     this.url = url;
    this.logger = logger;
  }
   createClass(StatisticsSender, [{
    key: 'send',
    value: function send(data, errorHandler) {
      var logger = this.logger;
       if (navigator.onLine === false) {
        logger.debug("Offline, can't send");
        errorHandler();
        return;
      }
      logger.debug("Sending data to " + this.url);
       var req = new XMLHttpRequest();
      req.withCredentials = true;
      req.addEventListener("load", function () {
        // Stats sent, nothing more to do
        logger.debug("Response: " + req.responseText);
      });
      req.addEventListener("error", function () {
        logger.debug("Send failed");
        errorHandler();
      });
      req.addEventListener("abort", function () {
        logger.debug("Send aborted");
        errorHandler();
      });
      req.open("POST", this.url);
      req.setRequestHeader("Content-Type", "application/json");
      req.send(data);
    }
  }]);
  return StatisticsSender;
  }();
  var StatisticsLogger = function () {
  function StatisticsLogger(id) {
    classCallCheck(this, StatisticsLogger);
     this.id = id;
  }
   createClass(StatisticsLogger, [{
    key: '_isDebug',
    value: function _isDebug() {
      return localStorage.getItem("vaadin." + this.id + ".debug");
    }
  }, {
    key: 'debug',
    value: function debug(msg) {
      if (this._isDebug()) {
        console.info(this.id + ": " + msg);
      }
    }
  }]);
  return StatisticsLogger;
  }();
  var UsageStatistics = function () {
  function UsageStatistics() {
    classCallCheck(this, UsageStatistics);
     this.now = new Date();
    this.timeNow = this.now.getTime();
    this.gatherDelay = 10; // Delay between loading this file and gathering stats
    this.initialDelay = 24 * 60 * 60;
     this.logger = new StatisticsLogger("statistics");
    this.storage = new StatisticsStorage("vaadin.statistics.basket");
    this.gatherer = new StatisticsGatherer(this.logger);
    this.sender = new StatisticsSender("https://tools.vaadin.com/usage-stats/submit", this.logger);
  }
   createClass(UsageStatistics, [{
    key: 'maybeGatherAndSend',
    value: function maybeGatherAndSend() {
      var _this = this;
       if (localStorage.getItem(UsageStatistics.optOutKey)) {
        return;
      }
      this.gatherer.gather(this.storage);
      setTimeout(function () {
        _this.maybeSend();
      }, this.gatherDelay * 1000);
    }
  }, {
    key: 'lottery',
    value: function lottery() {
      return Math.random() <= 0.05;
    }
  }, {
    key: 'currentMonth',
    value: function currentMonth() {
      return this.now.getYear() * 12 + this.now.getMonth();
    }
  }, {
    key: 'maybeSend',
    value: function maybeSend() {
      var firstUse = Number(localStorage.getItem(UsageStatistics.firstUseKey));
      var monthProcessed = Number(localStorage.getItem(UsageStatistics.monthProcessedKey));
       if (!firstUse) {
        // Use a grace period to avoid interfering with tests, incognito mode etc
        firstUse = this.timeNow;
        localStorage.setItem(UsageStatistics.firstUseKey, firstUse);
      }
       if (this.timeNow < firstUse + this.initialDelay * 1000) {
        this.logger.debug("No statistics will be sent until the initial delay of " + this.initialDelay + "s has passed");
        return;
      }
      if (this.currentMonth() <= monthProcessed) {
        this.logger.debug("This month has already been processed");
        return;
      }
      localStorage.setItem(UsageStatistics.monthProcessedKey, this.currentMonth());
      // Use random sampling
      if (this.lottery()) {
        this.logger.debug("Congratulations, we have a winner!");
      } else {
        this.logger.debug("Sorry, no stats from you this time");
        return;
      }
       this.send();
    }
  }, {
    key: 'send',
    value: function send() {
      // Ensure we have the latest data
      this.gatherer.gather(this.storage);
       // Read, send and clean up
      var data = this.storage.read();
      data["firstUse"] = Number(localStorage.getItem(UsageStatistics.firstUseKey));
      data["usageStatisticsVersion"] = UsageStatistics.version;
      var info = 'This request contains usage statistics gathered from the application running in development mode. \n\nStatistics gathering is automatically disabled and excluded from production builds.\n\nFor details and to opt-out, see https://github.com/vaadin/vaadin-usage-statistics.\n\n\n\n';
      var self = this;
      this.sender.send(info + JSON.stringify(data), function () {
        // Revert the 'month processed' flag
        localStorage.setItem(UsageStatistics.monthProcessedKey, self.currentMonth() - 1);
      });
    }
  }], [{
    key: 'version',
    get: function get$1() {
      return '2.0.1';
    }
  }, {
    key: 'firstUseKey',
    get: function get$1() {
      return 'vaadin.statistics.firstuse';
    }
  }, {
    key: 'monthProcessedKey',
    get: function get$1() {
      return 'vaadin.statistics.monthProcessed';
    }
  }, {
    key: 'optOutKey',
    get: function get$1() {
      return 'vaadin.statistics.optout';
    }
  }]);
  return UsageStatistics;
  }();
  try {
  window.Vaadin = window.Vaadin || {};
  window.Vaadin.usageStatistics = window.Vaadin.usageStatistics || new UsageStatistics();
  window.Vaadin.usageStatistics.maybeGatherAndSend();
  } catch (e) {
  // Intentionally ignored as this is not a problem in the app being developed
  }
  }());
   vaadin-dev-mode:end **/
}

const usageStatistics = function () {
  if (typeof runIfDevelopmentMode === 'function') {
    return runIfDevelopmentMode(maybeGatherAndSendStats);
  }
};

window.Vaadin = window.Vaadin || {};
window.Vaadin.registrations = window.Vaadin.registrations || [];
window.Vaadin.registrations.push({
  is: '@vaadin/router',
  version: '1.2.0'
});
usageStatistics();
Router.NavigationTrigger = {
  POPSTATE,
  CLICK
};

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const directives = new WeakMap();
const isDirective = o => {
  return typeof o === 'function' && directives.has(o);
};

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * True if the custom elements polyfill is in use.
 */
const isCEPolyfill = window.customElements !== undefined && window.customElements.polyfillWrapFlushCallback !== undefined;
/**
 * Removes nodes, starting from `startNode` (inclusive) to `endNode`
 * (exclusive), from `container`.
 */

const removeNodes = (container, startNode, endNode = null) => {
  let node = startNode;

  while (node !== endNode) {
    const n = node.nextSibling;
    container.removeChild(node);
    node = n;
  }
};

/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * A sentinel value that signals that a value was handled by a directive and
 * should not be written to the DOM.
 */
const noChange = {};
/**
 * A sentinel value that signals a NodePart to fully clear its content.
 */

const nothing = {};

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * An expression marker with embedded unique key to avoid collision with
 * possible text in templates.
 */
const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
/**
 * An expression marker used text-positions, multi-binding attributes, and
 * attributes with markup-like text values.
 */

const nodeMarker = `<!--${marker}-->`;
const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
/**
 * Suffix appended to all bound attribute names.
 */

const boundAttributeSuffix = '$lit$';
/**
 * An updateable Template that tracks the location of dynamic parts.
 */

class Template {
  constructor(result, element) {
    this.parts = [];
    this.element = element;
    let index = -1;
    let partIndex = 0;
    const nodesToRemove = [];

    const _prepareTemplate = template => {
      const content = template.content; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
      // null

      const walker = document.createTreeWalker(content, 133
      /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
      , null, false); // Keeps track of the last index associated with a part. We try to delete
      // unnecessary nodes, but we never want to associate two different parts
      // to the same index. They must have a constant node between.

      let lastPartIndex = 0;

      while (walker.nextNode()) {
        index++;
        const node = walker.currentNode;

        if (node.nodeType === 1
        /* Node.ELEMENT_NODE */
        ) {
            if (node.hasAttributes()) {
              const attributes = node.attributes; // Per
              // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
              // attributes are not guaranteed to be returned in document order.
              // In particular, Edge/IE can return them out of order, so we cannot
              // assume a correspondance between part index and attribute index.

              let count = 0;

              for (let i = 0; i < attributes.length; i++) {
                if (attributes[i].value.indexOf(marker) >= 0) {
                  count++;
                }
              }

              while (count-- > 0) {
                // Get the template literal section leading up to the first
                // expression in this attribute
                const stringForPart = result.strings[partIndex]; // Find the attribute name

                const name = lastAttributeNameRegex.exec(stringForPart)[2]; // Find the corresponding attribute
                // All bound attributes have had a suffix added in
                // TemplateResult#getHTML to opt out of special attribute
                // handling. To look up the attribute value we also need to add
                // the suffix.

                const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
                const attributeValue = node.getAttribute(attributeLookupName);
                const strings = attributeValue.split(markerRegex);
                this.parts.push({
                  type: 'attribute',
                  index,
                  name,
                  strings
                });
                node.removeAttribute(attributeLookupName);
                partIndex += strings.length - 1;
              }
            }

            if (node.tagName === 'TEMPLATE') {
              _prepareTemplate(node);
            }
          } else if (node.nodeType === 3
        /* Node.TEXT_NODE */
        ) {
            const data = node.data;

            if (data.indexOf(marker) >= 0) {
              const parent = node.parentNode;
              const strings = data.split(markerRegex);
              const lastIndex = strings.length - 1; // Generate a new text node for each literal section
              // These nodes are also used as the markers for node parts

              for (let i = 0; i < lastIndex; i++) {
                parent.insertBefore(strings[i] === '' ? createMarker() : document.createTextNode(strings[i]), node);
                this.parts.push({
                  type: 'node',
                  index: ++index
                });
              } // If there's no text, we must insert a comment to mark our place.
              // Else, we can trust it will stick around after cloning.


              if (strings[lastIndex] === '') {
                parent.insertBefore(createMarker(), node);
                nodesToRemove.push(node);
              } else {
                node.data = strings[lastIndex];
              } // We have a part for each match found


              partIndex += lastIndex;
            }
          } else if (node.nodeType === 8
        /* Node.COMMENT_NODE */
        ) {
            if (node.data === marker) {
              const parent = node.parentNode; // Add a new marker node to be the startNode of the Part if any of
              // the following are true:
              //  * We don't have a previousSibling
              //  * The previousSibling is already the start of a previous part

              if (node.previousSibling === null || index === lastPartIndex) {
                index++;
                parent.insertBefore(createMarker(), node);
              }

              lastPartIndex = index;
              this.parts.push({
                type: 'node',
                index
              }); // If we don't have a nextSibling, keep this node so we have an end.
              // Else, we can remove it to save future costs.

              if (node.nextSibling === null) {
                node.data = '';
              } else {
                nodesToRemove.push(node);
                index--;
              }

              partIndex++;
            } else {
              let i = -1;

              while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
                // Comment node has a binding marker inside, make an inactive part
                // The binding won't work, but subsequent bindings will
                // TODO (justinfagnani): consider whether it's even worth it to
                // make bindings in comments work
                this.parts.push({
                  type: 'node',
                  index: -1
                });
              }
            }
          }
      }
    };

    _prepareTemplate(element); // Remove text binding nodes after the walk to not disturb the TreeWalker


    for (const n of nodesToRemove) {
      n.parentNode.removeChild(n);
    }
  }

}
const isTemplatePartActive = part => part.index !== -1; // Allows `document.createComment('')` to be renamed for a
// small manual size-savings.

const createMarker = () => document.createComment('');
/**
 * This regex extracts the attribute name preceding an attribute-position
 * expression. It does this by matching the syntax allowed for attributes
 * against the string literal directly preceding the expression, assuming that
 * the expression is in an attribute-value position.
 *
 * See attributes in the HTML spec:
 * https://www.w3.org/TR/html5/syntax.html#attributes-0
 *
 * "\0-\x1F\x7F-\x9F" are Unicode control characters
 *
 * " \x09\x0a\x0c\x0d" are HTML space characters:
 * https://www.w3.org/TR/html5/infrastructure.html#space-character
 *
 * So an attribute is:
 *  * The name: any character except a control character, space character, ('),
 *    ("), ">", "=", or "/"
 *  * Followed by zero or more space characters
 *  * Followed by "="
 *  * Followed by zero or more space characters
 *  * Followed by:
 *    * Any character except space, ('), ("), "<", ">", "=", (`), or
 *    * (") then any non-("), or
 *    * (') then any non-(')
 */

const lastAttributeNameRegex = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * An instance of a `Template` that can be attached to the DOM and updated
 * with new values.
 */

class TemplateInstance {
  constructor(template, processor, options) {
    this._parts = [];
    this.template = template;
    this.processor = processor;
    this.options = options;
  }

  update(values) {
    let i = 0;

    for (const part of this._parts) {
      if (part !== undefined) {
        part.setValue(values[i]);
      }

      i++;
    }

    for (const part of this._parts) {
      if (part !== undefined) {
        part.commit();
      }
    }
  }

  _clone() {
    // When using the Custom Elements polyfill, clone the node, rather than
    // importing it, to keep the fragment in the template's document. This
    // leaves the fragment inert so custom elements won't upgrade and
    // potentially modify their contents by creating a polyfilled ShadowRoot
    // while we traverse the tree.
    const fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
    const parts = this.template.parts;
    let partIndex = 0;
    let nodeIndex = 0;

    const _prepareInstance = fragment => {
      // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
      // null
      const walker = document.createTreeWalker(fragment, 133
      /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
      , null, false);
      let node = walker.nextNode(); // Loop through all the nodes and parts of a template

      while (partIndex < parts.length && node !== null) {
        const part = parts[partIndex]; // Consecutive Parts may have the same node index, in the case of
        // multiple bound attributes on an element. So each iteration we either
        // increment the nodeIndex, if we aren't on a node with a part, or the
        // partIndex if we are. By not incrementing the nodeIndex when we find a
        // part, we allow for the next part to be associated with the current
        // node if neccessasry.

        if (!isTemplatePartActive(part)) {
          this._parts.push(undefined);

          partIndex++;
        } else if (nodeIndex === part.index) {
          if (part.type === 'node') {
            const part = this.processor.handleTextExpression(this.options);
            part.insertAfterNode(node.previousSibling);

            this._parts.push(part);
          } else {
            this._parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
          }

          partIndex++;
        } else {
          nodeIndex++;

          if (node.nodeName === 'TEMPLATE') {
            _prepareInstance(node.content);
          }

          node = walker.nextNode();
        }
      }
    };

    _prepareInstance(fragment);

    if (isCEPolyfill) {
      document.adoptNode(fragment);
      customElements.upgrade(fragment);
    }

    return fragment;
  }

}

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */

class TemplateResult {
  constructor(strings, values, type, processor) {
    this.strings = strings;
    this.values = values;
    this.type = type;
    this.processor = processor;
  }
  /**
   * Returns a string of HTML used to create a `<template>` element.
   */


  getHTML() {
    const endIndex = this.strings.length - 1;
    let html = '';

    for (let i = 0; i < endIndex; i++) {
      const s = this.strings[i]; // This exec() call does two things:
      // 1) Appends a suffix to the bound attribute name to opt out of special
      // attribute value parsing that IE11 and Edge do, like for style and
      // many SVG attributes. The Template class also appends the same suffix
      // when looking up attributes to create Parts.
      // 2) Adds an unquoted-attribute-safe marker for the first expression in
      // an attribute. Subsequent attribute expressions will use node markers,
      // and this is safe since attributes with multiple expressions are
      // guaranteed to be quoted.

      const match = lastAttributeNameRegex.exec(s);

      if (match) {
        // We're starting a new bound attribute.
        // Add the safe attribute suffix, and use unquoted-attribute-safe
        // marker.
        html += s.substr(0, match.index) + match[1] + match[2] + boundAttributeSuffix + match[3] + marker;
      } else {
        // We're either in a bound node, or trailing bound attribute.
        // Either way, nodeMarker is safe to use.
        html += s + nodeMarker;
      }
    }

    return html + this.strings[endIndex];
  }

  getTemplateElement() {
    const template = document.createElement('template');
    template.innerHTML = this.getHTML();
    return template;
  }

}

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const isPrimitive = value => {
  return value === null || !(typeof value === 'object' || typeof value === 'function');
};
/**
 * Sets attribute values for AttributeParts, so that the value is only set once
 * even if there are multiple parts for an attribute.
 */

class AttributeCommitter {
  constructor(element, name, strings) {
    this.dirty = true;
    this.element = element;
    this.name = name;
    this.strings = strings;
    this.parts = [];

    for (let i = 0; i < strings.length - 1; i++) {
      this.parts[i] = this._createPart();
    }
  }
  /**
   * Creates a single part. Override this to create a differnt type of part.
   */


  _createPart() {
    return new AttributePart(this);
  }

  _getValue() {
    const strings = this.strings;
    const l = strings.length - 1;
    let text = '';

    for (let i = 0; i < l; i++) {
      text += strings[i];
      const part = this.parts[i];

      if (part !== undefined) {
        const v = part.value;

        if (v != null && (Array.isArray(v) || // tslint:disable-next-line:no-any
        typeof v !== 'string' && v[Symbol.iterator])) {
          for (const t of v) {
            text += typeof t === 'string' ? t : String(t);
          }
        } else {
          text += typeof v === 'string' ? v : String(v);
        }
      }
    }

    text += strings[l];
    return text;
  }

  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element.setAttribute(this.name, this._getValue());
    }
  }

}
class AttributePart {
  constructor(comitter) {
    this.value = undefined;
    this.committer = comitter;
  }

  setValue(value) {
    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
      this.value = value; // If the value is a not a directive, dirty the committer so that it'll
      // call setAttribute. If the value is a directive, it'll dirty the
      // committer if it calls setValue().

      if (!isDirective(value)) {
        this.committer.dirty = true;
      }
    }
  }

  commit() {
    while (isDirective(this.value)) {
      const directive = this.value;
      this.value = noChange;
      directive(this);
    }

    if (this.value === noChange) {
      return;
    }

    this.committer.commit();
  }

}
class NodePart {
  constructor(options) {
    this.value = undefined;
    this._pendingValue = undefined;
    this.options = options;
  }
  /**
   * Inserts this part into a container.
   *
   * This part must be empty, as its contents are not automatically moved.
   */


  appendInto(container) {
    this.startNode = container.appendChild(createMarker());
    this.endNode = container.appendChild(createMarker());
  }
  /**
   * Inserts this part between `ref` and `ref`'s next sibling. Both `ref` and
   * its next sibling must be static, unchanging nodes such as those that appear
   * in a literal section of a template.
   *
   * This part must be empty, as its contents are not automatically moved.
   */


  insertAfterNode(ref) {
    this.startNode = ref;
    this.endNode = ref.nextSibling;
  }
  /**
   * Appends this part into a parent part.
   *
   * This part must be empty, as its contents are not automatically moved.
   */


  appendIntoPart(part) {
    part._insert(this.startNode = createMarker());

    part._insert(this.endNode = createMarker());
  }
  /**
   * Appends this part after `ref`
   *
   * This part must be empty, as its contents are not automatically moved.
   */


  insertAfterPart(ref) {
    ref._insert(this.startNode = createMarker());

    this.endNode = ref.endNode;
    ref.endNode = this.startNode;
  }

  setValue(value) {
    this._pendingValue = value;
  }

  commit() {
    while (isDirective(this._pendingValue)) {
      const directive = this._pendingValue;
      this._pendingValue = noChange;
      directive(this);
    }

    const value = this._pendingValue;

    if (value === noChange) {
      return;
    }

    if (isPrimitive(value)) {
      if (value !== this.value) {
        this._commitText(value);
      }
    } else if (value instanceof TemplateResult) {
      this._commitTemplateResult(value);
    } else if (value instanceof Node) {
      this._commitNode(value);
    } else if (Array.isArray(value) || // tslint:disable-next-line:no-any
    value[Symbol.iterator]) {
      this._commitIterable(value);
    } else if (value === nothing) {
      this.value = nothing;
      this.clear();
    } else {
      // Fallback, will render the string representation
      this._commitText(value);
    }
  }

  _insert(node) {
    this.endNode.parentNode.insertBefore(node, this.endNode);
  }

  _commitNode(value) {
    if (this.value === value) {
      return;
    }

    this.clear();

    this._insert(value);

    this.value = value;
  }

  _commitText(value) {
    const node = this.startNode.nextSibling;
    value = value == null ? '' : value;

    if (node === this.endNode.previousSibling && node.nodeType === 3
    /* Node.TEXT_NODE */
    ) {
        // If we only have a single text node between the markers, we can just
        // set its value, rather than replacing it.
        // TODO(justinfagnani): Can we just check if this.value is primitive?
        node.data = value;
      } else {
      this._commitNode(document.createTextNode(typeof value === 'string' ? value : String(value)));
    }

    this.value = value;
  }

  _commitTemplateResult(value) {
    const template = this.options.templateFactory(value);

    if (this.value instanceof TemplateInstance && this.value.template === template) {
      this.value.update(value.values);
    } else {
      // Make sure we propagate the template processor from the TemplateResult
      // so that we use its syntax extension, etc. The template factory comes
      // from the render function options so that it can control template
      // caching and preprocessing.
      const instance = new TemplateInstance(template, value.processor, this.options);

      const fragment = instance._clone();

      instance.update(value.values);

      this._commitNode(fragment);

      this.value = instance;
    }
  }

  _commitIterable(value) {
    // For an Iterable, we create a new InstancePart per item, then set its
    // value to the item. This is a little bit of overhead for every item in
    // an Iterable, but it lets us recurse easily and efficiently update Arrays
    // of TemplateResults that will be commonly returned from expressions like:
    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
    // If _value is an array, then the previous render was of an
    // iterable and _value will contain the NodeParts from the previous
    // render. If _value is not an array, clear this part and make a new
    // array for NodeParts.
    if (!Array.isArray(this.value)) {
      this.value = [];
      this.clear();
    } // Lets us keep track of how many items we stamped so we can clear leftover
    // items from a previous render


    const itemParts = this.value;
    let partIndex = 0;
    let itemPart;

    for (const item of value) {
      // Try to reuse an existing part
      itemPart = itemParts[partIndex]; // If no existing part, create a new one

      if (itemPart === undefined) {
        itemPart = new NodePart(this.options);
        itemParts.push(itemPart);

        if (partIndex === 0) {
          itemPart.appendIntoPart(this);
        } else {
          itemPart.insertAfterPart(itemParts[partIndex - 1]);
        }
      }

      itemPart.setValue(item);
      itemPart.commit();
      partIndex++;
    }

    if (partIndex < itemParts.length) {
      // Truncate the parts array so _value reflects the current state
      itemParts.length = partIndex;
      this.clear(itemPart && itemPart.endNode);
    }
  }

  clear(startNode = this.startNode) {
    removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
  }

}
/**
 * Implements a boolean attribute, roughly as defined in the HTML
 * specification.
 *
 * If the value is truthy, then the attribute is present with a value of
 * ''. If the value is falsey, the attribute is removed.
 */

class BooleanAttributePart {
  constructor(element, name, strings) {
    this.value = undefined;
    this._pendingValue = undefined;

    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
      throw new Error('Boolean attributes can only contain a single expression');
    }

    this.element = element;
    this.name = name;
    this.strings = strings;
  }

  setValue(value) {
    this._pendingValue = value;
  }

  commit() {
    while (isDirective(this._pendingValue)) {
      const directive = this._pendingValue;
      this._pendingValue = noChange;
      directive(this);
    }

    if (this._pendingValue === noChange) {
      return;
    }

    const value = !!this._pendingValue;

    if (this.value !== value) {
      if (value) {
        this.element.setAttribute(this.name, '');
      } else {
        this.element.removeAttribute(this.name);
      }
    }

    this.value = value;
    this._pendingValue = noChange;
  }

}
/**
 * Sets attribute values for PropertyParts, so that the value is only set once
 * even if there are multiple parts for a property.
 *
 * If an expression controls the whole property value, then the value is simply
 * assigned to the property under control. If there are string literals or
 * multiple expressions, then the strings are expressions are interpolated into
 * a string first.
 */

class PropertyCommitter extends AttributeCommitter {
  constructor(element, name, strings) {
    super(element, name, strings);
    this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';
  }

  _createPart() {
    return new PropertyPart(this);
  }

  _getValue() {
    if (this.single) {
      return this.parts[0].value;
    }

    return super._getValue();
  }

  commit() {
    if (this.dirty) {
      this.dirty = false; // tslint:disable-next-line:no-any

      this.element[this.name] = this._getValue();
    }
  }

}
class PropertyPart extends AttributePart {} // Detect event listener options support. If the `capture` property is read
// from the options object, then options are supported. If not, then the thrid
// argument to add/removeEventListener is interpreted as the boolean capture
// value so we should only pass the `capture` property.

let eventOptionsSupported = false;

try {
  const options = {
    get capture() {
      eventOptionsSupported = true;
      return false;
    }

  }; // tslint:disable-next-line:no-any

  window.addEventListener('test', options, options); // tslint:disable-next-line:no-any

  window.removeEventListener('test', options, options);
} catch (_e) {}

class EventPart {
  constructor(element, eventName, eventContext) {
    this.value = undefined;
    this._pendingValue = undefined;
    this.element = element;
    this.eventName = eventName;
    this.eventContext = eventContext;

    this._boundHandleEvent = e => this.handleEvent(e);
  }

  setValue(value) {
    this._pendingValue = value;
  }

  commit() {
    while (isDirective(this._pendingValue)) {
      const directive = this._pendingValue;
      this._pendingValue = noChange;
      directive(this);
    }

    if (this._pendingValue === noChange) {
      return;
    }

    const newListener = this._pendingValue;
    const oldListener = this.value;
    const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
    const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);

    if (shouldRemoveListener) {
      this.element.removeEventListener(this.eventName, this._boundHandleEvent, this._options);
    }

    if (shouldAddListener) {
      this._options = getOptions(newListener);
      this.element.addEventListener(this.eventName, this._boundHandleEvent, this._options);
    }

    this.value = newListener;
    this._pendingValue = noChange;
  }

  handleEvent(event) {
    if (typeof this.value === 'function') {
      this.value.call(this.eventContext || this.element, event);
    } else {
      this.value.handleEvent(event);
    }
  }

} // We copy options because of the inconsistent behavior of browsers when reading
// the third argument of add/removeEventListener. IE11 doesn't support options
// at all. Chrome 41 only reads `capture` if the argument is an object.

const getOptions = o => o && (eventOptionsSupported ? {
  capture: o.capture,
  passive: o.passive,
  once: o.once
} : o.capture);

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Creates Parts when a template is instantiated.
 */

class DefaultTemplateProcessor {
  /**
   * Create parts for an attribute-position binding, given the event, attribute
   * name, and string literals.
   *
   * @param element The element containing the binding
   * @param name  The attribute name
   * @param strings The string literals. There are always at least two strings,
   *   event for fully-controlled bindings with a single expression.
   */
  handleAttributeExpressions(element, name, strings, options) {
    const prefix = name[0];

    if (prefix === '.') {
      const comitter = new PropertyCommitter(element, name.slice(1), strings);
      return comitter.parts;
    }

    if (prefix === '@') {
      return [new EventPart(element, name.slice(1), options.eventContext)];
    }

    if (prefix === '?') {
      return [new BooleanAttributePart(element, name.slice(1), strings)];
    }

    const comitter = new AttributeCommitter(element, name, strings);
    return comitter.parts;
  }
  /**
   * Create parts for a text-position binding.
   * @param templateFactory
   */


  handleTextExpression(options) {
    return new NodePart(options);
  }

}
const defaultTemplateProcessor = new DefaultTemplateProcessor();

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * The default TemplateFactory which caches Templates keyed on
 * result.type and result.strings.
 */

function templateFactory(result) {
  let templateCache = templateCaches.get(result.type);

  if (templateCache === undefined) {
    templateCache = {
      stringsArray: new WeakMap(),
      keyString: new Map()
    };
    templateCaches.set(result.type, templateCache);
  }

  let template = templateCache.stringsArray.get(result.strings);

  if (template !== undefined) {
    return template;
  } // If the TemplateStringsArray is new, generate a key from the strings
  // This key is shared between all templates with identical content


  const key = result.strings.join(marker); // Check if we already have a Template for this key

  template = templateCache.keyString.get(key);

  if (template === undefined) {
    // If we have not seen this key before, create a new Template
    template = new Template(result, result.getTemplateElement()); // Cache the Template for this key

    templateCache.keyString.set(key, template);
  } // Cache all future queries for this TemplateStringsArray


  templateCache.stringsArray.set(result.strings, template);
  return template;
}
const templateCaches = new Map();

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const parts = new WeakMap();
/**
 * Renders a template to a container.
 *
 * To update a container with new values, reevaluate the template literal and
 * call `render` with the new result.
 *
 * @param result a TemplateResult created by evaluating a template tag like
 *     `html` or `svg`.
 * @param container A DOM parent to render to. The entire contents are either
 *     replaced, or efficiently updated if the same result type was previous
 *     rendered there.
 * @param options RenderOptions for the entire render tree rendered to this
 *     container. Render options must *not* change between renders to the same
 *     container, as those changes will not effect previously rendered DOM.
 */

const render = (result, container, options) => {
  let part = parts.get(container);

  if (part === undefined) {
    removeNodes(container, container.firstChild);
    parts.set(container, part = new NodePart(Object.assign({
      templateFactory
    }, options)));
    part.appendInto(container);
  }

  part.setValue(result);
  part.commit();
};

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// This line will be used in regexes to search for lit-html usage.
// TODO(justinfagnani): inject version number at build time

(window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.0.0');
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 */

const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const walkerNodeFilter = 133
/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
;
/**
 * Removes the list of nodes from a Template safely. In addition to removing
 * nodes from the Template, the Template part indices are updated to match
 * the mutated Template DOM.
 *
 * As the template is walked the removal state is tracked and
 * part indices are adjusted as needed.
 *
 * div
 *   div#1 (remove) <-- start removing (removing node is div#1)
 *     div
 *       div#2 (remove)  <-- continue removing (removing node is still div#1)
 *         div
 * div <-- stop removing since previous sibling is the removing node (div#1,
 * removed 4 nodes)
 */

function removeNodesFromTemplate(template, nodesToRemove) {
  const {
    element: {
      content
    },
    parts
  } = template;
  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts);
  let part = parts[partIndex];
  let nodeIndex = -1;
  let removeCount = 0;
  const nodesToRemoveInTemplate = [];
  let currentRemovingNode = null;

  while (walker.nextNode()) {
    nodeIndex++;
    const node = walker.currentNode; // End removal if stepped past the removing node

    if (node.previousSibling === currentRemovingNode) {
      currentRemovingNode = null;
    } // A node to remove was found in the template


    if (nodesToRemove.has(node)) {
      nodesToRemoveInTemplate.push(node); // Track node we're removing

      if (currentRemovingNode === null) {
        currentRemovingNode = node;
      }
    } // When removing, increment count by which to adjust subsequent part indices


    if (currentRemovingNode !== null) {
      removeCount++;
    }

    while (part !== undefined && part.index === nodeIndex) {
      // If part is in a removed node deactivate it by setting index to -1 or
      // adjust the index as needed.
      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount; // go to the next active part.

      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
      part = parts[partIndex];
    }
  }

  nodesToRemoveInTemplate.forEach(n => n.parentNode.removeChild(n));
}

const countNodes = node => {
  let count = node.nodeType === 11
  /* Node.DOCUMENT_FRAGMENT_NODE */
  ? 0 : 1;
  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);

  while (walker.nextNode()) {
    count++;
  }

  return count;
};

const nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {
  for (let i = startIndex + 1; i < parts.length; i++) {
    const part = parts[i];

    if (isTemplatePartActive(part)) {
      return i;
    }
  }

  return -1;
};
/**
 * Inserts the given node into the Template, optionally before the given
 * refNode. In addition to inserting the node into the Template, the Template
 * part indices are updated to match the mutated Template DOM.
 */


function insertNodeIntoTemplate(template, node, refNode = null) {
  const {
    element: {
      content
    },
    parts
  } = template; // If there's no refNode, then put node at end of template.
  // No part indices need to be shifted in this case.

  if (refNode === null || refNode === undefined) {
    content.appendChild(node);
    return;
  }

  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts);
  let insertCount = 0;
  let walkerIndex = -1;

  while (walker.nextNode()) {
    walkerIndex++;
    const walkerNode = walker.currentNode;

    if (walkerNode === refNode) {
      insertCount = countNodes(node);
      refNode.parentNode.insertBefore(node, refNode);
    }

    while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {
      // If we've inserted the node, simply adjust all subsequent parts
      if (insertCount > 0) {
        while (partIndex !== -1) {
          parts[partIndex].index += insertCount;
          partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
        }

        return;
      }

      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
    }
  }
}

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

const getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;

let compatibleShadyCSSVersion = true;

if (typeof window.ShadyCSS === 'undefined') {
  compatibleShadyCSSVersion = false;
} else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {
  console.warn(`Incompatible ShadyCSS version detected.` + `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and` + `@webcomponents/shadycss@1.3.1.`);
  compatibleShadyCSSVersion = false;
}
/**
 * Template factory which scopes template DOM using ShadyCSS.
 * @param scopeName {string}
 */


const shadyTemplateFactory = scopeName => result => {
  const cacheKey = getTemplateCacheKey(result.type, scopeName);
  let templateCache = templateCaches.get(cacheKey);

  if (templateCache === undefined) {
    templateCache = {
      stringsArray: new WeakMap(),
      keyString: new Map()
    };
    templateCaches.set(cacheKey, templateCache);
  }

  let template = templateCache.stringsArray.get(result.strings);

  if (template !== undefined) {
    return template;
  }

  const key = result.strings.join(marker);
  template = templateCache.keyString.get(key);

  if (template === undefined) {
    const element = result.getTemplateElement();

    if (compatibleShadyCSSVersion) {
      window.ShadyCSS.prepareTemplateDom(element, scopeName);
    }

    template = new Template(result, element);
    templateCache.keyString.set(key, template);
  }

  templateCache.stringsArray.set(result.strings, template);
  return template;
};

const TEMPLATE_TYPES = ['html', 'svg'];
/**
 * Removes all style elements from Templates for the given scopeName.
 */

const removeStylesFromLitTemplates = scopeName => {
  TEMPLATE_TYPES.forEach(type => {
    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));

    if (templates !== undefined) {
      templates.keyString.forEach(template => {
        const {
          element: {
            content
          }
        } = template; // IE 11 doesn't support the iterable param Set constructor

        const styles = new Set();
        Array.from(content.querySelectorAll('style')).forEach(s => {
          styles.add(s);
        });
        removeNodesFromTemplate(template, styles);
      });
    }
  });
};

const shadyRenderSet = new Set();
/**
 * For the given scope name, ensures that ShadyCSS style scoping is performed.
 * This is done just once per scope name so the fragment and template cannot
 * be modified.
 * (1) extracts styles from the rendered fragment and hands them to ShadyCSS
 * to be scoped and appended to the document
 * (2) removes style elements from all lit-html Templates for this scope name.
 *
 * Note, <style> elements can only be placed into templates for the
 * initial rendering of the scope. If <style> elements are included in templates
 * dynamically rendered to the scope (after the first scope render), they will
 * not be scoped and the <style> will be left in the template and rendered
 * output.
 */

const prepareTemplateStyles = (renderedDOM, template, scopeName) => {
  shadyRenderSet.add(scopeName); // Move styles out of rendered DOM and store.

  const styles = renderedDOM.querySelectorAll('style'); // If there are no styles, skip unnecessary work

  if (styles.length === 0) {
    // Ensure prepareTemplateStyles is called to support adding
    // styles via `prepareAdoptedCssText` since that requires that
    // `prepareTemplateStyles` is called.
    window.ShadyCSS.prepareTemplateStyles(template.element, scopeName);
    return;
  }

  const condensedStyle = document.createElement('style'); // Collect styles into a single style. This helps us make sure ShadyCSS
  // manipulations will not prevent us from being able to fix up template
  // part indices.
  // NOTE: collecting styles is inefficient for browsers but ShadyCSS
  // currently does this anyway. When it does not, this should be changed.

  for (let i = 0; i < styles.length; i++) {
    const style = styles[i];
    style.parentNode.removeChild(style);
    condensedStyle.textContent += style.textContent;
  } // Remove styles from nested templates in this scope.


  removeStylesFromLitTemplates(scopeName); // And then put the condensed style into the "root" template passed in as
  // `template`.

  insertNodeIntoTemplate(template, condensedStyle, template.element.content.firstChild); // Note, it's important that ShadyCSS gets the template that `lit-html`
  // will actually render so that it can update the style inside when
  // needed (e.g. @apply native Shadow DOM case).

  window.ShadyCSS.prepareTemplateStyles(template.element, scopeName);

  if (window.ShadyCSS.nativeShadow) {
    // When in native Shadow DOM, re-add styling to rendered content using
    // the style ShadyCSS produced.
    const style = template.element.content.querySelector('style');
    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
  } else {
    // When not in native Shadow DOM, at this point ShadyCSS will have
    // removed the style from the lit template and parts will be broken as a
    // result. To fix this, we put back the style node ShadyCSS removed
    // and then tell lit to remove that node from the template.
    // NOTE, ShadyCSS creates its own style so we can safely add/remove
    // `condensedStyle` here.
    template.element.content.insertBefore(condensedStyle, template.element.content.firstChild);
    const removes = new Set();
    removes.add(condensedStyle);
    removeNodesFromTemplate(template, removes);
  }
};
/**
 * Extension to the standard `render` method which supports rendering
 * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)
 * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used
 * or when the webcomponentsjs
 * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.
 *
 * Adds a `scopeName` option which is used to scope element DOM and stylesheets
 * when native ShadowDOM is unavailable. The `scopeName` will be added to
 * the class attribute of all rendered DOM. In addition, any style elements will
 * be automatically re-written with this `scopeName` selector and moved out
 * of the rendered DOM and into the document `<head>`.
 *
 * It is common to use this render method in conjunction with a custom element
 * which renders a shadowRoot. When this is done, typically the element's
 * `localName` should be used as the `scopeName`.
 *
 * In addition to DOM scoping, ShadyCSS also supports a basic shim for css
 * custom properties (needed only on older browsers like IE11) and a shim for
 * a deprecated feature called `@apply` that supports applying a set of css
 * custom properties to a given location.
 *
 * Usage considerations:
 *
 * * Part values in `<style>` elements are only applied the first time a given
 * `scopeName` renders. Subsequent changes to parts in style elements will have
 * no effect. Because of this, parts in style elements should only be used for
 * values that will never change, for example parts that set scope-wide theme
 * values or parts which render shared style elements.
 *
 * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a
 * custom element's `constructor` is not supported. Instead rendering should
 * either done asynchronously, for example at microtask timing (for example
 * `Promise.resolve()`), or be deferred until the first time the element's
 * `connectedCallback` runs.
 *
 * Usage considerations when using shimmed custom properties or `@apply`:
 *
 * * Whenever any dynamic changes are made which affect
 * css custom properties, `ShadyCSS.styleElement(element)` must be called
 * to update the element. There are two cases when this is needed:
 * (1) the element is connected to a new parent, (2) a class is added to the
 * element that causes it to match different custom properties.
 * To address the first case when rendering a custom element, `styleElement`
 * should be called in the element's `connectedCallback`.
 *
 * * Shimmed custom properties may only be defined either for an entire
 * shadowRoot (for example, in a `:host` rule) or via a rule that directly
 * matches an element with a shadowRoot. In other words, instead of flowing from
 * parent to child as do native css custom properties, shimmed custom properties
 * flow only from shadowRoots to nested shadowRoots.
 *
 * * When using `@apply` mixing css shorthand property names with
 * non-shorthand names (for example `border` and `border-width`) is not
 * supported.
 */


const render$1 = (result, container, options) => {
  const scopeName = options.scopeName;
  const hasRendered = parts.has(container);
  const needsScoping = container instanceof ShadowRoot && compatibleShadyCSSVersion && result instanceof TemplateResult; // Handle first render to a scope specially...

  const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName); // On first scope render, render into a fragment; this cannot be a single
  // fragment that is reused since nested renders can occur synchronously.

  const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
  render(result, renderContainer, Object.assign({
    templateFactory: shadyTemplateFactory(scopeName)
  }, options)); // When performing first scope render,
  // (1) We've rendered into a fragment so that there's a chance to
  // `prepareTemplateStyles` before sub-elements hit the DOM
  // (which might cause them to render based on a common pattern of
  // rendering in a custom element's `connectedCallback`);
  // (2) Scope the template with ShadyCSS one time only for this scope.
  // (3) Render the fragment into the container and make sure the
  // container knows its `part` is the one we just rendered. This ensures
  // DOM will be re-used on subsequent renders.

  if (firstScopeRender) {
    const part = parts.get(renderContainer);
    parts.delete(renderContainer);

    if (part.value instanceof TemplateInstance) {
      prepareTemplateStyles(renderContainer, part.value.template, scopeName);
    }

    removeNodes(container, container.firstChild);
    container.appendChild(renderContainer);
    parts.set(container, part);
  } // After elements have hit the DOM, update styling if this is the
  // initial render to this container.
  // This is needed whenever dynamic changes are made so it would be
  // safest to do every render; however, this would regress performance
  // so we leave it up to the user to call `ShadyCSSS.styleElement`
  // for dynamic changes.


  if (!hasRendered && needsScoping) {
    window.ShadyCSS.styleElement(container.host);
  }
};

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is
 * replaced at compile time by the munged name for object[property]. We cannot
 * alias this function, so we have to use a small shim that has the same
 * behavior when not compiling.
 */
window.JSCompiler_renameProperty = (prop, _obj) => prop;

const defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value ? '' : null;

      case Object:
      case Array:
        // if the value is `null` or `undefined` pass this through
        // to allow removing/no change behavior.
        return value == null ? value : JSON.stringify(value);
    }

    return value;
  },

  fromAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value !== null;

      case Number:
        return value === null ? null : Number(value);

      case Object:
      case Array:
        return JSON.parse(value);
    }

    return value;
  }

};
/**
 * Change function that returns true if `value` is different from `oldValue`.
 * This method is used as the default for a property's `hasChanged` function.
 */

const notEqual = (value, old) => {
  // This ensures (old==NaN, value==NaN) always returns false
  return old !== value && (old === old || value === value);
};
const defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
const microtaskPromise = Promise.resolve(true);
const STATE_HAS_UPDATED = 1;
const STATE_UPDATE_REQUESTED = 1 << 2;
const STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
const STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
const STATE_HAS_CONNECTED = 1 << 5;
/**
 * Base element class which manages element properties and attributes. When
 * properties change, the `update` method is asynchronously called. This method
 * should be supplied by subclassers to render updates as desired.
 */

class UpdatingElement extends HTMLElement {
  constructor() {
    super();
    this._updateState = 0;
    this._instanceProperties = undefined;
    this._updatePromise = microtaskPromise;
    this._hasConnectedResolver = undefined;
    /**
     * Map with keys for any properties that have changed since the last
     * update cycle with previous values.
     */

    this._changedProperties = new Map();
    /**
     * Map with keys of properties that should be reflected when updated.
     */

    this._reflectingProperties = undefined;
    this.initialize();
  }
  /**
   * Returns a list of attributes corresponding to the registered properties.
   * @nocollapse
   */


  static get observedAttributes() {
    // note: piggy backing on this to ensure we're finalized.
    this.finalize();
    const attributes = []; // Use forEach so this works even if for/of loops are compiled to for loops
    // expecting arrays

    this._classProperties.forEach((v, p) => {
      const attr = this._attributeNameForProperty(p, v);

      if (attr !== undefined) {
        this._attributeToPropertyMap.set(attr, p);

        attributes.push(attr);
      }
    });

    return attributes;
  }
  /**
   * Ensures the private `_classProperties` property metadata is created.
   * In addition to `finalize` this is also called in `createProperty` to
   * ensure the `@property` decorator can add property metadata.
   */

  /** @nocollapse */


  static _ensureClassProperties() {
    // ensure private storage for property declarations.
    if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
      this._classProperties = new Map(); // NOTE: Workaround IE11 not supporting Map constructor argument.

      const superProperties = Object.getPrototypeOf(this)._classProperties;

      if (superProperties !== undefined) {
        superProperties.forEach((v, k) => this._classProperties.set(k, v));
      }
    }
  }
  /**
   * Creates a property accessor on the element prototype if one does not exist.
   * The property setter calls the property's `hasChanged` property option
   * or uses a strict identity check to determine whether or not to request
   * an update.
   * @nocollapse
   */


  static createProperty(name, options = defaultPropertyDeclaration) {
    // Note, since this can be called by the `@property` decorator which
    // is called before `finalize`, we ensure storage exists for property
    // metadata.
    this._ensureClassProperties();

    this._classProperties.set(name, options); // Do not generate an accessor if the prototype already has one, since
    // it would be lost otherwise and that would never be the user's intention;
    // Instead, we expect users to call `requestUpdate` themselves from
    // user-defined accessors. Note that if the super has an accessor we will
    // still overwrite it


    if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
      return;
    }

    const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
    Object.defineProperty(this.prototype, name, {
      // tslint:disable-next-line:no-any no symbol in index
      get() {
        return this[key];
      },

      set(value) {
        // tslint:disable-next-line:no-any no symbol in index
        const oldValue = this[name]; // tslint:disable-next-line:no-any no symbol in index

        this[key] = value;

        this._requestUpdate(name, oldValue);
      },

      configurable: true,
      enumerable: true
    });
  }
  /**
   * Creates property accessors for registered properties and ensures
   * any superclasses are also finalized.
   * @nocollapse
   */


  static finalize() {
    if (this.hasOwnProperty(JSCompiler_renameProperty('finalized', this)) && this.finalized) {
      return;
    } // finalize any superclasses


    const superCtor = Object.getPrototypeOf(this);

    if (typeof superCtor.finalize === 'function') {
      superCtor.finalize();
    }

    this.finalized = true;

    this._ensureClassProperties(); // initialize Map populated in observedAttributes


    this._attributeToPropertyMap = new Map(); // make any properties
    // Note, only process "own" properties since this element will inherit
    // any properties defined on the superClass, and finalization ensures
    // the entire prototype chain is finalized.

    if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
      const props = this.properties; // support symbols in properties (IE11 does not support this)

      const propKeys = [...Object.getOwnPropertyNames(props), ...(typeof Object.getOwnPropertySymbols === 'function' ? Object.getOwnPropertySymbols(props) : [])]; // This for/of is ok because propKeys is an array

      for (const p of propKeys) {
        // note, use of `any` is due to TypeSript lack of support for symbol in
        // index types
        // tslint:disable-next-line:no-any no symbol in index
        this.createProperty(p, props[p]);
      }
    }
  }
  /**
   * Returns the property name for the given attribute `name`.
   * @nocollapse
   */


  static _attributeNameForProperty(name, options) {
    const attribute = options.attribute;
    return attribute === false ? undefined : typeof attribute === 'string' ? attribute : typeof name === 'string' ? name.toLowerCase() : undefined;
  }
  /**
   * Returns true if a property should request an update.
   * Called when a property value is set and uses the `hasChanged`
   * option for the property if present or a strict identity check.
   * @nocollapse
   */


  static _valueHasChanged(value, old, hasChanged = notEqual) {
    return hasChanged(value, old);
  }
  /**
   * Returns the property value for the given attribute value.
   * Called via the `attributeChangedCallback` and uses the property's
   * `converter` or `converter.fromAttribute` property option.
   * @nocollapse
   */


  static _propertyValueFromAttribute(value, options) {
    const type = options.type;
    const converter = options.converter || defaultConverter;
    const fromAttribute = typeof converter === 'function' ? converter : converter.fromAttribute;
    return fromAttribute ? fromAttribute(value, type) : value;
  }
  /**
   * Returns the attribute value for the given property value. If this
   * returns undefined, the property will *not* be reflected to an attribute.
   * If this returns null, the attribute will be removed, otherwise the
   * attribute will be set to the value.
   * This uses the property's `reflect` and `type.toAttribute` property options.
   * @nocollapse
   */


  static _propertyValueToAttribute(value, options) {
    if (options.reflect === undefined) {
      return;
    }

    const type = options.type;
    const converter = options.converter;
    const toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;
    return toAttribute(value, type);
  }
  /**
   * Performs element initialization. By default captures any pre-set values for
   * registered properties.
   */


  initialize() {
    this._saveInstanceProperties(); // ensures first update will be caught by an early access of `updateComplete`


    this._requestUpdate();
  }
  /**
   * Fixes any properties set on the instance before upgrade time.
   * Otherwise these would shadow the accessor and break these properties.
   * The properties are stored in a Map which is played back after the
   * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
   * (<=41), properties created for native platform properties like (`id` or
   * `name`) may not have default values set in the element constructor. On
   * these browsers native properties appear on instances and therefore their
   * default value will overwrite any element default (e.g. if the element sets
   * this.id = 'id' in the constructor, the 'id' will become '' since this is
   * the native platform default).
   */


  _saveInstanceProperties() {
    // Use forEach so this works even if for/of loops are compiled to for loops
    // expecting arrays
    this.constructor._classProperties.forEach((_v, p) => {
      if (this.hasOwnProperty(p)) {
        const value = this[p];
        delete this[p];

        if (!this._instanceProperties) {
          this._instanceProperties = new Map();
        }

        this._instanceProperties.set(p, value);
      }
    });
  }
  /**
   * Applies previously saved instance properties.
   */


  _applyInstanceProperties() {
    // Use forEach so this works even if for/of loops are compiled to for loops
    // expecting arrays
    // tslint:disable-next-line:no-any
    this._instanceProperties.forEach((v, p) => this[p] = v);

    this._instanceProperties = undefined;
  }

  connectedCallback() {
    this._updateState = this._updateState | STATE_HAS_CONNECTED; // Ensure first connection completes an update. Updates cannot complete before
    // connection and if one is pending connection the `_hasConnectionResolver`
    // will exist. If so, resolve it to complete the update, otherwise
    // requestUpdate.

    if (this._hasConnectedResolver) {
      this._hasConnectedResolver();

      this._hasConnectedResolver = undefined;
    }
  }
  /**
   * Allows for `super.disconnectedCallback()` in extensions while
   * reserving the possibility of making non-breaking feature additions
   * when disconnecting at some point in the future.
   */


  disconnectedCallback() {}
  /**
   * Synchronizes property values when attributes change.
   */


  attributeChangedCallback(name, old, value) {
    if (old !== value) {
      this._attributeToProperty(name, value);
    }
  }

  _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
    const ctor = this.constructor;

    const attr = ctor._attributeNameForProperty(name, options);

    if (attr !== undefined) {
      const attrValue = ctor._propertyValueToAttribute(value, options); // an undefined value does not change the attribute.


      if (attrValue === undefined) {
        return;
      } // Track if the property is being reflected to avoid
      // setting the property again via `attributeChangedCallback`. Note:
      // 1. this takes advantage of the fact that the callback is synchronous.
      // 2. will behave incorrectly if multiple attributes are in the reaction
      // stack at time of calling. However, since we process attributes
      // in `update` this should not be possible (or an extreme corner case
      // that we'd like to discover).
      // mark state reflecting


      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;

      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      } // mark state not reflecting


      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
    }
  }

  _attributeToProperty(name, value) {
    // Use tracking info to avoid deserializing attribute value if it was
    // just set from a property setter.
    if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
      return;
    }

    const ctor = this.constructor;

    const propName = ctor._attributeToPropertyMap.get(name);

    if (propName !== undefined) {
      const options = ctor._classProperties.get(propName) || defaultPropertyDeclaration; // mark state reflecting

      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
      this[propName] = // tslint:disable-next-line:no-any
      ctor._propertyValueFromAttribute(value, options); // mark state not reflecting

      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
    }
  }
  /**
   * This private version of `requestUpdate` does not access or return the
   * `updateComplete` promise. This promise can be overridden and is therefore
   * not free to access.
   */


  _requestUpdate(name, oldValue) {
    let shouldRequestUpdate = true; // If we have a property key, perform property update steps.

    if (name !== undefined) {
      const ctor = this.constructor;
      const options = ctor._classProperties.get(name) || defaultPropertyDeclaration;

      if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
        if (!this._changedProperties.has(name)) {
          this._changedProperties.set(name, oldValue);
        } // Add to reflecting properties set.
        // Note, it's important that every change has a chance to add the
        // property to `_reflectingProperties`. This ensures setting
        // attribute + property reflects correctly.


        if (options.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
          if (this._reflectingProperties === undefined) {
            this._reflectingProperties = new Map();
          }

          this._reflectingProperties.set(name, options);
        }
      } else {
        // Abort the request if the property should not be considered changed.
        shouldRequestUpdate = false;
      }
    }

    if (!this._hasRequestedUpdate && shouldRequestUpdate) {
      this._enqueueUpdate();
    }
  }
  /**
   * Requests an update which is processed asynchronously. This should
   * be called when an element should update based on some state not triggered
   * by setting a property. In this case, pass no arguments. It should also be
   * called when manually implementing a property setter. In this case, pass the
   * property `name` and `oldValue` to ensure that any configured property
   * options are honored. Returns the `updateComplete` Promise which is resolved
   * when the update completes.
   *
   * @param name {PropertyKey} (optional) name of requesting property
   * @param oldValue {any} (optional) old value of requesting property
   * @returns {Promise} A Promise that is resolved when the update completes.
   */


  requestUpdate(name, oldValue) {
    this._requestUpdate(name, oldValue);

    return this.updateComplete;
  }
  /**
   * Sets up the element to asynchronously update.
   */


  async _enqueueUpdate() {
    // Mark state updating...
    this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
    let resolve;
    let reject;
    const previousUpdatePromise = this._updatePromise;
    this._updatePromise = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });

    try {
      // Ensure any previous update has resolved before updating.
      // This `await` also ensures that property changes are batched.
      await previousUpdatePromise;
    } catch (e) {} // Ignore any previous errors. We only care that the previous cycle is
    // done. Any error should have been handled in the previous update.
    // Make sure the element has connected before updating.


    if (!this._hasConnected) {
      await new Promise(res => this._hasConnectedResolver = res);
    }

    try {
      const result = this.performUpdate(); // If `performUpdate` returns a Promise, we await it. This is done to
      // enable coordinating updates with a scheduler. Note, the result is
      // checked to avoid delaying an additional microtask unless we need to.

      if (result != null) {
        await result;
      }
    } catch (e) {
      reject(e);
    }

    resolve(!this._hasRequestedUpdate);
  }

  get _hasConnected() {
    return this._updateState & STATE_HAS_CONNECTED;
  }

  get _hasRequestedUpdate() {
    return this._updateState & STATE_UPDATE_REQUESTED;
  }

  get hasUpdated() {
    return this._updateState & STATE_HAS_UPDATED;
  }
  /**
   * Performs an element update. Note, if an exception is thrown during the
   * update, `firstUpdated` and `updated` will not be called.
   *
   * You can override this method to change the timing of updates. If this
   * method is overridden, `super.performUpdate()` must be called.
   *
   * For instance, to schedule updates to occur just before the next frame:
   *
   * ```
   * protected async performUpdate(): Promise<unknown> {
   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
   *   super.performUpdate();
   * }
   * ```
   */


  performUpdate() {
    // Mixin instance properties once, if they exist.
    if (this._instanceProperties) {
      this._applyInstanceProperties();
    }

    let shouldUpdate = false;
    const changedProperties = this._changedProperties;

    try {
      shouldUpdate = this.shouldUpdate(changedProperties);

      if (shouldUpdate) {
        this.update(changedProperties);
      }
    } catch (e) {
      // Prevent `firstUpdated` and `updated` from running when there's an
      // update exception.
      shouldUpdate = false;
      throw e;
    } finally {
      // Ensure element can accept additional updates after an exception.
      this._markUpdated();
    }

    if (shouldUpdate) {
      if (!(this._updateState & STATE_HAS_UPDATED)) {
        this._updateState = this._updateState | STATE_HAS_UPDATED;
        this.firstUpdated(changedProperties);
      }

      this.updated(changedProperties);
    }
  }

  _markUpdated() {
    this._changedProperties = new Map();
    this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
  }
  /**
   * Returns a Promise that resolves when the element has completed updating.
   * The Promise value is a boolean that is `true` if the element completed the
   * update without triggering another update. The Promise result is `false` if
   * a property was set inside `updated()`. If the Promise is rejected, an
   * exception was thrown during the update. This getter can be implemented to
   * await additional state. For example, it is sometimes useful to await a
   * rendered element before fulfilling this Promise. To do this, first await
   * `super.updateComplete` then any subsequent state.
   *
   * @returns {Promise} The Promise returns a boolean that indicates if the
   * update resolved without triggering another update.
   */


  get updateComplete() {
    return this._updatePromise;
  }
  /**
   * Controls whether or not `update` should be called when the element requests
   * an update. By default, this method always returns `true`, but this can be
   * customized to control when to update.
   *
   * * @param _changedProperties Map of changed properties with old values
   */


  shouldUpdate(_changedProperties) {
    return true;
  }
  /**
   * Updates the element. This method reflects property values to attributes.
   * It can be overridden to render and keep updated element DOM.
   * Setting properties inside this method will *not* trigger
   * another update.
   *
   * * @param _changedProperties Map of changed properties with old values
   */


  update(_changedProperties) {
    if (this._reflectingProperties !== undefined && this._reflectingProperties.size > 0) {
      // Use forEach so this works even if for/of loops are compiled to for
      // loops expecting arrays
      this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));

      this._reflectingProperties = undefined;
    }
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * * @param _changedProperties Map of changed properties with old values
   */


  updated(_changedProperties) {}
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * * @param _changedProperties Map of changed properties with old values
   */


  firstUpdated(_changedProperties) {}

}
/**
 * Marks class as having finished creating properties.
 */

UpdatingElement.finalized = true;

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const supportsAdoptingStyleSheets = 'adoptedStyleSheets' in Document.prototype && 'replace' in CSSStyleSheet.prototype;

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// This line will be used in regexes to search for LitElement usage.
// TODO(justinfagnani): inject version number at build time

(window['litElementVersions'] || (window['litElementVersions'] = [])).push('2.0.1');
/**
 * Minimal implementation of Array.prototype.flat
 * @param arr the array to flatten
 * @param result the accumlated result
 */

function arrayFlat(styles, result = []) {
  for (let i = 0, length = styles.length; i < length; i++) {
    const value = styles[i];

    if (Array.isArray(value)) {
      arrayFlat(value, result);
    } else {
      result.push(value);
    }
  }

  return result;
}
/** Deeply flattens styles array. Uses native flat if available. */


const flattenStyles = styles => styles.flat ? styles.flat(Infinity) : arrayFlat(styles);

class LitElement extends UpdatingElement {
  /** @nocollapse */
  static finalize() {
    super.finalize(); // Prepare styling that is stamped at first render time. Styling
    // is built from user provided `styles` or is inherited from the superclass.

    this._styles = this.hasOwnProperty(JSCompiler_renameProperty('styles', this)) ? this._getUniqueStyles() : this._styles || [];
  }
  /** @nocollapse */


  static _getUniqueStyles() {
    // Take care not to call `this.styles` multiple times since this generates
    // new CSSResults each time.
    // TODO(sorvell): Since we do not cache CSSResults by input, any
    // shared styles will generate new stylesheet objects, which is wasteful.
    // This should be addressed when a browser ships constructable
    // stylesheets.
    const userStyles = this.styles;
    const styles = [];

    if (Array.isArray(userStyles)) {
      const flatStyles = flattenStyles(userStyles); // As a performance optimization to avoid duplicated styling that can
      // occur especially when composing via subclassing, de-duplicate styles
      // preserving the last item in the list. The last item is kept to
      // try to preserve cascade order with the assumption that it's most
      // important that last added styles override previous styles.

      const styleSet = flatStyles.reduceRight((set, s) => {
        set.add(s); // on IE set.add does not return the set.

        return set;
      }, new Set()); // Array.from does not work on Set in IE

      styleSet.forEach(v => styles.unshift(v));
    } else if (userStyles) {
      styles.push(userStyles);
    }

    return styles;
  }
  /**
   * Performs element initialization. By default this calls `createRenderRoot`
   * to create the element `renderRoot` node and captures any pre-set values for
   * registered properties.
   */


  initialize() {
    super.initialize();
    this.renderRoot = this.createRenderRoot(); // Note, if renderRoot is not a shadowRoot, styles would/could apply to the
    // element's getRootNode(). While this could be done, we're choosing not to
    // support this now since it would require different logic around de-duping.

    if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
      this.adoptStyles();
    }
  }
  /**
   * Returns the node into which the element should render and by default
   * creates and returns an open shadowRoot. Implement to customize where the
   * element's DOM is rendered. For example, to render into the element's
   * childNodes, return `this`.
   * @returns {Element|DocumentFragment} Returns a node into which to render.
   */


  createRenderRoot() {
    return this.attachShadow({
      mode: 'open'
    });
  }
  /**
   * Applies styling to the element shadowRoot using the `static get styles`
   * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
   * available and will fallback otherwise. When Shadow DOM is polyfilled,
   * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
   * is available but `adoptedStyleSheets` is not, styles are appended to the
   * end of the `shadowRoot` to [mimic spec
   * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
   */


  adoptStyles() {
    const styles = this.constructor._styles;

    if (styles.length === 0) {
      return;
    } // There are three separate cases here based on Shadow DOM support.
    // (1) shadowRoot polyfilled: use ShadyCSS
    // (2) shadowRoot.adoptedStyleSheets available: use it.
    // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
    // rendering


    if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {
      window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map(s => s.cssText), this.localName);
    } else if (supportsAdoptingStyleSheets) {
      this.renderRoot.adoptedStyleSheets = styles.map(s => s.styleSheet);
    } else {
      // This must be done after rendering so the actual style insertion is done
      // in `update`.
      this._needsShimAdoptedStyleSheets = true;
    }
  }

  connectedCallback() {
    super.connectedCallback(); // Note, first update/render handles styleElement so we only call this if
    // connected after first update.

    if (this.hasUpdated && window.ShadyCSS !== undefined) {
      window.ShadyCSS.styleElement(this);
    }
  }
  /**
   * Updates the element. This method reflects property values to attributes
   * and calls `render` to render DOM via lit-html. Setting properties inside
   * this method will *not* trigger another update.
   * * @param _changedProperties Map of changed properties with old values
   */


  update(changedProperties) {
    super.update(changedProperties);
    const templateResult = this.render();

    if (templateResult instanceof TemplateResult) {
      this.constructor.render(templateResult, this.renderRoot, {
        scopeName: this.localName,
        eventContext: this
      });
    } // When native Shadow DOM is used but adoptedStyles are not supported,
    // insert styling after rendering to ensure adoptedStyles have highest
    // priority.


    if (this._needsShimAdoptedStyleSheets) {
      this._needsShimAdoptedStyleSheets = false;

      this.constructor._styles.forEach(s => {
        const style = document.createElement('style');
        style.textContent = s.cssText;
        this.renderRoot.appendChild(style);
      });
    }
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */


  render() {}

}
/**
 * Ensure this class is marked as `finalized` as an optimization ensuring
 * it will not needlessly try to `finalize`.
 */

LitElement.finalized = true;
/**
 * Render method used to render the lit-html TemplateResult to the element's
 * DOM.
 * @param {TemplateResult} Template to render.
 * @param {Element|DocumentFragment} Node into which to render.
 * @param {String} Element name.
 * @nocollapse
 */

LitElement.render = render$1;

/**
@license
Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
  This is a JavaScript mixin that you can use to connect a Custom Element base
  class to a Redux store. The `stateChanged(state)` method will be called when
  the state is updated.

  Example:

      import { connect } from 'pwa-helpers/connect-mixin.js';

      class MyElement extends connect(store)(HTMLElement) {
        stateChanged(state) {
          this.textContent = state.data.count.toString();
        }
      }
*/
const connect = store => baseElement => class extends baseElement {
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }

    this._storeUnsubscribe = store.subscribe(() => this.stateChanged(store.getState()));
    this.stateChanged(store.getState());
  }

  disconnectedCallback() {
    this._storeUnsubscribe();

    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
  }
  /**
   * The `stateChanged(state)` method will be called when the state is updated.
   */


  stateChanged(_state) {}

};

/**
@license
Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
@license
Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
@license
Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
@license
Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
@license
Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
@license
Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const UPDATE_PATH = 'UPDATE_PATH';
const ADD_FILMS = 'ADD_FILMS';
const UPDATE_TOPIC = 'UPDATE_TOPIC';
const DELETE_FILM = 'DELETE_FILM';
const addFilms = films => {
  return {
    type: ADD_FILMS,
    films
  };
};
const updateTopic = topic => {
  return {
    type: UPDATE_TOPIC,
    topic
  };
};
const deleteFilm = (films, index) => {
  return {
    type: DELETE_FILM,
    films,
    index
  };
};

function symbolObservablePonyfill(root) {
  var result;
  var Symbol = root.Symbol;

  if (typeof Symbol === 'function') {
    if (Symbol.observable) {
      result = Symbol.observable;
    } else {
      result = Symbol('observable');
      Symbol.observable = result;
    }
  } else {
    result = '@@observable';
  }

  return result;
}

/* global window */
var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = symbolObservablePonyfill(root);

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */

var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */

function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}
/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */


function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.');
    }

    if (isDispatching) {
      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[result] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[result] = observable, _ref2;
}
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */


function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}
/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */


function isCrushed() {}

if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
}

const INITIAL_STATE = {
  path: '/',
  topic: '',
  films: []
};
const reducer = (state = INITIAL_STATE, action) => {
  switch (action.type) {
    case UPDATE_PATH:
      return { ...state,
        path: action.path
      };

    case ADD_FILMS:
      return { ...state,
        films: action.films
      };

    case UPDATE_TOPIC:
      return { ...state,
        topic: action.topic
      };

    case DELETE_FILM:
      action.films.splice(action.index, 1);
      return { ...state,
        films: action.films
      };

    default:
      return state;
  }
};

const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());

class ListElement extends connect(store)(LitElement) {
  render() {
    return html`
      <div>
        <style>
          li {
            margin: 20px;
          }
          .delete-btn {
            padding: 2px 10px;
            height: 6px;
            background-color: red;
            border-radius: 2px;
            color: #fff;
            cursor: pointer;
          }
        </style>

        ${this.films === undefined ? html`<p>Nothing found !!!</p>` : ''}
        <ul>
          ${this.films !== undefined ? this.films.map((item, i) => html`<li>${item.Title} <span class="delete-btn" @click="${() => {
      store.dispatch(deleteFilm(this.films, i));
    }}">-</span></li>`) : ''}
        </ul>
      </div>
    `;
  }

  static get properties() {
    return {
      films: {
        type: Array
      }
    };
  }

}

customElements.define('list-element', ListElement);

class FetcherElement extends connect(store)(LitElement) {
  render() {
    return html`
      <div>
        <h2>Home</h2>

        <input type="text" placeholder='Type here...' .value=${this.topic} @input=${this.handleInput}>
        <button @click="${this.doSearch}">Search</button>

        <list-element .films=${this.films}></list-element>
        <p>${this.films.length}</p>
      </div>
      `;
  }

  stateChanged(state) {
    this.topic = '';
    this.films = [...state.films];
  }

  static get properties() {
    return {
      topic: {
        type: String
      },
      films: {
        type: Array
      }
    };
  }

  handleInput(e) {
    this.topic = e.target.value;
  }

  doSearch() {
    if (this.topic !== '') {
      fetch(`https://www.omdbapi.com/?s=${this.topic}&plot=full&apikey=e477ed6a`).then(response => response.json()).then((myJson, topic = this.topic) => {
        store.dispatch(addFilms(myJson.Search));
        store.dispatch(updateTopic(topic));
      }).catch(error => console.log('Error: ', error));
    }
  }

}

customElements.define('fetcher-element', FetcherElement);

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/* eslint-disable no-unused-vars */

/**
 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]
 * We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.
 *
 * @param {string} prop Property name
 * @param {?Object} obj Reference object
 * @return {string} Potentially renamed property name
 */
window.JSCompiler_renameProperty = function (prop, obj) {
  return prop;
};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Class representing a static string value which can be used to filter
 * strings by asseting that they have been created via this class. The
 * `value` property returns the string passed to the constructor.
 */

class LiteralString {
  constructor(string) {
    /** @type {string} */
    this.value = string.toString();
  }
  /**
   * @return {string} LiteralString string value
   * @override
   */


  toString() {
    return this.value;
  }

}
/**
 * @param {*} value Object to stringify into HTML
 * @return {string} HTML stringified form of `obj`
 */


function literalValue(value) {
  if (value instanceof LiteralString) {
    return (
      /** @type {!LiteralString} */
      value.value
    );
  } else {
    throw new Error(`non-literal value passed to Polymer's htmlLiteral function: ${value}`);
  }
}
/**
 * @param {*} value Object to stringify into HTML
 * @return {string} HTML stringified form of `obj`
 */


function htmlValue(value) {
  if (value instanceof HTMLTemplateElement) {
    return (
      /** @type {!HTMLTemplateElement } */
      value.innerHTML
    );
  } else if (value instanceof LiteralString) {
    return literalValue(value);
  } else {
    throw new Error(`non-template value passed to Polymer's html function: ${value}`);
  }
}
/**
 * A template literal tag that creates an HTML <template> element from the
 * contents of the string.
 *
 * This allows you to write a Polymer Template in JavaScript.
 *
 * Templates can be composed by interpolating `HTMLTemplateElement`s in
 * expressions in the JavaScript template literal. The nested template's
 * `innerHTML` is included in the containing template.  The only other
 * values allowed in expressions are those returned from `htmlLiteral`
 * which ensures only literal values from JS source ever reach the HTML, to
 * guard against XSS risks.
 *
 * All other values are disallowed in expressions to help prevent XSS
 * attacks; however, `htmlLiteral` can be used to compose static
 * string values into templates. This is useful to compose strings into
 * places that do not accept html, like the css text of a `style`
 * element.
 *
 * Example:
 *
 *     static get template() {
 *       return html`
 *         <style>:host{ content:"..." }</style>
 *         <div class="shadowed">${this.partialTemplate}</div>
 *         ${super.template}
 *       `;
 *     }
 *     static get partialTemplate() { return html`<span>Partial!</span>`; }
 *
 * @param {!ITemplateArray} strings Constant parts of tagged template literal
 * @param {...*} values Variable parts of tagged template literal
 * @return {!HTMLTemplateElement} Constructed HTMLTemplateElement
 */


const html$1 = function html(strings, ...values) {
  const template =
  /** @type {!HTMLTemplateElement} */
  document.createElement('template');
  template.innerHTML = values.reduce((acc, v, idx) => acc + htmlValue(v) + strings[idx + 1], strings[0]);
  return template;
};

const $_documentContainer = html$1`<dom-module id="vaadin-chart-default-theme" theme-for="vaadin-chart">
    <template>
      <style>
/* When updating this file do not override vaadin-charts custom properties section */
/* disable stylelint for highcharts css */
/* stylelint-disable */
/**
 * @license Highcharts
 *
 * (c) 2009-2016 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
 .highcharts-container {
  position: relative;
  overflow: hidden;
  width: 100%;
  height: 100%;
  text-align: left;
  line-height: normal;
  z-index: 0;
  /* #1072 */
  -webkit-tap-highlight-color: transparent;
  font-family: "Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif;
  font-size: 12px;
}

.highcharts-root {
  display: block;
}

.highcharts-root text {
  stroke-width: 0;
}

.highcharts-strong {
  font-weight: bold;
}

.highcharts-emphasized {
  font-style: italic;
}

.highcharts-anchor {
  cursor: pointer;
}

.highcharts-background {
  fill: #ffffff;
}

.highcharts-plot-border, .highcharts-plot-background {
  fill: none;
}

.highcharts-label-box {
  fill: none;
}

.highcharts-button-box {
  fill: inherit;
}

.highcharts-tracker-line {
  stroke-linejoin: round;
  stroke: rgba(192, 192, 192, 0.0001);
  stroke-width: 22;
  fill: none;
}

.highcharts-tracker-area {
  fill: rgba(192, 192, 192, 0.0001);
  stroke-width: 0;
}

/* Titles */
.highcharts-title {
  fill: #333333;
  font-size: 1.5em;
}

.highcharts-subtitle {
  fill: #666666;
}

/* Axes */
.highcharts-axis-line {
  fill: none;
  stroke: #ccd6eb;
}

.highcharts-yaxis .highcharts-axis-line {
  stroke-width: 0;
}

.highcharts-axis-title {
  fill: #666666;
}

.highcharts-axis-labels {
  fill: #666666;
  cursor: default;
  font-size: 0.9em;
}

.highcharts-grid-line {
  fill: none;
  stroke: #e6e6e6;
}

.highcharts-xaxis-grid .highcharts-grid-line {
  stroke-width: 0px;
}

.highcharts-tick {
  stroke: #ccd6eb;
}

.highcharts-yaxis .highcharts-tick {
  stroke-width: 0;
}

.highcharts-minor-grid-line {
  stroke: #f2f2f2;
}

.highcharts-crosshair-thin {
  stroke-width: 1px;
  stroke: #cccccc;
}

.highcharts-crosshair-category {
  stroke: #ccd6eb;
  stroke-opacity: 0.25;
}

/* Credits */
.highcharts-credits {
  cursor: pointer;
  fill: #999999;
  font-size: 0.7em;
  transition: fill 250ms, font-size 250ms;
}

.highcharts-credits:hover {
  fill: black;
  font-size: 1em;
}

/* Tooltip */
.highcharts-tooltip {
  cursor: default;
  pointer-events: none;
  white-space: nowrap;
  transition: stroke 150ms;
}

.highcharts-tooltip text {
  fill: #333333;
}

.highcharts-tooltip .highcharts-header {
  font-size: 0.85em;
}

.highcharts-tooltip-box {
  stroke-width: 1px;
  fill: #f7f7f7;
  fill-opacity: 0.85;
}

.highcharts-tooltip-box .highcharts-label-box {
  fill: #f7f7f7;
  fill-opacity: 0.85;
}

.highcharts-selection-marker {
  fill: #335cad;
  fill-opacity: 0.25;
}

.highcharts-graph {
  fill: none;
  stroke-width: 2px;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.highcharts-state-hover .highcharts-graph {
  stroke-width: 3;
}

.highcharts-state-hover path {
  transition: stroke-width 50;
  /* quick in */
}

.highcharts-state-normal path {
  transition: stroke-width 250ms;
  /* slow out */
}

/* Legend hover affects points and series */
g.highcharts-series,
.highcharts-point,
.highcharts-markers,
.highcharts-data-labels {
  transition: opacity 250ms;
}

.highcharts-legend-series-active g.highcharts-series:not(.highcharts-series-hover),
.highcharts-legend-point-active .highcharts-point:not(.highcharts-point-hover),
.highcharts-legend-series-active .highcharts-markers:not(.highcharts-series-hover),
.highcharts-legend-series-active .highcharts-data-labels:not(.highcharts-series-hover) {
  opacity: 0.2;
}

/* Series options */
/* Default colors */
/* vaadin-charts custom properties */
.highcharts-color-0 {
  fill: var(--vaadin-charts-color-0, #7cb5ec);
  stroke: var(--vaadin-charts-color-0, #7cb5ec);
}

.highcharts-color-1 {
  fill: var(--vaadin-charts-color-1, #434348);
  stroke: var(--vaadin-charts-color-1, #434348);
}

.highcharts-color-2 {
  fill: var(--vaadin-charts-color-2, #90ed7d);
  stroke: var(--vaadin-charts-color-2, #90ed7d);
}

.highcharts-color-3 {
  fill: var(--vaadin-charts-color-3, #f7a35c);
  stroke: var(--vaadin-charts-color-3, #f7a35c);
}

.highcharts-color-4 {
  fill: var(--vaadin-charts-color-4, #8085e9);
  stroke: var(--vaadin-charts-color-4, #8085e9);
}

.highcharts-color-5 {
  fill: var(--vaadin-charts-color-5, #f15c80);
  stroke: var(--vaadin-charts-color-5, #f15c80);
}

.highcharts-color-6 {
  fill: var(--vaadin-charts-color-6, #e4d354);
  stroke: var(--vaadin-charts-color-6, #e4d354);
}

.highcharts-color-7 {
  fill: var(--vaadin-charts-color-7, #2b908f);
  stroke: var(--vaadin-charts-color-7, #2b908f);
}

.highcharts-color-8 {
  fill: var(--vaadin-charts-color-8, #f45b5b);
  stroke: var(--vaadin-charts-color-8, #f45b5b);
}

.highcharts-color-9 {
  fill: var(--vaadin-charts-color-9, #91e8e1);
  stroke: var(--vaadin-charts-color-9, #91e8e1);
}
/* end of vaadin-charts custom properties */

.highcharts-area {
  fill-opacity: 0.75;
  stroke-width: 0;
}

.highcharts-markers {
  stroke-width: 1px;
  stroke: #ffffff;
}

.highcharts-point {
  stroke-width: 1px;
}

.highcharts-dense-data .highcharts-point {
  stroke-width: 0;
}

.highcharts-data-label {
  font-size: 0.9em;
  font-weight: bold;
}

.highcharts-data-label-box {
  fill: none;
  stroke-width: 0;
}

.highcharts-data-label text, text.highcharts-data-label {
  fill: #333333;
}

.highcharts-data-label-connector {
  fill: none;
}

.highcharts-halo {
  fill-opacity: 0.25;
  stroke-width: 0;
}

.highcharts-series:not(.highcharts-pie-series) .highcharts-point-select {
  fill: #cccccc;
  stroke: #000000;
}

.highcharts-column-series rect.highcharts-point {
  stroke: #ffffff;
}

.highcharts-column-series .highcharts-point {
  transition: fill-opacity 250ms;
}

.highcharts-column-series .highcharts-point-hover {
  fill-opacity: 0.75;
  transition: fill-opacity 50ms;
}

.highcharts-pie-series .highcharts-point {
  stroke-linejoin: round;
  stroke: #ffffff;
}

.highcharts-pie-series .highcharts-point-hover {
  fill-opacity: 0.75;
  transition: fill-opacity 50ms;
}

.highcharts-funnel-series .highcharts-point {
  stroke-linejoin: round;
  stroke: #ffffff;
}

.highcharts-funnel-series .highcharts-point-hover {
  fill-opacity: 0.75;
  transition: fill-opacity 50ms;
}

.highcharts-funnel-series .highcharts-point-select {
  fill: inherit;
  stroke: inherit;
}

.highcharts-pyramid-series .highcharts-point {
  stroke-linejoin: round;
  stroke: #ffffff;
}

.highcharts-pyramid-series .highcharts-point-hover {
  fill-opacity: 0.75;
  transition: fill-opacity 50ms;
}

.highcharts-pyramid-series .highcharts-point-select {
  fill: inherit;
  stroke: inherit;
}

.highcharts-solidgauge-series .highcharts-point {
  stroke-width: 0;
}

.highcharts-treemap-series .highcharts-point {
  stroke-width: 1px;
  stroke: #e6e6e6;
  transition: stroke 250ms, fill 250ms, fill-opacity 250ms;
}

.highcharts-treemap-series .highcharts-point-hover {
  stroke: #999999;
  transition: stroke 25ms, fill 25ms, fill-opacity 25ms;
}

.highcharts-treemap-series .highcharts-above-level {
  display: none;
}

.highcharts-treemap-series .highcharts-internal-node {
  fill: none;
}

.highcharts-treemap-series .highcharts-internal-node-interactive {
  fill-opacity: 0.15;
  cursor: pointer;
}

.highcharts-treemap-series .highcharts-internal-node-interactive:hover {
  fill-opacity: 0.75;
}

/* Legend */
.highcharts-legend-box {
  fill: none;
  stroke-width: 0;
}

.highcharts-legend-item text {
  fill: #333333;
  font-weight: bold;
  font-size: 1em;
  cursor: pointer;
  stroke-width: 0;
}

.highcharts-legend-item:hover text {
  fill: #000000;
}

.highcharts-legend-item-hidden * {
  fill: #cccccc !important;
  stroke: #cccccc !important;
  transition: fill 250ms;
}

.highcharts-legend-nav-active {
  fill: #003399;
  cursor: pointer;
}

.highcharts-legend-nav-inactive {
  fill: #cccccc;
}

.highcharts-legend-title-box {
  fill: none;
  stroke-width: 0;
}

/* Loading */
.highcharts-loading {
  position: absolute;
  background-color: #ffffff;
  opacity: 0.5;
  text-align: center;
  z-index: 10;
  transition: opacity 250ms;
}

.highcharts-loading-hidden {
  height: 0 !important;
  opacity: 0;
  overflow: hidden;
  transition: opacity 250ms, height 250ms step-end;
}

.highcharts-loading-inner {
  font-weight: bold;
  position: relative;
  top: 45%;
}

/* Plot bands and polar pane backgrounds */
.highcharts-plot-band, .highcharts-pane {
  fill: #000000;
  fill-opacity: 0.05;
}

.highcharts-plot-line {
  fill: none;
  stroke: #999999;
  stroke-width: 1px;
}

/* Highcharts More and modules */
.highcharts-boxplot-box {
  fill: #ffffff;
}

.highcharts-boxplot-median {
  stroke-width: 2px;
}

.highcharts-bubble-series .highcharts-point {
  fill-opacity: 0.5;
}

.highcharts-errorbar-series .highcharts-point {
  stroke: #000000;
}

.highcharts-gauge-series .highcharts-data-label-box {
  stroke: #cccccc;
  stroke-width: 1px;
}

.highcharts-gauge-series .highcharts-dial {
  fill: #000000;
  stroke-width: 0;
}

.highcharts-polygon-series .highcharts-graph {
  fill: inherit;
  stroke-width: 0;
}

.highcharts-waterfall-series .highcharts-graph {
  stroke: #333333;
  stroke-dasharray: 1, 3;
}

.highcharts-sankey-series .highcharts-point {
  stroke-width: 0;
}

.highcharts-sankey-series .highcharts-link {
  transition: fill 250ms, fill-opacity 250ms;
  fill-opacity: 0.5;
}

.highcharts-sankey-series .highcharts-point-hover.highcharts-link {
  transition: fill 50ms, fill-opacity 50ms;
  fill-opacity: 1;
}

/* Highstock */
.highcharts-navigator-mask-outside {
  fill-opacity: 0;
}

.highcharts-navigator-mask-inside {
  fill: #6685c2;
  /* navigator.maskFill option */
  fill-opacity: 0.25;
  cursor: ew-resize;
}

.highcharts-navigator-outline {
  stroke: #cccccc;
  fill: none;
}

.highcharts-navigator-handle {
  stroke: #cccccc;
  fill: #f2f2f2;
  cursor: ew-resize;
}

.highcharts-navigator-series {
  fill: #335cad;
  stroke: #335cad;
}

.highcharts-navigator-series .highcharts-graph {
  stroke-width: 1px;
}

.highcharts-navigator-series .highcharts-area {
  fill-opacity: 0.05;
}

.highcharts-navigator-xaxis .highcharts-axis-line {
  stroke-width: 0;
}

.highcharts-navigator-xaxis .highcharts-grid-line {
  stroke-width: 1px;
  stroke: #e6e6e6;
}

.highcharts-navigator-xaxis.highcharts-axis-labels {
  fill: #999999;
}

.highcharts-navigator-yaxis .highcharts-grid-line {
  stroke-width: 0;
}

.highcharts-scrollbar-thumb {
  fill: #cccccc;
  stroke: #cccccc;
  stroke-width: 1px;
}

.highcharts-scrollbar-button {
  fill: #e6e6e6;
  stroke: #cccccc;
  stroke-width: 1px;
}

.highcharts-scrollbar-arrow {
  fill: #666666;
}

.highcharts-scrollbar-rifles {
  stroke: #666666;
  stroke-width: 1px;
}

.highcharts-scrollbar-track {
  fill: #f2f2f2;
  stroke: #f2f2f2;
  stroke-width: 1px;
}

.highcharts-button {
  fill: #f7f7f7;
  stroke: #cccccc;
  cursor: default;
  stroke-width: 1px;
  transition: fill 250ms;
}

.highcharts-button text {
  fill: #333333;
}

.highcharts-button-hover {
  transition: fill 0ms;
  fill: #e6e6e6;
  stroke: #cccccc;
}

.highcharts-button-hover text {
  fill: #333333;
}

.highcharts-button-pressed {
  font-weight: bold;
  fill: #e6ebf5;
  stroke: #cccccc;
}

.highcharts-button-pressed text {
  fill: #333333;
  font-weight: bold;
}

.highcharts-button-disabled text {
  fill: #333333;
}

.highcharts-range-selector-buttons .highcharts-button {
  stroke-width: 0px;
}

.highcharts-range-label rect {
  fill: none;
}

.highcharts-range-label text {
  fill: #666666;
}

.highcharts-range-input rect {
  fill: none;
}

.highcharts-range-input text {
  fill: #333333;
}

.highcharts-range-input {
  stroke-width: 1px;
  stroke: #cccccc;
}

input.highcharts-range-selector {
  position: absolute;
  border: 0;
  width: 1px;
  /* Chrome needs a pixel to see it */
  height: 1px;
  padding: 0;
  text-align: center;
  left: -9em;
  /* #4798 */
}

.highcharts-crosshair-label text {
  fill: #ffffff;
  font-size: 1.1em;
}

.highcharts-crosshair-label .highcharts-label-box {
  fill: inherit;
}

.highcharts-candlestick-series .highcharts-point {
  stroke: #000000;
  stroke-width: 1px;
}

.highcharts-candlestick-series .highcharts-point-up {
  fill: #ffffff;
}

.highcharts-ohlc-series .highcharts-point-hover {
  stroke-width: 3px;
}

.highcharts-flags-series .highcharts-point .highcharts-label-box {
  stroke: #999999;
  fill: #ffffff;
  transition: fill 250ms;
}

.highcharts-flags-series .highcharts-point-hover .highcharts-label-box {
  stroke: #000000;
  fill: #ccd6eb;
}

.highcharts-flags-series .highcharts-point text {
  fill: #000000;
  font-size: 0.9em;
  font-weight: bold;
}

/* Highmaps */
.highcharts-map-series .highcharts-point {
  transition: fill 500ms, fill-opacity 500ms, stroke-width 250ms;
  stroke: #cccccc;
}

.highcharts-map-series .highcharts-point-hover {
  transition: fill 0ms, fill-opacity 0ms;
  fill-opacity: 0.5;
  stroke-width: 2px;
}

.highcharts-mapline-series .highcharts-point {
  fill: none;
}

.highcharts-heatmap-series .highcharts-point {
  stroke-width: 0;
}

.highcharts-map-navigation {
  font-size: 1.3em;
  font-weight: bold;
  text-align: center;
}

.highcharts-coloraxis {
  stroke-width: 0;
}

.highcharts-coloraxis-marker {
  fill: #999999;
}

.highcharts-null-point {
  fill: #f7f7f7;
}

/* 3d charts */
.highcharts-3d-frame {
  fill: transparent;
}

/* Exporting module */
.highcharts-contextbutton {
  fill: #ffffff;
  /* needed to capture hover */
  stroke: none;
  stroke-linecap: round;
}

.highcharts-contextbutton:hover {
  fill: #e6e6e6;
  stroke: #e6e6e6;
}

.highcharts-button-symbol {
  stroke: #666666;
  stroke-width: 3px;
}

.highcharts-menu {
  border: 1px solid #999999;
  background: #ffffff;
  padding: 5px 0;
  box-shadow: 3px 3px 10px #888;
}

.highcharts-menu-item {
  padding: 0.5em 1em;
  background: none;
  color: #333333;
  cursor: pointer;
  transition: background 250ms, color 250ms;
}

.highcharts-menu-item:hover {
  background: #335cad;
  color: #ffffff;
}

/* Drilldown module */
.highcharts-drilldown-point {
  cursor: pointer;
}

.highcharts-drilldown-data-label text,
text.highcharts-drilldown-data-label,
.highcharts-drilldown-axis-label {
  cursor: pointer;
  fill: #003399;
  font-weight: bold;
  text-decoration: underline;
}

/* No-data module */
.highcharts-no-data text {
  font-weight: bold;
  font-size: 12px;
  fill: #666666;
}

/* Drag-panes module */
.highcharts-axis-resizer {
  cursor: ns-resize;
  stroke: black;
  stroke-width: 2px;
}

/* Bullet type series */
.highcharts-bullet-target {
  stroke-width: 0;
}

/* Lineargauge type series */
.highcharts-lineargauge-target {
  stroke-width: 1px;
  stroke: #333333;
}

.highcharts-lineargauge-target-line {
  stroke-width: 1px;
  stroke: #333333;
}

/* Annotations module */
.highcharts-annotation-label-box {
  stroke-width: 1px;
  stroke: #000000;
  fill: #000000;
  fill-opacity: 0.75;
}

.highcharts-annotation-label text {
  fill: #e6e6e6;
}




/* stylelint-enable */
    </style>
  </template>
</dom-module>`;
document.head.appendChild($_documentContainer.content);
/**
@license
Vaadin Charts
Copyright (C) 2015 Vaadin Ltd
This program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).
See the file LICENSE.md distributed with this software for more information about licensing.
See <a href="https://vaadin.com/license/cval-3">the website</a> for the complete license.
*/

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let CSS_URL_RX = /(url\()([^)]*)(\))/g;
let ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
let workingURL;
let resolveDoc;
/**
 * Resolves the given URL against the provided `baseUri'.
 *
 * Note that this function performs no resolution for URLs that start
 * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
 * URL resolution, use `window.URL`.
 *
 * @param {string} url Input URL to resolve
 * @param {?string=} baseURI Base URI to resolve the URL against
 * @return {string} resolved URL
 */

function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  } // Lazy feature detection.


  if (workingURL === undefined) {
    workingURL = false;

    try {
      const u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      workingURL = u.href === 'http://a/c%20d';
    } catch (e) {// silently fail
    }
  }

  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }

  if (workingURL) {
    return new URL(url, baseURI).href;
  } // Fallback to creating an anchor into a disconnected document.


  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument('temp');
    resolveDoc.base = resolveDoc.createElement('base');
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement('a');
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }

  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;
}
/**
 * Resolves any relative URL's in the given CSS text against the provided
 * `ownerDocument`'s `baseURI`.
 *
 * @param {string} cssText CSS text to process
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Processed CSS text with resolved URL's
 */

function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
    return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
  });
}
/**
 * Returns a path from a given `url`. The path includes the trailing
 * `/` from the url.
 *
 * @param {string} url Input URL to transform
 * @return {string} resolved path
 */

function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf('/') + 1);
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const useShadow = !window.ShadyDOM;
const useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
const useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;
/**
 * Globally settable property that is automatically assigned to
 * `ElementMixin` instances, useful for binding in templates to
 * make URL's relative to an application's root.  Defaults to the main
 * document URL, but can be overridden by users.  It may be useful to set
 * `rootPath` to provide a stable application mount path when
 * using client side routing.
 */

let rootPath = pathFromUrl(document.baseURI || window.location.href);
/**
 * A global callback used to sanitize any value before inserting it into the DOM.
 * The callback signature is:
 *
 *  function sanitizeDOMValue(value, name, type, node) { ... }
 *
 * Where:
 *
 * `value` is the value to sanitize.
 * `name` is the name of an attribute or property (for example, href).
 * `type` indicates where the value is being inserted: one of property, attribute, or text.
 * `node` is the node where the value is being inserted.
 *
 * @type {(function(*,string,string,Node):*)|undefined}
 */

let sanitizeDOMValue = window.Polymer && window.Polymer.sanitizeDOMValue || undefined;
/**
 * Setting to ensure Polymer template evaluation only occurs based on tempates
 * defined in trusted script.  When true, `<dom-module>` re-registration is
 * disallowed, `<dom-bind>` is disabled, and `<dom-if>`/`<dom-repeat>`
 * templates will only evaluate in the context of a trusted element template.
 */

let strictTemplatePolicy = false;
/**
 * Setting to enable dom-module lookup from Polymer.Element.  By default,
 * templates must be defined in script using the `static get template()`
 * getter and the `html` tag function.  To enable legacy loading of templates
 * via dom-module, set this flag to true.
 */

let allowTemplateFromDomModule = false;
/**
 * Setting to skip processing style includes and re-writing urls in css styles.
 * Normally "included" styles are pulled into the element and all urls in styles
 * are re-written to be relative to the containing script url.
 * If no includes or relative urls are used in styles, these steps can be
 * skipped as an optimization.
 */

let legacyOptimizations = false;
/**
 * Setting to perform initial rendering synchronously when running under ShadyDOM.
 * This matches the behavior of Polymer 1.
 */

let syncInitialRender = false;

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

let dedupeId = 0;
/* eslint-disable valid-jsdoc */

/**
 * Wraps an ES6 class expression mixin such that the mixin is only applied
 * if it has not already been applied its base argument. Also memoizes mixin
 * applications.
 *
 * @template T
 * @param {T} mixin ES6 class expression mixin to wrap
 * @return {T}
 * @suppress {invalidCasts}
 */

const dedupingMixin = function (mixin) {
  let mixinApplications =
  /** @type {!MixinFunction} */
  mixin.__mixinApplications;

  if (!mixinApplications) {
    mixinApplications = new WeakMap();
    /** @type {!MixinFunction} */

    mixin.__mixinApplications = mixinApplications;
  } // maintain a unique id for each mixin


  let mixinDedupeId = dedupeId++;

  function dedupingMixin(base) {
    let baseSet =
    /** @type {!MixinFunction} */
    base.__mixinSet;

    if (baseSet && baseSet[mixinDedupeId]) {
      return base;
    }

    let map = mixinApplications;
    let extended = map.get(base);

    if (!extended) {
      extended =
      /** @type {!Function} */
      mixin(base);
      map.set(base, extended);
    } // copy inherited mixin set from the extended class, or the base class
    // NOTE: we avoid use of Set here because some browser (IE11)
    // cannot extend a base Set via the constructor.


    let mixinSet = Object.create(
    /** @type {!MixinFunction} */
    extended.__mixinSet || baseSet || null);
    mixinSet[mixinDedupeId] = true;
    /** @type {!MixinFunction} */

    extended.__mixinSet = mixinSet;
    return extended;
  }

  return dedupingMixin;
};
/* eslint-enable valid-jsdoc */

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let modules = {};
let lcModules = {};
/**
 * Sets a dom-module into the global registry by id.
 *
 * @param {string} id dom-module id
 * @param {DomModule} module dom-module instance
 * @return {void}
 */

function setModule(id, module) {
  // store id separate from lowercased id so that
  // in all cases mixedCase id will stored distinctly
  // and lowercase version is a fallback
  modules[id] = lcModules[id.toLowerCase()] = module;
}
/**
 * Retrieves a dom-module from the global registry by id.
 *
 * @param {string} id dom-module id
 * @return {DomModule!} dom-module instance
 */


function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}

function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector('style')) {
    console.warn('dom-module %s has style outside template', inst.id);
  }
}
/**
 * The `dom-module` element registers the dom it contains to the name given
 * by the module's id attribute. It provides a unified database of dom
 * accessible via its static `import` API.
 *
 * A key use case of `dom-module` is for providing custom element `<template>`s
 * via HTML imports that are parsed by the native HTML parser, that can be
 * relocated during a bundling pass and still looked up by `id`.
 *
 * Example:
 *
 *     <dom-module id="foo">
 *       <img src="stuff.png">
 *     </dom-module>
 *
 * Then in code in some other location that cannot access the dom-module above
 *
 *     let img = customElements.get('dom-module').import('foo', 'img');
 *
 * @customElement
 * @extends HTMLElement
 * @summary Custom element that provides a registry of relocatable DOM content
 *   by `id` that is agnostic to bundling.
 * @unrestricted
 */


class DomModule extends HTMLElement {
  static get observedAttributes() {
    return ['id'];
  }
  /**
   * Retrieves the element specified by the css `selector` in the module
   * registered by `id`. For example, this.import('foo', 'img');
   * @param {string} id The id of the dom-module in which to search.
   * @param {string=} selector The css selector by which to find the element.
   * @return {Element} Returns the element which matches `selector` in the
   * module registered at the specified `id`.
   *
   * @export
   * @nocollapse Referred to indirectly in style-gather.js
   */


  static import(id, selector) {
    if (id) {
      let m = findModule(id);

      if (m && selector) {
        return m.querySelector(selector);
      }

      return m;
    }

    return null;
  }
  /* eslint-disable no-unused-vars */

  /**
   * @param {string} name Name of attribute.
   * @param {?string} old Old value of attribute.
   * @param {?string} value Current value of attribute.
   * @param {?string} namespace Attribute namespace.
   * @return {void}
   * @override
   */


  attributeChangedCallback(name, old, value, namespace) {
    if (old !== value) {
      this.register();
    }
  }
  /* eslint-enable no-unused-args */

  /**
   * The absolute URL of the original location of this `dom-module`.
   *
   * This value will differ from this element's `ownerDocument` in the
   * following ways:
   * - Takes into account any `assetpath` attribute added during bundling
   *   to indicate the original location relative to the bundled location
   * - Uses the HTMLImports polyfill's `importForElement` API to ensure
   *   the path is relative to the import document's location since
   *   `ownerDocument` is not currently polyfilled
   */


  get assetpath() {
    // Don't override existing assetpath.
    if (!this.__assetpath) {
      // note: assetpath set via an attribute must be relative to this
      // element's location; accomodate polyfilled HTMLImports
      const owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
      const url = resolveUrl(this.getAttribute('assetpath') || '', owner.baseURI);
      this.__assetpath = pathFromUrl(url);
    }

    return this.__assetpath;
  }
  /**
   * Registers the dom-module at a given id. This method should only be called
   * when a dom-module is imperatively created. For
   * example, `document.createElement('dom-module').register('foo')`.
   * @param {string=} id The id at which to register the dom-module.
   * @return {void}
   */


  register(id) {
    id = id || this.id;

    if (id) {
      // Under strictTemplatePolicy, reject and null out any re-registered
      // dom-module since it is ambiguous whether first-in or last-in is trusted
      if (strictTemplatePolicy && findModule(id) !== undefined) {
        setModule(id, null);
        throw new Error(`strictTemplatePolicy: dom-module ${id} re-registered`);
      }

      this.id = id;
      setModule(id, this);
      styleOutsideTemplateCheck(this);
    }
  }

}
DomModule.prototype['modules'] = modules;
customElements.define('dom-module', DomModule);

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
const INCLUDE_ATTR = 'include';
const SHADY_UNSCOPED_ATTR = 'shady-unscoped';
/**
 * @param {string} moduleId .
 * @return {?DomModule} .
 */

function importModule(moduleId) {
  return (
    /** @type {?DomModule} */
    DomModule.import(moduleId)
  );
}

function styleForImport(importDoc) {
  // NOTE: polyfill affordance.
  // under the HTMLImports polyfill, there will be no 'body',
  // but the import pseudo-doc can be used directly.
  let container = importDoc.body ? importDoc.body : importDoc;
  const importCss = resolveCss(container.textContent, importDoc.baseURI);
  const style = document.createElement('style');
  style.textContent = importCss;
  return style;
}

/**
 * Returns a list of <style> elements in a space-separated list of `dom-module`s.
 *
 * @function
 * @param {string} moduleIds List of dom-module id's within which to
 * search for css.
 * @return {!Array<!HTMLStyleElement>} Array of contained <style> elements
 */

function stylesFromModules(moduleIds) {
  const modules = moduleIds.trim().split(/\s+/);
  const styles = [];

  for (let i = 0; i < modules.length; i++) {
    styles.push(...stylesFromModule(modules[i]));
  }

  return styles;
}
/**
 * Returns a list of <style> elements in a given `dom-module`.
 * Styles in a `dom-module` can come either from `<style>`s within the
 * first `<template>`, or else from one or more
 * `<link rel="import" type="css">` links outside the template.
 *
 * @param {string} moduleId dom-module id to gather styles from
 * @return {!Array<!HTMLStyleElement>} Array of contained styles.
 */

function stylesFromModule(moduleId) {
  const m = importModule(moduleId);

  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
    return [];
  }

  if (m._styles === undefined) {
    const styles = []; // module imports: <link rel="import" type="css">

    styles.push(..._stylesFromModuleImports(m)); // include css from the first template in the module

    const template =
    /** @type {?HTMLTemplateElement} */
    m.querySelector('template');

    if (template) {
      styles.push(...stylesFromTemplate(template,
      /** @type {templateWithAssetPath} */
      m.assetpath));
    }

    m._styles = styles;
  }

  return m._styles;
}
/**
 * Returns the `<style>` elements within a given template.
 *
 * @param {!HTMLTemplateElement} template Template to gather styles from
 * @param {string=} baseURI baseURI for style content
 * @return {!Array<!HTMLStyleElement>} Array of styles
 */

function stylesFromTemplate(template, baseURI) {
  if (!template._styles) {
    const styles = []; // if element is a template, get content from its .content

    const e$ = template.content.querySelectorAll('style');

    for (let i = 0; i < e$.length; i++) {
      let e = e$[i]; // support style sharing by allowing styles to "include"
      // other dom-modules that contain styling

      let include = e.getAttribute(INCLUDE_ATTR);

      if (include) {
        styles.push(...stylesFromModules(include).filter(function (item, index, self) {
          return self.indexOf(item) === index;
        }));
      }

      if (baseURI) {
        e.textContent = resolveCss(e.textContent,
        /** @type {string} */
        baseURI);
      }

      styles.push(e);
    }

    template._styles = styles;
  }

  return template._styles;
}
/**
 * Returns a list of <style> elements  from stylesheets loaded via `<link rel="import" type="css">` links within the specified `dom-module`.
 *
 * @param {string} moduleId Id of `dom-module` to gather CSS from
 * @return {!Array<!HTMLStyleElement>} Array of contained styles.
 */

function stylesFromModuleImports(moduleId) {
  let m = importModule(moduleId);
  return m ? _stylesFromModuleImports(m) : [];
}
/**
 * @param {!HTMLElement} module dom-module element that could contain `<link rel="import" type="css">` styles
 * @return {!Array<!HTMLStyleElement>} Array of contained styles
 */

function _stylesFromModuleImports(module) {
  const styles = [];
  const p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);

  for (let i = 0; i < p$.length; i++) {
    let p = p$[i];

    if (p.import) {
      const importDoc = p.import;
      const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);

      if (unscoped && !importDoc._unscopedStyle) {
        const style = styleForImport(importDoc);
        style.setAttribute(SHADY_UNSCOPED_ATTR, '');
        importDoc._unscopedStyle = style;
      } else if (!importDoc._style) {
        importDoc._style = styleForImport(importDoc);
      }

      styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);
    }
  }

  return styles;
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/* eslint-disable valid-jsdoc */

/**
 * Node wrapper to ensure ShadowDOM safe operation regardless of polyfill
 * presence or mode. Note that with the introduction of `ShadyDOM.noPatch`,
 * a node wrapper must be used to access ShadowDOM API.
 * This is similar to using `Polymer.dom` but relies exclusively
 * on the presence of the ShadyDOM polyfill rather than requiring the loading
 * of legacy (Polymer.dom) API.
 * @type {function(Node):Node}
 */
const wrap = window['ShadyDOM'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['wrap'] ? window['ShadyDOM']['wrap'] : n => n;

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Module with utilities for manipulating structured data path strings.
 *
 * @summary Module with utilities for manipulating structured data path strings.
 */

/**
 * Returns true if the given string is a structured data path (has dots).
 *
 * Example:
 *
 * ```
 * isPath('foo.bar.baz') // true
 * isPath('foo')         // false
 * ```
 *
 * @param {string} path Path string
 * @return {boolean} True if the string contained one or more dots
 */

function isPath(path) {
  return path.indexOf('.') >= 0;
}
/**
 * Returns the root property name for the given path.
 *
 * Example:
 *
 * ```
 * root('foo.bar.baz') // 'foo'
 * root('foo')         // 'foo'
 * ```
 *
 * @param {string} path Path string
 * @return {string} Root property name
 */

function root$1(path) {
  let dotIndex = path.indexOf('.');

  if (dotIndex === -1) {
    return path;
  }

  return path.slice(0, dotIndex);
}
/**
 * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not
 * Returns true if the given path is an ancestor of the base path.
 *
 * Example:
 *
 * ```
 * isAncestor('foo.bar', 'foo')         // true
 * isAncestor('foo.bar', 'foo.bar')     // false
 * isAncestor('foo.bar', 'foo.bar.baz') // false
 * ```
 *
 * @param {string} base Path string to test against.
 * @param {string} path Path string to test.
 * @return {boolean} True if `path` is an ancestor of `base`.
 */

function isAncestor(base, path) {
  //     base.startsWith(path + '.');
  return base.indexOf(path + '.') === 0;
}
/**
 * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant
 *
 * Example:
 *
 * ```
 * isDescendant('foo.bar', 'foo.bar.baz') // true
 * isDescendant('foo.bar', 'foo.bar')     // false
 * isDescendant('foo.bar', 'foo')         // false
 * ```
 *
 * @param {string} base Path string to test against.
 * @param {string} path Path string to test.
 * @return {boolean} True if `path` is a descendant of `base`.
 */

function isDescendant(base, path) {
  //     path.startsWith(base + '.');
  return path.indexOf(base + '.') === 0;
}
/**
 * Replaces a previous base path with a new base path, preserving the
 * remainder of the path.
 *
 * User must ensure `path` has a prefix of `base`.
 *
 * Example:
 *
 * ```
 * translate('foo.bar', 'zot', 'foo.bar.baz') // 'zot.baz'
 * ```
 *
 * @param {string} base Current base string to remove
 * @param {string} newBase New base string to replace with
 * @param {string} path Path to translate
 * @return {string} Translated string
 */

function translate(base, newBase, path) {
  return newBase + path.slice(base.length);
}
/**
 * Converts array-based paths to flattened path.  String-based paths
 * are returned as-is.
 *
 * Example:
 *
 * ```
 * normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'
 * normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'
 * ```
 *
 * @param {string | !Array<string|number>} path Input path
 * @return {string} Flattened path
 */

function normalize(path) {
  if (Array.isArray(path)) {
    let parts = [];

    for (let i = 0; i < path.length; i++) {
      let args = path[i].toString().split('.');

      for (let j = 0; j < args.length; j++) {
        parts.push(args[j]);
      }
    }

    return parts.join('.');
  } else {
    return path;
  }
}
/**
 * Splits a path into an array of property names. Accepts either arrays
 * of path parts or strings.
 *
 * Example:
 *
 * ```
 * split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']
 * split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']
 * ```
 *
 * @param {string | !Array<string|number>} path Input path
 * @return {!Array<string>} Array of path parts
 * @suppress {checkTypes}
 */

function split(path) {
  if (Array.isArray(path)) {
    return normalize(path).split('.');
  }

  return path.toString().split('.');
}
/**
 * Reads a value from a path.  If any sub-property in the path is `undefined`,
 * this method returns `undefined` (will never throw.
 *
 * @param {Object} root Object from which to dereference path from
 * @param {string | !Array<string|number>} path Path to read
 * @param {Object=} info If an object is provided to `info`, the normalized
 *  (flattened) path will be set to `info.path`.
 * @return {*} Value at path, or `undefined` if the path could not be
 *  fully dereferenced.
 */

function get(root, path, info) {
  let prop = root;
  let parts = split(path); // Loop over path parts[0..n-1] and dereference

  for (let i = 0; i < parts.length; i++) {
    if (!prop) {
      return;
    }

    let part = parts[i];
    prop = prop[part];
  }

  if (info) {
    info.path = parts.join('.');
  }

  return prop;
}
/**
 * Sets a value to a path.  If any sub-property in the path is `undefined`,
 * this method will no-op.
 *
 * @param {Object} root Object from which to dereference path from
 * @param {string | !Array<string|number>} path Path to set
 * @param {*} value Value to set to path
 * @return {string | undefined} The normalized version of the input path
 */

function set(root, path, value) {
  let prop = root;
  let parts = split(path);
  let last = parts[parts.length - 1];

  if (parts.length > 1) {
    // Loop over path parts[0..n-2] and dereference
    for (let i = 0; i < parts.length - 1; i++) {
      let part = parts[i];
      prop = prop[part];

      if (!prop) {
        return;
      }
    } // Set value to object at end of path


    prop[last] = value;
  } else {
    // Simple property set
    prop[path] = value;
  }

  return parts.join('.');
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const caseMap = {};
const DASH_TO_CAMEL = /-[a-z]/g;
const CAMEL_TO_DASH = /([A-Z])/g;
/**
 * @fileoverview Module with utilities for converting between "dash-case" and
 * "camelCase" identifiers.
 */

/**
 * Converts "dash-case" identifier (e.g. `foo-bar-baz`) to "camelCase"
 * (e.g. `fooBarBaz`).
 *
 * @param {string} dash Dash-case identifier
 * @return {string} Camel-case representation of the identifier
 */

function dashToCamelCase(dash) {
  return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, m => m[1].toUpperCase()));
}
/**
 * Converts "camelCase" identifier (e.g. `fooBarBaz`) to "dash-case"
 * (e.g. `foo-bar-baz`).
 *
 * @param {string} camel Camel-case identifier
 * @return {string} Dash-case representation of the identifier
 */

function camelToDashCase(camel) {
  return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

let microtaskCurrHandle = 0;
let microtaskLastHandle = 0;
let microtaskCallbacks = [];
let microtaskNodeContent = 0;
let microtaskNode = document.createTextNode('');
new window.MutationObserver(microtaskFlush).observe(microtaskNode, {
  characterData: true
});

function microtaskFlush() {
  const len = microtaskCallbacks.length;

  for (let i = 0; i < len; i++) {
    let cb = microtaskCallbacks[i];

    if (cb) {
      try {
        cb();
      } catch (e) {
        setTimeout(() => {
          throw e;
        });
      }
    }
  }

  microtaskCallbacks.splice(0, len);
  microtaskLastHandle += len;
}
/**
 * Async interface wrapper around `requestIdleCallback`.  Falls back to
 * `setTimeout` on browsers that do not support `requestIdleCallback`.
 *
 * @namespace
 * @summary Async interface wrapper around `requestIdleCallback`.
 */

const idlePeriod = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof idlePeriod
   * @param {function(!IdleDeadline):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
  },

  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
  }

};
/**
 * Async interface for enqueuing callbacks that run at microtask timing.
 *
 * Note that microtask timing is achieved via a single `MutationObserver`,
 * and thus callbacks enqueued with this API will all run in a single
 * batch, and not interleaved with other microtasks such as promises.
 * Promises are avoided as an implementation choice for the time being
 * due to Safari bugs that cause Promises to lack microtask guarantees.
 *
 * @namespace
 * @summary Async interface for enqueuing callbacks that run at microtask
 *   timing.
 */

const microTask = {
  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(callback) {
    microtaskNode.textContent = microtaskNodeContent++;
    microtaskCallbacks.push(callback);
    return microtaskCurrHandle++;
  },

  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    const idx = handle - microtaskLastHandle;

    if (idx >= 0) {
      if (!microtaskCallbacks[idx]) {
        throw new Error('invalid async handle: ' + handle);
      }

      microtaskCallbacks[idx] = null;
    }
  }

};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/** @const {!AsyncInterface} */

const microtask = microTask;
/**
 * Element class mixin that provides basic meta-programming for creating one
 * or more property accessors (getter/setter pair) that enqueue an async
 * (batched) `_propertiesChanged` callback.
 *
 * For basic usage of this mixin, call `MyClass.createProperties(props)`
 * once at class definition time to create property accessors for properties
 * named in props, implement `_propertiesChanged` to react as desired to
 * property changes, and implement `static get observedAttributes()` and
 * include lowercase versions of any property names that should be set from
 * attributes. Last, call `this._enableProperties()` in the element's
 * `connectedCallback` to enable the accessors.
 *
 * @mixinFunction
 * @polymer
 * @summary Element class mixin for reacting to property changes from
 *   generated property accessors.
 */

const PropertiesChanged = dedupingMixin(
/**
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */
superClass => {
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertiesChanged}
   * @unrestricted
   */
  class PropertiesChanged extends superClass {
    /**
     * Creates property accessors for the given property names.
     * @param {!Object} props Object whose keys are names of accessors.
     * @return {void}
     * @protected
     */
    static createProperties(props) {
      const proto = this.prototype;

      for (let prop in props) {
        // don't stomp an existing accessor
        if (!(prop in proto)) {
          proto._createPropertyAccessor(prop);
        }
      }
    }
    /**
     * Returns an attribute name that corresponds to the given property.
     * The attribute name is the lowercased property name. Override to
     * customize this mapping.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     */


    static attributeNameForProperty(property) {
      return property.toLowerCase();
    }
    /**
     * Override point to provide a type to which to deserialize a value to
     * a given property.
     * @param {string} name Name of property
     *
     * @protected
     */


    static typeForProperty(name) {} //eslint-disable-line no-unused-vars

    /**
     * Creates a setter/getter pair for the named property with its own
     * local storage.  The getter returns the value in the local storage,
     * and the setter calls `_setProperty`, which updates the local storage
     * for the property and enqueues a `_propertiesChanged` callback.
     *
     * This method may be called on a prototype or an instance.  Calling
     * this method may overwrite a property value that already exists on
     * the prototype/instance by creating the accessor.
     *
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created; the
     *   protected `_setProperty` function must be used to set the property
     * @return {void}
     * @protected
     * @override
     */


    _createPropertyAccessor(property, readOnly) {
      this._addPropertyToAttributeMap(property);

      if (!this.hasOwnProperty('__dataHasAccessor')) {
        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
      }

      if (!this.__dataHasAccessor[property]) {
        this.__dataHasAccessor[property] = true;

        this._definePropertyAccessor(property, readOnly);
      }
    }
    /**
     * Adds the given `property` to a map matching attribute names
     * to property names, using `attributeNameForProperty`. This map is
     * used when deserializing attribute values to properties.
     *
     * @param {string} property Name of the property
     * @override
     */


    _addPropertyToAttributeMap(property) {
      if (!this.hasOwnProperty('__dataAttributes')) {
        this.__dataAttributes = Object.assign({}, this.__dataAttributes);
      }

      if (!this.__dataAttributes[property]) {
        const attr = this.constructor.attributeNameForProperty(property);
        this.__dataAttributes[attr] = property;
      }
    }
    /**
     * Defines a property accessor for the given property.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     * @return {void}
     * @override
     */


    _definePropertyAccessor(property, readOnly) {
      Object.defineProperty(this, property, {
        /* eslint-disable valid-jsdoc */

        /** @this {PropertiesChanged} */
        get() {
          return this._getProperty(property);
        },

        /** @this {PropertiesChanged} */
        set: readOnly ? function () {} : function (value) {
          this._setProperty(property, value);
        }
        /* eslint-enable */

      });
    }

    constructor() {
      super();
      /** @protected {boolean} */

      this.__dataEnabled = false;
      this.__dataReady = false;
      this.__dataInvalid = false;
      this.__data = {};
      this.__dataPending = null;
      this.__dataOld = null;
      this.__dataInstanceProps = null;
      this.__serializing = false;

      this._initializeProperties();
    }
    /**
     * Lifecycle callback called when properties are enabled via
     * `_enableProperties`.
     *
     * Users may override this function to implement behavior that is
     * dependent on the element having its property data initialized, e.g.
     * from defaults (initialized from `constructor`, `_initializeProperties`),
     * `attributeChangedCallback`, or values propagated from host e.g. via
     * bindings.  `super.ready()` must be called to ensure the data system
     * becomes enabled.
     *
     * @return {void}
     * @public
     * @override
     */


    ready() {
      this.__dataReady = true;

      this._flushProperties();
    }
    /**
     * Initializes the local storage for property accessors.
     *
     * Provided as an override point for performing any setup work prior
     * to initializing the property accessor system.
     *
     * @return {void}
     * @protected
     * @override
     */


    _initializeProperties() {
      // Capture instance properties; these will be set into accessors
      // during first flush. Don't set them here, since we want
      // these to overwrite defaults/constructor assignments
      for (let p in this.__dataHasAccessor) {
        if (this.hasOwnProperty(p)) {
          this.__dataInstanceProps = this.__dataInstanceProps || {};
          this.__dataInstanceProps[p] = this[p];
          delete this[p];
        }
      }
    }
    /**
     * Called at ready time with bag of instance properties that overwrote
     * accessors when the element upgraded.
     *
     * The default implementation sets these properties back into the
     * setter at ready time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */


    _initializeInstanceProperties(props) {
      Object.assign(this, props);
    }
    /**
     * Updates the local storage for a property (via `_setPendingProperty`)
     * and enqueues a `_proeprtiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     * @protected
     * @override
     */


    _setProperty(property, value) {
      if (this._setPendingProperty(property, value)) {
        this._invalidateProperties();
      }
    }
    /**
     * Returns the value for the given property.
     * @param {string} property Name of property
     * @return {*} Value for the given property
     * @protected
     * @override
     */


    _getProperty(property) {
      return this.__data[property];
    }
    /* eslint-disable no-unused-vars */

    /**
     * Updates the local storage for a property, records the previous value,
     * and adds it to the set of "pending changes" that will be passed to the
     * `_propertiesChanged` callback.  This method does not enqueue the
     * `_propertiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} ext Not used here; affordance for closure
     * @return {boolean} Returns true if the property changed
     * @protected
     * @override
     */


    _setPendingProperty(property, value, ext) {
      let old = this.__data[property];

      let changed = this._shouldPropertyChange(property, value, old);

      if (changed) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        } // Ensure old is captured from the last turn


        if (this.__dataOld && !(property in this.__dataOld)) {
          this.__dataOld[property] = old;
        }

        this.__data[property] = value;
        this.__dataPending[property] = value;
      }

      return changed;
    }
    /* eslint-enable */

    /**
     * Marks the properties as invalid, and enqueues an async
     * `_propertiesChanged` callback.
     *
     * @return {void}
     * @protected
     * @override
     */


    _invalidateProperties() {
      if (!this.__dataInvalid && this.__dataReady) {
        this.__dataInvalid = true;
        microtask.run(() => {
          if (this.__dataInvalid) {
            this.__dataInvalid = false;

            this._flushProperties();
          }
        });
      }
    }
    /**
     * Call to enable property accessor processing. Before this method is
     * called accessor values will be set but side effects are
     * queued. When called, any pending side effects occur immediately.
     * For elements, generally `connectedCallback` is a normal spot to do so.
     * It is safe to call this method multiple times as it only turns on
     * property accessors once.
     *
     * @return {void}
     * @protected
     * @override
     */


    _enableProperties() {
      if (!this.__dataEnabled) {
        this.__dataEnabled = true;

        if (this.__dataInstanceProps) {
          this._initializeInstanceProperties(this.__dataInstanceProps);

          this.__dataInstanceProps = null;
        }

        this.ready();
      }
    }
    /**
     * Calls the `_propertiesChanged` callback with the current set of
     * pending changes (and old values recorded when pending changes were
     * set), and resets the pending set of changes. Generally, this method
     * should not be called in user code.
     *
     * @return {void}
     * @protected
     * @override
     */


    _flushProperties() {
      const props = this.__data;
      const changedProps = this.__dataPending;
      const old = this.__dataOld;

      if (this._shouldPropertiesChange(props, changedProps, old)) {
        this.__dataPending = null;
        this.__dataOld = null;

        this._propertiesChanged(props, changedProps, old);
      }
    }
    /**
     * Called in `_flushProperties` to determine if `_propertiesChanged`
     * should be called. The default implementation returns true if
     * properties are pending. Override to customize when
     * `_propertiesChanged` is called.
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {boolean} true if changedProps is truthy
     * @override
     */


    _shouldPropertiesChange(currentProps, changedProps, oldProps) {
      // eslint-disable-line no-unused-vars
      return Boolean(changedProps);
    }
    /**
     * Callback called when any properties with accessors created via
     * `_createPropertyAccessor` have been set.
     *
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     * @protected
     * @override
     */


    _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars

    /**
     * Method called to determine whether a property value should be
     * considered as a change and cause the `_propertiesChanged` callback
     * to be enqueued.
     *
     * The default implementation returns `true` if a strict equality
     * check fails. The method always returns false for `NaN`.
     *
     * Override this method to e.g. provide stricter checking for
     * Objects/Arrays when using immutable patterns.
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     *   and enqueue a `_proeprtiesChanged` callback
     * @protected
     * @override
     */


    _shouldPropertyChange(property, value, old) {
      return (// Strict equality check
        old !== value && ( // This ensures (old==NaN, value==NaN) always returns false
        old === old || value === value)
      );
    }
    /**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     * @param {?string=} namespace Attribute namespace.
     * @return {void}
     * @suppress {missingProperties} Super may or may not implement the callback
     * @override
     */


    attributeChangedCallback(name, old, value, namespace) {
      if (old !== value) {
        this._attributeToProperty(name, value);
      }

      if (super.attributeChangedCallback) {
        super.attributeChangedCallback(name, old, value, namespace);
      }
    }
    /**
     * Deserializes an attribute to its associated property.
     *
     * This method calls the `_deserializeValue` method to convert the string to
     * a typed value.
     *
     * @param {string} attribute Name of attribute to deserialize.
     * @param {?string} value of the attribute.
     * @param {*=} type type to deserialize to, defaults to the value
     * returned from `typeForProperty`
     * @return {void}
     * @override
     */


    _attributeToProperty(attribute, value, type) {
      if (!this.__serializing) {
        const map = this.__dataAttributes;
        const property = map && map[attribute] || attribute;
        this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));
      }
    }
    /**
     * Serializes a property to its associated attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is an element.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect to.
     * @param {*=} value Property value to refect.
     * @return {void}
     * @override
     */


    _propertyToAttribute(property, attribute, value) {
      this.__serializing = true;
      value = arguments.length < 3 ? this[property] : value;

      this._valueToNodeAttribute(
      /** @type {!HTMLElement} */
      this, value, attribute || this.constructor.attributeNameForProperty(property));

      this.__serializing = false;
    }
    /**
     * Sets a typed value to an HTML attribute on a node.
     *
     * This method calls the `_serializeValue` method to convert the typed
     * value to a string.  If the `_serializeValue` method returns `undefined`,
     * the attribute will be removed (this is the default for boolean
     * type `false`).
     *
     * @param {Element} node Element to set attribute to.
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     * @return {void}
     * @override
     */


    _valueToNodeAttribute(node, value, attribute) {
      const str = this._serializeValue(value);

      if (str === undefined) {
        node.removeAttribute(attribute);
      } else {
        if (attribute === 'class' || attribute === 'name' || attribute === 'slot') {
          node =
          /** @type {?Element} */
          wrap(node);
        }

        node.setAttribute(attribute, str);
      }
    }
    /**
     * Converts a typed JavaScript value to a string.
     *
     * This method is called when setting JS property values to
     * HTML attributes.  Users may override this method to provide
     * serialization for custom types.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided
     * property  value.
     * @override
     */


    _serializeValue(value) {
      switch (typeof value) {
        case 'boolean':
          return value ? '' : undefined;

        default:
          return value != null ? value.toString() : undefined;
      }
    }
    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called when reading HTML attribute values to
     * JS properties.  Users may override this method to provide
     * deserialization for custom `type`s. Types for `Boolean`, `String`,
     * and `Number` convert attributes to the expected types.
     *
     * @param {?string} value Value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */


    _deserializeValue(value, type) {
      switch (type) {
        case Boolean:
          return value !== null;

        case Number:
          return Number(value);

        default:
          return value;
      }
    }

  }

  return PropertiesChanged;
});

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
// that won't have their values "saved" by `saveAccessorValue`, since
// reading from an HTMLElement accessor from the context of a prototype throws

const nativeProperties = {};
let proto = HTMLElement.prototype;

while (proto) {
  let props = Object.getOwnPropertyNames(proto);

  for (let i = 0; i < props.length; i++) {
    nativeProperties[props[i]] = true;
  }

  proto = Object.getPrototypeOf(proto);
}
/**
 * Used to save the value of a property that will be overridden with
 * an accessor. If the `model` is a prototype, the values will be saved
 * in `__dataProto`, and it's up to the user (or downstream mixin) to
 * decide how/when to set these values back into the accessors.
 * If `model` is already an instance (it has a `__data` property), then
 * the value will be set as a pending property, meaning the user should
 * call `_invalidateProperties` or `_flushProperties` to take effect
 *
 * @param {Object} model Prototype or instance
 * @param {string} property Name of property
 * @return {void}
 * @private
 */


function saveAccessorValue(model, property) {
  // Don't read/store value for any native properties since they could throw
  if (!nativeProperties[property]) {
    let value = model[property];

    if (value !== undefined) {
      if (model.__data) {
        // Adding accessor to instance; update the property
        // It is the user's responsibility to call _flushProperties
        model._setPendingProperty(property, value);
      } else {
        // Adding accessor to proto; save proto's value for instance-time use
        if (!model.__dataProto) {
          model.__dataProto = {};
        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
          model.__dataProto = Object.create(model.__dataProto);
        }

        model.__dataProto[property] = value;
      }
    }
  }
}
/**
 * Element class mixin that provides basic meta-programming for creating one
 * or more property accessors (getter/setter pair) that enqueue an async
 * (batched) `_propertiesChanged` callback.
 *
 * For basic usage of this mixin:
 *
 * -   Declare attributes to observe via the standard `static get
 *     observedAttributes()`. Use `dash-case` attribute names to represent
 *     `camelCase` property names.
 * -   Implement the `_propertiesChanged` callback on the class.
 * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to
 *     generate property accessors for each observed attribute. This must be
 *     called before the first instance is created, for example, by calling it
 *     before calling `customElements.define`. It can also be called lazily from
 *     the element's `constructor`, as long as it's guarded so that the call is
 *     only made once, when the first instance is created.
 * -   Call `this._enableProperties()` in the element's `connectedCallback` to
 *     enable the accessors.
 *
 * Any `observedAttributes` will automatically be
 * deserialized via `attributeChangedCallback` and set to the associated
 * property using `dash-case`-to-`camelCase` convention.
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin PropertiesChanged
 * @summary Element class mixin for reacting to property changes from
 *   generated property accessors.
 */


const PropertyAccessors = dedupingMixin(superClass => {
  /**
   * @constructor
   * @implements {Polymer_PropertiesChanged}
   * @unrestricted
   * @private
   */
  const base = PropertiesChanged(superClass);
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyAccessors}
   * @extends {base}
   * @unrestricted
   */

  class PropertyAccessors extends base {
    /**
     * Generates property accessors for all attributes in the standard
     * static `observedAttributes` array.
     *
     * Attribute names are mapped to property names using the `dash-case` to
     * `camelCase` convention
     *
     * @return {void}
     */
    static createPropertiesForAttributes() {
      let a$ = this.observedAttributes;

      for (let i = 0; i < a$.length; i++) {
        this.prototype._createPropertyAccessor(dashToCamelCase(a$[i]));
      }
    }
    /**
     * Returns an attribute name that corresponds to the given property.
     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     */


    static attributeNameForProperty(property) {
      return camelToDashCase(property);
    }
    /**
     * Overrides PropertiesChanged implementation to initialize values for
     * accessors created for values that already existed on the element
     * prototype.
     *
     * @return {void}
     * @protected
     * @override
     */


    _initializeProperties() {
      if (this.__dataProto) {
        this._initializeProtoProperties(this.__dataProto);

        this.__dataProto = null;
      }

      super._initializeProperties();
    }
    /**
     * Called at instance time with bag of properties that were overwritten
     * by accessors on the prototype when accessors were created.
     *
     * The default implementation sets these properties back into the
     * setter at instance time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */


    _initializeProtoProperties(props) {
      for (let p in props) {
        this._setProperty(p, props[p]);
      }
    }
    /**
     * Ensures the element has the given attribute. If it does not,
     * assigns the given value to the attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is infact an
     *     element
     *
     * @param {string} attribute Name of attribute to ensure is set.
     * @param {string} value of the attribute.
     * @return {void}
     * @override
     */


    _ensureAttribute(attribute, value) {
      const el =
      /** @type {!HTMLElement} */
      this;

      if (!el.hasAttribute(attribute)) {
        this._valueToNodeAttribute(el, value, attribute);
      }
    }
    /**
     * Overrides PropertiesChanged implemention to serialize objects as JSON.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided property
     *     value.
     * @override
     */


    _serializeValue(value) {
      /* eslint-disable no-fallthrough */
      switch (typeof value) {
        case 'object':
          if (value instanceof Date) {
            return value.toString();
          } else if (value) {
            try {
              return JSON.stringify(value);
            } catch (x) {
              return '';
            }
          }

        default:
          return super._serializeValue(value);
      }
    }
    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called by Polymer when reading HTML attribute values to
     * JS properties.  Users may override this method on Polymer element
     * prototypes to provide deserialization for custom `type`s.  Note,
     * the `type` argument is the value of the `type` field provided in the
     * `properties` configuration object for a given property, and is
     * by convention the constructor for the type to deserialize.
     *
     *
     * @param {?string} value Attribute value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */


    _deserializeValue(value, type) {
      /**
       * @type {*}
       */
      let outValue;

      switch (type) {
        case Object:
          try {
            outValue = JSON.parse(
            /** @type {string} */
            value);
          } catch (x) {
            // allow non-JSON literals like Strings and Numbers
            outValue = value;
          }

          break;

        case Array:
          try {
            outValue = JSON.parse(
            /** @type {string} */
            value);
          } catch (x) {
            outValue = null;
            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);
          }

          break;

        case Date:
          outValue = isNaN(value) ? String(value) : Number(value);
          outValue = new Date(outValue);
          break;

        default:
          outValue = super._deserializeValue(value, type);
          break;
      }

      return outValue;
    }
    /* eslint-enable no-fallthrough */

    /**
     * Overrides PropertiesChanged implementation to save existing prototype
     * property value so that it can be reset.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     *
     * When calling on a prototype, any overwritten values are saved in
     * `__dataProto`, and it is up to the subclasser to decide how/when
     * to set those properties back into the accessor.  When calling on an
     * instance, the overwritten value is set via `_setPendingProperty`,
     * and the user should call `_invalidateProperties` or `_flushProperties`
     * for the values to take effect.
     * @protected
     * @return {void}
     * @override
     */


    _definePropertyAccessor(property, readOnly) {
      saveAccessorValue(this, property);

      super._definePropertyAccessor(property, readOnly);
    }
    /**
     * Returns true if this library created an accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if an accessor was created
     * @override
     */


    _hasAccessor(property) {
      return this.__dataHasAccessor && this.__dataHasAccessor[property];
    }
    /**
     * Returns true if the specified property has a pending change.
     *
     * @param {string} prop Property name
     * @return {boolean} True if property has a pending change
     * @protected
     * @override
     */


    _isPropertyPending(prop) {
      return Boolean(this.__dataPending && prop in this.__dataPending);
    }

  }

  return PropertyAccessors;
});

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const walker = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, false); // 1.x backwards-compatible auto-wrapper for template type extensions
// This is a clear layering violation and gives favored-nation status to
// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
// a.) to ease 1.x backwards-compatibility due to loss of `is`, and
// b.) to maintain if/repeat capability in parser-constrained elements
//     (e.g. table, select) in lieu of native CE type extensions without
//     massive new invention in this space (e.g. directive system)

const templateExtensions = {
  'dom-if': true,
  'dom-repeat': true
};

function wrapTemplateExtension(node) {
  let is = node.getAttribute('is');

  if (is && templateExtensions[is]) {
    let t = node;
    t.removeAttribute('is');
    node = t.ownerDocument.createElement(is);
    t.parentNode.replaceChild(node, t);
    node.appendChild(t);

    while (t.attributes.length) {
      node.setAttribute(t.attributes[0].name, t.attributes[0].value);
      t.removeAttribute(t.attributes[0].name);
    }
  }

  return node;
}

function findTemplateNode(root, nodeInfo) {
  // recursively ascend tree until we hit root
  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo); // unwind the stack, returning the indexed node at each level

  if (parent) {
    // note: marginally faster than indexing via childNodes
    // (http://jsperf.com/childnodes-lookup)
    walker.currentNode = parent;

    for (let n = walker.firstChild(), i = 0; n; n = walker.nextSibling()) {
      if (nodeInfo.parentIndex === i++) {
        return n;
      }
    }
  } else {
    return root;
  }
} // construct `$` map (from id annotations)


function applyIdToMap(inst, map, node, nodeInfo) {
  if (nodeInfo.id) {
    map[nodeInfo.id] = node;
  }
} // install event listeners (from event annotations)


function applyEventListener(inst, node, nodeInfo) {
  if (nodeInfo.events && nodeInfo.events.length) {
    for (let j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {
      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
    }
  }
} // push configuration references at configure time


function applyTemplateContent(inst, node, nodeInfo) {
  if (nodeInfo.templateInfo) {
    node._templateInfo = nodeInfo.templateInfo;
  }
}

function createNodeEventHandler(context, eventName, methodName) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  context = context._methodHost || context;

  let handler = function (e) {
    if (context[methodName]) {
      context[methodName](e, e.detail);
    } else {
      console.warn('listener method `' + methodName + '` not defined');
    }
  };

  return handler;
}
/**
 * Element mixin that provides basic template parsing and stamping, including
 * the following template-related features for stamped templates:
 *
 * - Declarative event listeners (`on-eventname="listener"`)
 * - Map of node id's to stamped node instances (`this.$.id`)
 * - Nested template content caching/removal and re-installation (performance
 *   optimization)
 *
 * @mixinFunction
 * @polymer
 * @summary Element class mixin that provides basic template parsing and stamping
 */


const TemplateStamp = dedupingMixin(
/**
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */
superClass => {
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_TemplateStamp}
   */
  class TemplateStamp extends superClass {
    /**
     * Scans a template to produce template metadata.
     *
     * Template-specific metadata are stored in the object returned, and node-
     * specific metadata are stored in objects in its flattened `nodeInfoList`
     * array.  Only nodes in the template that were parsed as nodes of
     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
     * contains an `index` (`childNodes` index in parent) and optionally
     * `parent`, which points to node info of its parent (including its index).
     *
     * The template metadata object returned from this method has the following
     * structure (many fields optional):
     *
     * ```js
     *   {
     *     // Flattened list of node metadata (for nodes that generated metadata)
     *     nodeInfoList: [
     *       {
     *         // `id` attribute for any nodes with id's for generating `$` map
     *         id: {string},
     *         // `on-event="handler"` metadata
     *         events: [
     *           {
     *             name: {string},   // event name
     *             value: {string},  // handler method name
     *           }, ...
     *         ],
     *         // Notes when the template contained a `<slot>` for shady DOM
     *         // optimization purposes
     *         hasInsertionPoint: {boolean},
     *         // For nested `<template>`` nodes, nested template metadata
     *         templateInfo: {object}, // nested template metadata
     *         // Metadata to allow efficient retrieval of instanced node
     *         // corresponding to this metadata
     *         parentInfo: {number},   // reference to parent nodeInfo>
     *         parentIndex: {number},  // index in parent's `childNodes` collection
     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
     *       },
     *       ...
     *     ],
     *     // When true, the template had the `strip-whitespace` attribute
     *     // or was nested in a template with that setting
     *     stripWhitespace: {boolean},
     *     // For nested templates, nested template content is moved into
     *     // a document fragment stored here; this is an optimization to
     *     // avoid the cost of nested template cloning
     *     content: {DocumentFragment}
     *   }
     * ```
     *
     * This method kicks off a recursive treewalk as follows:
     *
     * ```
     *    _parseTemplate <---------------------+
     *      _parseTemplateContent              |
     *        _parseTemplateNode  <------------|--+
     *          _parseTemplateNestedTemplate --+  |
     *          _parseTemplateChildNodes ---------+
     *          _parseTemplateNodeAttributes
     *            _parseTemplateNodeAttribute
     *
     * ```
     *
     * These methods may be overridden to add custom metadata about templates
     * to either `templateInfo` or `nodeInfo`.
     *
     * Note that this method may be destructive to the template, in that
     * e.g. event annotations may be removed after being noted in the
     * template metadata.
     *
     * @param {!HTMLTemplateElement} template Template to parse
     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
     *   template, for parsing nested templates
     * @return {!TemplateInfo} Parsed template metadata
     */
    static _parseTemplate(template, outerTemplateInfo) {
      // since a template may be re-used, memo-ize metadata
      if (!template._templateInfo) {
        let templateInfo = template._templateInfo = {};
        templateInfo.nodeInfoList = [];
        templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');

        this._parseTemplateContent(template, templateInfo, {
          parent: null
        });
      }

      return template._templateInfo;
    }

    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
    }
    /**
     * Parses template node and adds template and node metadata based on
     * the current node, and its `childNodes` and `attributes`.
     *
     * This method may be overridden to add custom node or template specific
     * metadata based on this node.
     *
     * @param {Node} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */


    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted;
      let element =
      /** @type {Element} */
      node;

      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
      } else if (element.localName === 'slot') {
        // For ShadyDom optimization, indicating there is an insertion point
        templateInfo.hasInsertionPoint = true;
      }

      walker.currentNode = element;

      if (walker.firstChild()) {
        noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
      }

      if (element.hasAttributes && element.hasAttributes()) {
        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
      }

      return noted;
    }
    /**
     * Parses template child nodes for the given root node.
     *
     * This method also wraps whitelisted legacy template extensions
     * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
     * wrappers, collapses text nodes, and strips whitespace from the template
     * if the `templateInfo.stripWhitespace` setting was provided.
     *
     * @param {Node} root Root node whose `childNodes` will be parsed
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {void}
     */


    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
      if (root.localName === 'script' || root.localName === 'style') {
        return;
      }

      walker.currentNode = root;

      for (let node = walker.firstChild(), parentIndex = 0, next; node; node = next) {
        // Wrap templates
        if (node.localName == 'template') {
          node = wrapTemplateExtension(node);
        } // collapse adjacent textNodes: fixes an IE issue that can cause
        // text nodes to be inexplicably split =(
        // note that root.normalize() should work but does not so we do this
        // manually.


        walker.currentNode = node;
        next = walker.nextSibling();

        if (node.nodeType === Node.TEXT_NODE) {
          let
          /** Node */
          n = next;

          while (n && n.nodeType === Node.TEXT_NODE) {
            node.textContent += n.textContent;
            next = walker.nextSibling();
            root.removeChild(n);
            n = next;
          } // optionally strip whitespace


          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
            root.removeChild(node);
            continue;
          }
        }

        let childInfo = {
          parentIndex,
          parentInfo: nodeInfo
        };

        if (this._parseTemplateNode(node, templateInfo, childInfo)) {
          childInfo.infoIndex = templateInfo.nodeInfoList.push(
          /** @type {!NodeInfo} */
          childInfo) - 1;
        } // Increment if not removed


        walker.currentNode = node;

        if (walker.parentNode()) {
          parentIndex++;
        }
      }
    }
    /**
     * Parses template content for the given nested `<template>`.
     *
     * Nested template info is stored as `templateInfo` in the current node's
     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
     * It will then be the responsibility of the host to set it back to the
     * template and for users stamping nested templates to use the
     * `_contentForTemplate` method to retrieve the content for this template
     * (an optimization to avoid the cost of cloning nested template content).
     *
     * @param {HTMLTemplateElement} node Node to parse (a <template>)
     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
     *   that includes the template `node`
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */


    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
      let templateInfo = this._parseTemplate(node, outerTemplateInfo);

      let content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();
      content.appendChild(node.content);
      nodeInfo.templateInfo = templateInfo;
      return true;
    }
    /**
     * Parses template node attributes and adds node metadata to `nodeInfo`
     * for nodes of interest.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */


    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
      // Make copy of original attribute list, since the order may change
      // as attributes are added and removed
      let noted = false;
      let attrs = Array.from(node.attributes);

      for (let i = attrs.length - 1, a; a = attrs[i]; i--) {
        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
      }

      return noted;
    }
    /**
     * Parses a single template node attribute and adds node metadata to
     * `nodeInfo` for attributes of interest.
     *
     * This implementation adds metadata for `on-event="handler"` attributes
     * and `id` attributes.
     *
     * @param {Element} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */


    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      // events (on-*)
      if (name.slice(0, 3) === 'on-') {
        node.removeAttribute(name);
        nodeInfo.events = nodeInfo.events || [];
        nodeInfo.events.push({
          name: name.slice(3),
          value
        });
        return true;
      } // static id
      else if (name === 'id') {
          nodeInfo.id = value;
          return true;
        }

      return false;
    }
    /**
     * Returns the `content` document fragment for a given template.
     *
     * For nested templates, Polymer performs an optimization to cache nested
     * template content to avoid the cost of cloning deeply nested templates.
     * This method retrieves the cached content for a given template.
     *
     * @param {HTMLTemplateElement} template Template to retrieve `content` for
     * @return {DocumentFragment} Content fragment
     */


    static _contentForTemplate(template) {
      let templateInfo =
      /** @type {HTMLTemplateElementWithInfo} */
      template._templateInfo;
      return templateInfo && templateInfo.content || template.content;
    }
    /**
     * Clones the provided template content and returns a document fragment
     * containing the cloned dom.
     *
     * The template is parsed (once and memoized) using this library's
     * template parsing features, and provides the following value-added
     * features:
     * * Adds declarative event listeners for `on-event="handler"` attributes
     * * Generates an "id map" for all nodes with id's under `$` on returned
     *   document fragment
     * * Passes template info including `content` back to templates as
     *   `_templateInfo` (a performance optimization to avoid deep template
     *   cloning)
     *
     * Note that the memoized template parsing process is destructive to the
     * template: attributes for bindings and declarative event listeners are
     * removed after being noted in notes, and any nested `<template>.content`
     * is removed and stored in notes as well.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @return {!StampedTemplate} Cloned template content
     * @override
     */


    _stampTemplate(template) {
      // Polyfill support: bootstrap the template if it has not already been
      if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
        HTMLTemplateElement.decorate(template);
      }

      let templateInfo = this.constructor._parseTemplate(template);

      let nodeInfo = templateInfo.nodeInfoList;
      let content = templateInfo.content || template.content;
      let dom =
      /** @type {DocumentFragment} */
      document.importNode(content, true); // NOTE: ShadyDom optimization indicating there is an insertion point

      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
      let nodes = dom.nodeList = new Array(nodeInfo.length);
      dom.$ = {};

      for (let i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {
        let node = nodes[i] = findTemplateNode(dom, info);
        applyIdToMap(this, dom.$, node, info);
        applyTemplateContent(this, node, info);
        applyEventListener(this, node, info);
      }

      dom =
      /** @type {!StampedTemplate} */
      dom; // eslint-disable-line no-self-assign

      return dom;
    }
    /**
     * Adds an event listener by method name for the event provided.
     *
     * This method generates a handler function that looks up the method
     * name at handling time.
     *
     * @param {!EventTarget} node Node to add listener on
     * @param {string} eventName Name of event
     * @param {string} methodName Name of method
     * @param {*=} context Context the method will be called on (defaults
     *   to `node`)
     * @return {Function} Generated handler function
     * @override
     */


    _addMethodEventListenerToNode(node, eventName, methodName, context) {
      context = context || node;
      let handler = createNodeEventHandler(context, eventName, methodName);

      this._addEventListenerToNode(node, eventName, handler);

      return handler;
    }
    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {!EventTarget} node Node to add event listener to
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to add
     * @return {void}
     * @override
     */


    _addEventListenerToNode(node, eventName, handler) {
      node.addEventListener(eventName, handler);
    }
    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {!EventTarget} node Node to remove event listener from
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to remove
     * @return {void}
     * @override
     */


    _removeEventListenerFromNode(node, eventName, handler) {
      node.removeEventListener(eventName, handler);
    }

  }

  return TemplateStamp;
});

/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
// from multiple properties in the same turn

let dedupeId$1 = 0;
/**
 * Property effect types; effects are stored on the prototype using these keys
 * @enum {string}
 */

const TYPES = {
  COMPUTE: '__computeEffects',
  REFLECT: '__reflectEffects',
  NOTIFY: '__notifyEffects',
  PROPAGATE: '__propagateEffects',
  OBSERVE: '__observeEffects',
  READ_ONLY: '__readOnly'
};
/** @const {!RegExp} */

const capitalAttributeRegex = /[A-Z]/;

/**
 * Ensures that the model has an own-property map of effects for the given type.
 * The model may be a prototype or an instance.
 *
 * Property effects are stored as arrays of effects by property in a map,
 * by named type on the model. e.g.
 *
 *   __computeEffects: {
 *     foo: [ ... ],
 *     bar: [ ... ]
 *   }
 *
 * If the model does not yet have an effect map for the type, one is created
 * and returned.  If it does, but it is not an own property (i.e. the
 * prototype had effects), the the map is deeply cloned and the copy is
 * set on the model and returned, ready for new effects to be added.
 *
 * @param {Object} model Prototype or instance
 * @param {string} type Property effect type
 * @return {Object} The own-property map of effects for the given type
 * @private
 */

function ensureOwnEffectMap(model, type) {
  let effects = model[type];

  if (!effects) {
    effects = model[type] = {};
  } else if (!model.hasOwnProperty(type)) {
    effects = model[type] = Object.create(model[type]);

    for (let p in effects) {
      let protoFx = effects[p];
      let instFx = effects[p] = Array(protoFx.length);

      for (let i = 0; i < protoFx.length; i++) {
        instFx[i] = protoFx[i];
      }
    }
  }

  return effects;
} // -- effects ----------------------------------------------

/**
 * Runs all effects of a given type for the given set of property changes
 * on an instance.
 *
 * @param {!Polymer_PropertyEffects} inst The instance with effects to run
 * @param {?Object} effects Object map of property-to-Array of effects
 * @param {?Object} props Bag of current property changes
 * @param {?Object=} oldProps Bag of previous values for changed properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */


function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
  if (effects) {
    let ran = false;
    let id = dedupeId$1++;

    for (let prop in props) {
      if (runEffectsForProperty(inst,
      /** @type {!Object} */
      effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
        ran = true;
      }
    }

    return ran;
  }

  return false;
}
/**
 * Runs a list of effects for a given property.
 *
 * @param {!Polymer_PropertyEffects} inst The instance with effects to run
 * @param {!Object} effects Object map of property-to-Array of effects
 * @param {number} dedupeId Counter used for de-duping effects
 * @param {string} prop Name of changed property
 * @param {*} props Changed properties
 * @param {*} oldProps Old properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */


function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
  let ran = false;
  let rootProperty = hasPaths ? root$1(prop) : prop;
  let fxs = effects[rootProperty];

  if (fxs) {
    for (let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
      if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        if (fx.info) {
          fx.info.lastRun = dedupeId;
        }

        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
        ran = true;
      }
    }
  }

  return ran;
}
/**
 * Determines whether a property/path that has changed matches the trigger
 * criteria for an effect.  A trigger is a descriptor with the following
 * structure, which matches the descriptors returned from `parseArg`.
 * e.g. for `foo.bar.*`:
 * ```
 * trigger: {
 *   name: 'a.b',
 *   structured: true,
 *   wildcard: true
 * }
 * ```
 * If no trigger is given, the path is deemed to match.
 *
 * @param {string} path Path or property that changed
 * @param {?DataTrigger} trigger Descriptor
 * @return {boolean} Whether the path matched the trigger
 */


function pathMatchesTrigger(path, trigger) {
  if (trigger) {
    let triggerPath =
    /** @type {string} */
    trigger.name;
    return triggerPath == path || !!(trigger.structured && isAncestor(triggerPath, path)) || !!(trigger.wildcard && isDescendant(triggerPath, path));
  } else {
    return true;
  }
}
/**
 * Implements the "observer" effect.
 *
 * Calls the method with `info.methodName` on the instance, passing the
 * new and old values.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {void}
 * @private
 */


function runObserverEffect(inst, property, props, oldProps, info) {
  let fn = typeof info.method === "string" ? inst[info.method] : info.method;
  let changedProp = info.property;

  if (fn) {
    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
  } else if (!info.dynamicFn) {
    console.warn('observer method `' + info.method + '` not defined');
  }
}
/**
 * Runs "notify" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * will dispatch path notification events in the case that the property
 * changed was a path and the root property for that path didn't have a
 * "notify" effect.  This is to maintain 1.0 behavior that did not require
 * `notify: true` to ensure object sub-property notifications were
 * sent.
 *
 * @param {!Polymer_PropertyEffects} inst The instance with effects to run
 * @param {Object} notifyProps Bag of properties to notify
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @return {void}
 * @private
 */


function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
  // Notify
  let fxs = inst[TYPES.NOTIFY];
  let notified;
  let id = dedupeId$1++; // Try normal notify effects; if none, fall back to try path notification

  for (let prop in notifyProps) {
    if (notifyProps[prop]) {
      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
        notified = true;
      } else if (hasPaths && notifyPath(inst, prop, props)) {
        notified = true;
      }
    }
  } // Flush host if we actually notified and host was batching
  // And the host has already initialized clients; this prevents
  // an issue with a host observing data changes before clients are ready.


  let host;

  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
    host._invalidateProperties();
  }
}
/**
 * Dispatches {property}-changed events with path information in the detail
 * object to indicate a sub-path of the property was changed.
 *
 * @param {!Polymer_PropertyEffects} inst The element from which to fire the
 *     event
 * @param {string} path The path that was changed
 * @param {Object} props Bag of current property changes
 * @return {boolean} Returns true if the path was notified
 * @private
 */


function notifyPath(inst, path, props) {
  let rootProperty = root$1(path);

  if (rootProperty !== path) {
    let eventName = camelToDashCase(rootProperty) + '-changed';
    dispatchNotifyEvent(inst, eventName, props[path], path);
    return true;
  }

  return false;
}
/**
 * Dispatches {property}-changed events to indicate a property (or path)
 * changed.
 *
 * @param {!Polymer_PropertyEffects} inst The element from which to fire the
 *     event
 * @param {string} eventName The name of the event to send
 *     ('{property}-changed')
 * @param {*} value The value of the changed property
 * @param {string | null | undefined} path If a sub-path of this property
 *     changed, the path that changed (optional).
 * @return {void}
 * @private
 * @suppress {invalidCasts}
 */


function dispatchNotifyEvent(inst, eventName, value, path) {
  let detail = {
    value: value,
    queueProperty: true
  };

  if (path) {
    detail.path = path;
  }

  wrap(
  /** @type {!HTMLElement} */
  inst).dispatchEvent(new CustomEvent(eventName, {
    detail
  }));
}
/**
 * Implements the "notify" effect.
 *
 * Dispatches a non-bubbling event named `info.eventName` on the instance
 * with a detail object containing the new `value`.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @return {void}
 * @private
 */


function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
  let rootProperty = hasPaths ? root$1(property) : property;
  let path = rootProperty != property ? property : null;
  let value = path ? get(inst, path) : inst.__data[property];

  if (path && value === undefined) {
    value = props[property]; // specifically for .splices
  }

  dispatchNotifyEvent(inst, info.eventName, value, path);
}
/**
 * Handler function for 2-way notification events. Receives context
 * information captured in the `addNotifyListener` closure from the
 * `__notifyListeners` metadata.
 *
 * Sets the value of the notified property to the host property or path.  If
 * the event contained path information, translate that path to the host
 * scope's name for that path first.
 *
 * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
 * @param {!Polymer_PropertyEffects} inst Host element instance handling the
 *     notification event
 * @param {string} fromProp Child element property that was bound
 * @param {string} toPath Host property/path that was bound
 * @param {boolean} negate Whether the binding was negated
 * @return {void}
 * @private
 */


function handleNotification(event, inst, fromProp, toPath, negate) {
  let value;
  let detail =
  /** @type {Object} */
  event.detail;
  let fromPath = detail && detail.path;

  if (fromPath) {
    toPath = translate(fromProp, toPath, fromPath);
    value = detail && detail.value;
  } else {
    value = event.currentTarget[fromProp];
  }

  value = negate ? !value : value;

  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
      inst._invalidateProperties();
    }
  }
}
/**
 * Implements the "reflect" effect.
 *
 * Sets the attribute named `info.attrName` to the given property value.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {void}
 * @private
 */


function runReflectEffect(inst, property, props, oldProps, info) {
  let value = inst.__data[property];

  if (sanitizeDOMValue) {
    value = sanitizeDOMValue(value, info.attrName, 'attribute',
    /** @type {Node} */
    inst);
  }

  inst._propertyToAttribute(property, info.attrName, value);
}
/**
 * Runs "computed" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * continues to run computed effects based on the output of each pass until
 * there are no more newly computed properties.  This ensures that all
 * properties that will be computed by the initial set of changes are
 * computed before other effects (binding propagation, observers, and notify)
 * run.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {?Object} changedProps Bag of changed properties
 * @param {?Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @return {void}
 * @private
 */


function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
  let computeEffects = inst[TYPES.COMPUTE];

  if (computeEffects) {
    let inputProps = changedProps;

    while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
      Object.assign(
      /** @type {!Object} */
      oldProps, inst.__dataOld);
      Object.assign(
      /** @type {!Object} */
      changedProps, inst.__dataPending);
      inputProps = inst.__dataPending;
      inst.__dataPending = null;
    }
  }
}
/**
 * Implements the "computed property" effect by running the method with the
 * values of the arguments specified in the `info` object and setting the
 * return value to the computed property specified.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {?Object} props Bag of current property changes
 * @param {?Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {void}
 * @private
 */


function runComputedEffect(inst, property, props, oldProps, info) {
  let result = runMethodEffect(inst, property, props, oldProps, info);
  let computedProp = info.methodInfo;

  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
    inst._setPendingProperty(computedProp, result, true);
  } else {
    inst[computedProp] = result;
  }
}
/**
 * Computes path changes based on path links set up using the `linkPaths`
 * API.
 *
 * @param {!Polymer_PropertyEffects} inst The instance whose props are changing
 * @param {string} path Path that has changed
 * @param {*} value Value of changed path
 * @return {void}
 * @private
 */


function computeLinkedPaths(inst, path, value) {
  let links = inst.__dataLinkedPaths;

  if (links) {
    let link;

    for (let a in links) {
      let b = links[a];

      if (isDescendant(a, path)) {
        link = translate(a, b, path);

        inst._setPendingPropertyOrPath(link, value, true, true);
      } else if (isDescendant(b, path)) {
        link = translate(b, a, path);

        inst._setPendingPropertyOrPath(link, value, true, true);
      }
    }
  }
} // -- bindings ----------------------------------------------

/**
 * Adds binding metadata to the current `nodeInfo`, and binding effects
 * for all part dependencies to `templateInfo`.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {NodeInfo} nodeInfo Node metadata for current template node
 * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
 * @param {string} target Target property name
 * @param {!Array<!BindingPart>} parts Array of binding part metadata
 * @param {string=} literal Literal text surrounding binding parts (specified
 *   only for 'property' bindings, since these must be initialized as part
 *   of boot-up)
 * @return {void}
 * @private
 */


function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
  // Create binding metadata and add to nodeInfo
  nodeInfo.bindings = nodeInfo.bindings || [];
  let
  /** Binding */
  binding = {
    kind,
    target,
    parts,
    literal,
    isCompound: parts.length !== 1
  };
  nodeInfo.bindings.push(binding); // Add listener info to binding metadata

  if (shouldAddListener(binding)) {
    let {
      event,
      negate
    } = binding.parts[0];
    binding.listenerEvent = event || camelToDashCase(target) + '-changed';
    binding.listenerNegate = negate;
  } // Add "propagate" property effects to templateInfo


  let index = templateInfo.nodeInfoList.length;

  for (let i = 0; i < binding.parts.length; i++) {
    let part = binding.parts[i];
    part.compoundIndex = i;
    addEffectForBindingPart(constructor, templateInfo, binding, part, index);
  }
}
/**
 * Adds property effects to the given `templateInfo` for the given binding
 * part.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {number} index Index into `nodeInfoList` for this node
 * @return {void}
 */


function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
  if (!part.literal) {
    if (binding.kind === 'attribute' && binding.target[0] === '-') {
      console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
    } else {
      let dependencies = part.dependencies;
      let info = {
        index,
        binding,
        part,
        evaluator: constructor
      };

      for (let j = 0; j < dependencies.length; j++) {
        let trigger = dependencies[j];

        if (typeof trigger == 'string') {
          trigger = parseArg(trigger);
          trigger.wildcard = true;
        }

        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
          fn: runBindingEffect,
          info,
          trigger
        });
      }
    }
  }
}
/**
 * Implements the "binding" (property/path binding) effect.
 *
 * Note that binding syntax is overridable via `_parseBindings` and
 * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
 * non-literal parts returned from `_parseBindings`.  However,
 * there is no support for _path_ bindings via custom binding parts,
 * as this is specific to Polymer's path binding syntax.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} path Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
 *   metadata
 * @return {void}
 * @private
 */


function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
  let node = nodeList[info.index];
  let binding = info.binding;
  let part = info.part; // Subpath notification: transform path and set to client
  // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop

  if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
    let value = props[path];
    path = translate(part.source, binding.target, path);

    if (node._setPendingPropertyOrPath(path, value, false, true)) {
      inst._enqueueClient(node);
    }
  } else {
    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths); // Propagate value to child


    applyBindingValue(inst, node, binding, part, value);
  }
}
/**
 * Sets the value for an "binding" (binding) effect to a node,
 * either as a property or attribute.
 *
 * @param {!Polymer_PropertyEffects} inst The instance owning the binding effect
 * @param {Node} node Target node for binding
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {*} value Value to set
 * @return {void}
 * @private
 */


function applyBindingValue(inst, node, binding, part, value) {
  value = computeBindingValue(node, value, binding, part);

  if (sanitizeDOMValue) {
    value = sanitizeDOMValue(value, binding.target, binding.kind, node);
  }

  if (binding.kind == 'attribute') {
    // Attribute binding
    inst._valueToNodeAttribute(
    /** @type {Element} */
    node, value, binding.target);
  } else {
    // Property binding
    let prop = binding.target;

    if (node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
        if (node._setPendingProperty(prop, value)) {
          inst._enqueueClient(node);
        }
      }
    } else {
      inst._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
}
/**
 * Transforms an "binding" effect value based on compound & negation
 * effect metadata, as well as handling for special-case properties
 *
 * @param {Node} node Node the value will be set to
 * @param {*} value Value to set
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @return {*} Transformed value to set
 * @private
 */


function computeBindingValue(node, value, binding, part) {
  if (binding.isCompound) {
    let storage = node.__dataCompoundStorage[binding.target];
    storage[part.compoundIndex] = value;
    value = storage.join('');
  }

  if (binding.kind !== 'attribute') {
    // Some browsers serialize `undefined` to `"undefined"`
    if (binding.target === 'textContent' || binding.target === 'value' && (node.localName === 'input' || node.localName === 'textarea')) {
      value = value == undefined ? '' : value;
    }
  }

  return value;
}
/**
 * Returns true if a binding's metadata meets all the requirements to allow
 * 2-way binding, and therefore a `<property>-changed` event listener should be
 * added:
 * - used curly braces
 * - is a property (not attribute) binding
 * - is not a textContent binding
 * - is not compound
 *
 * @param {!Binding} binding Binding metadata
 * @return {boolean} True if 2-way listener should be added
 * @private
 */


function shouldAddListener(binding) {
  return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
}
/**
 * Setup compound binding storage structures, notify listeners, and dataHost
 * references onto the bound nodeList.
 *
 * @param {!Polymer_PropertyEffects} inst Instance that bas been previously
 *     bound
 * @param {TemplateInfo} templateInfo Template metadata
 * @return {void}
 * @private
 */


function setupBindings(inst, templateInfo) {
  // Setup compound storage, dataHost, and notify listeners
  let {
    nodeList,
    nodeInfoList
  } = templateInfo;

  if (nodeInfoList.length) {
    for (let i = 0; i < nodeInfoList.length; i++) {
      let info = nodeInfoList[i];
      let node = nodeList[i];
      let bindings = info.bindings;

      if (bindings) {
        for (let i = 0; i < bindings.length; i++) {
          let binding = bindings[i];
          setupCompoundStorage(node, binding);
          addNotifyListener(node, inst, binding);
        }
      }

      node.__dataHost = inst;
    }
  }
}
/**
 * Initializes `__dataCompoundStorage` local storage on a bound node with
 * initial literal data for compound bindings, and sets the joined
 * literal parts to the bound property.
 *
 * When changes to compound parts occur, they are first set into the compound
 * storage array for that property, and then the array is joined to result in
 * the final value set to the property/attribute.
 *
 * @param {Node} node Bound node to initialize
 * @param {Binding} binding Binding metadata
 * @return {void}
 * @private
 */


function setupCompoundStorage(node, binding) {
  if (binding.isCompound) {
    // Create compound storage map
    let storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
    let parts = binding.parts; // Copy literals from parts into storage for this binding

    let literals = new Array(parts.length);

    for (let j = 0; j < parts.length; j++) {
      literals[j] = parts[j].literal;
    }

    let target = binding.target;
    storage[target] = literals; // Configure properties with their literal parts

    if (binding.literal && binding.kind == 'property') {
      node[target] = binding.literal;
    }
  }
}
/**
 * Adds a 2-way binding notification event listener to the node specified
 *
 * @param {Object} node Child element to add listener to
 * @param {!Polymer_PropertyEffects} inst Host element instance to handle
 *     notification event
 * @param {Binding} binding Binding metadata
 * @return {void}
 * @private
 */


function addNotifyListener(node, inst, binding) {
  if (binding.listenerEvent) {
    let part = binding.parts[0];
    node.addEventListener(binding.listenerEvent, function (e) {
      handleNotification(e, inst, binding.target, part.source, part.negate);
    });
  }
} // -- for method-based effects (complexObserver & computed) --------------

/**
 * Adds property effects for each argument in the method signature (and
 * optionally, for the method name if `dynamic` is true) that calls the
 * provided effect function.
 *
 * @param {Element | Object} model Prototype or instance
 * @param {!MethodSignature} sig Method signature metadata
 * @param {string} type Type of property effect to add
 * @param {Function} effectFn Function to run when arguments change
 * @param {*=} methodInfo Effect-specific information to be included in
 *   method effect metadata
 * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
 *   method names should be included as a dependency to the effect. Note,
 *   defaults to true if the signature is static (sig.static is true).
 * @return {void}
 * @private
 */


function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
  dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]);
  let info = {
    methodName: sig.methodName,
    args: sig.args,
    methodInfo,
    dynamicFn
  };

  for (let i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
    if (!arg.literal) {
      model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn,
        info: info,
        trigger: arg
      });
    }
  }

  if (dynamicFn) {
    model._addPropertyEffect(sig.methodName, type, {
      fn: effectFn,
      info: info
    });
  }
}
/**
 * Calls a method with arguments marshaled from properties on the instance
 * based on the method signature contained in the effect metadata.
 *
 * Multi-property observers, computed properties, and inline computing
 * functions call this function to invoke the method, then use the return
 * value accordingly.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {*} Returns the return value from the method invocation
 * @private
 */


function runMethodEffect(inst, property, props, oldProps, info) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  let context = inst._methodHost || inst;
  let fn = context[info.methodName];

  if (fn) {
    let args = inst._marshalArgs(info.args, property, props);

    return fn.apply(context, args);
  } else if (!info.dynamicFn) {
    console.warn('method `' + info.methodName + '` not defined');
  }
}

const emptyArray = []; // Regular expressions used for binding

const IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
const NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
const SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
const DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
const STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
const ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
const ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
const ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
const BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3

const OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
const CLOSE_BRACKET = '(?:]]|}})';
const NEGATE = '(?:(!)\\s*)?'; // Group 2

const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
const bindingRegex = new RegExp(EXPRESSION, "g");
/**
 * Create a string from binding parts of all the literal parts
 *
 * @param {!Array<BindingPart>} parts All parts to stringify
 * @return {string} String made from the literal parts
 */

function literalFromParts(parts) {
  let s = '';

  for (let i = 0; i < parts.length; i++) {
    let literal = parts[i].literal;
    s += literal || '';
  }

  return s;
}
/**
 * Parses an expression string for a method signature, and returns a metadata
 * describing the method in terms of `methodName`, `static` (whether all the
 * arguments are literals), and an array of `args`
 *
 * @param {string} expression The expression to parse
 * @return {?MethodSignature} The method metadata object if a method expression was
 *   found, otherwise `undefined`
 * @private
 */


function parseMethod(expression) {
  // tries to match valid javascript property names
  let m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);

  if (m) {
    let methodName = m[1];
    let sig = {
      methodName,
      static: true,
      args: emptyArray
    };

    if (m[2].trim()) {
      // replace escaped commas with comma entity, split on un-escaped commas
      let args = m[2].replace(/\\,/g, '&comma;').split(',');
      return parseArgs(args, sig);
    } else {
      return sig;
    }
  }

  return null;
}
/**
 * Parses an array of arguments and sets the `args` property of the supplied
 * signature metadata object. Sets the `static` property to false if any
 * argument is a non-literal.
 *
 * @param {!Array<string>} argList Array of argument names
 * @param {!MethodSignature} sig Method signature metadata object
 * @return {!MethodSignature} The updated signature metadata object
 * @private
 */


function parseArgs(argList, sig) {
  sig.args = argList.map(function (rawArg) {
    let arg = parseArg(rawArg);

    if (!arg.literal) {
      sig.static = false;
    }

    return arg;
  }, this);
  return sig;
}
/**
 * Parses an individual argument, and returns an argument metadata object
 * with the following fields:
 *
 *   {
 *     value: 'prop',        // property/path or literal value
 *     literal: false,       // whether argument is a literal
 *     structured: false,    // whether the property is a path
 *     rootProperty: 'prop', // the root property of the path
 *     wildcard: false       // whether the argument was a wildcard '.*' path
 *   }
 *
 * @param {string} rawArg The string value of the argument
 * @return {!MethodArg} Argument metadata object
 * @private
 */


function parseArg(rawArg) {
  // clean up whitespace
  let arg = rawArg.trim() // replace comma entity with comma
  .replace(/&comma;/g, ',') // repair extra escape sequences; note only commas strictly need
  // escaping, but we allow any other char to be escaped since its
  // likely users will do this
  .replace(/\\(.)/g, '\$1'); // basic argument descriptor

  let a = {
    name: arg,
    value: '',
    literal: false
  }; // detect literal value (must be String or Number)

  let fc = arg[0];

  if (fc === '-') {
    fc = arg[1];
  }

  if (fc >= '0' && fc <= '9') {
    fc = '#';
  }

  switch (fc) {
    case "'":
    case '"':
      a.value = arg.slice(1, -1);
      a.literal = true;
      break;

    case '#':
      a.value = Number(arg);
      a.literal = true;
      break;
  } // if not literal, look for structured path


  if (!a.literal) {
    a.rootProperty = root$1(arg); // detect structured path (has dots)

    a.structured = isPath(arg);

    if (a.structured) {
      a.wildcard = arg.slice(-2) == '.*';

      if (a.wildcard) {
        a.name = arg.slice(0, -2);
      }
    }
  }

  return a;
}

function getArgValue(data, props, path) {
  let value = get(data, path); // when data is not stored e.g. `splices`, get the value from changedProps
  // TODO(kschaaf): Note, this can cause a rare issue where the wildcard
  // info.value could pull a stale value out of changedProps during a reentrant
  // change that sets the value back to undefined.
  // https://github.com/Polymer/polymer/issues/5479

  if (value === undefined) {
    value = props[path];
  }

  return value;
} // data api

/**
 * Sends array splice notifications (`.splices` and `.length`)
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!Polymer_PropertyEffects} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {Array} splices Array of splice records
 * @return {void}
 * @private
 */


function notifySplices(inst, array, path, splices) {
  inst.notifyPath(path + '.splices', {
    indexSplices: splices
  });
  inst.notifyPath(path + '.length', array.length);
}
/**
 * Creates a splice record and sends an array splice notification for
 * the described mutation
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!Polymer_PropertyEffects} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {number} index Index at which the array mutation occurred
 * @param {number} addedCount Number of added items
 * @param {Array} removed Array of removed items
 * @return {void}
 * @private
 */


function notifySplice(inst, array, path, index, addedCount, removed) {
  notifySplices(inst, array, path, [{
    index: index,
    addedCount: addedCount,
    removed: removed,
    object: array,
    type: 'splice'
  }]);
}
/**
 * Returns an upper-cased version of the string.
 *
 * @param {string} name String to uppercase
 * @return {string} Uppercased string
 * @private
 */


function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}
/**
 * Element class mixin that provides meta-programming for Polymer's template
 * binding and data observation (collectively, "property effects") system.
 *
 * This mixin uses provides the following key static methods for adding
 * property effects to an element class:
 * - `addPropertyEffect`
 * - `createPropertyObserver`
 * - `createMethodObserver`
 * - `createNotifyingProperty`
 * - `createReadOnlyProperty`
 * - `createReflectedProperty`
 * - `createComputedProperty`
 * - `bindTemplate`
 *
 * Each method creates one or more property accessors, along with metadata
 * used by this mixin's implementation of `_propertiesChanged` to perform
 * the property effects.
 *
 * Underscored versions of the above methods also exist on the element
 * prototype for adding property effects on instances at runtime.
 *
 * Note that this mixin overrides several `PropertyAccessors` methods, in
 * many cases to maintain guarantees provided by the Polymer 1.x features;
 * notably it changes property accessors to be synchronous by default
 * whereas the default when using `PropertyAccessors` standalone is to be
 * async by default.
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin TemplateStamp
 * @appliesMixin PropertyAccessors
 * @summary Element class mixin that provides meta-programming for Polymer's
 * template binding and data observation system.
 */


const PropertyEffects = dedupingMixin(superClass => {
  /**
   * @constructor
   * @implements {Polymer_PropertyAccessors}
   * @implements {Polymer_TemplateStamp}
   * @unrestricted
   * @private
   */
  const propertyEffectsBase = TemplateStamp(PropertyAccessors(superClass));
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyEffects}
   * @extends {propertyEffectsBase}
   * @unrestricted
   */

  class PropertyEffects extends propertyEffectsBase {
    constructor() {
      super();
      /** @type {boolean} */
      // Used to identify users of this mixin, ala instanceof

      this.__isPropertyEffectsClient = true;
      /** @type {number} */
      // NOTE: used to track re-entrant calls to `_flushProperties`
      // path changes dirty check against `__dataTemp` only during one "turn"
      // and are cleared when `__dataCounter` returns to 0.

      this.__dataCounter = 0;
      /** @type {boolean} */

      this.__dataClientsReady;
      /** @type {Array} */

      this.__dataPendingClients;
      /** @type {Object} */

      this.__dataToNotify;
      /** @type {Object} */

      this.__dataLinkedPaths;
      /** @type {boolean} */

      this.__dataHasPaths;
      /** @type {Object} */

      this.__dataCompoundStorage;
      /** @type {Polymer_PropertyEffects} */

      this.__dataHost;
      /** @type {!Object} */

      this.__dataTemp;
      /** @type {boolean} */

      this.__dataClientsInitialized;
      /** @type {!Object} */

      this.__data;
      /** @type {!Object|null} */

      this.__dataPending;
      /** @type {!Object} */

      this.__dataOld;
      /** @type {Object} */

      this.__computeEffects;
      /** @type {Object} */

      this.__reflectEffects;
      /** @type {Object} */

      this.__notifyEffects;
      /** @type {Object} */

      this.__propagateEffects;
      /** @type {Object} */

      this.__observeEffects;
      /** @type {Object} */

      this.__readOnly;
      /** @type {!TemplateInfo} */

      this.__templateInfo;
    }

    get PROPERTY_EFFECT_TYPES() {
      return TYPES;
    }
    /**
     * @override
     * @return {void}
     */


    _initializeProperties() {
      super._initializeProperties();

      hostStack.registerHost(this);
      this.__dataClientsReady = false;
      this.__dataPendingClients = null;
      this.__dataToNotify = null;
      this.__dataLinkedPaths = null;
      this.__dataHasPaths = false; // May be set on instance prior to upgrade

      this.__dataCompoundStorage = this.__dataCompoundStorage || null;
      this.__dataHost = this.__dataHost || null;
      this.__dataTemp = {};
      this.__dataClientsInitialized = false;
    }
    /**
     * Overrides `PropertyAccessors` implementation to provide a
     * more efficient implementation of initializing properties from
     * the prototype on the instance.
     *
     * @override
     * @param {Object} props Properties to initialize on the prototype
     * @return {void}
     */


    _initializeProtoProperties(props) {
      this.__data = Object.create(props);
      this.__dataPending = Object.create(props);
      this.__dataOld = {};
    }
    /**
     * Overrides `PropertyAccessors` implementation to avoid setting
     * `_setProperty`'s `shouldNotify: true`.
     *
     * @override
     * @param {Object} props Properties to initialize on the instance
     * @return {void}
     */


    _initializeInstanceProperties(props) {
      let readOnly = this[TYPES.READ_ONLY];

      for (let prop in props) {
        if (!readOnly || !readOnly[prop]) {
          this.__dataPending = this.__dataPending || {};
          this.__dataOld = this.__dataOld || {};
          this.__data[prop] = this.__dataPending[prop] = props[prop];
        }
      }
    } // Prototype setup ----------------------------------------

    /**
     * Equivalent to static `addPropertyEffect` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     */


    _addPropertyEffect(property, type, effect) {
      this._createPropertyAccessor(property, type == TYPES.READ_ONLY); // effects are accumulated into arrays per property based on type


      let effects = ensureOwnEffectMap(this, type)[property];

      if (!effects) {
        effects = this[type][property] = [];
      }

      effects.push(effect);
    }
    /**
     * Removes the given property effect.
     *
     * @override
     * @param {string} property Property the effect was associated with
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object to remove
     * @return {void}
     */


    _removePropertyEffect(property, type, effect) {
      let effects = ensureOwnEffectMap(this, type)[property];
      let idx = effects.indexOf(effect);

      if (idx >= 0) {
        effects.splice(idx, 1);
      }
    }
    /**
     * Returns whether the current prototype/instance has a property effect
     * of a certain type.
     *
     * @override
     * @param {string} property Property name
     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */


    _hasPropertyEffect(property, type) {
      let effects = this[type];
      return Boolean(effects && effects[property]);
    }
    /**
     * Returns whether the current prototype/instance has a "read only"
     * accessor for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */


    _hasReadOnlyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.READ_ONLY);
    }
    /**
     * Returns whether the current prototype/instance has a "notify"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */


    _hasNotifyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.NOTIFY);
    }
    /**
     * Returns whether the current prototype/instance has a "reflect to
     * attribute" property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */


    _hasReflectEffect(property) {
      return this._hasPropertyEffect(property, TYPES.REFLECT);
    }
    /**
     * Returns whether the current prototype/instance has a "computed"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */


    _hasComputedEffect(property) {
      return this._hasPropertyEffect(property, TYPES.COMPUTE);
    } // Runtime ----------------------------------------

    /**
     * Sets a pending property or path.  If the root property of the path in
     * question had no accessor, the path is set, otherwise it is enqueued
     * via `_setPendingProperty`.
     *
     * This function isolates relatively expensive functionality necessary
     * for the public API (`set`, `setProperties`, `notifyPath`, and property
     * change listeners via {{...}} bindings), such that it is only done
     * when paths enter the system, and not at every propagation step.  It
     * also sets a `__dataHasPaths` flag on the instance which is used to
     * fast-path slower path-matching code in the property effects host paths.
     *
     * `path` can be a path string or array of path parts as accepted by the
     * public API.
     *
     * @override
     * @param {string | !Array<number|string>} path Path to set
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify Set to true if this change should
     *  cause a property notification event dispatch
     * @param {boolean=} isPathNotification If the path being set is a path
     *   notification of an already changed value, as opposed to a request
     *   to set and notify the change.  In the latter `false` case, a dirty
     *   check is performed and then the value is set to the path before
     *   enqueuing the pending property change.
     * @return {boolean} Returns true if the property/path was enqueued in
     *   the pending changes bag.
     * @protected
     */


    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
      if (isPathNotification || root$1(Array.isArray(path) ? path[0] : path) !== path) {
        // Dirty check changes being set to a path against the actual object,
        // since this is the entry point for paths into the system; from here
        // the only dirty checks are against the `__dataTemp` cache to prevent
        // duplicate work in the same turn only. Note, if this was a notification
        // of a change already set to a path (isPathNotification: true),
        // we always let the change through and skip the `set` since it was
        // already dirty checked at the point of entry and the underlying
        // object has already been updated
        if (!isPathNotification) {
          let old = get(this, path);
          path =
          /** @type {string} */
          set(this, path, value); // Use property-accessor's simpler dirty check

          if (!path || !super._shouldPropertyChange(path, value, old)) {
            return false;
          }
        }

        this.__dataHasPaths = true;

        if (this._setPendingProperty(
        /**@type{string}*/
        path, value, shouldNotify)) {
          computeLinkedPaths(this,
          /**@type{string}*/
          path, value);
          return true;
        }
      } else {
        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
          return this._setPendingProperty(
          /**@type{string}*/
          path, value, shouldNotify);
        } else {
          this[path] = value;
        }
      }

      return false;
    }
    /**
     * Applies a value to a non-Polymer element/node's property.
     *
     * The implementation makes a best-effort at binding interop:
     * Some native element properties have side-effects when
     * re-setting the same value (e.g. setting `<input>.value` resets the
     * cursor position), so we do a dirty-check before setting the value.
     * However, for better interop with non-Polymer custom elements that
     * accept objects, we explicitly re-set object changes coming from the
     * Polymer world (which may include deep object changes without the
     * top reference changing), erring on the side of providing more
     * information.
     *
     * Users may override this method to provide alternate approaches.
     *
     * @override
     * @param {!Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @return {void}
     * @protected
     */


    _setUnmanagedPropertyToNode(node, prop, value) {
      // It is a judgment call that resetting primitives is
      // "bad" and resettings objects is also "good"; alternatively we could
      // implement a whitelist of tag & property values that should never
      // be reset (e.g. <input>.value && <select>.value)
      if (value !== node[prop] || typeof value == 'object') {
        node[prop] = value;
      }
    }
    /**
     * Overrides the `PropertiesChanged` implementation to introduce special
     * dirty check logic depending on the property & value being set:
     *
     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
     * 2. Object set to simple property (e.g. 'prop': {...})
     *    Stored in `__dataTemp` and `__data`, dirty checked against
     *    `__dataTemp` by default implementation of `_shouldPropertyChange`
     * 3. Primitive value set to simple property (e.g. 'prop': 42)
     *    Stored in `__data`, dirty checked against `__data`
     *
     * The dirty-check is important to prevent cycles due to two-way
     * notification, but paths and objects are only dirty checked against any
     * previous value set during this turn via a "temporary cache" that is
     * cleared when the last `_propertiesChanged` exits. This is so:
     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
     *    due to array mutations like shift/unshift/splice; this is fine
     *    since path changes are dirty-checked at user entry points like `set`
     * b. dirty-checking for objects only lasts one turn to allow the user
     *    to mutate the object in-place and re-set it with the same identity
     *    and have all sub-properties re-propagated in a subsequent turn.
     *
     * The temp cache is not necessarily sufficient to prevent invalid array
     * paths, since a splice can happen during the same turn (with pathological
     * user code); we could introduce a "fixup" for temporarily cached array
     * paths if needed: https://github.com/Polymer/polymer/issues/4227
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify True if property should fire notification
     *   event (applies only for `notify: true` properties)
     * @return {boolean} Returns true if the property changed
     */


    _setPendingProperty(property, value, shouldNotify) {
      let propIsPath = this.__dataHasPaths && isPath(property);
      let prevProps = propIsPath ? this.__dataTemp : this.__data;

      if (this._shouldPropertyChange(property, value, prevProps[property])) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        } // Ensure old is captured from the last turn


        if (!(property in this.__dataOld)) {
          this.__dataOld[property] = this.__data[property];
        } // Paths are stored in temporary cache (cleared at end of turn),
        // which is used for dirty-checking, all others stored in __data


        if (propIsPath) {
          this.__dataTemp[property] = value;
        } else {
          this.__data[property] = value;
        } // All changes go into pending property bag, passed to _propertiesChanged


        this.__dataPending[property] = value; // Track properties that should notify separately

        if (propIsPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
          this.__dataToNotify = this.__dataToNotify || {};
          this.__dataToNotify[property] = shouldNotify;
        }

        return true;
      }

      return false;
    }
    /**
     * Overrides base implementation to ensure all accessors set `shouldNotify`
     * to true, for per-property notification tracking.
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     */


    _setProperty(property, value) {
      if (this._setPendingProperty(property, value, true)) {
        this._invalidateProperties();
      }
    }
    /**
     * Overrides `PropertyAccessor`'s default async queuing of
     * `_propertiesChanged`: if `__dataReady` is false (has not yet been
     * manually flushed), the function no-ops; otherwise flushes
     * `_propertiesChanged` synchronously.
     *
     * @override
     * @return {void}
     */


    _invalidateProperties() {
      if (this.__dataReady) {
        this._flushProperties();
      }
    }
    /**
     * Enqueues the given client on a list of pending clients, whose
     * pending property changes can later be flushed via a call to
     * `_flushClients`.
     *
     * @override
     * @param {Object} client PropertyEffects client to enqueue
     * @return {void}
     * @protected
     */


    _enqueueClient(client) {
      this.__dataPendingClients = this.__dataPendingClients || [];

      if (client !== this) {
        this.__dataPendingClients.push(client);
      }
    }
    /**
     * Overrides superclass implementation.
     *
     * @override
     * @return {void}
     * @protected
     */


    _flushProperties() {
      this.__dataCounter++;

      super._flushProperties();

      this.__dataCounter--;
    }
    /**
     * Flushes any clients previously enqueued via `_enqueueClient`, causing
     * their `_flushProperties` method to run.
     *
     * @override
     * @return {void}
     * @protected
     */


    _flushClients() {
      if (!this.__dataClientsReady) {
        this.__dataClientsReady = true;

        this._readyClients(); // Override point where accessors are turned on; importantly,
        // this is after clients have fully readied, providing a guarantee
        // that any property effects occur only after all clients are ready.


        this.__dataReady = true;
      } else {
        this.__enableOrFlushClients();
      }
    } // NOTE: We ensure clients either enable or flush as appropriate. This
    // handles two corner cases:
    // (1) clients flush properly when connected/enabled before the host
    // enables; e.g.
    //   (a) Templatize stamps with no properties and does not flush and
    //   (b) the instance is inserted into dom and
    //   (c) then the instance flushes.
    // (2) clients enable properly when not connected/enabled when the host
    // flushes; e.g.
    //   (a) a template is runtime stamped and not yet connected/enabled
    //   (b) a host sets a property, causing stamped dom to flush
    //   (c) the stamped dom enables.


    __enableOrFlushClients() {
      let clients = this.__dataPendingClients;

      if (clients) {
        this.__dataPendingClients = null;

        for (let i = 0; i < clients.length; i++) {
          let client = clients[i];

          if (!client.__dataEnabled) {
            client._enableProperties();
          } else if (client.__dataPending) {
            client._flushProperties();
          }
        }
      }
    }
    /**
     * Perform any initial setup on client dom. Called before the first
     * `_flushProperties` call on client dom and before any element
     * observers are called.
     *
     * @override
     * @return {void}
     * @protected
     */


    _readyClients() {
      this.__enableOrFlushClients();
    }
    /**
     * Sets a bag of property changes to this instance, and
     * synchronously processes all effects of the properties as a batch.
     *
     * Property names must be simple properties, not paths.  Batched
     * path propagation is not supported.
     *
     * @override
     * @param {Object} props Bag of one or more key-value pairs whose key is
     *   a property and value is the new value to set for that property.
     * @param {boolean=} setReadOnly When true, any private values set in
     *   `props` will be set. By default, `setProperties` will not set
     *   `readOnly: true` root properties.
     * @return {void}
     * @public
     */


    setProperties(props, setReadOnly) {
      for (let path in props) {
        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
          //TODO(kschaaf): explicitly disallow paths in setProperty?
          // wildcard observers currently only pass the first changed path
          // in the `info` object, and you could do some odd things batching
          // paths, e.g. {'foo.bar': {...}, 'foo': null}
          this._setPendingPropertyOrPath(path, props[path], true);
        }
      }

      this._invalidateProperties();
    }
    /**
     * Overrides `PropertyAccessors` so that property accessor
     * side effects are not enabled until after client dom is fully ready.
     * Also calls `_flushClients` callback to ensure client dom is enabled
     * that was not enabled as a result of flushing properties.
     *
     * @override
     * @return {void}
     */


    ready() {
      // It is important that `super.ready()` is not called here as it
      // immediately turns on accessors. Instead, we wait until `readyClients`
      // to enable accessors to provide a guarantee that clients are ready
      // before processing any accessors side effects.
      this._flushProperties(); // If no data was pending, `_flushProperties` will not `flushClients`
      // so ensure this is done.


      if (!this.__dataClientsReady) {
        this._flushClients();
      } // Before ready, client notifications do not trigger _flushProperties.
      // Therefore a flush is necessary here if data has been set.


      if (this.__dataPending) {
        this._flushProperties();
      }
    }
    /**
     * Implements `PropertyAccessors`'s properties changed callback.
     *
     * Runs each class of effects for the batch of changed properties in
     * a specific order (compute, propagate, reflect, observe, notify).
     *
     * @override
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     */


    _propertiesChanged(currentProps, changedProps, oldProps) {
      // ----------------------------
      // let c = Object.getOwnPropertyNames(changedProps || {});
      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
      // if (window.debug) { debugger; }
      // ----------------------------
      let hasPaths = this.__dataHasPaths;
      this.__dataHasPaths = false; // Compute properties

      runComputedEffects(this, changedProps, oldProps, hasPaths); // Clear notify properties prior to possible reentry (propagate, observe),
      // but after computing effects have a chance to add to them

      let notifyProps = this.__dataToNotify;
      this.__dataToNotify = null; // Propagate properties to clients

      this._propagatePropertyChanges(changedProps, oldProps, hasPaths); // Flush clients


      this._flushClients(); // Reflect properties


      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths); // Observe properties

      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths); // Notify properties to host

      if (notifyProps) {
        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
      } // Clear temporary cache at end of turn


      if (this.__dataCounter == 1) {
        this.__dataTemp = {};
      } // ----------------------------
      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
      // ----------------------------

    }
    /**
     * Called to propagate any property changes to stamped template nodes
     * managed by this element.
     *
     * @override
     * @param {Object} changedProps Bag of changed properties
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {void}
     * @protected
     */


    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
      if (this[TYPES.PROPAGATE]) {
        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
      }

      let templateInfo = this.__templateInfo;

      while (templateInfo) {
        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);
        templateInfo = templateInfo.nextTemplateInfo;
      }
    }
    /**
     * Aliases one data path as another, such that path notifications from one
     * are routed to the other.
     *
     * @override
     * @param {string | !Array<string|number>} to Target path to link.
     * @param {string | !Array<string|number>} from Source path to link.
     * @return {void}
     * @public
     */


    linkPaths(to, from) {
      to = normalize(to);
      from = normalize(from);
      this.__dataLinkedPaths = this.__dataLinkedPaths || {};
      this.__dataLinkedPaths[to] = from;
    }
    /**
     * Removes a data path alias previously established with `_linkPaths`.
     *
     * Note, the path to unlink should be the target (`to`) used when
     * linking the paths.
     *
     * @override
     * @param {string | !Array<string|number>} path Target path to unlink.
     * @return {void}
     * @public
     */


    unlinkPaths(path) {
      path = normalize(path);

      if (this.__dataLinkedPaths) {
        delete this.__dataLinkedPaths[path];
      }
    }
    /**
     * Notify that an array has changed.
     *
     * Example:
     *
     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
     *     ...
     *     this.items.splice(1, 1, {name: 'Sam'});
     *     this.items.push({name: 'Bob'});
     *     this.notifySplices('items', [
     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,
     *         object: this.items, type: 'splice' },
     *       { index: 3, removed: [], addedCount: 1,
     *         object: this.items, type: 'splice'}
     *     ]);
     *
     * @param {string} path Path that should be notified.
     * @param {Array} splices Array of splice records indicating ordered
     *   changes that occurred to the array. Each record should have the
     *   following fields:
     *    * index: index at which the change occurred
     *    * removed: array of items that were removed from this index
     *    * addedCount: number of new items added at this index
     *    * object: a reference to the array in question
     *    * type: the string literal 'splice'
     *
     *   Note that splice records _must_ be normalized such that they are
     *   reported in index order (raw results from `Object.observe` are not
     *   ordered and must be normalized/merged before notifying).
     *
     * @override
     * @return {void}
     * @public
     */


    notifySplices(path, splices) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      get(this, path, info);
      notifySplices(this, array, info.path, splices);
    }
    /**
     * Convenience method for reading a value from a path.
     *
     * Note, if any part in the path is undefined, this method returns
     * `undefined` (this method does not throw when dereferencing undefined
     * paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `users.12.name` or `['users', 12, 'name']`).
     * @param {Object=} root Root object from which the path is evaluated.
     * @return {*} Value at the path, or `undefined` if any part of the path
     *   is undefined.
     * @public
     */


    get(path, root) {
      return get(root || this, path);
    }
    /**
     * Convenience method for setting a value to a path and notifying any
     * elements bound to the same path.
     *
     * Note, if any part in the path except for the last is undefined,
     * this method does nothing (this method does not throw when
     * dereferencing undefined paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
     * @param {*} value Value to set at the specified path.
     * @param {Object=} root Root object from which the path is evaluated.
     *   When specified, no notification will occur.
     * @return {void}
     * @public
     */


    set(path, value, root) {
      if (root) {
        set(root, path, value);
      } else {
        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][
        /** @type {string} */
        path]) {
          if (this._setPendingPropertyOrPath(path, value, true)) {
            this._invalidateProperties();
          }
        }
      }
    }
    /**
     * Adds items onto the end of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to push onto array
     * @return {number} New length of the array.
     * @public
     */


    push(path, ...items) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array}*/
      get(this, path, info);
      let len = array.length;
      let ret = array.push(...items);

      if (items.length) {
        notifySplice(this, array, info.path, len, items.length, []);
      }

      return ret;
    }
    /**
     * Removes an item from the end of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */


    pop(path) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      get(this, path, info);
      let hadLength = Boolean(array.length);
      let ret = array.pop();

      if (hadLength) {
        notifySplice(this, array, info.path, array.length, 0, [ret]);
      }

      return ret;
    }
    /**
     * Starting from the start index specified, removes 0 or more items
     * from the array and inserts 0 or more new items in their place.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.splice`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {number} start Index from which to start removing/inserting.
     * @param {number=} deleteCount Number of items to remove.
     * @param {...*} items Items to insert into array.
     * @return {Array} Array of removed items.
     * @public
     */


    splice(path, start, deleteCount, ...items) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      get(this, path, info); // Normalize fancy native splice handling of crazy start values

      if (start < 0) {
        start = array.length - Math.floor(-start);
      } else if (start) {
        start = Math.floor(start);
      } // array.splice does different things based on the number of arguments
      // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)
      // do different things. In the former, the whole array is cleared. In the
      // latter, no items are removed.
      // This means that we need to detect whether 1. one of the arguments
      // is actually passed in and then 2. determine how many arguments
      // we should pass on to the native array.splice
      //


      let ret; // Omit any additional arguments if they were not passed in

      if (arguments.length === 2) {
        ret = array.splice(start); // Either start was undefined and the others were defined, but in this
        // case we can safely pass on all arguments
        //
        // Note: this includes the case where none of the arguments were passed in,
        // e.g. this.splice('array'). However, if both start and deleteCount
        // are undefined, array.splice will not modify the array (as expected)
      } else {
        ret = array.splice(start, deleteCount, ...items);
      } // At the end, check whether any items were passed in (e.g. insertions)
      // or if the return array contains items (e.g. deletions).
      // Only notify if items were added or deleted.


      if (items.length || ret.length) {
        notifySplice(this, array, info.path, start, items.length, ret);
      }

      return ret;
    }
    /**
     * Removes an item from the beginning of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */


    shift(path) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      get(this, path, info);
      let hadLength = Boolean(array.length);
      let ret = array.shift();

      if (hadLength) {
        notifySplice(this, array, info.path, 0, 0, [ret]);
      }

      return ret;
    }
    /**
     * Adds items onto the beginning of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to insert info array
     * @return {number} New length of the array.
     * @public
     */


    unshift(path, ...items) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      get(this, path, info);
      let ret = array.unshift(...items);

      if (items.length) {
        notifySplice(this, array, info.path, 0, items.length, []);
      }

      return ret;
    }
    /**
     * Notify that a path has changed.
     *
     * Example:
     *
     *     this.item.user.name = 'Bob';
     *     this.notifyPath('item.user.name');
     *
     * @override
     * @param {string} path Path that should be notified.
     * @param {*=} value Value at the path (optional).
     * @return {void}
     * @public
     */


    notifyPath(path, value) {
      /** @type {string} */
      let propPath;

      if (arguments.length == 1) {
        // Get value if not supplied
        let info = {
          path: ''
        };
        value = get(this, path, info);
        propPath = info.path;
      } else if (Array.isArray(path)) {
        // Normalize path if needed
        propPath = normalize(path);
      } else {
        propPath =
        /** @type{string} */
        path;
      }

      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
        this._invalidateProperties();
      }
    }
    /**
     * Equivalent to static `createReadOnlyProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     */


    _createReadOnlyProperty(property, protectedSetter) {
      this._addPropertyEffect(property, TYPES.READ_ONLY);

      if (protectedSetter) {
        this['_set' + upper(property)] =
        /** @this {PropertyEffects} */
        function (value) {
          this._setProperty(property, value);
        };
      }
    }
    /**
     * Equivalent to static `createPropertyObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method
     *     to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     */


    _createPropertyObserver(property, method, dynamicFn) {
      let info = {
        property,
        method,
        dynamicFn: Boolean(dynamicFn)
      };

      this._addPropertyEffect(property, TYPES.OBSERVE, {
        fn: runObserverEffect,
        info,
        trigger: {
          name: property
        }
      });

      if (dynamicFn) {
        this._addPropertyEffect(
        /** @type {string} */
        method, TYPES.OBSERVE, {
          fn: runObserverEffect,
          info,
          trigger: {
            name: method
          }
        });
      }
    }
    /**
     * Equivalent to static `createMethodObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */


    _createMethodObserver(expression, dynamicFn) {
      let sig = parseMethod(expression);

      if (!sig) {
        throw new Error("Malformed observer expression '" + expression + "'");
      }

      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
    }
    /**
     * Equivalent to static `createNotifyingProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     */


    _createNotifyingProperty(property) {
      this._addPropertyEffect(property, TYPES.NOTIFY, {
        fn: runNotifyEffect,
        info: {
          eventName: camelToDashCase(property) + '-changed',
          property: property
        }
      });
    }
    /**
     * Equivalent to static `createReflectedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */


    _createReflectedProperty(property) {
      let attr = this.constructor.attributeNameForProperty(property);

      if (attr[0] === '-') {
        console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');
      } else {
        this._addPropertyEffect(property, TYPES.REFLECT, {
          fn: runReflectEffect,
          info: {
            attrName: attr
          }
        });
      }
    }
    /**
     * Equivalent to static `createComputedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */


    _createComputedProperty(property, expression, dynamicFn) {
      let sig = parseMethod(expression);

      if (!sig) {
        throw new Error("Malformed computed expression '" + expression + "'");
      }

      createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
    }
    /**
     * Gather the argument values for a method specified in the provided array
     * of argument metadata.
     *
     * The `path` and `value` arguments are used to fill in wildcard descriptor
     * when the method is being called as a result of a path notification.
     *
     * @param {!Array<!MethodArg>} args Array of argument metadata
     * @param {string} path Property/path name that triggered the method effect
     * @param {Object} props Bag of current property changes
     * @return {Array<*>} Array of argument values
     * @private
     */


    _marshalArgs(args, path, props) {
      const data = this.__data;
      const values = [];

      for (let i = 0, l = args.length; i < l; i++) {
        let {
          name,
          structured,
          wildcard,
          value,
          literal
        } = args[i];

        if (!literal) {
          if (wildcard) {
            const matches = isDescendant(name, path);
            const pathValue = getArgValue(data, props, matches ? path : name);
            value = {
              path: matches ? path : name,
              value: pathValue,
              base: matches ? get(data, name) : pathValue
            };
          } else {
            value = structured ? getArgValue(data, props, name) : data[name];
          }
        }

        values[i] = value;
      }

      return values;
    } // -- static class methods ------------

    /**
     * Ensures an accessor exists for the specified property, and adds
     * to a list of "property effects" that will run when the accessor for
     * the specified property is set.  Effects are grouped by "type", which
     * roughly corresponds to a phase in effect processing.  The effect
     * metadata should be in the following form:
     *
     *     {
     *       fn: effectFunction, // Reference to function to call to perform effect
     *       info: { ... }       // Effect metadata passed to function
     *       trigger: {          // Optional triggering metadata; if not provided
     *         name: string      // the property is treated as a wildcard
     *         structured: boolean
     *         wildcard: boolean
     *       }
     *     }
     *
     * Effects are called from `_propertiesChanged` in the following order by
     * type:
     *
     * 1. COMPUTE
     * 2. PROPAGATE
     * 3. REFLECT
     * 4. OBSERVE
     * 5. NOTIFY
     *
     * Effect functions are called with the following signature:
     *
     *     effectFunction(inst, path, props, oldProps, info, hasPaths)
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     */


    static addPropertyEffect(property, type, effect) {
      this.prototype._addPropertyEffect(property, type, effect);
    }
    /**
     * Creates a single-property observer for the given property.
     *
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     */


    static createPropertyObserver(property, method, dynamicFn) {
      this.prototype._createPropertyObserver(property, method, dynamicFn);
    }
    /**
     * Creates a multi-property "method observer" based on the provided
     * expression, which should be a string in the form of a normal JavaScript
     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
     * should correspond to a property or path in the context of this
     * prototype (or instance), or may be a literal string or number.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     * @return {void}
     *   whether method names should be included as a dependency to the effect.
     * @protected
     */


    static createMethodObserver(expression, dynamicFn) {
      this.prototype._createMethodObserver(expression, dynamicFn);
    }
    /**
     * Causes the setter for the given property to dispatch `<property>-changed`
     * events to notify of changes to the property.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     */


    static createNotifyingProperty(property) {
      this.prototype._createNotifyingProperty(property);
    }
    /**
     * Creates a read-only accessor for the given property.
     *
     * To set the property, use the protected `_setProperty` API.
     * To create a custom protected setter (e.g. `_setMyProp()` for
     * property `myProp`), pass `true` for `protectedSetter`.
     *
     * Note, if the property will have other property effects, this method
     * should be called first, before adding other effects.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     */


    static createReadOnlyProperty(property, protectedSetter) {
      this.prototype._createReadOnlyProperty(property, protectedSetter);
    }
    /**
     * Causes the setter for the given property to reflect the property value
     * to a (dash-cased) attribute of the same name.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     */


    static createReflectedProperty(property) {
      this.prototype._createReflectedProperty(property);
    }
    /**
     * Creates a computed property whose value is set to the result of the
     * method described by the given `expression` each time one or more
     * arguments to the method changes.  The expression should be a string
     * in the form of a normal JavaScript function signature:
     * `'methodName(arg1, [..., argn])'`
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
     *   method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */


    static createComputedProperty(property, expression, dynamicFn) {
      this.prototype._createComputedProperty(property, expression, dynamicFn);
    }
    /**
     * Parses the provided template to ensure binding effects are created
     * for them, and then ensures property accessors are created for any
     * dependent properties in the template.  Binding effects for bound
     * templates are stored in a linked list on the instance so that
     * templates can be efficiently stamped and unstamped.
     *
     * @param {!HTMLTemplateElement} template Template containing binding
     *   bindings
     * @return {!TemplateInfo} Template metadata object
     * @protected
     */


    static bindTemplate(template) {
      return this.prototype._bindTemplate(template);
    } // -- binding ----------------------------------------------

    /**
     * Equivalent to static `bindTemplate` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * This method may be called on the prototype (for prototypical template
     * binding, to avoid creating accessors every instance) once per prototype,
     * and will be called with `runtimeBinding: true` by `_stampTemplate` to
     * create and link an instance of the template metadata associated with a
     * particular stamping.
     *
     * @override
     * @param {!HTMLTemplateElement} template Template containing binding
     *   bindings
     * @param {boolean=} instanceBinding When false (default), performs
     *   "prototypical" binding of the template and overwrites any previously
     *   bound template for the class. When true (as passed from
     *   `_stampTemplate`), the template info is instanced and linked into
     *   the list of bound templates.
     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
     *   this is an instance of the prototypical template info
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */


    _bindTemplate(template, instanceBinding) {
      let templateInfo = this.constructor._parseTemplate(template);

      let wasPreBound = this.__templateInfo == templateInfo; // Optimization: since this is called twice for proto-bound templates,
      // don't attempt to recreate accessors if this template was pre-bound

      if (!wasPreBound) {
        for (let prop in templateInfo.propertyEffects) {
          this._createPropertyAccessor(prop);
        }
      }

      if (instanceBinding) {
        // For instance-time binding, create instance of template metadata
        // and link into list of templates if necessary
        templateInfo =
        /** @type {!TemplateInfo} */
        Object.create(templateInfo);
        templateInfo.wasPreBound = wasPreBound;

        if (!wasPreBound && this.__templateInfo) {
          let last = this.__templateInfoLast || this.__templateInfo;
          this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
          templateInfo.previousTemplateInfo = last;
          return templateInfo;
        }
      }

      return this.__templateInfo = templateInfo;
    }
    /**
     * Adds a property effect to the given template metadata, which is run
     * at the "propagate" stage of `_propertiesChanged` when the template
     * has been bound to the element via `_bindTemplate`.
     *
     * The `effect` object should match the format in `_addPropertyEffect`.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     */


    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
      hostProps[prop] = true;
      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
      let propEffects = effects[prop] = effects[prop] || [];
      propEffects.push(effect);
    }
    /**
     * Stamps the provided template and performs instance-time setup for
     * Polymer template features, including data bindings, declarative event
     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
     * is returned containing the stamped DOM, ready for insertion into the
     * DOM.
     *
     * This method may be called more than once; however note that due to
     * `shadycss` polyfill limitations, only styles from templates prepared
     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
     * to the shadow root and support CSS custom properties), and note that
     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
     * any styles required by in runtime-stamped templates must be included
     * in the main element template.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @return {!StampedTemplate} Cloned template content
     * @override
     * @protected
     */


    _stampTemplate(template) {
      // Ensures that created dom is `_enqueueClient`'d to this element so
      // that it can be flushed on next call to `_flushProperties`
      hostStack.beginHosting(this);

      let dom = super._stampTemplate(template);

      hostStack.endHosting(this);

      let templateInfo =
      /** @type {!TemplateInfo} */
      this._bindTemplate(template, true); // Add template-instance-specific data to instanced templateInfo


      templateInfo.nodeList = dom.nodeList; // Capture child nodes to allow unstamping of non-prototypical templates

      if (!templateInfo.wasPreBound) {
        let nodes = templateInfo.childNodes = [];

        for (let n = dom.firstChild; n; n = n.nextSibling) {
          nodes.push(n);
        }
      }

      dom.templateInfo = templateInfo; // Setup compound storage, 2-way listeners, and dataHost for bindings

      setupBindings(this, templateInfo); // Flush properties into template nodes if already booted

      if (this.__dataReady) {
        runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);
      }

      return dom;
    }
    /**
     * Removes and unbinds the nodes previously contained in the provided
     * DocumentFragment returned from `_stampTemplate`.
     *
     * @override
     * @param {!StampedTemplate} dom DocumentFragment previously returned
     *   from `_stampTemplate` associated with the nodes to be removed
     * @return {void}
     * @protected
     */


    _removeBoundDom(dom) {
      // Unlink template info
      let templateInfo = dom.templateInfo;

      if (templateInfo.previousTemplateInfo) {
        templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;
      }

      if (templateInfo.nextTemplateInfo) {
        templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;
      }

      if (this.__templateInfoLast == templateInfo) {
        this.__templateInfoLast = templateInfo.previousTemplateInfo;
      }

      templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null; // Remove stamped nodes

      let nodes = templateInfo.childNodes;

      for (let i = 0; i < nodes.length; i++) {
        let node = nodes[i];
        node.parentNode.removeChild(node);
      }
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */


    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted = super._parseTemplateNode(node, templateInfo, nodeInfo);

      if (node.nodeType === Node.TEXT_NODE) {
        let parts = this._parseBindings(node.textContent, templateInfo);

        if (parts) {
          // Initialize the textContent with any literal parts
          // NOTE: default to a space here so the textNode remains; some browsers
          // (IE) omit an empty textNode following cloneNode/importNode.
          node.textContent = literalFromParts(parts) || ' ';
          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
          noted = true;
        }
      }

      return noted;
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from attributes.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */


    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      let parts = this._parseBindings(value, templateInfo);

      if (parts) {
        // Attribute or property
        let origName = name;
        let kind = 'property'; // The only way we see a capital letter here is if the attr has
        // a capital letter in it per spec. In this case, to make sure
        // this binding works, we go ahead and make the binding to the attribute.

        if (capitalAttributeRegex.test(name)) {
          kind = 'attribute';
        } else if (name[name.length - 1] == '$') {
          name = name.slice(0, -1);
          kind = 'attribute';
        } // Initialize attribute bindings with any literal parts


        let literal = literalFromParts(parts);

        if (literal && kind == 'attribute') {
          // Ensure a ShadyCSS template scoped style is not removed
          // when a class$ binding's initial literal value is set.
          if (name == 'class' && node.hasAttribute('class')) {
            literal += ' ' + node.getAttribute(name);
          }

          node.setAttribute(name, literal);
        } // Clear attribute before removing, since IE won't allow removing
        // `value` attribute if it previously had a value (can't
        // unconditionally set '' before removing since attributes with `$`
        // can't be set using setAttribute)


        if (node.localName === 'input' && origName === 'value') {
          node.setAttribute(origName, '');
        } // Remove annotation


        node.removeAttribute(origName); // Case hackery: attributes are lower-case, but bind targets
        // (properties) are case sensitive. Gambit is to map dash-case to
        // camel-case: `foo-bar` becomes `fooBar`.
        // Attribute bindings are excepted.

        if (kind === 'property') {
          name = dashToCamelCase(name);
        }

        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
        return true;
      } else {
        return super._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value);
      }
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * binding the properties that a nested template depends on to the template
     * as `_host_<property>`.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */


    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
      let noted = super._parseTemplateNestedTemplate(node, templateInfo, nodeInfo); // Merge host props into outer template and add bindings


      let hostProps = nodeInfo.templateInfo.hostProps;
      let mode = '{';

      for (let source in hostProps) {
        let parts = [{
          mode,
          source,
          dependencies: [source]
        }];
        addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
      }

      return noted;
    }
    /**
     * Called to parse text in a template (either attribute values or
     * textContent) into binding metadata.
     *
     * Any overrides of this method should return an array of binding part
     * metadata  representing one or more bindings found in the provided text
     * and any "literal" text in between.  Any non-literal parts will be passed
     * to `_evaluateBinding` when any dependencies change.  The only required
     * fields of each "part" in the returned array are as follows:
     *
     * - `dependencies` - Array containing trigger metadata for each property
     *   that should trigger the binding to update
     * - `literal` - String containing text if the part represents a literal;
     *   in this case no `dependencies` are needed
     *
     * Additional metadata for use by `_evaluateBinding` may be provided in
     * each part object as needed.
     *
     * The default implementation handles the following types of bindings
     * (one or more may be intermixed with literal strings):
     * - Property binding: `[[prop]]`
     * - Path binding: `[[object.prop]]`
     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
     * - Two-way property or path bindings (supports negation):
     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
     * - Inline computed method (supports negation):
     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
     *
     * The default implementation uses a regular expression for best
     * performance. However, the regular expression uses a white-list of
     * allowed characters in a data-binding, which causes problems for
     * data-bindings that do use characters not in this white-list.
     *
     * Instead of updating the white-list with all allowed characters,
     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)
     * that uses a state machine instead. This state machine is able to handle
     * all characters. However, it is slightly less performant, therefore we
     * extracted it into a separate optional mixin.
     *
     * @param {string} text Text to parse from attribute or textContent
     * @param {Object} templateInfo Current template metadata
     * @return {Array<!BindingPart>} Array of binding part metadata
     * @protected
     */


    static _parseBindings(text, templateInfo) {
      let parts = [];
      let lastIndex = 0;
      let m; // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
      // Regex matches:
      //        Iteration 1:  Iteration 2:
      // m[1]: '{{'          '[['
      // m[2]: ''            '!'
      // m[3]: 'prop'        'compute(foo,bar)'

      while ((m = bindingRegex.exec(text)) !== null) {
        // Add literal part
        if (m.index > lastIndex) {
          parts.push({
            literal: text.slice(lastIndex, m.index)
          });
        } // Add binding part


        let mode = m[1][0];
        let negate = Boolean(m[2]);
        let source = m[3].trim();
        let customEvent = false,
            notifyEvent = '',
            colon = -1;

        if (mode == '{' && (colon = source.indexOf('::')) > 0) {
          notifyEvent = source.substring(colon + 2);
          source = source.substring(0, colon);
          customEvent = true;
        }

        let signature = parseMethod(source);
        let dependencies = [];

        if (signature) {
          // Inline computed function
          let {
            args,
            methodName
          } = signature;

          for (let i = 0; i < args.length; i++) {
            let arg = args[i];

            if (!arg.literal) {
              dependencies.push(arg);
            }
          }

          let dynamicFns = templateInfo.dynamicFns;

          if (dynamicFns && dynamicFns[methodName] || signature.static) {
            dependencies.push(methodName);
            signature.dynamicFn = true;
          }
        } else {
          // Property or path
          dependencies.push(source);
        }

        parts.push({
          source,
          mode,
          negate,
          customEvent,
          signature,
          dependencies,
          event: notifyEvent
        });
        lastIndex = bindingRegex.lastIndex;
      } // Add a final literal part


      if (lastIndex && lastIndex < text.length) {
        let literal = text.substring(lastIndex);

        if (literal) {
          parts.push({
            literal: literal
          });
        }
      }

      if (parts.length) {
        return parts;
      } else {
        return null;
      }
    }
    /**
     * Called to evaluate a previously parsed binding part based on a set of
     * one or more changed dependencies.
     *
     * @param {!Polymer_PropertyEffects} inst Element that should be used as
     *     scope for binding dependencies
     * @param {BindingPart} part Binding part metadata
     * @param {string} path Property/path that triggered this effect
     * @param {Object} props Bag of current property changes
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {*} Value the binding part evaluated to
     * @protected
     */


    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
      let value;

      if (part.signature) {
        value = runMethodEffect(inst, path, props, oldProps, part.signature);
      } else if (path != part.source) {
        value = get(inst, part.source);
      } else {
        if (hasPaths && isPath(path)) {
          value = get(inst, path);
        } else {
          value = inst.__data[path];
        }
      }

      if (part.negate) {
        value = !value;
      }

      return value;
    }

  }

  return PropertyEffects;
});
/**
 * Helper api for enqueuing client dom created by a host element.
 *
 * By default elements are flushed via `_flushProperties` when
 * `connectedCallback` is called. Elements attach their client dom to
 * themselves at `ready` time which results from this first flush.
 * This provides an ordering guarantee that the client dom an element
 * creates is flushed before the element itself (i.e. client `ready`
 * fires before host `ready`).
 *
 * However, if `_flushProperties` is called *before* an element is connected,
 * as for example `Templatize` does, this ordering guarantee cannot be
 * satisfied because no elements are connected. (Note: Bound elements that
 * receive data do become enqueued clients and are properly ordered but
 * unbound elements are not.)
 *
 * To maintain the desired "client before host" ordering guarantee for this
 * case we rely on the "host stack. Client nodes registers themselves with
 * the creating host element when created. This ensures that all client dom
 * is readied in the proper order, maintaining the desired guarantee.
 *
 * @private
 */

class HostStack {
  constructor() {
    this.stack = [];
  }
  /**
   * @param {*} inst Instance to add to hostStack
   * @return {void}
   */


  registerHost(inst) {
    if (this.stack.length) {
      let host = this.stack[this.stack.length - 1];

      host._enqueueClient(inst);
    }
  }
  /**
   * @param {*} inst Instance to begin hosting
   * @return {void}
   */


  beginHosting(inst) {
    this.stack.push(inst);
  }
  /**
   * @param {*} inst Instance to end hosting
   * @return {void}
   */


  endHosting(inst) {
    let stackLen = this.stack.length;

    if (stackLen && this.stack[stackLen - 1] == inst) {
      this.stack.pop();
    }
  }

}

const hostStack = new HostStack();

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Registers a class prototype for telemetry purposes.
 * @param {!PolymerElementConstructor} prototype Element prototype to register
 * @protected
 */


function register(prototype) {
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Creates a copy of `props` with each property normalized such that
 * upgraded it is an object with at least a type property { type: Type}.
 *
 * @param {Object} props Properties to normalize
 * @return {Object} Copy of input `props` with normalized properties that
 * are in the form {type: Type}
 * @private
 */

function normalizeProperties(props) {
  const output = {};

  for (let p in props) {
    const o = props[p];
    output[p] = typeof o === 'function' ? {
      type: o
    } : o;
  }

  return output;
}
/**
 * Mixin that provides a minimal starting point to using the PropertiesChanged
 * mixin by providing a mechanism to declare properties in a static
 * getter (e.g. static get properties() { return { foo: String } }). Changes
 * are reported via the `_propertiesChanged` method.
 *
 * This mixin provides no specific support for rendering. Users are expected
 * to create a ShadowRoot and put content into it and update it in whatever
 * way makes sense. This can be done in reaction to properties changing by
 * implementing `_propertiesChanged`.
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin PropertiesChanged
 * @summary Mixin that provides a minimal starting point for using
 * the PropertiesChanged mixin by providing a declarative `properties` object.
 */


const PropertiesMixin = dedupingMixin(superClass => {
  /**
   * @constructor
   * @implements {Polymer_PropertiesChanged}
   * @private
   */
  const base = PropertiesChanged(superClass);
  /**
   * Returns the super class constructor for the given class, if it is an
   * instance of the PropertiesMixin.
   *
   * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor
   * @return {?PropertiesMixinConstructor} Super class constructor
   */

  function superPropertiesClass(constructor) {
    const superCtor = Object.getPrototypeOf(constructor); // Note, the `PropertiesMixin` class below only refers to the class
    // generated by this call to the mixin; the instanceof test only works
    // because the mixin is deduped and guaranteed only to apply once, hence
    // all constructors in a proto chain will see the same `PropertiesMixin`

    return superCtor.prototype instanceof PropertiesMixin ?
    /** @type {!PropertiesMixinConstructor} */
    superCtor : null;
  }
  /**
   * Returns a memoized version of the `properties` object for the
   * given class. Properties not in object format are converted to at
   * least {type}.
   *
   * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor
   * @return {Object} Memoized properties object
   */


  function ownProperties(constructor) {
    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {
      let props = null;

      if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor))) {
        const properties = constructor.properties;

        if (properties) {
          props = normalizeProperties(properties);
        }
      }

      constructor.__ownProperties = props;
    }

    return constructor.__ownProperties;
  }
  /**
   * @polymer
   * @mixinClass
   * @extends {base}
   * @implements {Polymer_PropertiesMixin}
   * @unrestricted
   */


  class PropertiesMixin extends base {
    /**
     * Implements standard custom elements getter to observes the attributes
     * listed in `properties`.
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */
    static get observedAttributes() {
      if (!this.hasOwnProperty('__observedAttributes')) {
        register(this.prototype);
        const props = this._properties;
        this.__observedAttributes = props ? Object.keys(props).map(p => this.attributeNameForProperty(p)) : [];
      }

      return this.__observedAttributes;
    }
    /**
     * Finalizes an element definition, including ensuring any super classes
     * are also finalized. This includes ensuring property
     * accessors exist on the element prototype. This method calls
     * `_finalizeClass` to finalize each constructor in the prototype chain.
     * @return {void}
     */


    static finalize() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {
        const superCtor = superPropertiesClass(
        /** @type {!PropertiesMixinConstructor} */
        this);

        if (superCtor) {
          superCtor.finalize();
        }

        this.__finalized = true;

        this._finalizeClass();
      }
    }
    /**
     * Finalize an element class. This includes ensuring property
     * accessors exist on the element prototype. This method is called by
     * `finalize` and finalizes the class constructor.
     *
     * @protected
     */


    static _finalizeClass() {
      const props = ownProperties(
      /** @type {!PropertiesMixinConstructor} */
      this);

      if (props) {
        this.createProperties(props);
      }
    }
    /**
     * Returns a memoized version of all properties, including those inherited
     * from super classes. Properties not in object format are converted to
     * at least {type}.
     *
     * @return {Object} Object containing properties for this class
     * @protected
     */


    static get _properties() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('__properties', this))) {
        const superCtor = superPropertiesClass(
        /** @type {!PropertiesMixinConstructor} */
        this);
        this.__properties = Object.assign({}, superCtor && superCtor._properties, ownProperties(
        /** @type {PropertiesMixinConstructor} */
        this));
      }

      return this.__properties;
    }
    /**
     * Overrides `PropertiesChanged` method to return type specified in the
     * static `properties` object for the given property.
     * @param {string} name Name of property
     * @return {*} Type to which to deserialize attribute
     *
     * @protected
     */


    static typeForProperty(name) {
      const info = this._properties[name];
      return info && info.type;
    }
    /**
     * Overrides `PropertiesChanged` method and adds a call to
     * `finalize` which lazily configures the element's property accessors.
     * @override
     * @return {void}
     */


    _initializeProperties() {
      this.constructor.finalize();

      super._initializeProperties();
    }
    /**
     * Called when the element is added to a document.
     * Calls `_enableProperties` to turn on property system from
     * `PropertiesChanged`.
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */


    connectedCallback() {
      if (super.connectedCallback) {
        super.connectedCallback();
      }

      this._enableProperties();
    }
    /**
     * Called when the element is removed from a document
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */


    disconnectedCallback() {
      if (super.disconnectedCallback) {
        super.disconnectedCallback();
      }
    }

  }

  return PropertiesMixin;
});

/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
/**
 * Current Polymer version in Semver notation.
 * @type {string} Semver notation of the current version of Polymer.
 */

const version = '3.2.0';
const builtCSS = window.ShadyCSS && window.ShadyCSS['cssBuild'];
/**
 * Element class mixin that provides the core API for Polymer's meta-programming
 * features including template stamping, data-binding, attribute deserialization,
 * and property change observation.
 *
 * Subclassers may provide the following static getters to return metadata
 * used to configure Polymer's features for the class:
 *
 * - `static get is()`: When the template is provided via a `dom-module`,
 *   users should return the `dom-module` id from a static `is` getter.  If
 *   no template is needed or the template is provided directly via the
 *   `template` getter, there is no need to define `is` for the element.
 *
 * - `static get template()`: Users may provide the template directly (as
 *   opposed to via `dom-module`) by implementing a static `template` getter.
 *   The getter must return an `HTMLTemplateElement`.
 *
 * - `static get properties()`: Should return an object describing
 *   property-related metadata used by Polymer features (key: property name
 *   value: object containing property metadata). Valid keys in per-property
 *   metadata include:
 *   - `type` (String|Number|Object|Array|...): Used by
 *     `attributeChangedCallback` to determine how string-based attributes
 *     are deserialized to JavaScript property values.
 *   - `notify` (boolean): Causes a change in the property to fire a
 *     non-bubbling event called `<property>-changed`. Elements that have
 *     enabled two-way binding to the property use this event to observe changes.
 *   - `readOnly` (boolean): Creates a getter for the property, but no setter.
 *     To set a read-only property, use the private setter method
 *     `_setProperty(property, value)`.
 *   - `observer` (string): Observer method name that will be called when
 *     the property changes. The arguments of the method are
 *     `(value, previousValue)`.
 *   - `computed` (string): String describing method and dependent properties
 *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
 *     Computed properties are read-only by default and can only be changed
 *     via the return value of the computing method.
 *
 * - `static get observers()`: Array of strings describing multi-property
 *   observer methods and their dependent properties (e.g.
 *   `'observeABC(a, b, c)'`).
 *
 * The base class provides default implementations for the following standard
 * custom element lifecycle callbacks; users may override these, but should
 * call the super method to ensure
 * - `constructor`: Run when the element is created or upgraded
 * - `connectedCallback`: Run each time the element is connected to the
 *   document
 * - `disconnectedCallback`: Run each time the element is disconnected from
 *   the document
 * - `attributeChangedCallback`: Run each time an attribute in
 *   `observedAttributes` is set or removed (note: this element's default
 *   `observedAttributes` implementation will automatically return an array
 *   of dash-cased attributes based on `properties`)
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin PropertyEffects
 * @appliesMixin PropertiesMixin
 * @property rootPath {string} Set to the value of `rootPath`,
 *   which defaults to the main document path
 * @property importPath {string} Set to the value of the class's static
 *   `importPath` property, which defaults to the path of this element's
 *   `dom-module` (when `is` is used), but can be overridden for other
 *   import strategies.
 * @summary Element class mixin that provides the core API for Polymer's
 * meta-programming features.
 */

const ElementMixin = dedupingMixin(base => {
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   * @implements {Polymer_PropertiesMixin}
   * @extends {HTMLElement}
   * @private
   */
  const polymerElementBase = PropertiesMixin(PropertyEffects(base));
  /**
   * Returns a list of properties with default values.
   * This list is created as an optimization since it is a subset of
   * the list returned from `_properties`.
   * This list is used in `_initializeProperties` to set property defaults.
   *
   * @param {PolymerElementConstructor} constructor Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   *   that have default values
   * @private
   */

  function propertyDefaults(constructor) {
    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__propertyDefaults', constructor))) {
      constructor.__propertyDefaults = null;
      let props = constructor._properties;

      for (let p in props) {
        let info = props[p];

        if ('value' in info) {
          constructor.__propertyDefaults = constructor.__propertyDefaults || {};
          constructor.__propertyDefaults[p] = info;
        }
      }
    }

    return constructor.__propertyDefaults;
  }
  /**
   * Returns a memoized version of the `observers` array.
   * @param {PolymerElementConstructor} constructor Element class
   * @return {Array} Array containing own observers for the given class
   * @protected
   */


  function ownObservers(constructor) {
    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', constructor))) {
      constructor.__ownObservers = constructor.hasOwnProperty(JSCompiler_renameProperty('observers', constructor)) ?
      /** @type {PolymerElementConstructor} */
      constructor.observers : null;
    }

    return constructor.__ownObservers;
  }
  /**
   * Creates effects for a property.
   *
   * Note, once a property has been set to
   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
   * these values may not be changed. For example, a subclass cannot
   * alter these settings. However, additional `observers` may be added
   * by subclasses.
   *
   * The info object should contain property metadata as follows:
   *
   * * `type`: {function} type to which an attribute matching the property
   * is deserialized. Note the property is camel-cased from a dash-cased
   * attribute. For example, 'foo-bar' attribute is deserialized to a
   * property named 'fooBar'.
   *
   * * `readOnly`: {boolean} creates a readOnly property and
   * makes a private setter for the private of the form '_setFoo' for a
   * property 'foo',
   *
   * * `computed`: {string} creates a computed property. A computed property
   * is also automatically set to `readOnly: true`. The value is calculated
   * by running a method and arguments parsed from the given string. For
   * example 'compute(foo)' will compute a given property when the
   * 'foo' property changes by executing the 'compute' method. This method
   * must return the computed value.
   *
   * * `reflectToAttribute`: {boolean} If true, the property value is reflected
   * to an attribute of the same name. Note, the attribute is dash-cased
   * so a property named 'fooBar' is reflected as 'foo-bar'.
   *
   * * `notify`: {boolean} sends a non-bubbling notification event when
   * the property changes. For example, a property named 'foo' sends an
   * event named 'foo-changed' with `event.detail` set to the value of
   * the property.
   *
   * * observer: {string} name of a method that runs when the property
   * changes. The arguments of the method are (value, previousValue).
   *
   * Note: Users may want control over modifying property
   * effects via subclassing. For example, a user might want to make a
   * reflectToAttribute property not do so in a subclass. We've chosen to
   * disable this because it leads to additional complication.
   * For example, a readOnly effect generates a special setter. If a subclass
   * disables the effect, the setter would fail unexpectedly.
   * Based on feedback, we may want to try to make effects more malleable
   * and/or provide an advanced api for manipulating them.
   *
   * @param {!PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {string} name Name of the property.
   * @param {Object} info Info object from which to create property effects.
   * Supported keys:
   * @param {Object} allProps Flattened map of all properties defined in this
   *   element (including inherited properties)
   * @return {void}
   * @private
   */


  function createPropertyFromConfig(proto, name, info, allProps) {
    // computed forces readOnly...
    if (info.computed) {
      info.readOnly = true;
    } // Note, since all computed properties are readOnly, this prevents
    // adding additional computed property effects (which leads to a confusing
    // setup where multiple triggers for setting a property)
    // While we do have `hasComputedEffect` this is set on the property's
    // dependencies rather than itself.


    if (info.computed) {
      if (proto._hasReadOnlyEffect(name)) {
        console.warn(`Cannot redefine computed property '${name}'.`);
      } else {
        proto._createComputedProperty(name, info.computed, allProps);
      }
    }

    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
      proto._createReadOnlyProperty(name, !info.computed);
    } else if (info.readOnly === false && proto._hasReadOnlyEffect(name)) {
      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);
    }

    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
      proto._createReflectedProperty(name);
    } else if (info.reflectToAttribute === false && proto._hasReflectEffect(name)) {
      console.warn(`Cannot make reflected property '${name}' non-reflected.`);
    }

    if (info.notify && !proto._hasNotifyEffect(name)) {
      proto._createNotifyingProperty(name);
    } else if (info.notify === false && proto._hasNotifyEffect(name)) {
      console.warn(`Cannot make notify property '${name}' non-notify.`);
    } // always add observer


    if (info.observer) {
      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
    } // always create the mapping from attribute back to property for deserialization.


    proto._addPropertyToAttributeMap(name);
  }
  /**
   * Process all style elements in the element template. Styles with the
   * `include` attribute are processed such that any styles in
   * the associated "style modules" are included in the element template.
   * @param {PolymerElementConstructor} klass Element class
   * @param {!HTMLTemplateElement} template Template to process
   * @param {string} is Name of element
   * @param {string} baseURI Base URI for element
   * @private
   */


  function processElementStyles(klass, template, is, baseURI) {
    if (!builtCSS) {
      const templateStyles = template.content.querySelectorAll('style');
      const stylesWithImports = stylesFromTemplate(template); // insert styles from <link rel="import" type="css"> at the top of the template

      const linkedStyles = stylesFromModuleImports(is);
      const firstTemplateChild = template.content.firstElementChild;

      for (let idx = 0; idx < linkedStyles.length; idx++) {
        let s = linkedStyles[idx];
        s.textContent = klass._processStyleText(s.textContent, baseURI);
        template.content.insertBefore(s, firstTemplateChild);
      } // keep track of the last "concrete" style in the template we have encountered


      let templateStyleIndex = 0; // ensure all gathered styles are actually in this template.

      for (let i = 0; i < stylesWithImports.length; i++) {
        let s = stylesWithImports[i];
        let templateStyle = templateStyles[templateStyleIndex]; // if the style is not in this template, it's been "included" and
        // we put a clone of it in the template before the style that included it

        if (templateStyle !== s) {
          s = s.cloneNode(true);
          templateStyle.parentNode.insertBefore(s, templateStyle);
        } else {
          templateStyleIndex++;
        }

        s.textContent = klass._processStyleText(s.textContent, baseURI);
      }
    }

    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template, is);
    }
  }
  /**
   * Look up template from dom-module for element
   *
   * @param {string} is Element name to look up
   * @return {?HTMLTemplateElement|undefined} Template found in dom module, or
   *   undefined if not found
   * @protected
   */


  function getTemplateFromDomModule(is) {
    let template = null; // Under strictTemplatePolicy in 3.x+, dom-module lookup is only allowed
    // when opted-in via allowTemplateFromDomModule

    if (is && (!strictTemplatePolicy || allowTemplateFromDomModule)) {
      template =
      /** @type {?HTMLTemplateElement} */
      DomModule.import(is, 'template'); // Under strictTemplatePolicy, require any element with an `is`
      // specified to have a dom-module

      if (strictTemplatePolicy && !template) {
        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);
      }
    }

    return template;
  }
  /**
   * @polymer
   * @mixinClass
   * @unrestricted
   * @implements {Polymer_ElementMixin}
   * @extends {polymerElementBase}
   */


  class PolymerElement extends polymerElementBase {
    /**
     * Current Polymer version in Semver notation.
     * @type {string} Semver notation of the current version of Polymer.
     */
    static get polymerElementVersion() {
      return version;
    }
    /**
     * Override of PropertiesMixin _finalizeClass to create observers and
     * find the template.
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */


    static _finalizeClass() {
      super._finalizeClass();

      const observers = ownObservers(this);

      if (observers) {
        this.createObservers(observers, this._properties);
      }

      this._prepareTemplate();
    }

    static _prepareTemplate() {
      // note: create "working" template that is finalized at instance time
      let template =
      /** @type {PolymerElementConstructor} */
      this.template;

      if (template) {
        if (typeof template === 'string') {
          console.error('template getter must return HTMLTemplateElement');
          template = null;
        } else if (!legacyOptimizations) {
          template = template.cloneNode(true);
        }
      }

      this.prototype._template = template;
    }
    /**
     * Override of PropertiesChanged createProperties to create accessors
     * and property effects for all of the properties.
     * @param {!Object} props .
     * @return {void}
     * @protected
     */


    static createProperties(props) {
      for (let p in props) {
        createPropertyFromConfig(this.prototype, p, props[p], props);
      }
    }
    /**
     * Creates observers for the given `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {Object} observers Array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @return {void}
     * @protected
     */


    static createObservers(observers, dynamicFns) {
      const proto = this.prototype;

      for (let i = 0; i < observers.length; i++) {
        proto._createMethodObserver(observers[i], dynamicFns);
      }
    }
    /**
     * Returns the template that will be stamped into this element's shadow root.
     *
     * If a `static get is()` getter is defined, the default implementation
     * will return the first `<template>` in a `dom-module` whose `id`
     * matches this element's `is`.
     *
     * Users may override this getter to return an arbitrary template
     * (in which case the `is` getter is unnecessary). The template returned
     * must be an `HTMLTemplateElement`.
     *
     * Note that when subclassing, if the super class overrode the default
     * implementation and the subclass would like to provide an alternate
     * template via a `dom-module`, it should override this getter and
     * return `DomModule.import(this.is, 'template')`.
     *
     * If a subclass would like to modify the super class template, it should
     * clone it rather than modify it in place.  If the getter does expensive
     * work such as cloning/modifying a template, it should memoize the
     * template for maximum performance:
     *
     *   let memoizedTemplate;
     *   class MySubClass extends MySuperClass {
     *     static get template() {
     *       if (!memoizedTemplate) {
     *         memoizedTemplate = super.template.cloneNode(true);
     *         let subContent = document.createElement('div');
     *         subContent.textContent = 'This came from MySubClass';
     *         memoizedTemplate.content.appendChild(subContent);
     *       }
     *       return memoizedTemplate;
     *     }
     *   }
     *
     * @return {!HTMLTemplateElement|string} Template to be stamped
     */


    static get template() {
      // Explanation of template-related properties:
      // - constructor.template (this getter): the template for the class.
      //     This can come from the prototype (for legacy elements), from a
      //     dom-module, or from the super class's template (or can be overridden
      //     altogether by the user)
      // - constructor._template: memoized version of constructor.template
      // - prototype._template: working template for the element, which will be
      //     parsed and modified in place. It is a cloned version of
      //     constructor.template, saved in _finalizeClass(). Note that before
      //     this getter is called, for legacy elements this could be from a
      //     _template field on the info object passed to Polymer(), a behavior,
      //     or set in registered(); once the static getter runs, a clone of it
      //     will overwrite it on the prototype as the working template.
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
        this._template = // If user has put template on prototype (e.g. in legacy via registered
        // callback or info object), prefer that first
        this.prototype.hasOwnProperty(JSCompiler_renameProperty('_template', this.prototype)) ? this.prototype._template : // Look in dom-module associated with this element's is
        getTemplateFromDomModule(
        /** @type {PolymerElementConstructor}*/
        this.is) || // Next look for superclass template (call the super impl this
        // way so that `this` points to the superclass)
        Object.getPrototypeOf(
        /** @type {PolymerElementConstructor}*/
        this.prototype).constructor.template;
      }

      return this._template;
    }
    /**
     * Set the template.
     *
     * @param {!HTMLTemplateElement|string} value Template to set.
     */


    static set template(value) {
      this._template = value;
    }
    /**
     * Path matching the url from which the element was imported.
     *
     * This path is used to resolve url's in template style cssText.
     * The `importPath` property is also set on element instances and can be
     * used to create bindings relative to the import path.
     *
     * For elements defined in ES modules, users should implement
     * `static get importMeta() { return import.meta; }`, and the default
     * implementation of `importPath` will  return `import.meta.url`'s path.
     * For elements defined in HTML imports, this getter will return the path
     * to the document containing a `dom-module` element matching this
     * element's static `is` property.
     *
     * Note, this path should contain a trailing `/`.
     *
     * @return {string} The import path for this element class
     * @suppress {missingProperties}
     */


    static get importPath() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
        const meta = this.importMeta;

        if (meta) {
          this._importPath = pathFromUrl(meta.url);
        } else {
          const module = DomModule.import(
          /** @type {PolymerElementConstructor} */
          this.is);
          this._importPath = module && module.assetpath || Object.getPrototypeOf(
          /** @type {PolymerElementConstructor}*/
          this.prototype).constructor.importPath;
        }
      }

      return this._importPath;
    }

    constructor() {
      super();
      /** @type {HTMLTemplateElement} */

      this._template;
      /** @type {string} */

      this._importPath;
      /** @type {string} */

      this.rootPath;
      /** @type {string} */

      this.importPath;
      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */

      this.root;
      /** @type {!Object<string, !Element>} */

      this.$;
    }
    /**
     * Overrides the default `PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @return {void}
     * @override
     * @suppress {invalidCasts,missingProperties} go/missingfnprops
     */


    _initializeProperties() {
      this.constructor.finalize(); // note: finalize template when we have access to `localName` to
      // avoid dependence on `is` for polyfilling styling.

      this.constructor._finalizeTemplate(
      /** @type {!HTMLElement} */
      this.localName);

      super._initializeProperties(); // set path defaults


      this.rootPath = rootPath;
      this.importPath = this.constructor.importPath; // apply property defaults...

      let p$ = propertyDefaults(this.constructor);

      if (!p$) {
        return;
      }

      for (let p in p$) {
        let info = p$[p]; // Don't set default value if there is already an own property, which
        // happens when a `properties` property with default but no effects had
        // a property set (e.g. bound) by its host before upgrade

        if (!this.hasOwnProperty(p)) {
          let value = typeof info.value == 'function' ? info.value.call(this) : info.value; // Set via `_setProperty` if there is an accessor, to enable
          // initializing readOnly property defaults

          if (this._hasAccessor(p)) {
            this._setPendingProperty(p, value, true);
          } else {
            this[p] = value;
          }
        }
      }
    }
    /**
     * Gather style text for a style element in the template.
     *
     * @param {string} cssText Text containing styling to process
     * @param {string} baseURI Base URI to rebase CSS paths against
     * @return {string} The processed CSS text
     * @protected
     */


    static _processStyleText(cssText, baseURI) {
      return resolveCss(cssText, baseURI);
    }
    /**
    * Configures an element `proto` to function with a given `template`.
    * The element name `is` and extends `ext` must be specified for ShadyCSS
    * style scoping.
    *
    * @param {string} is Tag name (or type extension name) for this element
    * @return {void}
    * @protected
    */


    static _finalizeTemplate(is) {
      /** @const {HTMLTemplateElement} */
      const template = this.prototype._template;

      if (template && !template.__polymerFinalized) {
        template.__polymerFinalized = true;
        const importPath = this.importPath;
        const baseURI = importPath ? resolveUrl(importPath) : ''; // e.g. support `include="module-name"`, and ShadyCSS

        processElementStyles(this, template, is, baseURI);

        this.prototype._bindTemplate(template);
      }
    }
    /**
     * Provides a default implementation of the standard Custom Elements
     * `connectedCallback`.
     *
     * The default implementation enables the property effects system and
     * flushes any pending properties, and updates shimmed CSS properties
     * when using the ShadyCSS scoping/custom properties polyfill.
     *
     * @override
     * @suppress {missingProperties, invalidCasts} Super may or may not
     *     implement the callback
     * @return {void}
     */


    connectedCallback() {
      if (window.ShadyCSS && this._template) {
        window.ShadyCSS.styleElement(
        /** @type {!HTMLElement} */
        this);
      }

      super.connectedCallback();
    }
    /**
     * Stamps the element template.
     *
     * @return {void}
     * @override
     */


    ready() {
      if (this._template) {
        this.root = this._stampTemplate(this._template);
        this.$ = this.root.$;
      }

      super.ready();
    }
    /**
     * Implements `PropertyEffects`'s `_readyClients` call. Attaches
     * element dom by calling `_attachDom` with the dom stamped from the
     * element's template via `_stampTemplate`. Note that this allows
     * client dom to be attached to the element prior to any observers
     * running.
     *
     * @return {void}
     * @override
     */


    _readyClients() {
      if (this._template) {
        this.root = this._attachDom(
        /** @type {StampedTemplate} */
        this.root);
      } // The super._readyClients here sets the clients initialized flag.
      // We must wait to do this until after client dom is created/attached
      // so that this flag can be checked to prevent notifications fired
      // during this process from being handled before clients are ready.


      super._readyClients();
    }
    /**
     * Attaches an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @override
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {StampedTemplate} dom to attach to the element.
     * @return {ShadowRoot} node to which the dom has been attached.
     */


    _attachDom(dom) {
      const n = wrap(this);

      if (n.attachShadow) {
        if (dom) {
          if (!n.shadowRoot) {
            n.attachShadow({
              mode: 'open'
            });
          }

          n.shadowRoot.appendChild(dom);

          if (syncInitialRender && window.ShadyDOM) {
            ShadyDOM.flushInitial(n.shadowRoot);
          }

          return n.shadowRoot;
        }

        return null;
      } else {
        throw new Error('ShadowDOM not available. ' + // TODO(sorvell): move to compile-time conditional when supported
        'PolymerElement can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
      }
    }
    /**
     * When using the ShadyCSS scoping and custom property shim, causes all
     * shimmed styles in this element (and its subtree) to be updated
     * based on current custom property values.
     *
     * The optional parameter overrides inline custom property styles with an
     * object of properties where the keys are CSS properties, and the values
     * are strings.
     *
     * Example: `this.updateStyles({'--color': 'blue'})`
     *
     * These properties are retained unless a value of `null` is set.
     *
     * Note: This function does not support updating CSS mixins.
     * You can not dynamically change the value of an `@apply`.
     *
     * @override
     * @param {Object=} properties Bag of custom property key/values to
     *   apply to this element.
     * @return {void}
     * @suppress {invalidCasts}
     */


    updateStyles(properties) {
      if (window.ShadyCSS) {
        window.ShadyCSS.styleSubtree(
        /** @type {!HTMLElement} */
        this, properties);
      }
    }
    /**
     * Rewrites a given URL relative to a base URL. The base URL defaults to
     * the original location of the document containing the `dom-module` for
     * this element. This method will return the same URL before and after
     * bundling.
     *
     * Note that this function performs no resolution for URLs that start
     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
     * URL resolution, use `window.URL`.
     *
     * @override
     * @param {string} url URL to resolve.
     * @param {string=} base Optional base URL to resolve against, defaults
     * to the element's `importPath`
     * @return {string} Rewritten URL relative to base
     */


    resolveUrl(url, base) {
      if (!base && this.importPath) {
        base = resolveUrl(this.importPath);
      }

      return resolveUrl(url, base);
    }
    /**
     * Overrides `PropertyEffects` to add map of dynamic functions on
     * template info, for consumption by `PropertyEffects` template binding
     * code. This map determines which method templates should have accessors
     * created for them.
     *
     * @param {!HTMLTemplateElement} template Template
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} .
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */


    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;
      return super._parseTemplateContent(template, templateInfo, nodeInfo);
    }
    /**
     * Overrides `PropertyEffects` to warn on use of undeclared properties in
     * template.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */


    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      // Warn if properties are used in template without being declared.
      // Properties must be listed in `properties` to be included in
      // `observedAttributes` since CE V1 reads that at registration time, and
      // since we want to keep template parsing lazy, we can't automatically
      // add undeclared properties used in templates to `observedAttributes`.
      // The warning is only enabled in `legacyOptimizations` mode, since
      // we don't want to spam existing users who might have adopted the
      // shorthand when attribute deserialization is not important.
      if (legacyOptimizations && !(prop in this._properties)) {
        console.warn(`Property '${prop}' used in template but not declared in 'properties'; ` + `attribute will not be observed.`);
      }

      return super._addTemplatePropertyEffect(templateInfo, prop, effect);
    }

  }

  return PolymerElement;
});

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Base class that provides the core API for Polymer's meta-programming
 * features including template stamping, data-binding, attribute deserialization,
 * and property change observation.
 *
 * @customElement
 * @polymer
 * @constructor
 * @implements {Polymer_ElementMixin}
 * @extends HTMLElement
 * @appliesMixin ElementMixin
 * @summary Custom element base class that provides the core API for Polymer's
 *   key meta-programming features including template stamping, data-binding,
 *   attribute deserialization, and property change observation
 */

const PolymerElement = ElementMixin(HTMLElement);

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}

const EDIT_LEAVE = 0;
const EDIT_UPDATE = 1;
const EDIT_ADD = 2;
const EDIT_DELETE = 3; // Note: This function is *based* on the computation of the Levenshtein
// "edit" distance. The one change is that "updates" are treated as two
// edits - not one. With Array splices, an update is really a delete
// followed by an add. By retaining this, we optimize for "keeping" the
// maximum array items in the original array. For example:
//
//   'xxxx123' -> '123yyyy'
//
// With 1-edit updates, the shortest path would be just to update all seven
// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
// leaves the substring '123' intact.

function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  // "Deletion" columns
  let rowCount = oldEnd - oldStart + 1;
  let columnCount = currentEnd - currentStart + 1;
  let distances = new Array(rowCount); // "Addition" rows. Initialize null column.

  for (let i = 0; i < rowCount; i++) {
    distances[i] = new Array(columnCount);
    distances[i][0] = i;
  } // Initialize null row


  for (let j = 0; j < columnCount; j++) distances[0][j] = j;

  for (let i = 1; i < rowCount; i++) {
    for (let j = 1; j < columnCount; j++) {
      if (equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1];else {
        let north = distances[i - 1][j] + 1;
        let west = distances[i][j - 1] + 1;
        distances[i][j] = north < west ? north : west;
      }
    }
  }

  return distances;
} // This starts at the final weight, and walks "backward" by finding
// the minimum previous weight recursively until the origin of the weight
// matrix.


function spliceOperationsFromEditDistances(distances) {
  let i = distances.length - 1;
  let j = distances[0].length - 1;
  let current = distances[i][j];
  let edits = [];

  while (i > 0 || j > 0) {
    if (i == 0) {
      edits.push(EDIT_ADD);
      j--;
      continue;
    }

    if (j == 0) {
      edits.push(EDIT_DELETE);
      i--;
      continue;
    }

    let northWest = distances[i - 1][j - 1];
    let west = distances[i - 1][j];
    let north = distances[i][j - 1];
    let min;
    if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;

    if (min == northWest) {
      if (northWest == current) {
        edits.push(EDIT_LEAVE);
      } else {
        edits.push(EDIT_UPDATE);
        current = northWest;
      }

      i--;
      j--;
    } else if (min == west) {
      edits.push(EDIT_DELETE);
      i--;
      current = west;
    } else {
      edits.push(EDIT_ADD);
      j--;
      current = north;
    }
  }

  edits.reverse();
  return edits;
}
/**
 * Splice Projection functions:
 *
 * A splice map is a representation of how a previous array of items
 * was transformed into a new array of items. Conceptually it is a list of
 * tuples of
 *
 *   <index, removed, addedCount>
 *
 * which are kept in ascending index order of. The tuple represents that at
 * the |index|, |removed| sequence of items were removed, and counting forward
 * from |index|, |addedCount| items were added.
 */

/**
 * Lacking individual splice mutation information, the minimal set of
 * splices can be synthesized given the previous state and final state of an
 * array. The basic approach is to calculate the edit distance matrix and
 * choose the shortest path through it.
 *
 * Complexity: O(l * p)
 *   l: The length of the current array
 *   p: The length of the old array
 *
 * @param {!Array} current The current "changed" array for which to
 * calculate splices.
 * @param {number} currentStart Starting index in the `current` array for
 * which splices are calculated.
 * @param {number} currentEnd Ending index in the `current` array for
 * which splices are calculated.
 * @param {!Array} old The original "unchanged" array to compare `current`
 * against to determine splices.
 * @param {number} oldStart Starting index in the `old` array for
 * which splices are calculated.
 * @param {number} oldEnd Ending index in the `old` array for
 * which splices are calculated.
 * @return {!Array} Returns an array of splice record objects. Each of these
 * contains: `index` the location where the splice occurred; `removed`
 * the array of removed items from this location; `addedCount` the number
 * of items added at this location.
 */


function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  let prefixCount = 0;
  let suffixCount = 0;
  let splice;
  let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
  if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);
  if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);
  currentStart += prefixCount;
  oldStart += prefixCount;
  currentEnd -= suffixCount;
  oldEnd -= suffixCount;
  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];

  if (currentStart == currentEnd) {
    splice = newSplice(currentStart, [], 0);

    while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);

    return [splice];
  } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];

  let ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
  splice = undefined;
  let splices = [];
  let index = currentStart;
  let oldIndex = oldStart;

  for (let i = 0; i < ops.length; i++) {
    switch (ops[i]) {
      case EDIT_LEAVE:
        if (splice) {
          splices.push(splice);
          splice = undefined;
        }

        index++;
        oldIndex++;
        break;

      case EDIT_UPDATE:
        if (!splice) splice = newSplice(index, [], 0);
        splice.addedCount++;
        index++;
        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;

      case EDIT_ADD:
        if (!splice) splice = newSplice(index, [], 0);
        splice.addedCount++;
        index++;
        break;

      case EDIT_DELETE:
        if (!splice) splice = newSplice(index, [], 0);
        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
    }
  }

  if (splice) {
    splices.push(splice);
  }

  return splices;
}

function sharedPrefix(current, old, searchLength) {
  for (let i = 0; i < searchLength; i++) if (!equals(current[i], old[i])) return i;

  return searchLength;
}

function sharedSuffix(current, old, searchLength) {
  let index1 = current.length;
  let index2 = old.length;
  let count = 0;

  while (count < searchLength && equals(current[--index1], old[--index2])) count++;

  return count;
}
/**
 * Returns an array of splice records indicating the minimum edits required
 * to transform the `previous` array into the `current` array.
 *
 * Splice records are ordered by index and contain the following fields:
 * - `index`: index where edit started
 * - `removed`: array of removed items from this index
 * - `addedCount`: number of items added at this index
 *
 * This function is based on the Levenshtein "minimum edit distance"
 * algorithm. Note that updates are treated as removal followed by addition.
 *
 * The worst-case time complexity of this algorithm is `O(l * p)`
 *   l: The length of the current array
 *   p: The length of the previous array
 *
 * However, the worst-case complexity is reduced by an `O(n)` optimization
 * to detect any shared prefix & suffix between the two arrays and only
 * perform the more expensive minimum edit distance calculation over the
 * non-shared portions of the arrays.
 *
 * @function
 * @param {!Array} current The "changed" array for which splices will be
 * calculated.
 * @param {!Array} previous The "unchanged" original array to compare
 * `current` against to determine the splices.
 * @return {!Array} Returns an array of splice record objects. Each of these
 * contains: `index` the location where the splice occurred; `removed`
 * the array of removed items from this location; `addedCount` the number
 * of items added at this location.
 */


function calculateSplices(current, previous) {
  return calcSplices(current, 0, current.length, previous, 0, previous.length);
}

function equals(currentValue, previousValue) {
  return currentValue === previousValue;
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Returns true if `node` is a slot element
 * @param {!Node} node Node to test.
 * @return {boolean} Returns true if the given `node` is a slot
 * @private
 */

function isSlot(node) {
  return node.localName === 'slot';
}
/**
 * Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`. The list of flattened nodes consists
 * of a node's children and, for any children that are `<slot>` elements,
 * the expanded flattened list of `assignedNodes`.
 * For example, if the observed node has children `<a></a><slot></slot><b></b>`
 * and the `<slot>` has one `<div>` assigned to it, then the flattened
 * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
 * `<slot>` elements assigned to it, these are flattened as well.
 *
 * The provided `callback` is called whenever any change to this list
 * of flattened nodes occurs, where an addition or removal of a node is
 * considered a change. The `callback` is called with one argument, an object
 * containing an array of any `addedNodes` and `removedNodes`.
 *
 * Note: the callback is called asynchronous to any changes
 * at a microtask checkpoint. This is because observation is performed using
 * `MutationObserver` and the `<slot>` element's `slotchange` event which
 * are asynchronous.
 *
 * An example:
 * ```js
 * class TestSelfObserve extends PolymerElement {
 *   static get is() { return 'test-self-observe';}
 *   connectedCallback() {
 *     super.connectedCallback();
 *     this._observer = new FlattenedNodesObserver(this, (info) => {
 *       this.info = info;
 *     });
 *   }
 *   disconnectedCallback() {
 *     super.disconnectedCallback();
 *     this._observer.disconnect();
 *   }
 * }
 * customElements.define(TestSelfObserve.is, TestSelfObserve);
 * ```
 *
 * @summary Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`.
 * @implements {PolymerDomApi.ObserveHandle}
 */


let FlattenedNodesObserver = class {
  /**
   * Returns the list of flattened nodes for the given `node`.
   * This list consists of a node's children and, for any children
   * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
   * For example, if the observed node has children `<a></a><slot></slot><b></b>`
   * and the `<slot>` has one `<div>` assigned to it, then the flattened
   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
   * `<slot>` elements assigned to it, these are flattened as well.
   *
   * @param {!HTMLElement|!HTMLSlotElement} node The node for which to
   *      return the list of flattened nodes.
   * @return {!Array<!Node>} The list of flattened nodes for the given `node`.
   * @nocollapse See https://github.com/google/closure-compiler/issues/2763
   */
  // eslint-disable-next-line
  static getFlattenedNodes(node) {
    const wrapped = wrap(node);

    if (isSlot(node)) {
      node =
      /** @type {!HTMLSlotElement} */
      node; // eslint-disable-line no-self-assign

      return wrapped.assignedNodes({
        flatten: true
      });
    } else {
      return Array.from(wrapped.childNodes).map(node => {
        if (isSlot(node)) {
          node =
          /** @type {!HTMLSlotElement} */
          node; // eslint-disable-line no-self-assign

          return wrap(node).assignedNodes({
            flatten: true
          });
        } else {
          return [node];
        }
      }).reduce((a, b) => a.concat(b), []);
    }
  }
  /**
   * @param {!HTMLElement} target Node on which to listen for changes.
   * @param {?function(this: Element, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Function called when there are additions
   * or removals from the target's list of flattened nodes.
   */
  // eslint-disable-next-line


  constructor(target, callback) {
    /**
     * @type {MutationObserver}
     * @private
     */
    this._shadyChildrenObserver = null;
    /**
     * @type {MutationObserver}
     * @private
     */

    this._nativeChildrenObserver = null;
    this._connected = false;
    /**
     * @type {!HTMLElement}
     * @private
     */

    this._target = target;
    this.callback = callback;
    this._effectiveNodes = [];
    this._observer = null;
    this._scheduled = false;
    /**
     * @type {function()}
     * @private
     */

    this._boundSchedule = () => {
      this._schedule();
    };

    this.connect();

    this._schedule();
  }
  /**
   * Activates an observer. This method is automatically called when
   * a `FlattenedNodesObserver` is created. It should only be called to
   * re-activate an observer that has been deactivated via the `disconnect` method.
   *
   * @return {void}
   */


  connect() {
    if (isSlot(this._target)) {
      this._listenSlots([this._target]);
    } else if (wrap(this._target).children) {
      this._listenSlots(
      /** @type {!NodeList<!Node>} */
      wrap(this._target).children);

      if (window.ShadyDOM) {
        this._shadyChildrenObserver = ShadyDOM.observeChildren(this._target, mutations => {
          this._processMutations(mutations);
        });
      } else {
        this._nativeChildrenObserver = new MutationObserver(mutations => {
          this._processMutations(mutations);
        });

        this._nativeChildrenObserver.observe(this._target, {
          childList: true
        });
      }
    }

    this._connected = true;
  }
  /**
   * Deactivates the flattened nodes observer. After calling this method
   * the observer callback will not be called when changes to flattened nodes
   * occur. The `connect` method may be subsequently called to reactivate
   * the observer.
   *
   * @return {void}
   * @override
   */


  disconnect() {
    if (isSlot(this._target)) {
      this._unlistenSlots([this._target]);
    } else if (wrap(this._target).children) {
      this._unlistenSlots(
      /** @type {!NodeList<!Node>} */
      wrap(this._target).children);

      if (window.ShadyDOM && this._shadyChildrenObserver) {
        ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
        this._shadyChildrenObserver = null;
      } else if (this._nativeChildrenObserver) {
        this._nativeChildrenObserver.disconnect();

        this._nativeChildrenObserver = null;
      }
    }

    this._connected = false;
  }
  /**
   * @return {void}
   * @private
   */


  _schedule() {
    if (!this._scheduled) {
      this._scheduled = true;
      microTask.run(() => this.flush());
    }
  }
  /**
   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
   * @return {void}
   * @private
   */


  _processMutations(mutations) {
    this._processSlotMutations(mutations);

    this.flush();
  }
  /**
   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
   * @return {void}
   * @private
   */


  _processSlotMutations(mutations) {
    if (mutations) {
      for (let i = 0; i < mutations.length; i++) {
        let mutation = mutations[i];

        if (mutation.addedNodes) {
          this._listenSlots(mutation.addedNodes);
        }

        if (mutation.removedNodes) {
          this._unlistenSlots(mutation.removedNodes);
        }
      }
    }
  }
  /**
   * Flushes the observer causing any pending changes to be immediately
   * delivered the observer callback. By default these changes are delivered
   * asynchronously at the next microtask checkpoint.
   *
   * @return {boolean} Returns true if any pending changes caused the observer
   * callback to run.
   */


  flush() {
    if (!this._connected) {
      return false;
    }

    if (window.ShadyDOM) {
      ShadyDOM.flush();
    }

    if (this._nativeChildrenObserver) {
      this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
    } else if (this._shadyChildrenObserver) {
      this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
    }

    this._scheduled = false;
    let info = {
      target: this._target,
      addedNodes: [],
      removedNodes: []
    };
    let newNodes = this.constructor.getFlattenedNodes(this._target);
    let splices = calculateSplices(newNodes, this._effectiveNodes); // process removals

    for (let i = 0, s; i < splices.length && (s = splices[i]); i++) {
      for (let j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
        info.removedNodes.push(n);
      }
    } // process adds


    for (let i = 0, s; i < splices.length && (s = splices[i]); i++) {
      for (let j = s.index; j < s.index + s.addedCount; j++) {
        info.addedNodes.push(newNodes[j]);
      }
    } // update cache


    this._effectiveNodes = newNodes;
    let didFlush = false;

    if (info.addedNodes.length || info.removedNodes.length) {
      didFlush = true;
      this.callback.call(this._target, info);
    }

    return didFlush;
  }
  /**
   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
   * @return {void}
   * @private
   */


  _listenSlots(nodeList) {
    for (let i = 0; i < nodeList.length; i++) {
      let n = nodeList[i];

      if (isSlot(n)) {
        n.addEventListener('slotchange', this._boundSchedule);
      }
    }
  }
  /**
   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
   * @return {void}
   * @private
   */


  _unlistenSlots(nodeList) {
    for (let i = 0; i < nodeList.length; i++) {
      let n = nodeList[i];

      if (isSlot(n)) {
        n.removeEventListener('slotchange', this._boundSchedule);
      }
    }
  }

};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let scheduled = false;
let beforeRenderQueue = [];
let afterRenderQueue = [];

function schedule() {
  scheduled = true; // before next render

  requestAnimationFrame(function () {
    scheduled = false;
    flushQueue(beforeRenderQueue); // after the render

    setTimeout(function () {
      runQueue(afterRenderQueue);
    });
  });
}

function flushQueue(queue) {
  while (queue.length) {
    callMethod(queue.shift());
  }
}

function runQueue(queue) {
  for (let i = 0, l = queue.length; i < l; i++) {
    callMethod(queue.shift());
  }
}

function callMethod(info) {
  const context = info[0];
  const callback = info[1];
  const args = info[2];

  try {
    callback.apply(context, args);
  } catch (e) {
    setTimeout(() => {
      throw e;
    });
  }
}
/**
 * Enqueues a callback which will be run before the next render, at
 * `requestAnimationFrame` timing.
 *
 * This method is useful for enqueuing work that requires DOM measurement,
 * since measurement may not be reliable in custom element callbacks before
 * the first render, as well as for batching measurement tasks in general.
 *
 * Tasks in this queue may be flushed by calling `flush()`.
 *
 * @param {*} context Context object the callback function will be bound to
 * @param {function(...*):void} callback Callback function
 * @param {!Array=} args An array of arguments to call the callback function with
 * @return {void}
 */

function beforeNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }

  beforeRenderQueue.push([context, callback, args]);
}

/**
 * @polymerMixin
 */
const ThemePropertyMixin = superClass => class VaadinThemePropertyMixin extends superClass {
  static get properties() {
    return {
      /**
       * Helper property with theme attribute value facilitating propagation
       * in shadow DOM. Allows using `theme$="[[theme]]"` in the template.
       *
       * @protected
       */
      theme: {
        type: String,
        readOnly: true
      }
    };
  }
  /** @protected */


  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);

    if (name === 'theme') {
      this._setTheme(newValue);
    }
  }

};

/**
 * @polymerMixin
 */

const ThemableMixin = superClass => class VaadinThemableMixin extends ThemePropertyMixin(superClass) {
  /** @protected */
  static finalize() {
    super.finalize();
    const template = this.prototype._template;
    const hasOwnTemplate = this.template && this.template.parentElement && this.template.parentElement.id === this.is;

    const inheritedTemplate = Object.getPrototypeOf(this.prototype)._template;

    if (inheritedTemplate && !hasOwnTemplate) {
      // The element doesn't define its own template -> include the theme modules from the inherited template
      Array.from(inheritedTemplate.content.querySelectorAll('style[include]')).forEach(s => {
        this._includeStyle(s.getAttribute('include'), template);
      });
    }

    this._includeMatchingThemes(template);
  }
  /** @protected */


  static _includeMatchingThemes(template) {
    const domModule = DomModule;
    const modules = domModule.prototype.modules;
    let hasThemes = false;
    const defaultModuleName = this.is + '-default-theme';
    Object.keys(modules).sort((moduleNameA, moduleNameB) => {
      const vaadinA = moduleNameA.indexOf('vaadin-') === 0;
      const vaadinB = moduleNameB.indexOf('vaadin-') === 0;
      const vaadinThemePrefixes = ['lumo-', 'material-'];
      const vaadinThemeA = vaadinThemePrefixes.filter(prefix => moduleNameA.indexOf(prefix) === 0).length > 0;
      const vaadinThemeB = vaadinThemePrefixes.filter(prefix => moduleNameB.indexOf(prefix) === 0).length > 0;

      if (vaadinA !== vaadinB) {
        // Include vaadin core styles first
        return vaadinA ? -1 : 1;
      } else if (vaadinThemeA !== vaadinThemeB) {
        // Include vaadin theme styles after that
        return vaadinThemeA ? -1 : 1;
      } else {
        // Lastly include custom styles so they override all vaadin styles
        return 0;
      }
    }).forEach(moduleName => {
      if (moduleName !== defaultModuleName) {
        const themeFor = modules[moduleName].getAttribute('theme-for');

        if (themeFor) {
          themeFor.split(' ').forEach(themeForToken => {
            if (new RegExp('^' + themeForToken.split('*').join('.*') + '$').test(this.is)) {
              hasThemes = true;

              this._includeStyle(moduleName, template);
            }
          });
        }
      }
    });

    if (!hasThemes && modules[defaultModuleName]) {
      // No theme modules found, include the default module if it exists
      this._includeStyle(defaultModuleName, template);
    }
  }
  /** @private */


  static _includeStyle(moduleName, template) {
    if (template && !template.content.querySelector(`style[include="${moduleName}"]`)) {
      const styleEl = document.createElement('style');
      styleEl.setAttribute('include', moduleName);
      template.content.appendChild(styleEl);
    }
  }

};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
 * @summary Collapse multiple callbacks into one invocation after a timer.
 */

class Debouncer {
  constructor() {
    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncInterface} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   * @return {void}
   */


  setConfig(asyncModule, callback) {
    this._asyncModule = asyncModule;
    this._callback = callback;
    this._timer = this._asyncModule.run(() => {
      this._timer = null;
      debouncerQueue.delete(this);

      this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */


  cancel() {
    if (this.isActive()) {
      this._cancelAsync(); // Canceling a debouncer removes its spot from the flush queue,
      // so if a debouncer is manually canceled and re-debounced, it
      // will reset its flush order (this is a very minor difference from 1.x)
      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order


      debouncerQueue.delete(this);
    }
  }
  /**
   * Cancels a debouncer's async callback.
   *
   * @return {void}
   */


  _cancelAsync() {
    if (this.isActive()) {
      this._asyncModule.cancel(
      /** @type {number} */
      this._timer);

      this._timer = null;
    }
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */


  flush() {
    if (this.isActive()) {
      this.cancel();

      this._callback();
    }
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */


  isActive() {
    return this._timer != null;
  }
  /**
   * Creates a debouncer if no debouncer is passed as a parameter
   * or it cancels an active debouncer otherwise. The following
   * example shows how a debouncer can be called multiple times within a
   * microtask and "debounced" such that the provided callback function is
   * called once. Add this method to a custom element:
   *
   * ```js
   * import {microTask} from '@polymer/polymer/lib/utils/async.js';
   * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';
   * // ...
   *
   * _debounceWork() {
   *   this._debounceJob = Debouncer.debounce(this._debounceJob,
   *       microTask, () => this._doWork());
   * }
   * ```
   *
   * If the `_debounceWork` method is called multiple times within the same
   * microtask, the `_doWork` function will be called only once at the next
   * microtask checkpoint.
   *
   * Note: In testing it is often convenient to avoid asynchrony. To accomplish
   * this with a debouncer, you can use `enqueueDebouncer` and
   * `flush`. For example, extend the above example by adding
   * `enqueueDebouncer(this._debounceJob)` at the end of the
   * `_debounceWork` method. Then in a test, call `flush` to ensure
   * the debouncer has completed.
   *
   * @param {Debouncer?} debouncer Debouncer object.
   * @param {!AsyncInterface} asyncModule Object with Async interface
   * @param {function()} callback Callback to run.
   * @return {!Debouncer} Returns a debouncer object.
   */


  static debounce(debouncer, asyncModule, callback) {
    if (debouncer instanceof Debouncer) {
      // Cancel the async callback, but leave in debouncerQueue if it was
      // enqueued, to maintain 1.x flush order
      debouncer._cancelAsync();
    } else {
      debouncer = new Debouncer();
    }

    debouncer.setConfig(asyncModule, callback);
    return debouncer;
  }

}
let debouncerQueue = new Set();
/**
 * Adds a `Debouncer` to a list of globally flushable tasks.
 *
 * @param {!Debouncer} debouncer Debouncer to enqueue
 * @return {void}
 */

const enqueueDebouncer = function (debouncer) {
  debouncerQueue.add(debouncer);
};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const DEV_MODE_CODE_REGEXP$1 = /\/\*\*\s+vaadin-dev-mode:start([\s\S]*)vaadin-dev-mode:end\s+\*\*\//i;

function isMinified$1() {
  function test() {
    /** vaadin-dev-mode:start
    return false;
    vaadin-dev-mode:end **/
    return true;
  }

  return uncommentAndRun$1(test);
}

function isDevelopmentMode$1() {
  try {
    return isForcedDevelopmentMode$1() || isLocalhost$1() && !isMinified$1() && !isFlowProductionMode$1();
  } catch (e) {
    // Some error in this code, assume production so no further actions will be taken
    return false;
  }
}

function isForcedDevelopmentMode$1() {
  return localStorage.getItem("vaadin.developmentmode.force");
}

function isLocalhost$1() {
  return ["localhost", "127.0.0.1"].indexOf(window.location.hostname) >= 0;
}

function isFlowProductionMode$1() {
  if (window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients) {
    const productionModeApps = Object.keys(window.Vaadin.Flow.clients).map(key => window.Vaadin.Flow.clients[key]).filter(client => client.productionMode);

    if (productionModeApps.length > 0) {
      return true;
    }
  }

  return false;
}

function uncommentAndRun$1(callback, args) {
  if (typeof callback !== 'function') {
    return;
  }

  const match = DEV_MODE_CODE_REGEXP$1.exec(callback.toString());

  if (match) {
    try {
      // requires CSP: script-src 'unsafe-eval'
      callback = new Function(match[1]);
    } catch (e) {
      // eat the exception
      console.log('vaadin-development-mode-detector: uncommentAndRun() failed', e);
    }
  }

  return callback(args);
} // A guard against polymer-modulizer removing the window.Vaadin
// initialization above.


window['Vaadin'] = window['Vaadin'] || {};
/**
 * Inspects the source code of the given `callback` function for
 * specially-marked _commented_ code. If such commented code is found in the
 * callback source, uncomments and runs that code instead of the callback
 * itself. Otherwise runs the callback as is.
 *
 * The optional arguments are passed into the callback / uncommented code,
 * the result is returned.
 *
 * See the `isMinified()` function source code in this file for an example.
 *
 */

const runIfDevelopmentMode$1 = function (callback, args) {
  if (window.Vaadin.developmentMode) {
    return uncommentAndRun$1(callback, args);
  }
};

if (window.Vaadin.developmentMode === undefined) {
  window.Vaadin.developmentMode = isDevelopmentMode$1();
}

/* This file is autogenerated from src/vaadin-usage-statistics.tpl.html */

function maybeGatherAndSendStats$1() {
  /** vaadin-dev-mode:start
  (function () {
  'use strict';
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
  } : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
  };
  var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
   return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
  }();
  var getPolymerVersion = function getPolymerVersion() {
  return window.Polymer && window.Polymer.version;
  };
  var StatisticsGatherer = function () {
  function StatisticsGatherer(logger) {
    classCallCheck(this, StatisticsGatherer);
     this.now = new Date().getTime();
    this.logger = logger;
  }
   createClass(StatisticsGatherer, [{
    key: 'frameworkVersionDetectors',
    value: function frameworkVersionDetectors() {
      return {
        'Flow': function Flow() {
          if (window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients) {
            var flowVersions = Object.keys(window.Vaadin.Flow.clients).map(function (key) {
              return window.Vaadin.Flow.clients[key];
            }).filter(function (client) {
              return client.getVersionInfo;
            }).map(function (client) {
              return client.getVersionInfo().flow;
            });
            if (flowVersions.length > 0) {
              return flowVersions[0];
            }
          }
        },
        'Vaadin Framework': function VaadinFramework() {
          if (window.vaadin && window.vaadin.clients) {
            var frameworkVersions = Object.values(window.vaadin.clients).filter(function (client) {
              return client.getVersionInfo;
            }).map(function (client) {
              return client.getVersionInfo().vaadinVersion;
            });
            if (frameworkVersions.length > 0) {
              return frameworkVersions[0];
            }
          }
        },
        'AngularJs': function AngularJs() {
          if (window.angular && window.angular.version && window.angular.version) {
            return window.angular.version.full;
          }
        },
        'Angular': function Angular() {
          if (window.ng) {
            var tags = document.querySelectorAll("[ng-version]");
            if (tags.length > 0) {
              return tags[0].getAttribute("ng-version");
            }
            return "Unknown";
          }
        },
        'Backbone.js': function BackboneJs() {
          if (window.Backbone) {
            return window.Backbone.VERSION;
          }
        },
        'React': function React() {
          var reactSelector = '[data-reactroot], [data-reactid]';
          if (!!document.querySelector(reactSelector)) {
            // React does not publish the version by default
            return "unknown";
          }
        },
        'Ember': function Ember() {
          if (window.Em && window.Em.VERSION) {
            return window.Em.VERSION;
          } else if (window.Ember && window.Ember.VERSION) {
            return window.Ember.VERSION;
          }
        },
        'jQuery': function (_jQuery) {
          function jQuery() {
            return _jQuery.apply(this, arguments);
          }
           jQuery.toString = function () {
            return _jQuery.toString();
          };
           return jQuery;
        }(function () {
          if (typeof jQuery === 'function' && jQuery.prototype.jquery !== undefined) {
            return jQuery.prototype.jquery;
          }
        }),
        'Polymer': function Polymer() {
          var version = getPolymerVersion();
          if (version) {
            return version;
          }
        },
        'LitElement': function LitElement() {
          var version = window.litElementVersions && window.litElementVersions[0];
          if (version) {
            return version;
          }
        },
        'LitHtml': function LitHtml() {
          var version = window.litHtmlVersions && window.litHtmlVersions[0];
          if (version) {
            return version;
          }
        },
        'Vue.js': function VueJs() {
          if (window.Vue) {
            return window.Vue.version;
          }
        }
      };
    }
  }, {
    key: 'getUsedVaadinElements',
    value: function getUsedVaadinElements(elements) {
      var version = getPolymerVersion();
      var elementClasses = void 0;
      if (version && version.indexOf('2') === 0) {
        // Polymer 2: components classes are stored in window.Vaadin
        elementClasses = Object.keys(window.Vaadin).map(function (c) {
          return window.Vaadin[c];
        }).filter(function (c) {
          return c.is;
        });
      } else {
        // Polymer 3: components classes are stored in window.Vaadin.registrations
        elementClasses = window.Vaadin.registrations || [];
      }
      elementClasses.forEach(function (klass) {
        var version = klass.version ? klass.version : "0.0.0";
        elements[klass.is] = { version: version };
      });
    }
  }, {
    key: 'getUsedVaadinThemes',
    value: function getUsedVaadinThemes(themes) {
      ['Lumo', 'Material'].forEach(function (themeName) {
        var theme;
        var version = getPolymerVersion();
        if (version && version.indexOf('2') === 0) {
          // Polymer 2: themes are stored in window.Vaadin
          theme = window.Vaadin[themeName];
        } else {
          // Polymer 3: themes are stored in custom element registry
          theme = customElements.get('vaadin-' + themeName.toLowerCase() + '-styles');
        }
        if (theme && theme.version) {
          themes[themeName] = { version: theme.version };
        }
      });
    }
  }, {
    key: 'getFrameworks',
    value: function getFrameworks(frameworks) {
      var detectors = this.frameworkVersionDetectors();
      Object.keys(detectors).forEach(function (framework) {
        var detector = detectors[framework];
        try {
          var version = detector();
          if (version) {
            frameworks[framework] = { "version": version };
          }
        } catch (e) {}
      });
    }
  }, {
    key: 'gather',
    value: function gather(storage) {
      var storedStats = storage.read();
      var gatheredStats = {};
      var types = ["elements", "frameworks", "themes"];
       types.forEach(function (type) {
        gatheredStats[type] = {};
        if (!storedStats[type]) {
          storedStats[type] = {};
        }
      });
       var previousStats = JSON.stringify(storedStats);
       this.getUsedVaadinElements(gatheredStats.elements);
      this.getFrameworks(gatheredStats.frameworks);
      this.getUsedVaadinThemes(gatheredStats.themes);
       var now = this.now;
      types.forEach(function (type) {
        var keys = Object.keys(gatheredStats[type]);
        keys.forEach(function (key) {
          if (!storedStats[type][key] || _typeof(storedStats[type][key]) != _typeof({})) {
            storedStats[type][key] = { "firstUsed": now };
          }
          // Discards any previously logged version numebr
          storedStats[type][key].version = gatheredStats[type][key].version;
          storedStats[type][key].lastUsed = now;
        });
      });
       var newStats = JSON.stringify(storedStats);
      storage.write(newStats);
      if (newStats != previousStats && Object.keys(storedStats).length > 0) {
        this.logger.debug("New stats: " + newStats);
      }
    }
  }]);
  return StatisticsGatherer;
  }();
  var StatisticsStorage = function () {
  function StatisticsStorage(key) {
    classCallCheck(this, StatisticsStorage);
     this.key = key;
  }
   createClass(StatisticsStorage, [{
    key: 'read',
    value: function read() {
      var localStorageStatsString = localStorage.getItem(this.key);
      try {
        return JSON.parse(localStorageStatsString ? localStorageStatsString : '{}');
      } catch (e) {
        return {};
      }
    }
  }, {
    key: 'write',
    value: function write(data) {
      localStorage.setItem(this.key, data);
    }
  }, {
    key: 'clear',
    value: function clear() {
      localStorage.removeItem(this.key);
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      var storedStats = this.read();
      var empty = true;
      Object.keys(storedStats).forEach(function (key) {
        if (Object.keys(storedStats[key]).length > 0) {
          empty = false;
        }
      });
       return empty;
    }
  }]);
  return StatisticsStorage;
  }();
  var StatisticsSender = function () {
  function StatisticsSender(url, logger) {
    classCallCheck(this, StatisticsSender);
     this.url = url;
    this.logger = logger;
  }
   createClass(StatisticsSender, [{
    key: 'send',
    value: function send(data, errorHandler) {
      var logger = this.logger;
       if (navigator.onLine === false) {
        logger.debug("Offline, can't send");
        errorHandler();
        return;
      }
      logger.debug("Sending data to " + this.url);
       var req = new XMLHttpRequest();
      req.withCredentials = true;
      req.addEventListener("load", function () {
        // Stats sent, nothing more to do
        logger.debug("Response: " + req.responseText);
      });
      req.addEventListener("error", function () {
        logger.debug("Send failed");
        errorHandler();
      });
      req.addEventListener("abort", function () {
        logger.debug("Send aborted");
        errorHandler();
      });
      req.open("POST", this.url);
      req.setRequestHeader("Content-Type", "application/json");
      req.send(data);
    }
  }]);
  return StatisticsSender;
  }();
  var StatisticsLogger = function () {
  function StatisticsLogger(id) {
    classCallCheck(this, StatisticsLogger);
     this.id = id;
  }
   createClass(StatisticsLogger, [{
    key: '_isDebug',
    value: function _isDebug() {
      return localStorage.getItem("vaadin." + this.id + ".debug");
    }
  }, {
    key: 'debug',
    value: function debug(msg) {
      if (this._isDebug()) {
        console.info(this.id + ": " + msg);
      }
    }
  }]);
  return StatisticsLogger;
  }();
  var UsageStatistics = function () {
  function UsageStatistics() {
    classCallCheck(this, UsageStatistics);
     this.now = new Date();
    this.timeNow = this.now.getTime();
    this.gatherDelay = 10; // Delay between loading this file and gathering stats
    this.initialDelay = 24 * 60 * 60;
     this.logger = new StatisticsLogger("statistics");
    this.storage = new StatisticsStorage("vaadin.statistics.basket");
    this.gatherer = new StatisticsGatherer(this.logger);
    this.sender = new StatisticsSender("https://tools.vaadin.com/usage-stats/submit", this.logger);
  }
   createClass(UsageStatistics, [{
    key: 'maybeGatherAndSend',
    value: function maybeGatherAndSend() {
      var _this = this;
       if (localStorage.getItem(UsageStatistics.optOutKey)) {
        return;
      }
      this.gatherer.gather(this.storage);
      setTimeout(function () {
        _this.maybeSend();
      }, this.gatherDelay * 1000);
    }
  }, {
    key: 'lottery',
    value: function lottery() {
      return Math.random() <= 0.05;
    }
  }, {
    key: 'currentMonth',
    value: function currentMonth() {
      return this.now.getYear() * 12 + this.now.getMonth();
    }
  }, {
    key: 'maybeSend',
    value: function maybeSend() {
      var firstUse = Number(localStorage.getItem(UsageStatistics.firstUseKey));
      var monthProcessed = Number(localStorage.getItem(UsageStatistics.monthProcessedKey));
       if (!firstUse) {
        // Use a grace period to avoid interfering with tests, incognito mode etc
        firstUse = this.timeNow;
        localStorage.setItem(UsageStatistics.firstUseKey, firstUse);
      }
       if (this.timeNow < firstUse + this.initialDelay * 1000) {
        this.logger.debug("No statistics will be sent until the initial delay of " + this.initialDelay + "s has passed");
        return;
      }
      if (this.currentMonth() <= monthProcessed) {
        this.logger.debug("This month has already been processed");
        return;
      }
      localStorage.setItem(UsageStatistics.monthProcessedKey, this.currentMonth());
      // Use random sampling
      if (this.lottery()) {
        this.logger.debug("Congratulations, we have a winner!");
      } else {
        this.logger.debug("Sorry, no stats from you this time");
        return;
      }
       this.send();
    }
  }, {
    key: 'send',
    value: function send() {
      // Ensure we have the latest data
      this.gatherer.gather(this.storage);
       // Read, send and clean up
      var data = this.storage.read();
      data["firstUse"] = Number(localStorage.getItem(UsageStatistics.firstUseKey));
      data["usageStatisticsVersion"] = UsageStatistics.version;
      var info = 'This request contains usage statistics gathered from the application running in development mode. \n\nStatistics gathering is automatically disabled and excluded from production builds.\n\nFor details and to opt-out, see https://github.com/vaadin/vaadin-usage-statistics.\n\n\n\n';
      var self = this;
      this.sender.send(info + JSON.stringify(data), function () {
        // Revert the 'month processed' flag
        localStorage.setItem(UsageStatistics.monthProcessedKey, self.currentMonth() - 1);
      });
    }
  }], [{
    key: 'version',
    get: function get$1() {
      return '2.0.1';
    }
  }, {
    key: 'firstUseKey',
    get: function get$1() {
      return 'vaadin.statistics.firstuse';
    }
  }, {
    key: 'monthProcessedKey',
    get: function get$1() {
      return 'vaadin.statistics.monthProcessed';
    }
  }, {
    key: 'optOutKey',
    get: function get$1() {
      return 'vaadin.statistics.optout';
    }
  }]);
  return UsageStatistics;
  }();
  try {
  window.Vaadin = window.Vaadin || {};
  window.Vaadin.usageStatsChecker = window.Vaadin.usageStatsChecker || new UsageStatistics();
  window.Vaadin.usageStatsChecker.maybeGatherAndSend();
  } catch (e) {
  // Intentionally ignored as this is not a problem in the app being developed
  }
  }());
   vaadin-dev-mode:end **/
}

const usageStatistics$1 = function () {
  if (typeof runIfDevelopmentMode$1 === 'function') {
    return runIfDevelopmentMode$1(maybeGatherAndSendStats$1);
  }
};

if (!window.Vaadin) {
  window['Vaadin'] = {};
}
/**
 * Array of Vaadin custom element classes that have been finalized.
 */


window['Vaadin'].registrations = window.Vaadin.registrations || []; // Use the hack to prevent polymer-modulizer from converting to exports

window['Vaadin'].developmentModeCallback = window.Vaadin.developmentModeCallback || {};

window['Vaadin'].developmentModeCallback['vaadin-usage-statistics'] = function () {
  if (usageStatistics$1) {
    usageStatistics$1();
  }
};

let statsJob;
/**
 * @polymerMixin
 */

const ElementMixin$1 = superClass => class VaadinElementMixin extends superClass {
  /** @protected */
  static _finalizeClass() {
    super._finalizeClass(); // Registers a class prototype for telemetry purposes.


    if (this.is) {
      window.Vaadin.registrations.push(this);

      if (window.Vaadin.developmentModeCallback) {
        statsJob = Debouncer.debounce(statsJob, idlePeriod, () => {
          window.Vaadin.developmentModeCallback['vaadin-usage-statistics']();
        });
        enqueueDebouncer(statsJob);
      }
    }
  }

  ready() {
    super.ready();

    if (document.doctype === null) {
      console.warn('Vaadin components require the "standards mode" declaration. Please add <!DOCTYPE html> to the HTML document.');
    }
  }

};

/* This file is autogenerated from src/vaadin-license-checker.tpl.html */

function maybeCheckLicenses() {
  /** vaadin-dev-mode:start
  (function () {
  'use strict';
  var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
  };
  var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
   return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
  }();
  var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
   subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
   return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };
  function _CustomElement() {
  return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
  }
  Object.setPrototypeOf(_CustomElement.prototype, HTMLElement.prototype);
  Object.setPrototypeOf(_CustomElement, HTMLElement);
  var licenseBoxTemplate = document.createElement('template');
  licenseBoxTemplate.innerHTML = '\n  <style>\n    :host {\n      font: 16px/1.625 -apple-system, BlinkMacSystemFont, "Roboto", "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";\n      position: fixed;\n      top: .5em;\n      right: .5em;\n      z-index: 10000;\n      cursor: pointer;\n      backface-visibility: hidden;\n    }\n\n    #content {\n      padding: 1em 1.5em;\n      margin: 0;\n      display: inline-block;\n      text-align: left;\n      font-size: inherit;\n      line-height: inherit;\n      font-weight: inherit;\n      -webkit-font-smoothing: antialiased;\n      -moz-osx-font-smoothin: grayscale;\n      white-space: nowrap;\n      letter-spacing: 0;\n      border-radius: 4px;\n      box-shadow: 0 2px 6px -1px hsla(214, 53%, 23%, 0.16), 0 8px 24px -4px hsla(214, 47%, 21%, 0.38);\n      color: #fff;\n    }\n\n    #content[type="needsvalidation"] {\n      background-color: hsl(3, 100%, 61%);\n    }\n\n    #content[type="ok"] {\n      background-color: hsl(145, 80%, 42%);\n    }\n\n    #content > svg {\n      display: none;\n      fill: currentColor;\n      stroke: currentColor 1px;\n      padding-left: 1.25em;\n    }\n\n    #content[type="needsvalidation"] > #link {\n      display: inline;\n    }\n\n    #content[type="ok"] > #close {\n      display: inline;\n      vertical-align: -.125em;\n    }\n  </style>\n\n  <div id="content">\n    <span></span>\n    <svg id="link" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16">\n      <g id="external-link"><path d="M14 16v-11l-1 1v9h-12v-12h9l1-1h-11v14z"/><path d="M16 0h-5l1.8 1.8-6.8 6.8 1.4 1.4 6.8-6.8 1.8 1.8z"/></g>\n    </svg>\n    <svg id="close" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16">\n      <g id="close-big"><path d="M16 0l-1 0.010-7 6.99-7-6.99-1-0.010v1l7 7-7 7v1h1l7-7 7 7h1v-1l-7-7 7-7v-1z"/></g>\n    </svg>\n  </div>\n';
  window.ShadyCSS && window.ShadyCSS.prepareTemplate(licenseBoxTemplate, 'vaadin-license-box');
  var LicenseBoxElement = function (_CustomElement2) {
  inherits(LicenseBoxElement, _CustomElement2);
   function LicenseBoxElement() {
    classCallCheck(this, LicenseBoxElement);
    return possibleConstructorReturn(this, (LicenseBoxElement.__proto__ || Object.getPrototypeOf(LicenseBoxElement)).apply(this, arguments));
  }
   createClass(LicenseBoxElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      window.ShadyCSS && window.ShadyCSS.styleElement(this);
       if (!this.shadowRoot) {
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.appendChild(document.importNode(licenseBoxTemplate.content, true));
        this._contentElement = this.shadowRoot.querySelector('#content');
        this._render();
      }
    }
  }, {
    key: '_render',
    value: function _render() {
      if (!this._contentElement) {
        return;
      }
       if (this._type) {
        this._contentElement.setAttribute('type', this._type);
      } else {
        this._contentElement.removeAttribute('type');
      }
       this._contentElement.firstElementChild.textContent = this._content;
    }
  }, {
    key: 'type',
    get: function () {
      return this._type;
    },
    set: function (type) {
      this._type = type;
      this._render();
    }
  }, {
    key: 'content',
    get: function () {
      return this._content;
    },
    set: function (content) {
      this._content = content;
      this._render();
    }
  }]);
  return LicenseBoxElement;
  }(_CustomElement);
  customElements.define('vaadin-license-box', LicenseBoxElement);
  var LicenseCheckerLogger = function () {
  function LicenseCheckerLogger() {
    classCallCheck(this, LicenseCheckerLogger);
     this.id = "vaadin-license-checker";
  }
   createClass(LicenseCheckerLogger, [{
    key: 'isDebug',
    value: function isDebug() {
      return localStorage.getItem("vaadin.licenses.debug");
    }
  }, {
    key: 'debug',
    value: function debug(msg) {
      if (this.isDebug()) {
        console.info(this.id + ": " + msg);
      }
    }
  }]);
  return LicenseCheckerLogger;
  }();
  var LicenseCheckerStorage = function () {
  function LicenseCheckerStorage() {
    classCallCheck(this, LicenseCheckerStorage);
     this.logger = new LicenseCheckerLogger();
  }
   createClass(LicenseCheckerStorage, [{
    key: 'getLastCheckKey',
    value: function getLastCheckKey(productInfo) {
      return "vaadin.licenses.{product}.lastCheck".replace("{product}", productInfo.name);
    }
  }, {
    key: 'getLastCheck',
    value: function getLastCheck(productInfo) {
      return Number(localStorage.getItem(this.getLastCheckKey(productInfo)));
    }
  }, {
    key: 'setLastCheck',
    value: function setLastCheck(productInfo, timestamp) {
      this.logger.debug("Setting last check time to " + new Date(timestamp));
      localStorage.setItem(this.getLastCheckKey(productInfo), timestamp);
    }
  }]);
  return LicenseCheckerStorage;
  }();
  var VaadinLicenseChecker = function () {
  function VaadinLicenseChecker() {
    classCallCheck(this, VaadinLicenseChecker);
     this.okNotifier = new LicenseOkNotifier();
    this.validationNeededNotifier = new LicenseValidationNeededNotifier();
    this.storage = new LicenseCheckerStorage();
    this.checkInterval = 1000 * 60 * 60 * 24;
    this.logger = new LicenseCheckerLogger();
    this.url = "https://tools.vaadin.com/vaadin-license-server/licenses/pro";
  }
   createClass(VaadinLicenseChecker, [{
    key: 'getForcedResponseKey',
    value: function getForcedResponseKey(productInfo) {
      return 'vaadin.licenses.{product}.forcedResponse'.replace('{product}', productInfo.name);
    }
  }, {
    key: 'getForcedResponse',
    value: function getForcedResponse(productInfo) {
      return localStorage.getItem(this.getForcedResponseKey(productInfo));
    }
  }, {
    key: 'clearForcedResponse',
    value: function clearForcedResponse(productInfo) {
      return localStorage.removeItem(this.getForcedResponseKey(productInfo));
    }
  }, {
    key: 'maybeCheck',
    value: function maybeCheck(productInfo) {
      this.logger.debug("maybeCheck(" + JSON.stringify(productInfo) + ")");
      // Defer first check until interval has expired to avoid interfering with tests etc
      var now = new Date().getTime();
      var lastCheck = this.storage.getLastCheck(productInfo);
      if (!lastCheck) {
        this.logger.debug("Deferring first check until " + new Date(now + this.checkInterval));
        this.storage.setLastCheck(productInfo, now);
        return;
      } else {
        var sinceLastCheck = Math.round((now - lastCheck) / 1000);
        var nextCheck = Math.round(this.checkInterval / 1000 - sinceLastCheck);
        if (nextCheck > 0) {
          // Checked recently
          var nextCheckDate = new Date(lastCheck + this.checkInterval);
          this.logger.debug("Checked " + sinceLastCheck + "s ago. Next check in " + nextCheck + "s at " + nextCheckDate + ".");
          return;
        } else {
          this.logger.debug("Last check was " + sinceLastCheck + "s ago.");
        }
      }
      this.check(productInfo);
    }
  }, {
    key: 'check',
    value: function check(productInfo) {
      this.logger.debug("check(" + JSON.stringify(productInfo) + ")");
       // Only show an ok notification if the "validation needed" notification was shown.
      // For background checks, show no visual notification if all goes well
      var showOkOnSuccess = this.validationNeededNotifier.isVisible(productInfo);
       var checker = this;
      var onerror = function () {
        // Offline or blocked, just log to console and let people get work done
        console.error("Unable to validate the license for " + productInfo.name + ". Check your internet access.");
      };
      var onresponse = function (responseText) {
        var response = JSON.parse(responseText);
        if (response.result == "ok") {
          // Everything is fine, stop
          checker.logger.debug("License check ok for " + JSON.stringify(productInfo));
          checker.storage.setLastCheck(productInfo, new Date().getTime());
          if (showOkOnSuccess) {
            checker.logger.debug("Showing validation-ok dialog");
            checker.okNotifier.show(productInfo);
          }
        } else {
          checker.logger.debug("License check failed for " + JSON.stringify(productInfo));
          checker.logger.debug("Showing validation-needed dialog");
          checker.validationNeededNotifier.show(productInfo);
        }
        if (response.message) {
          console.log(response.message);
        }
      };
       // This is typically hidden already but when receiving a window message it is not
      this.logger.debug("Ensuring validation-needed dialog is hidden");
      this.validationNeededNotifier.hide(productInfo);
       if (this.logger.isDebug() && this.getForcedResponse(productInfo)) {
        var respJson = this.getForcedResponse(productInfo);
        this.clearForcedResponse(productInfo);
        if (JSON.parse(respJson).type == "error") {
          this.logger.debug("Forced error for check");
          onerror();
        } else {
          this.logger.debug("Forced response for check: " + respJson);
          onresponse(respJson);
        }
      } else {
        this.send(this.url, productInfo, onresponse, onerror);
      }
    }
  }, {
    key: 'send',
    value: function send(url, productInfo, onsuccess, onerror) {
      this.logger.debug("Sending request to " + url);
      var req = new XMLHttpRequest();
      req.withCredentials = true;
      req.addEventListener("readystatechange", function () {
        if (req.readyState === XMLHttpRequest.DONE && req.status === 200) {
          onsuccess(req.responseText);
        }
      });
      req.addEventListener("error", function () {
        onerror();
      });
      req.open("GET", url);
      req.setRequestHeader("check-source", "webcomponent");
      req.setRequestHeader("product-name", productInfo.name);
      req.setRequestHeader("product-version", productInfo.version);
       req.send();
    }
  }], [{
    key: 'version',
    get: function () {
      return '2.1.0';
    }
  }]);
  return VaadinLicenseChecker;
  }();
  var LicenseOkNotifier = function () {
  function LicenseOkNotifier() {
    classCallCheck(this, LicenseOkNotifier);
  }
   createClass(LicenseOkNotifier, [{
    key: 'getInstance',
    value: function getInstance() {
      return document.getElementById(LicenseOkNotifier.id);
    }
  }, {
    key: 'show',
    value: function show(productInfo) {
      // Only show one ok box even if multiple licenses were checked
      if (this.getInstance()) {
        // Already shown
        return;
      }
      var instance = document.createElement("vaadin-license-box");
      instance.id = LicenseOkNotifier.id;
      instance.type = "ok";
      instance.content = "Your license has been validated";
      document.body.appendChild(instance);
      instance.addEventListener("click", function () {
        instance.parentElement.removeChild(instance);
      });
    }
  }], [{
    key: 'id',
    get: function () {
      return 'vaadin-license-validation-ok';
    }
  }]);
  return LicenseOkNotifier;
  }();
  var LicenseValidationNeededNotifier = function () {
  function LicenseValidationNeededNotifier() {
    classCallCheck(this, LicenseValidationNeededNotifier);
  }
   createClass(LicenseValidationNeededNotifier, [{
    key: 'id',
    value: function id(productInfo) {
      return "vaadin-license-validation-notification-{product}".replace("{product}", productInfo.name);
    }
  }, {
    key: 'getInstance',
    value: function getInstance(productInfo) {
      return document.getElementById(this.id(productInfo));
    }
  }, {
    key: 'show',
    value: function show(productInfo) {
      if (this.getInstance(productInfo)) {
        // Already shown
        return;
      }
      var instance = document.createElement("vaadin-license-box");
      instance.id = this.id(productInfo);
      instance.type = "needsvalidation";
      instance.content = "Click to validate your Vaadin Subscription";
      document.body.appendChild(instance);
      instance.addEventListener("click", function () {
        window.open("https://vaadin.com/pro/validate-license", "_blank");
      });
    }
  }, {
    key: 'hide',
    value: function hide(productInfo) {
      var instance = this.getInstance(productInfo);
      if (instance) {
        instance.parentElement.removeChild(instance);
      }
    }
  }, {
    key: 'isVisible',
    value: function isVisible(productInfo) {
      return !!this.getInstance(productInfo);
    }
  }]);
  return LicenseValidationNeededNotifier;
  }();
  var proProducts = [];
  window.Vaadin = window.Vaadin || {};
  window.Vaadin.LicenseChecker = window.Vaadin.VaadinLicenseChecker || new VaadinLicenseChecker();
  window.Vaadin.LicenseCheckerClass = window.Vaadin.LicenseCheckerClass || VaadinLicenseChecker;
  window.Vaadin.developmentModeCallback = window.Vaadin.developmentModeCallback || {};
  window.Vaadin.developmentModeCallback["vaadin-license-checker"] = function (cls) {
  var productInfo = { name: cls.is, version: cls.version };
  proProducts.push(productInfo);
  window.addEventListener("message", function (e) {
    if (e.data == "validate-license") {
      window.Vaadin.LicenseChecker.check(productInfo);
    }
  }, false);
   window.Vaadin.checkLicenses = function () {
    // Force checking of all licenses to avoid e.g. popups during presentations when the grace period just has ended
    proProducts.forEach(function (productInfo) {
      window.Vaadin.LicenseChecker.check(productInfo);
    });
  };
   window.Vaadin.LicenseChecker.maybeCheck(productInfo);
  };
  }());
   vaadin-dev-mode:end **/
}

if (typeof runIfDevelopmentMode$1 === 'function') {
  runIfDevelopmentMode$1(maybeCheckLicenses);
}

/**
@license
Vaadin Charts
Copyright (C) 2015 Vaadin Ltd
This program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).
See the file LICENSE.md distributed with this software for more information about licensing.
See <a href="https://vaadin.com/license/cval-3">the website</a> for the complete license.
*/

if (!PolymerElement) {
  throw new Error(`Unexpected Polymer version ${Polymer.version} is used, expected v2.0.0 or later.`);
}
/**
 * `<vaadin-chart-series>` is a custom element for creating series for Vaadin Charts.
 *
 * ### Basic use
 *
 * To use `<vaadin-chart-series>`, simply add it inside a `<vaadin-chart>` element:
 *
 * ```
 *  <vaadin-chart>
 *    <vaadin-chart-series></vaadin-chart-series>
 *  </vaadin-chart>
 * ```
 *
 * `<vaadin-chart-series>` accepts `values` as an array attribute, so you can add it to your element definition:
 *
 * ```
 *  <vaadin-chart-series values="[10,20,30,40,50]"></vaadin-chart-series>
 * ```
 *
 * which will add a new line series, where each value will be a data point.
 * Look for the Properties session to see all available attributes.
 *
 * ### Dynamically adding and removing series
 *
 * You are also able to add and remove series by using DOM API.
 *
 * To create a new series, simply call `document.createElement('vaadin-chart-series')` and append it to your `<vaadin-chart>`:
 *
 * ```
 *  const chart = \* a <vaadin-chart> reference *\
 *  const newSeries = document.createElement('vaadin-chart-series');
 *  newSeries.values = [10,20,30,40,50];
 *  chart.appendChild(newSeries);
 * ```
 *
 * In order to remove it, you should use the series to be removed as a reference for the `#removeChild()` call:
 *
 * ```
 *  const chart = \* a <vaadin-chart> reference *\
 *  const seriesToBeRemoved = \* a <vaadin-chart-series> reference to remove*\
 *  chart.removeChild(seriesToBeRemoved);
 * ```
 *
 * (There's an issue with `#remove()` method on Firefox, so we advice to remove the element from its parent)
 *
 *
 * @polymer
 * @customElement
 * @extends {Polymer.Element}
 * @memberof Vaadin
 * @demo demo/index.html
 */


class ChartSeriesElement extends PolymerElement {
  static get is() {
    return 'vaadin-chart-series';
  }

  get options() {
    const options = ChartDeepMerger.__deepMerge({}, this.additionalOptions);

    if (this.type) {
      options.type = this.type;
    }

    if (this.title) {
      options.name = this.title;
    }

    if (this.values) {
      options.data = this.values;
    }

    if (this.markers) {
      if (!this.__isMarkersValid()) {
        this.markers = 'auto';
      }

      options.marker = this.__markersConfiguration;
    }

    if (this.unit) {
      options.yAxis = this.unit;
    }

    if (this.stack) {
      options.stack = this.stack;
    }

    if (isFinite(this.valueMin)) {
      options.yAxisValueMin = this.valueMin;
    }

    if (isFinite(this.valueMax)) {
      options.yAxisValueMax = this.valueMax;
    }

    if (this.neckWidth) {
      options.neckWidth = this.neckWidth;
    }

    if (this.neckPosition) {
      options.neckHeight = this.neckPosition;
    }

    return options;
  }

  static get properties() {
    return {
      /**
       * An array of data used by the series.
       * Format depends on the chart type and can be:
       *   - An array of numerical values `[y0, y1, y2, y3,...]`
       *   - An array of arrays with 2 values (`x`, `y`) `[ [x0, y0], [x1, y1], [x2, y2], ... ]`
       *   - An array of objects, each one describing one point `[ {x: x0, y: y0, name: 'Point0', color: '#FF0000'}, {...}, ...]`
       *
       *  See more in [API Site](https://api.highcharts.com/highcharts/series)
       *
       * Note that you should always use [Polymer API](https://www.polymer-project.org/2.0/docs/devguide/model-data#array-mutation)
       * to mutate the values array in order to make the component aware of the
       * change and be able to synchronize it.
       */
      values: {
        type: Array,
        value: () => []
      },

      /**
       *  Value-axis minimum-value.
       *  Sets the value to a series bound by 'unit' property.
       *  Otherwise sets the value to the first series.
       *  Undefined by default (determined from data).
       */
      valueMin: {
        type: Number,
        observer: '__valueMinObserver',
        reflectToAttribute: true
      },

      /**
       *  Value-axis maximum-value.
       *  See the 'valueMin'
       */
      valueMax: {
        type: Number,
        observer: '__valueMaxObserver',
        reflectToAttribute: true
      },

      /**
       *  A string with the type of the series.
       *  Defaults to `'line'` in case no type is set for the chart.
       * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type on `<vaadin-chart>`.
       */
      type: {
        type: String,
        observer: '__typeObserver',
        reflectToAttribute: true
      },

      /**
       * The name of the series as shown in the legend, tooltip etc.
       */
      title: {
        type: String,
        observer: '__titleObserver',
        reflectToAttribute: true
      },

      /**
       * Shows/hides data-point markers for line-like series.
       * Acceptable input are:
       *  - `shown`: markers are always visible
       *  - `hidden`: markers are always hidden
       *  - `auto`: markers are visible for widespread data and hidden, when data is dense *(default)*
       */
      markers: {
        type: String,
        observer: '__markersObserver',
        reflectToAttribute: true
      },

      /** Used to connect the series to an axis; if multiple series have the same “unit”, they will share axis.
       * Displayed as a title for the axis.
       * If no unit is defined, then series will be connected to the first axis.
       */
      unit: {
        type: String,
        observer: '__unitObserver',
        reflectToAttribute: true
      },

      /** Used to group series in a different stacks.
       * "stacking" property should be specified either for each series or in plotOptions.
       * It is recommended to place series in a single stack, when they belong to the same yAxis.
       */
      stack: {
        type: String,
        observer: '__stackObserver',
        reflectToAttribute: true
      },

      /** The height of the neck, the lower part of the funnel.
       * A number defines pixel width, a percentage string defines a percentage of the plot area height. Defaults to 30%.
       * Note that this property only applies for "funnel" charts.
       */
      neckPosition: {
        type: String,
        observer: '__neckPositionOberserver',
        reflectToAttribute: true
      },

      /** The width of the neck, the lower part of the funnel.
       * A number defines pixel width, a percentage string defines a percentage of the plot area width. Defaults to 30%.
       * Note that this property only applies for "funnel" charts.
       */
      neckWidth: {
        type: String,
        observer: '__neckWidthOberserver',
        reflectToAttribute: true
      },

      /**
       * Object with the configured options defined and used to create a series.
       *
       * @readonly
       */
      options: {
        type: Object
      },

      /**
       * Represents additional JSON configuration.
       */
      additionalOptions: {
        type: Object,
        reflectToAttribute: true
      }
    };
  }

  static get observers() {
    return ['__valuesObserver(values.splices)', '__additionalOptionsObserver(additionalOptions.*)'];
  }
  /** @private */


  disconnectedCallback() {
    super.disconnectedCallback();

    if (this.__hasSeriesConfig()) {
      this._series.remove();
    }
  }
  /**
   * Method to attach a series object of type `Highcharts.Series`.
   * @param series Object of type `Highcharts.Series`
   */


  setSeries(series) {
    this._series = series;
  }

  __valuesObserver() {
    if (this.__hasSeriesConfig()) {
      this._series.setData(this.values);
    }
  }

  __additionalOptionsObserver() {
    if (this.__hasSeriesConfig()) {
      this._series.update(this.additionalOptions);
    }
  }

  __valueMinObserver() {
    if (!this.__hasSeriesConfig()) {
      return;
    }

    if (!isFinite(this.valueMin)) {
      this.__showWarn('value-min', 'Numbers or null');

      return;
    }

    if (this._series.yAxis) {
      this._series.yAxis.update({
        min: this.valueMin
      });
    }
  }

  __valueMaxObserver() {
    if (!this.__hasSeriesConfig()) {
      return;
    }

    if (!isFinite(this.valueMax)) {
      this.__showWarn('value-max', 'Numbers or null');

      return;
    }

    if (this._series.yAxis) {
      this._series.yAxis.update({
        max: this.valueMax
      });
    }
  }

  __typeObserver() {
    if (this.__hasSeriesConfig()) {
      this._series.update({
        type: this.type
      });
    }
  }

  __titleObserver() {
    if (this.__hasSeriesConfig()) {
      this._series.update({
        name: this.title
      });
    }
  }

  __stackObserver() {
    if (!this.__hasSeriesConfig()) {
      return;
    }

    this._series.update({
      stack: this.stack
    });
  }

  __neckPositionOberserver() {
    if (!this.__hasSeriesConfig()) {
      return;
    }

    this._series.update({
      neckHeight: this.neckPosition
    });
  }

  __neckWidthOberserver() {
    if (!this.__hasSeriesConfig()) {
      return;
    }

    this._series.update({
      neckWidth: this.neckWidth
    });
  }

  __unitObserver() {
    if (this.__hasSeriesConfig()) {
      const parent = this.parentNode instanceof ChartElement && this.parentNode;

      if (parent && parent instanceof ChartElement) {
        if (this.unit && !parent.__getAxis(this.unit)) {
          const title = {
            title: {
              text: this.unit
            }
          };

          parent.__addAxis(Object.assign({
            id: this.unit,
            axisGenerated: true
          }, title));
        }

        this._series.update({
          yAxis: this.unit || 0
        });

        this.__valueMinObserver();

        this.__valueMaxObserver();

        parent.__removeAxisIfEmpty();
      }
    }
  }

  __hasSeriesConfig() {
    return !!this._series;
  }

  __isMarkersValid() {
    if (['shown', 'hidden', 'auto'].indexOf(this.markers) === -1) {
      this.__showWarn('markers', '"shown", "hidden" or "auto"');

      return false;
    }

    return true;
  }

  __markersObserver() {
    if (!this.__isMarkersValid()) {
      this.markers = 'auto';
      return;
    }

    if (this.__hasSeriesConfig()) {
      this._series.update({
        marker: this.__markersConfiguration
      });
    }
  }

  get __markersConfiguration() {
    const config = {};

    switch (this.markers) {
      case 'shown':
        config.enabled = true;
        break;

      case 'hidden':
        config.enabled = false;
        break;

      case 'auto':
      default:
        config.enabled = null;
        break;
    }

    return config;
  }

  __showWarn(propertyName, acceptedValues) {
    console.warn('<vaadin-chart-series> Acceptable values for "' + propertyName + '" are ' + acceptedValues);
  }

}

customElements.define(ChartSeriesElement.is, ChartSeriesElement);

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
let nativeCssVariables_;
/**
 * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings
 */

function calcCssVariables(settings) {
  if (settings && settings['shimcssproperties']) {
    nativeCssVariables_ = false;
  } else {
    // chrome 49 has semi-working css vars, check if box-shadow works
    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782
    // However, shim css custom properties are only supported with ShadyDOM enabled,
    // so fall back on native if we do not detect ShadyDOM
    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/
    nativeCssVariables_ = nativeShadow || Boolean(!navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));
  }
}
/** @type {string | undefined} */


let cssBuild;

if (window.ShadyCSS && window.ShadyCSS.cssBuild !== undefined) {
  cssBuild = window.ShadyCSS.cssBuild;
}
/** @type {boolean} */


const disableRuntime = Boolean(window.ShadyCSS && window.ShadyCSS.disableRuntime);

if (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {
  nativeCssVariables_ = window.ShadyCSS.nativeCss;
} else if (window.ShadyCSS) {
  calcCssVariables(window.ShadyCSS); // reset window variable to let ShadyCSS API take its place

  window.ShadyCSS = undefined;
} else {
  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);
} // Hack for type error under new type inference which doesn't like that
// nativeCssVariables is updated in a function and assigns the type
// `function(): ?` instead of `boolean`.


const nativeCssVariables =
/** @type {boolean} */
nativeCssVariables_;

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/** @unrestricted */

class StyleNode {
  constructor() {
    /** @type {number} */
    this['start'] = 0;
    /** @type {number} */

    this['end'] = 0;
    /** @type {StyleNode} */

    this['previous'] = null;
    /** @type {StyleNode} */

    this['parent'] = null;
    /** @type {Array<StyleNode>} */

    this['rules'] = null;
    /** @type {string} */

    this['parsedCssText'] = '';
    /** @type {string} */

    this['cssText'] = '';
    /** @type {boolean} */

    this['atRule'] = false;
    /** @type {number} */

    this['type'] = 0;
    /** @type {string} */

    this['keyframesName'] = '';
    /** @type {string} */

    this['selector'] = '';
    /** @type {string} */

    this['parsedSelector'] = '';
  }

}

/**
 * @param {string} text
 * @return {StyleNode}
 */

function parse$1(text) {
  text = clean(text);
  return parseCss(lex(text), text);
} // remove stuff we don't care about that may hinder parsing

/**
 * @param {string} cssText
 * @return {string}
 */

function clean(cssText) {
  return cssText.replace(RX.comments, '').replace(RX.port, '');
} // super simple {...} lexer that returns a node tree

/**
 * @param {string} text
 * @return {StyleNode}
 */


function lex(text) {
  let root = new StyleNode();
  root['start'] = 0;
  root['end'] = text.length;
  let n = root;

  for (let i = 0, l = text.length; i < l; i++) {
    if (text[i] === OPEN_BRACE) {
      if (!n['rules']) {
        n['rules'] = [];
      }

      let p = n;
      let previous = p['rules'][p['rules'].length - 1] || null;
      n = new StyleNode();
      n['start'] = i + 1;
      n['parent'] = p;
      n['previous'] = previous;
      p['rules'].push(n);
    } else if (text[i] === CLOSE_BRACE) {
      n['end'] = i + 1;
      n = n['parent'] || root;
    }
  }

  return root;
} // add selectors/cssText to node tree

/**
 * @param {StyleNode} node
 * @param {string} text
 * @return {StyleNode}
 */


function parseCss(node, text) {
  let t = text.substring(node['start'], node['end'] - 1);
  node['parsedCssText'] = node['cssText'] = t.trim();

  if (node['parent']) {
    let ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];
    t = text.substring(ss, node['start'] - 1);
    t = _expandUnicodeEscapes(t);
    t = t.replace(RX.multipleSpaces, ' '); // TODO(sorvell): ad hoc; make selector include only after last ;
    // helps with mixin syntax

    t = t.substring(t.lastIndexOf(';') + 1);
    let s = node['parsedSelector'] = node['selector'] = t.trim();
    node['atRule'] = s.indexOf(AT_START) === 0; // note, support a subset of rule types...

    if (node['atRule']) {
      if (s.indexOf(MEDIA_START) === 0) {
        node['type'] = types.MEDIA_RULE;
      } else if (s.match(RX.keyframesRule)) {
        node['type'] = types.KEYFRAMES_RULE;
        node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();
      }
    } else {
      if (s.indexOf(VAR_START) === 0) {
        node['type'] = types.MIXIN_RULE;
      } else {
        node['type'] = types.STYLE_RULE;
      }
    }
  }

  let r$ = node['rules'];

  if (r$) {
    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      parseCss(r, text);
    }
  }

  return node;
}
/**
 * conversion of sort unicode escapes with spaces like `\33 ` (and longer) into
 * expanded form that doesn't require trailing space `\000033`
 * @param {string} s
 * @return {string}
 */


function _expandUnicodeEscapes(s) {
  return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
    let code = arguments[1],
        repeat = 6 - code.length;

    while (repeat--) {
      code = '0' + code;
    }

    return '\\' + code;
  });
}
/**
 * stringify parsed css.
 * @param {StyleNode} node
 * @param {boolean=} preserveProperties
 * @param {string=} text
 * @return {string}
 */


function stringify(node, preserveProperties, text = '') {
  // calc rule cssText
  let cssText = '';

  if (node['cssText'] || node['rules']) {
    let r$ = node['rules'];

    if (r$ && !_hasMixinRules(r$)) {
      for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
        cssText = stringify(r, preserveProperties, cssText);
      }
    } else {
      cssText = preserveProperties ? node['cssText'] : removeCustomProps(node['cssText']);
      cssText = cssText.trim();

      if (cssText) {
        cssText = '  ' + cssText + '\n';
      }
    }
  } // emit rule if there is cssText


  if (cssText) {
    if (node['selector']) {
      text += node['selector'] + ' ' + OPEN_BRACE + '\n';
    }

    text += cssText;

    if (node['selector']) {
      text += CLOSE_BRACE + '\n\n';
    }
  }

  return text;
}
/**
 * @param {Array<StyleNode>} rules
 * @return {boolean}
 */

function _hasMixinRules(rules) {
  let r = rules[0];
  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;
}
/**
 * @param {string} cssText
 * @return {string}
 */


function removeCustomProps(cssText) {
  cssText = removeCustomPropAssignment(cssText);
  return removeCustomPropApply(cssText);
}
/**
 * @param {string} cssText
 * @return {string}
 */


function removeCustomPropAssignment(cssText) {
  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');
}
/**
 * @param {string} cssText
 * @return {string}
 */

function removeCustomPropApply(cssText) {
  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');
}
/** @enum {number} */


const types = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7,
  MEDIA_RULE: 4,
  MIXIN_RULE: 1000
};
const OPEN_BRACE = '{';
const CLOSE_BRACE = '}'; // helper regexp's

const RX = {
  comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
  port: /@import[^;]*;/gim,
  customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
  mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
  mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
  varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
  keyframesRule: /^@[^\s]*keyframes/,
  multipleSpaces: /\s+/g
};
const VAR_START = '--';
const MEDIA_START = '@media';
const AT_START = '@';

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const VAR_ASSIGN = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi;
const MIXIN_MATCH = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi;
const VAR_CONSUMED = /(--[\w-]+)\s*([:,;)]|$)/gi;
const ANIMATION_MATCH = /(animation\s*:)|(animation-name\s*:)/;
const MEDIA_MATCH = /@media\s(.*)/;
const BRACKETED = /\{[^}]*\}/g;
const HOST_PREFIX = '(?:^|[^.#[:])';
const HOST_SUFFIX = '($|[.:[\\s>+~])';

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/** @type {!Set<string>} */

const styleTextSet = new Set();
const scopingAttribute = 'shady-unscoped';
/**
 * Add a specifically-marked style to the document directly, and only one copy of that style.
 *
 * @param {!HTMLStyleElement} style
 * @return {undefined}
 */

function processUnscopedStyle(style) {
  const text = style.textContent;

  if (!styleTextSet.has(text)) {
    styleTextSet.add(text);
    const newStyle = style.cloneNode(true);
    document.head.appendChild(newStyle);
  }
}
/**
 * Check if a style is supposed to be unscoped
 * @param {!HTMLStyleElement} style
 * @return {boolean} true if the style has the unscoping attribute
 */

function isUnscopedStyle(style) {
  return style.hasAttribute(scopingAttribute);
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
 * @param {string|StyleNode} rules
 * @param {function(StyleNode)=} callback
 * @return {string}
 */

function toCssText(rules, callback) {
  if (!rules) {
    return '';
  }

  if (typeof rules === 'string') {
    rules = parse$1(rules);
  }

  if (callback) {
    forEachRule(rules, callback);
  }

  return stringify(rules, nativeCssVariables);
}
/**
 * @param {HTMLStyleElement} style
 * @return {StyleNode}
 */

function rulesForStyle(style) {
  if (!style['__cssRules'] && style.textContent) {
    style['__cssRules'] = parse$1(style.textContent);
  }

  return style['__cssRules'] || null;
} // Tests if a rule is a keyframes selector, which looks almost exactly
// like a normal selector but is not (it has nothing to do with scoping
// for example).

/**
 * @param {StyleNode} rule
 * @return {boolean}
 */

function isKeyframesSelector(rule) {
  return Boolean(rule['parent']) && rule['parent']['type'] === types.KEYFRAMES_RULE;
}
/**
 * @param {StyleNode} node
 * @param {Function=} styleRuleCallback
 * @param {Function=} keyframesRuleCallback
 * @param {boolean=} onlyActiveRules
 */

function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
  if (!node) {
    return;
  }

  let skipRules = false;
  let type = node['type'];

  if (onlyActiveRules) {
    if (type === types.MEDIA_RULE) {
      let matchMedia = node['selector'].match(MEDIA_MATCH);

      if (matchMedia) {
        // if rule is a non matching @media rule, skip subrules
        if (!window.matchMedia(matchMedia[1]).matches) {
          skipRules = true;
        }
      }
    }
  }

  if (type === types.STYLE_RULE) {
    styleRuleCallback(node);
  } else if (keyframesRuleCallback && type === types.KEYFRAMES_RULE) {
    keyframesRuleCallback(node);
  } else if (type === types.MIXIN_RULE) {
    skipRules = true;
  }

  let r$ = node['rules'];

  if (r$ && !skipRules) {
    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
    }
  }
} // add a string of cssText to the document.

/**
 * @param {string} cssText
 * @param {string} moniker
 * @param {Node} target
 * @param {Node} contextNode
 * @return {HTMLStyleElement}
 */

function applyCss(cssText, moniker, target, contextNode) {
  let style = createScopeStyle(cssText, moniker);
  applyStyle(style, target, contextNode);
  return style;
}
/**
 * @param {string} cssText
 * @param {string} moniker
 * @return {HTMLStyleElement}
 */

function createScopeStyle(cssText, moniker) {
  let style =
  /** @type {HTMLStyleElement} */
  document.createElement('style');

  if (moniker) {
    style.setAttribute('scope', moniker);
  }

  style.textContent = cssText;
  return style;
}
/**
 * Track the position of the last added style for placing placeholders
 * @type {Node}
 */

let lastHeadApplyNode = null; // insert a comment node as a styling position placeholder.

/**
 * @param {string} moniker
 * @return {!Comment}
 */

function applyStylePlaceHolder(moniker) {
  let placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
  let after = lastHeadApplyNode ? lastHeadApplyNode['nextSibling'] : null;
  let scope = document.head;
  scope.insertBefore(placeHolder, after || scope.firstChild);
  lastHeadApplyNode = placeHolder;
  return placeHolder;
}
/**
 * @param {HTMLStyleElement} style
 * @param {?Node} target
 * @param {?Node} contextNode
 */

function applyStyle(style, target, contextNode) {
  target = target || document.head;
  let after = contextNode && contextNode.nextSibling || target.firstChild;
  target.insertBefore(style, after);

  if (!lastHeadApplyNode) {
    lastHeadApplyNode = style;
  } else {
    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode
    let position = style.compareDocumentPosition(lastHeadApplyNode);

    if (position === Node.DOCUMENT_POSITION_PRECEDING) {
      lastHeadApplyNode = style;
    }
  }
}
/**
 * @param {string} buildType
 * @return {boolean}
 */

function isTargetedBuild(buildType) {
  return nativeShadow ? buildType === 'shadow' : buildType === 'shady';
}
/**
 * Walk from text[start] matching parens and
 * returns position of the outer end paren
 * @param {string} text
 * @param {number} start
 * @return {number}
 */

function findMatchingParen(text, start) {
  let level = 0;

  for (let i = start, l = text.length; i < l; i++) {
    if (text[i] === '(') {
      level++;
    } else if (text[i] === ')') {
      if (--level === 0) {
        return i;
      }
    }
  }

  return -1;
}
/**
 * @param {string} str
 * @param {function(string, string, string, string)} callback
 */

function processVariableAndFallback(str, callback) {
  // find 'var('
  let start = str.indexOf('var(');

  if (start === -1) {
    // no var?, everything is prefix
    return callback(str, '', '', '');
  } //${prefix}var(${inner})${suffix}


  let end = findMatchingParen(str, start + 3);
  let inner = str.substring(start + 4, end);
  let prefix = str.substring(0, start); // suffix may have other variables

  let suffix = processVariableAndFallback(str.substring(end + 1), callback);
  let comma = inner.indexOf(','); // value and fallback args should be trimmed to match in property lookup

  if (comma === -1) {
    // variable, no fallback
    return callback(prefix, inner.trim(), '', suffix);
  } // var(${value},${fallback})


  let value = inner.substring(0, comma).trim();
  let fallback = inner.substring(comma + 1).trim();
  return callback(prefix, value, fallback, suffix);
}
/**
 * @param {Element} element
 * @param {string} value
 */

function setElementClassRaw(element, value) {
  // use native setAttribute provided by ShadyDOM when setAttribute is patched
  if (nativeShadow) {
    element.setAttribute('class', value);
  } else {
    window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);
  }
}
/**
 * @type {function(*):*}
 */

const wrap$1 = window['ShadyDOM'] && window['ShadyDOM']['wrap'] || (node => node);
/**
 * @param {Element | {is: string, extends: string}} element
 * @return {{is: string, typeExtension: string}}
 */

function getIsExtends(element) {
  let localName = element['localName'];
  let is = '',
      typeExtension = '';
  /*
  NOTE: technically, this can be wrong for certain svg elements
  with `-` in the name like `<font-face>`
  */

  if (localName) {
    if (localName.indexOf('-') > -1) {
      is = localName;
    } else {
      typeExtension = localName;
      is = element.getAttribute && element.getAttribute('is') || '';
    }
  } else {
    is =
    /** @type {?} */
    element.is;
    typeExtension =
    /** @type {?} */
    element.extends;
  }

  return {
    is,
    typeExtension
  };
}
/**
 * @param {Element|DocumentFragment} element
 * @return {string}
 */

function gatherStyleText(element) {
  /** @type {!Array<string>} */
  const styleTextParts = [];
  const styles =
  /** @type {!NodeList<!HTMLStyleElement>} */
  element.querySelectorAll('style');

  for (let i = 0; i < styles.length; i++) {
    const style = styles[i];

    if (isUnscopedStyle(style)) {
      if (!nativeShadow) {
        processUnscopedStyle(style);
        style.parentNode.removeChild(style);
      }
    } else {
      styleTextParts.push(style.textContent);
      style.parentNode.removeChild(style);
    }
  }

  return styleTextParts.join('').trim();
}
/**
 * Split a selector separated by commas into an array in a smart way
 * @param {string} selector
 * @return {!Array<string>}
 */

function splitSelectorList(selector) {
  const parts = [];
  let part = '';

  for (let i = 0; i >= 0 && i < selector.length; i++) {
    // A selector with parentheses will be one complete part
    if (selector[i] === '(') {
      // find the matching paren
      const end = findMatchingParen(selector, i); // push the paren block into the part

      part += selector.slice(i, end + 1); // move the index to after the paren block

      i = end;
    } else if (selector[i] === ',') {
      parts.push(part);
      part = '';
    } else {
      part += selector[i];
    }
  } // catch any pieces after the last comma


  if (part) {
    parts.push(part);
  }

  return parts;
}
const CSS_BUILD_ATTR = 'css-build';
/**
 * Return the polymer-css-build "build type" applied to this element
 *
 * @param {!HTMLElement} element
 * @return {string} Can be "", "shady", or "shadow"
 */

function getCssBuild(element) {
  if (cssBuild !== undefined) {
    return (
      /** @type {string} */
      cssBuild
    );
  }

  if (element.__cssBuild === undefined) {
    // try attribute first, as it is the common case
    const attrValue = element.getAttribute(CSS_BUILD_ATTR);

    if (attrValue) {
      element.__cssBuild = attrValue;
    } else {
      const buildComment = getBuildComment(element);

      if (buildComment !== '') {
        // remove build comment so it is not needlessly copied into every element instance
        removeBuildComment(element);
      }

      element.__cssBuild = buildComment;
    }
  }

  return element.__cssBuild || '';
}
/**
 * Check if the given element, either a <template> or <style>, has been processed
 * by polymer-css-build.
 *
 * If so, then we can make a number of optimizations:
 * - polymer-css-build will decompose mixins into individual CSS Custom Properties,
 * so the ApplyShim can be skipped entirely.
 * - Under native ShadowDOM, the style text can just be copied into each instance
 * without modification
 * - If the build is "shady" and ShadyDOM is in use, the styling does not need
 * scoping beyond the shimming of CSS Custom Properties
 *
 * @param {!HTMLElement} element
 * @return {boolean}
 */

function elementHasBuiltCss(element) {
  return getCssBuild(element) !== '';
}
/**
 * For templates made with tagged template literals, polymer-css-build will
 * insert a comment of the form `<!--css-build:shadow-->`
 *
 * @param {!HTMLElement} element
 * @return {string}
 */

function getBuildComment(element) {
  const buildComment = element.localName === 'template' ?
  /** @type {!HTMLTemplateElement} */
  element.content.firstChild : element.firstChild;

  if (buildComment instanceof Comment) {
    const commentParts = buildComment.textContent.trim().split(':');

    if (commentParts[0] === CSS_BUILD_ATTR) {
      return commentParts[1];
    }
  }

  return '';
}
/**
 * Check if the css build status is optimal, and do no unneeded work.
 *
 * @param {string=} cssBuild CSS build status
 * @return {boolean} css build is optimal or not
 */

function isOptimalCssBuild(cssBuild = '') {
  // CSS custom property shim always requires work
  if (cssBuild === '' || !nativeCssVariables) {
    return false;
  }

  return nativeShadow ? cssBuild === 'shadow' : cssBuild === 'shady';
}
/**
 * @param {!HTMLElement} element
 */

function removeBuildComment(element) {
  const buildComment = element.localName === 'template' ?
  /** @type {!HTMLTemplateElement} */
  element.content.firstChild : element.firstChild;
  buildComment.parentNode.removeChild(buildComment);
}

var StyleUtil = /*#__PURE__*/Object.freeze({
  toCssText: toCssText,
  rulesForStyle: rulesForStyle,
  isKeyframesSelector: isKeyframesSelector,
  forEachRule: forEachRule,
  applyCss: applyCss,
  createScopeStyle: createScopeStyle,
  applyStylePlaceHolder: applyStylePlaceHolder,
  applyStyle: applyStyle,
  isTargetedBuild: isTargetedBuild,
  findMatchingParen: findMatchingParen,
  processVariableAndFallback: processVariableAndFallback,
  setElementClassRaw: setElementClassRaw,
  wrap: wrap$1,
  getIsExtends: getIsExtends,
  gatherStyleText: gatherStyleText,
  splitSelectorList: splitSelectorList,
  getCssBuild: getCssBuild,
  elementHasBuiltCss: elementHasBuiltCss,
  getBuildComment: getBuildComment,
  isOptimalCssBuild: isOptimalCssBuild
});

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/* Transforms ShadowDOM styling into ShadyDOM styling

* scoping:

  * elements in scope get scoping selector class="x-foo-scope"
  * selectors re-written as follows:

    div button -> div.x-foo-scope button.x-foo-scope

* :host -> scopeName

* :host(...) -> scopeName...

* ::slotted(...) -> scopeName > ...

* ...:dir(ltr|rtl) -> [dir="ltr|rtl"] ..., ...[dir="ltr|rtl"]

* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir="rtl"] scopeName, scopeName[dir="rtl"]

*/

const SCOPE_NAME = 'style-scope';

class StyleTransformer {
  get SCOPE_NAME() {
    return SCOPE_NAME;
  }
  /**
   * Given a node and scope name, add a scoping class to each node
   * in the tree. This facilitates transforming css into scoped rules.
   * @param {!Node} node
   * @param {string} scope
   * @param {boolean=} shouldRemoveScope
   * @deprecated
   */


  dom(node, scope, shouldRemoveScope) {
    const fn = node => {
      this.element(node, scope || '', shouldRemoveScope);
    };

    this._transformDom(node, fn);
  }
  /**
   * Given a node and scope name, add a scoping class to each node in the tree.
   * @param {!Node} node
   * @param {string} scope
   */


  domAddScope(node, scope) {
    const fn = node => {
      this.element(node, scope || '');
    };

    this._transformDom(node, fn);
  }
  /**
   * @param {!Node} startNode
   * @param {!function(!Node)} transformer
   */


  _transformDom(startNode, transformer) {
    if (startNode.nodeType === Node.ELEMENT_NODE) {
      transformer(startNode);
    }

    let c$;

    if (startNode.localName === 'template') {
      const template =
      /** @type {!HTMLTemplateElement} */
      startNode; // In case the template is in svg context, fall back to the node
      // since it won't be an HTMLTemplateElement with a .content property

      c$ = (template.content || template._content || template).childNodes;
    } else {
      c$ =
      /** @type {!ParentNode} */
      startNode.children || startNode.childNodes;
    }

    if (c$) {
      for (let i = 0; i < c$.length; i++) {
        this._transformDom(c$[i], transformer);
      }
    }
  }
  /**
   * @param {?} element
   * @param {?} scope
   * @param {?=} shouldRemoveScope
   */


  element(element, scope, shouldRemoveScope) {
    // note: if using classes, we add both the general 'style-scope' class
    // as well as the specific scope. This enables easy filtering of all
    // `style-scope` elements
    if (scope) {
      // note: svg on IE does not have classList so fallback to class
      if (element.classList) {
        if (shouldRemoveScope) {
          element.classList.remove(SCOPE_NAME);
          element.classList.remove(scope);
        } else {
          element.classList.add(SCOPE_NAME);
          element.classList.add(scope);
        }
      } else if (element.getAttribute) {
        let c = element.getAttribute(CLASS);

        if (shouldRemoveScope) {
          if (c) {
            let newValue = c.replace(SCOPE_NAME, '').replace(scope, '');
            setElementClassRaw(element, newValue);
          }
        } else {
          let newValue = (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope;
          setElementClassRaw(element, newValue);
        }
      }
    }
  }
  /**
   * Given a node, replace the scoping class to each subnode in the tree.
   * @param {!Node} node
   * @param {string} oldScope
   * @param {string} newScope
   */


  domReplaceScope(node, oldScope, newScope) {
    const fn = node => {
      this.element(node, oldScope, true);
      this.element(node, newScope);
    };

    this._transformDom(node, fn);
  }
  /**
   * Given a node, remove the scoping class to each subnode in the tree.
   * @param {!Node} node
   * @param {string} oldScope
   */


  domRemoveScope(node, oldScope) {
    const fn = node => {
      this.element(node, oldScope || '', true);
    };

    this._transformDom(node, fn);
  }
  /**
   * @param {?} element
   * @param {?} styleRules
   * @param {?=} callback
   * @param {string=} cssBuild
   * @param {string=} cssText
   * @return {string}
   */


  elementStyles(element, styleRules, callback, cssBuild = '', cssText = '') {
    // no need to shim selectors if settings.useNativeShadow, also
    // a shady css build will already have transformed selectors
    // NOTE: This method may be called as part of static or property shimming.
    // When there is a targeted build it will not be called for static shimming,
    // but when the property shim is used it is called and should opt out of
    // static shimming work when a proper build exists.
    if (cssText === '') {
      if (nativeShadow || cssBuild === 'shady') {
        cssText = toCssText(styleRules, callback);
      } else {
        let {
          is,
          typeExtension
        } = getIsExtends(element);
        cssText = this.css(styleRules, is, typeExtension, callback) + '\n\n';
      }
    }

    return cssText.trim();
  } // Given a string of cssText and a scoping string (scope), returns
  // a string of scoped css where each selector is transformed to include
  // a class created from the scope. ShadowDOM selectors are also transformed
  // (e.g. :host) to use the scoping selector.


  css(rules, scope, ext, callback) {
    let hostScope = this._calcHostScope(scope, ext);

    scope = this._calcElementScope(scope);
    let self = this;
    return toCssText(rules, function (
    /** StyleNode */
    rule) {
      if (!rule.isScoped) {
        self.rule(rule, scope, hostScope);
        rule.isScoped = true;
      }

      if (callback) {
        callback(rule, scope, hostScope);
      }
    });
  }

  _calcElementScope(scope) {
    if (scope) {
      return CSS_CLASS_PREFIX + scope;
    } else {
      return '';
    }
  }

  _calcHostScope(scope, ext) {
    return ext ? `[is=${scope}]` : scope;
  }

  rule(rule, scope, hostScope) {
    this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
  }
  /**
   * transforms a css rule to a scoped rule.
   *
   * @param {StyleNode} rule
   * @param {Function} transformer
   * @param {string=} scope
   * @param {string=} hostScope
   */


  _transformRule(rule, transformer, scope, hostScope) {
    // NOTE: save transformedSelector for subsequent matching of elements
    // against selectors (e.g. when calculating style properties)
    rule['selector'] = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);
  }
  /**
   * @param {StyleNode} rule
   * @param {Function} transformer
   * @param {string=} scope
   * @param {string=} hostScope
   */


  _transformRuleCss(rule, transformer, scope, hostScope) {
    let p$ = splitSelectorList(rule['selector']); // we want to skip transformation of rules that appear in keyframes,
    // because they are keyframe selectors, not element selectors.

    if (!isKeyframesSelector(rule)) {
      for (let i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
        p$[i] = transformer.call(this, p, scope, hostScope);
      }
    }

    return p$.filter(part => Boolean(part)).join(COMPLEX_SELECTOR_SEP);
  }
  /**
   * @param {string} selector
   * @return {string}
   */


  _twiddleNthPlus(selector) {
    return selector.replace(NTH, (m, type, inside) => {
      if (inside.indexOf('+') > -1) {
        inside = inside.replace(/\+/g, '___');
      } else if (inside.indexOf('___') > -1) {
        inside = inside.replace(/___/g, '+');
      }

      return `:${type}(${inside})`;
    });
  }
  /**
   * Preserve `:matches()` selectors by replacing them with MATCHES_REPLACMENT
   * and returning an array of `:matches()` selectors.
   * Use `_replacesMatchesPseudo` to replace the `:matches()` parts
   *
   * @param {string} selector
   * @return {{selector: string, matches: !Array<string>}}
   */


  _preserveMatchesPseudo(selector) {
    /** @type {!Array<string>} */
    const matches = [];
    let match;

    while (match = selector.match(MATCHES)) {
      const start = match.index;
      const end = findMatchingParen(selector, start);

      if (end === -1) {
        throw new Error(`${match.input} selector missing ')'`);
      }

      const part = selector.slice(start, end + 1);
      selector = selector.replace(part, MATCHES_REPLACEMENT);
      matches.push(part);
    }

    return {
      selector,
      matches
    };
  }
  /**
   * Replace MATCHES_REPLACMENT character with the given set of `:matches()`
   * selectors.
   *
   * @param {string} selector
   * @param {!Array<string>} matches
   * @return {string}
   */


  _replaceMatchesPseudo(selector, matches) {
    const parts = selector.split(MATCHES_REPLACEMENT);
    return matches.reduce((acc, cur, idx) => acc + cur + parts[idx + 1], parts[0]);
  }
  /**
   * @param {string} selector
   * @param {string} scope
   * @param {string=} hostScope
   */


  _transformComplexSelector(selector, scope, hostScope) {
    let stop = false;
    selector = selector.trim(); // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP

    let isNth = NTH.test(selector);

    if (isNth) {
      selector = selector.replace(NTH, (m, type, inner) => `:${type}(${inner.replace(/\s/g, '')})`);
      selector = this._twiddleNthPlus(selector);
    } // Preserve selectors like `:-webkit-any` so that SIMPLE_SELECTOR_SEP does
    // not get confused by spaces inside the pseudo selector


    const isMatches = MATCHES.test(selector);
    /** @type {!Array<string>} */

    let matches;

    if (isMatches) {
      ({
        selector,
        matches
      } = this._preserveMatchesPseudo(selector));
    }

    selector = selector.replace(SLOTTED_START, `${HOST} $1`);
    selector = selector.replace(SIMPLE_SELECTOR_SEP, (m, c, s) => {
      if (!stop) {
        let info = this._transformCompoundSelector(s, c, scope, hostScope);

        stop = stop || info.stop;
        c = info.combinator;
        s = info.value;
      }

      return c + s;
    }); // replace `:matches()` selectors

    if (isMatches) {
      selector = this._replaceMatchesPseudo(selector, matches);
    }

    if (isNth) {
      selector = this._twiddleNthPlus(selector);
    }

    selector = selector.replace(DIR_PAREN, (m, before, dir, after) => `[dir="${dir}"] ${before}${after}, ${before}[dir="${dir}"]${after}`);
    return selector;
  }

  _transformCompoundSelector(selector, combinator, scope, hostScope) {
    // replace :host with host scoping class
    let slottedIndex = selector.indexOf(SLOTTED);

    if (selector.indexOf(HOST) >= 0) {
      selector = this._transformHostSelector(selector, hostScope); // replace other selectors with scoping class
    } else if (slottedIndex !== 0) {
      selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
    } // mark ::slotted() scope jump to replace with descendant selector + arg
    // also ignore left-side combinator


    let slotted = false;

    if (slottedIndex >= 0) {
      combinator = '';
      slotted = true;
    } // process scope jumping selectors up to the scope jump and then stop


    let stop;

    if (slotted) {
      stop = true;

      if (slotted) {
        // .zonk ::slotted(.foo) -> .zonk.scope > .foo
        selector = selector.replace(SLOTTED_PAREN, (m, paren) => ` > ${paren}`);
      }
    }

    return {
      value: selector,
      combinator,
      stop
    };
  }

  _transformSimpleSelector(selector, scope) {
    const attributes = selector.split(/(\[.+?\])/);
    const output = [];

    for (let i = 0; i < attributes.length; i++) {
      // Do not attempt to transform any attribute selector content
      if (i % 2 === 1) {
        output.push(attributes[i]);
      } else {
        const part = attributes[i];

        if (!(part === '' && i === attributes.length - 1)) {
          let p$ = part.split(PSEUDO_PREFIX);
          p$[0] += scope;
          output.push(p$.join(PSEUDO_PREFIX));
        }
      }
    }

    return output.join('');
  } // :host(...) -> scopeName...


  _transformHostSelector(selector, hostScope) {
    let m = selector.match(HOST_PAREN);
    let paren = m && m[2].trim() || '';

    if (paren) {
      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
        // paren starts with a type selector
        let typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0]; // if the type selector is our hostScope then avoid pre-pending it

        if (typeSelector === hostScope) {
          return paren; // otherwise, this selector should not match in this scope so
          // output a bogus selector.
        } else {
          return SELECTOR_NO_MATCH;
        }
      } else {
        // make sure to do a replace here to catch selectors like:
        // `:host(.foo)::before`
        return selector.replace(HOST_PAREN, function (m, host, paren) {
          return hostScope + paren;
        });
      } // if no paren, do a straight :host replacement.
      // TODO(sorvell): this should not strictly be necessary but
      // it's needed to maintain support for `:host[foo]` type selectors
      // which have been improperly used under Shady DOM. This should be
      // deprecated.

    } else {
      return selector.replace(HOST, hostScope);
    }
  }
  /**
   * @param {StyleNode} rule
   */


  documentRule(rule) {
    // reset selector in case this is redone.
    rule['selector'] = rule['parsedSelector'];
    this.normalizeRootSelector(rule);

    this._transformRule(rule, this._transformDocumentSelector);
  }
  /**
   * @param {StyleNode} rule
   */


  normalizeRootSelector(rule) {
    if (rule['selector'] === ROOT) {
      rule['selector'] = 'html';
    }
  }
  /**
   * @param {string} selector
   */


  _transformDocumentSelector(selector) {
    if (selector.match(HOST)) {
      // remove ':host' type selectors in document rules
      return '';
    } else if (selector.match(SLOTTED)) {
      return this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR);
    } else {
      return this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
    }
  }

}

const NTH = /:(nth[-\w]+)\(([^)]+)\)/;
const SCOPE_DOC_SELECTOR = `:not(.${SCOPE_NAME})`;
const COMPLEX_SELECTOR_SEP = ',';
const SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=[])+)/g;
const SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;
const HOST = ':host';
const ROOT = ':root';
const SLOTTED = '::slotted';
const SLOTTED_START = new RegExp(`^(${SLOTTED})`); // NOTE: this supports 1 nested () pair for things like
// :host(:not([selected]), more general support requires
// parsing which seems like overkill

const HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/; // similar to HOST_PAREN

const SLOTTED_PAREN = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
const DIR_PAREN = /(.*):dir\((?:(ltr|rtl))\)(.*)/;
const CSS_CLASS_PREFIX = '.';
const PSEUDO_PREFIX = ':';
const CLASS = 'class';
const SELECTOR_NO_MATCH = 'should_not_match';
const MATCHES = /:(?:matches|any|-(?:webkit|moz)-any)/;
const MATCHES_REPLACEMENT = '\u{e000}';
var StyleTransformer$1 = new StyleTransformer();

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/** @const {string} */

const infoKey = '__styleInfo';
class StyleInfo {
  /**
   * @param {Element} node
   * @return {StyleInfo}
   */
  static get(node) {
    if (node) {
      return node[infoKey];
    } else {
      return null;
    }
  }
  /**
   * @param {!Element} node
   * @param {StyleInfo} styleInfo
   * @return {StyleInfo}
   */


  static set(node, styleInfo) {
    node[infoKey] = styleInfo;
    return styleInfo;
  }
  /**
   * @param {StyleNode} ast
   * @param {Node=} placeholder
   * @param {Array<string>=} ownStylePropertyNames
   * @param {string=} elementName
   * @param {string=} typeExtension
   * @param {string=} cssBuild
   */


  constructor(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {
    /** @type {StyleNode} */
    this.styleRules = ast || null;
    /** @type {Node} */

    this.placeholder = placeholder || null;
    /** @type {!Array<string>} */

    this.ownStylePropertyNames = ownStylePropertyNames || [];
    /** @type {Object} */

    this.overrideStyleProperties = null;
    /** @type {string} */

    this.elementName = elementName || '';
    /** @type {string} */

    this.cssBuild = cssBuild || '';
    /** @type {string} */

    this.typeExtension = typeExtension || '';
    /** @type {Object<string, string>} */

    this.styleProperties = null;
    /** @type {?string} */

    this.scopeSelector = null;
    /** @type {HTMLStyleElement} */

    this.customStyle = null;
  }

  _getStyleRules() {
    return this.styleRules;
  }

}
/* eslint-disable-next-line no-self-assign */

StyleInfo.prototype['_getStyleRules'] = StyleInfo.prototype._getStyleRules;

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @param {string} selector
 * @return {boolean}
 * @this {Element}
 */

const matchesSelector = function (selector) {
  const method = this.matches || this.matchesSelector || this.mozMatchesSelector || this.msMatchesSelector || this.oMatchesSelector || this.webkitMatchesSelector;
  return method && method.call(this, selector);
};

const IS_IE = navigator.userAgent.match('Trident');
const XSCOPE_NAME = 'x-scope';

class StyleProperties {
  get XSCOPE_NAME() {
    return XSCOPE_NAME;
  }
  /**
   * decorates styles with rule info and returns an array of used style property names
   *
   * @param {StyleNode} rules
   * @return {Array<string>}
   */


  decorateStyles(rules) {
    let self = this,
        props = {},
        keyframes = [],
        ruleIndex = 0;
    forEachRule(rules, function (rule) {
      self.decorateRule(rule); // mark in-order position of ast rule in styles block, used for cache key

      rule.index = ruleIndex++;
      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
    }, function onKeyframesRule(rule) {
      keyframes.push(rule);
    }); // Cache all found keyframes rules for later reference:

    rules._keyframes = keyframes; // return this list of property names *consumes* in these styles.

    let names = [];

    for (let i in props) {
      names.push(i);
    }

    return names;
  } // decorate a single rule with property info


  decorateRule(rule) {
    if (rule.propertyInfo) {
      return rule.propertyInfo;
    }

    let info = {},
        properties = {};
    let hasProperties = this.collectProperties(rule, properties);

    if (hasProperties) {
      info.properties = properties; // TODO(sorvell): workaround parser seeing mixins as additional rules

      rule['rules'] = null;
    }

    info.cssText = this.collectCssText(rule);
    rule.propertyInfo = info;
    return info;
  } // collects the custom properties from a rule's cssText


  collectProperties(rule, properties) {
    let info = rule.propertyInfo;

    if (info) {
      if (info.properties) {
        Object.assign(properties, info.properties);
        return true;
      }
    } else {
      let m,
          rx = VAR_ASSIGN;
      let cssText = rule['parsedCssText'];
      let value;
      let any;

      while (m = rx.exec(cssText)) {
        // note: group 2 is var, 3 is mixin
        value = (m[2] || m[3]).trim(); // value of 'inherit' or 'unset' is equivalent to not setting the property here

        if (value !== 'inherit' || value !== 'unset') {
          properties[m[1].trim()] = value;
        }

        any = true;
      }

      return any;
    }
  } // returns cssText of properties that consume variables/mixins


  collectCssText(rule) {
    return this.collectConsumingCssText(rule['parsedCssText']);
  } // NOTE: we support consumption inside mixin assignment
  // but not production, so strip out {...}


  collectConsumingCssText(cssText) {
    return cssText.replace(BRACKETED, '').replace(VAR_ASSIGN, '');
  }

  collectPropertiesInCssText(cssText, props) {
    let m;

    while (m = VAR_CONSUMED.exec(cssText)) {
      let name = m[1]; // This regex catches all variable names, and following non-whitespace char
      // If next char is not ':', then variable is a consumer

      if (m[2] !== ':') {
        props[name] = true;
      }
    }
  } // turns custom properties into realized values.


  reify(props) {
    // big perf optimization here: reify only *own* properties
    // since this object has __proto__ of the element's scope properties
    let names = Object.getOwnPropertyNames(props);

    for (let i = 0, n; i < names.length; i++) {
      n = names[i];
      props[n] = this.valueForProperty(props[n], props);
    }
  } // given a property value, returns the reified value
  // a property value may be:
  // (1) a literal value like: red or 5px;
  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or
  // var(--a, var(--b));
  // (3) a literal mixin value like { properties }. Each of these properties
  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.


  valueForProperty(property, props) {
    // case (1) default
    // case (3) defines a mixin and we have to reify the internals
    if (property) {
      if (property.indexOf(';') >= 0) {
        property = this.valueForProperties(property, props);
      } else {
        // case (2) variable
        let self = this;

        let fn = function (prefix, value, fallback, suffix) {
          if (!value) {
            return prefix + suffix;
          }

          let propertyValue = self.valueForProperty(props[value], props); // if value is "initial", then the variable should be treated as unset

          if (!propertyValue || propertyValue === 'initial') {
            // fallback may be --a or var(--a) or literal
            propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;
          } else if (propertyValue === 'apply-shim-inherit') {
            // CSS build will replace `inherit` with `apply-shim-inherit`
            // for use with native css variables.
            // Since we have full control, we can use `inherit` directly.
            propertyValue = 'inherit';
          }

          return prefix + (propertyValue || '') + suffix;
        };

        property = processVariableAndFallback(property, fn);
      }
    }

    return property && property.trim() || '';
  } // note: we do not yet support mixin within mixin


  valueForProperties(property, props) {
    let parts = property.split(';');

    for (let i = 0, p, m; i < parts.length; i++) {
      if (p = parts[i]) {
        MIXIN_MATCH.lastIndex = 0;
        m = MIXIN_MATCH.exec(p);

        if (m) {
          p = this.valueForProperty(props[m[1]], props);
        } else {
          let colon = p.indexOf(':');

          if (colon !== -1) {
            let pp = p.substring(colon);
            pp = pp.trim();
            pp = this.valueForProperty(pp, props) || pp;
            p = p.substring(0, colon) + pp;
          }
        }

        parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? // strip trailing ;
        p.slice(0, -1) : p || '';
      }
    }

    return parts.join(';');
  }

  applyProperties(rule, props) {
    let output = ''; // dynamically added sheets may not be decorated so ensure they are.

    if (!rule.propertyInfo) {
      this.decorateRule(rule);
    }

    if (rule.propertyInfo.cssText) {
      output = this.valueForProperties(rule.propertyInfo.cssText, props);
    }

    rule['cssText'] = output;
  } // Apply keyframe transformations to the cssText of a given rule. The
  // keyframeTransforms object is a map of keyframe names to transformer
  // functions which take in cssText and spit out transformed cssText.


  applyKeyframeTransforms(rule, keyframeTransforms) {
    let input = rule['cssText'];
    let output = rule['cssText'];

    if (rule.hasAnimations == null) {
      // Cache whether or not the rule has any animations to begin with:
      rule.hasAnimations = ANIMATION_MATCH.test(input);
    } // If there are no animations referenced, we can skip transforms:


    if (rule.hasAnimations) {
      let transform; // If we haven't transformed this rule before, we iterate over all
      // transforms:

      if (rule.keyframeNamesToTransform == null) {
        rule.keyframeNamesToTransform = [];

        for (let keyframe in keyframeTransforms) {
          transform = keyframeTransforms[keyframe];
          output = transform(input); // If the transform actually changed the CSS text, we cache the
          // transform name for future use:

          if (input !== output) {
            input = output;
            rule.keyframeNamesToTransform.push(keyframe);
          }
        }
      } else {
        // If we already have a list of keyframe names that apply to this
        // rule, we apply only those keyframe name transforms:
        for (let i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
          input = transform(input);
        }

        output = input;
      }
    }

    rule['cssText'] = output;
  } // Test if the rules in these styles matches the given `element` and if so,
  // collect any custom properties into `props`.

  /**
   * @param {StyleNode} rules
   * @param {Element} element
   */


  propertyDataFromStyles(rules, element) {
    let props = {}; // generates a unique key for these matches

    let o = []; // note: active rules excludes non-matching @media rules

    forEachRule(rules, rule => {
      // TODO(sorvell): we could trim the set of rules at declaration
      // time to only include ones that have properties
      if (!rule.propertyInfo) {
        this.decorateRule(rule);
      } // match element against transformedSelector: selector may contain
      // unwanted uniquification and parsedSelector does not directly match
      // for :host selectors.


      let selectorToMatch = rule.transformedSelector || rule['parsedSelector'];

      if (element && rule.propertyInfo.properties && selectorToMatch) {
        if (matchesSelector.call(element, selectorToMatch)) {
          this.collectProperties(rule, props); // produce numeric key for these matches for lookup

          addToBitMask(rule.index, o);
        }
      }
    }, null, true);
    return {
      properties: props,
      key: o
    };
  }
  /**
   * @param {Element} scope
   * @param {StyleNode} rule
   * @param {string} cssBuild
   * @param {function(Object)} callback
   */


  whenHostOrRootRule(scope, rule, cssBuild, callback) {
    if (!rule.propertyInfo) {
      this.decorateRule(rule);
    }

    if (!rule.propertyInfo.properties) {
      return;
    }

    let {
      is,
      typeExtension
    } = getIsExtends(scope);
    let hostScope = is ? StyleTransformer$1._calcHostScope(is, typeExtension) : 'html';
    let parsedSelector = rule['parsedSelector'];
    let isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';
    let isHost = parsedSelector.indexOf(':host') === 0 && !isRoot; // build info is either in scope (when scope is an element) or in the style
    // when scope is the default scope; note: this allows default scope to have
    // mixed mode built and unbuilt styles.

    if (cssBuild === 'shady') {
      // :root -> x-foo > *.x-foo for elements and html for custom-style
      isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1; // :host -> x-foo for elements, but sub-rules have .x-foo in them

      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;
    }

    if (!isRoot && !isHost) {
      return;
    }

    let selectorToMatch = hostScope;

    if (isHost) {
      // need to transform :host because `:host` does not work with `matches`
      if (!rule.transformedSelector) {
        // transform :host into a matchable selector
        rule.transformedSelector = StyleTransformer$1._transformRuleCss(rule, StyleTransformer$1._transformComplexSelector, StyleTransformer$1._calcElementScope(is), hostScope);
      }

      selectorToMatch = rule.transformedSelector || hostScope;
    }

    callback({
      selector: selectorToMatch,
      isHost: isHost,
      isRoot: isRoot
    });
  }
  /**
   * @param {Element} scope
   * @param {StyleNode} rules
   * @param {string} cssBuild
   * @return {Object}
   */


  hostAndRootPropertiesForScope(scope, rules, cssBuild) {
    let hostProps = {},
        rootProps = {}; // note: active rules excludes non-matching @media rules

    forEachRule(rules, rule => {
      // if scope is StyleDefaults, use _element for matchesSelector
      this.whenHostOrRootRule(scope, rule, cssBuild, info => {
        let element = scope._element || scope;

        if (matchesSelector.call(element, info.selector)) {
          if (info.isHost) {
            this.collectProperties(rule, hostProps);
          } else {
            this.collectProperties(rule, rootProps);
          }
        }
      });
    }, null, true);
    return {
      rootProps: rootProps,
      hostProps: hostProps
    };
  }
  /**
   * @param {Element} element
   * @param {Object} properties
   * @param {string} scopeSelector
   */


  transformStyles(element, properties, scopeSelector) {
    let self = this;
    let {
      is,
      typeExtension
    } = getIsExtends(element);

    let hostSelector = StyleTransformer$1._calcHostScope(is, typeExtension);

    let rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
    let hostRx = new RegExp(HOST_PREFIX + rxHostSelector + HOST_SUFFIX);
    let {
      styleRules: rules,
      cssBuild
    } = StyleInfo.get(element);

    let keyframeTransforms = this._elementKeyframeTransforms(element, rules, scopeSelector);

    return StyleTransformer$1.elementStyles(element, rules, function (rule) {
      self.applyProperties(rule, properties);

      if (!nativeShadow && !isKeyframesSelector(rule) && rule['cssText']) {
        // NOTE: keyframe transforms only scope munge animation names, so it
        // is not necessary to apply them in ShadowDOM.
        self.applyKeyframeTransforms(rule, keyframeTransforms);

        self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);
      }
    }, cssBuild);
  }
  /**
   * @param {Element} element
   * @param {StyleNode} rules
   * @param {string} scopeSelector
   * @return {Object}
   */


  _elementKeyframeTransforms(element, rules, scopeSelector) {
    let keyframesRules = rules._keyframes;
    let keyframeTransforms = {};

    if (!nativeShadow && keyframesRules) {
      // For non-ShadowDOM, we transform all known keyframes rules in
      // advance for the current scope. This allows us to catch keyframes
      // rules that appear anywhere in the stylesheet:
      for (let i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
        this._scopeKeyframes(keyframesRule, scopeSelector);

        keyframeTransforms[keyframesRule['keyframesName']] = this._keyframesRuleTransformer(keyframesRule);
      }
    }

    return keyframeTransforms;
  } // Generate a factory for transforming a chunk of CSS text to handle a
  // particular scoped keyframes rule.

  /**
   * @param {StyleNode} keyframesRule
   * @return {function(string):string}
   */


  _keyframesRuleTransformer(keyframesRule) {
    return function (cssText) {
      return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);
    };
  }
  /**
   * Transforms `@keyframes` names to be unique for the current host.
   * Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0
   *
   * @param {StyleNode} rule
   * @param {string} scopeId
   */


  _scopeKeyframes(rule, scopeId) {
    // Animation names are of the form [\w-], so ensure that the name regex does not partially apply
    // to similarly named keyframe names by checking for a word boundary at the beginning and
    // a non-word boundary or `-` at the end.
    rule.keyframesNameRx = new RegExp(`\\b${rule['keyframesName']}(?!\\B|-)`, 'g');
    rule.transformedKeyframesName = rule['keyframesName'] + '-' + scopeId;
    rule.transformedSelector = rule.transformedSelector || rule['selector'];
    rule['selector'] = rule.transformedSelector.replace(rule['keyframesName'], rule.transformedKeyframesName);
  } // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):
  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo
  // host selector: x-foo.wide -> .x-foo-42.wide
  // note: we use only the scope class (.x-foo-42) and not the hostSelector
  // (x-foo) to scope :host rules; this helps make property host rules
  // have low specificity. They are overrideable by class selectors but,
  // unfortunately, not by type selectors (e.g. overriding via
  // `.special` is ok, but not by `x-foo`).

  /**
   * @param {StyleNode} rule
   * @param {RegExp} hostRx
   * @param {string} hostSelector
   * @param {string} scopeId
   */


  _scopeSelector(rule, hostRx, hostSelector, scopeId) {
    rule.transformedSelector = rule.transformedSelector || rule['selector'];
    let selector = rule.transformedSelector;
    let scope = '.' + scopeId;
    let parts = splitSelectorList(selector);

    for (let i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
      parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : scope + ' ' + p;
    }

    rule['selector'] = parts.join(',');
  }
  /**
   * @param {Element} element
   * @param {string} selector
   * @param {string} old
   */


  applyElementScopeSelector(element, selector, old) {
    let c = element.getAttribute('class') || '';
    let v = c;

    if (old) {
      v = c.replace(new RegExp('\\s*' + XSCOPE_NAME + '\\s*' + old + '\\s*', 'g'), ' ');
    }

    v += (v ? ' ' : '') + XSCOPE_NAME + ' ' + selector;

    if (c !== v) {
      setElementClassRaw(element, v);
    }
  }
  /**
   * @param {HTMLElement} element
   * @param {Object} properties
   * @param {string} selector
   * @param {HTMLStyleElement} style
   * @return {HTMLStyleElement}
   */


  applyElementStyle(element, properties, selector, style) {
    // calculate cssText to apply
    let cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector); // if shady and we have a cached style that is not style, decrement

    let styleInfo = StyleInfo.get(element);
    let s = styleInfo.customStyle;

    if (s && !nativeShadow && s !== style) {
      s['_useCount']--;

      if (s['_useCount'] <= 0 && s.parentNode) {
        s.parentNode.removeChild(s);
      }
    } // apply styling always under native or if we generated style
    // or the cached style is not in document(!)


    if (nativeShadow) {
      // update existing style only under native
      if (styleInfo.customStyle) {
        styleInfo.customStyle.textContent = cssText;
        style = styleInfo.customStyle; // otherwise, if we have css to apply, do so
      } else if (cssText) {
        // apply css after the scope style of the element to help with
        // style precedence rules.
        style = applyCss(cssText, selector, element.shadowRoot, styleInfo.placeholder);
      }
    } else {
      // shady and no cache hit
      if (!style) {
        // apply css after the scope style of the element to help with
        // style precedence rules.
        if (cssText) {
          style = applyCss(cssText, selector, null, styleInfo.placeholder);
        } // shady and cache hit but not in document

      } else if (!style.parentNode) {
        if (IS_IE && cssText.indexOf('@media') > -1) {
          // @media rules may be stale in IE 10 and 11
          // refresh the text content of the style to revalidate them.
          style.textContent = cssText;
        }

        applyStyle(style, null, styleInfo.placeholder);
      }
    } // ensure this style is our custom style and increment its use count.


    if (style) {
      style['_useCount'] = style['_useCount'] || 0; // increment use count if we changed styles

      if (styleInfo.customStyle != style) {
        style['_useCount']++;
      }

      styleInfo.customStyle = style;
    }

    return style;
  }
  /**
   * @param {Element} style
   * @param {Object} properties
   */


  applyCustomStyle(style, properties) {
    let rules = rulesForStyle(
    /** @type {HTMLStyleElement} */
    style);
    let self = this;
    style.textContent = toCssText(rules, function (
    /** StyleNode */
    rule) {
      let css = rule['cssText'] = rule['parsedCssText'];

      if (rule.propertyInfo && rule.propertyInfo.cssText) {
        // remove property assignments
        // so next function isn't confused
        // NOTE: we have 3 categories of css:
        // (1) normal properties,
        // (2) custom property assignments (--foo: red;),
        // (3) custom property usage: border: var(--foo); @apply(--foo);
        // In elements, 1 and 3 are separated for efficiency; here they
        // are not and this makes this case unique.
        css = removeCustomPropAssignment(
        /** @type {string} */
        css); // replace with reified properties, scenario is same as mixin

        rule['cssText'] = self.valueForProperties(css, properties);
      }
    });
  }

}
/**
 * @param {number} n
 * @param {Array<number>} bits
 */


function addToBitMask(n, bits) {
  let o = parseInt(n / 32, 10);
  let v = 1 << n % 32;
  bits[o] = (bits[o] || 0) | v;
}

var StyleProperties$1 = new StyleProperties();

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/** @type {!Object<string, !Node>} */

const placeholderMap = {};
/**
 * @param {string} elementName
 * @return {Node}
 */

function getStylePlaceholder(elementName) {
  return placeholderMap[elementName] || null;
}
/**
 * @param {string} elementName
 */

function ensureStylePlaceholder(elementName) {
  if (!placeholderMap[elementName]) {
    placeholderMap[elementName] = applyStylePlaceHolder(elementName);
  }
}
/**
 * @const {CustomElementRegistry}
 */

const ce = window['customElements'];

if (ce && !nativeShadow && !disableRuntime) {
  /**
   * @const {function(this:CustomElementRegistry, string,function(new:HTMLElement),{extends: string}=)}
   */
  const origDefine = ce['define'];
  /**
   * @param {string} name
   * @param {function(new:HTMLElement)} clazz
   * @param {{extends: string}=} options
   */

  const wrappedDefine = (name, clazz, options) => {
    ensureStylePlaceholder(name);
    origDefine.call(
    /** @type {!CustomElementRegistry} */
    ce, name, clazz, options);
  };

  ce['define'] = wrappedDefine;
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

class StyleCache {
  constructor(typeMax = 100) {
    // map element name -> [{properties, styleElement, scopeSelector}]
    this.cache = {};
    /** @type {number} */

    this.typeMax = typeMax;
  }

  _validate(cacheEntry, properties, ownPropertyNames) {
    for (let idx = 0; idx < ownPropertyNames.length; idx++) {
      let pn = ownPropertyNames[idx];

      if (cacheEntry.properties[pn] !== properties[pn]) {
        return false;
      }
    }

    return true;
  }

  store(tagname, properties, styleElement, scopeSelector) {
    let list = this.cache[tagname] || [];
    list.push({
      properties,
      styleElement,
      scopeSelector
    });

    if (list.length > this.typeMax) {
      list.shift();
    }

    this.cache[tagname] = list;
  }

  fetch(tagname, properties, ownPropertyNames) {
    let list = this.cache[tagname];

    if (!list) {
      return;
    } // reverse list for most-recent lookups


    for (let idx = list.length - 1; idx >= 0; idx--) {
      let entry = list[idx];

      if (this._validate(entry, properties, ownPropertyNames)) {
        return entry;
      }
    }
  }

}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let flush = function () {};
/**
 * @param {!Element} element
 * @return {string}
 */

function getClasses(element) {
  if (element.classList && element.classList.value) {
    return element.classList.value;
  } else {
    // NOTE: className is patched to remove scoping classes in ShadyDOM
    // use getAttribute('class') instead, which is unpatched
    return element.getAttribute('class') || '';
  }
}

const scopeRegExp = new RegExp(`${StyleTransformer$1.SCOPE_NAME}\\s*([^\\s]*)`);
/**
 * @param {!Element} element
 * @return {string}
 */

function getCurrentScope(element) {
  const match = getClasses(element).match(scopeRegExp);

  if (match) {
    return match[1];
  } else {
    return '';
  }
}
/**
 * @param {!Node} node
 */

function getOwnerScope(node) {
  const ownerRoot = wrap$1(node).getRootNode();

  if (ownerRoot === node || ownerRoot === node.ownerDocument) {
    return '';
  }

  const host =
  /** @type {!ShadowRoot} */
  ownerRoot.host;

  if (!host) {
    // this may actually be a document fragment
    return '';
  }

  return getIsExtends(host).is;
}
/**
 * @param {!HTMLElement|!HTMLDocument} element
 */

function ensureCorrectSubtreeScoping(element) {
  // find unscoped subtree nodes
  const unscopedNodes = window['ShadyDOM']['nativeMethods']['querySelectorAll'].call(element, `:not(.${StyleTransformer$1.SCOPE_NAME})`);

  for (let j = 0; j < unscopedNodes.length; j++) {
    // it's possible, during large batch inserts, that nodes that aren't
    // scoped within the current scope were added.
    // To make sure that any unscoped nodes that were inserted in the current batch are correctly styled,
    // query all unscoped nodes and force their style-scope to be applied.
    // This could happen if a sub-element appended an unscoped node in its shadowroot and this function
    // runs on a parent element of the host of that unscoped node:
    // parent-element -> element -> unscoped node
    // Here unscoped node should have the style-scope element, not parent-element.
    const unscopedNode = unscopedNodes[j];
    const scopeForPreviouslyUnscopedNode = getOwnerScope(unscopedNode);

    if (scopeForPreviouslyUnscopedNode) {
      StyleTransformer$1.element(unscopedNode, scopeForPreviouslyUnscopedNode);
    }
  }
}
/**
 * @param {HTMLElement} el
 * @return {boolean}
 */

function isElementWithBuiltCss(el) {
  if (el.localName === 'style' || el.localName === 'template') {
    return elementHasBuiltCss(el);
  }

  return false;
}
/**
 * @param {Array<MutationRecord|null>|null} mxns
 */


function handler(mxns) {
  for (let x = 0; x < mxns.length; x++) {
    let mxn = mxns[x];

    if (mxn.target === document.documentElement || mxn.target === document.head) {
      continue;
    }

    for (let i = 0; i < mxn.addedNodes.length; i++) {
      let n = mxn.addedNodes[i];

      if (n.nodeType !== Node.ELEMENT_NODE) {
        continue;
      }

      n =
      /** @type {HTMLElement} */
      n; // eslint-disable-line no-self-assign

      let root = n.getRootNode();
      let currentScope = getCurrentScope(n); // node was scoped, but now is in document
      // If this element has built css, we must not remove scoping as this node
      // will be used as a template or style without re - applying scoping as an optimization

      if (currentScope && root === n.ownerDocument && !isElementWithBuiltCss(n)) {
        StyleTransformer$1.domRemoveScope(n, currentScope);
      } else if (root instanceof ShadowRoot) {
        const newScope = getOwnerScope(n); // rescope current node and subtree if necessary

        if (newScope !== currentScope) {
          StyleTransformer$1.domReplaceScope(n, currentScope, newScope);
        } // make sure all the subtree elements are scoped correctly


        ensureCorrectSubtreeScoping(n);
      }
    }
  }
} // if native Shadow DOM is being used, or ShadyDOM handles dynamic scoiping, do not activate the MutationObserver


if (!nativeShadow && !(window['ShadyDOM'] && window['ShadyDOM']['handlesDynamicScoping'])) {
  let observer = new MutationObserver(handler);

  let start = node => {
    observer.observe(node, {
      childList: true,
      subtree: true
    });
  };

  let nativeCustomElements = window['customElements'] && !window['customElements']['polyfillWrapFlushCallback']; // need to start immediately with native custom elements
  // TODO(dfreedm): with polyfilled HTMLImports and native custom elements
  // excessive mutations may be observed; this can be optimized via cooperation
  // with the HTMLImports polyfill.

  if (nativeCustomElements) {
    start(document);
  } else {
    let delayedStart = () => {
      start(document.body);
    }; // use polyfill timing if it's available


    if (window['HTMLImports']) {
      window['HTMLImports']['whenReady'](delayedStart); // otherwise push beyond native imports being ready
      // which requires RAF + readystate interactive.
    } else {
      requestAnimationFrame(function () {
        if (document.readyState === 'loading') {
          let listener = function () {
            delayedStart();
            document.removeEventListener('readystatechange', listener);
          };

          document.addEventListener('readystatechange', listener);
        } else {
          delayedStart();
        }
      });
    }
  }

  flush = function () {
    handler(observer.takeRecords());
  };
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
 * @const {!Object<string, !HTMLTemplateElement>}
 */

const templateMap = {};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/*
 * Utilities for handling invalidating apply-shim mixins for a given template.
 *
 * The invalidation strategy involves keeping track of the "current" version of a template's mixins, and updating that count when a mixin is invalidated.
 * The template
 */

/** @const {string} */

const CURRENT_VERSION = '_applyShimCurrentVersion';
/** @const {string} */

const NEXT_VERSION = '_applyShimNextVersion';
/** @const {string} */

const VALIDATING_VERSION = '_applyShimValidatingVersion';
/**
 * @const {Promise<void>}
 */

const promise = Promise.resolve();
/**
 * @param {string} elementName
 */

function invalidate(elementName) {
  let template = templateMap[elementName];

  if (template) {
    invalidateTemplate(template);
  }
}
/**
 * This function can be called multiple times to mark a template invalid
 * and signal that the style inside must be regenerated.
 *
 * Use `startValidatingTemplate` to begin an asynchronous validation cycle.
 * During that cycle, call `templateIsValidating` to see if the template must
 * be revalidated
 * @param {HTMLTemplateElement} template
 */

function invalidateTemplate(template) {
  // default the current version to 0
  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0; // ensure the "validating for" flag exists

  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0; // increment the next version

  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;
}
/**
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */

function templateIsValid(template) {
  return template[CURRENT_VERSION] === template[NEXT_VERSION];
}
/**
 * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.
 * If false, the template must be validated.
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */

function templateIsValidating(template) {
  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];
}
/**
 * Begin an asynchronous invalidation cycle.
 * This should be called after every validation of a template
 *
 * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`
 * @param {HTMLTemplateElement} template
 */

function startValidatingTemplate(template) {
  // remember that the current "next version" is the reason for this validation cycle
  template[VALIDATING_VERSION] = template[NEXT_VERSION]; // however, there only needs to be one async task to clear the counters

  if (!template._validating) {
    template._validating = true;
    promise.then(function () {
      // sync the current version to let future invalidations cause a refresh cycle
      template[CURRENT_VERSION] = template[NEXT_VERSION];
      template._validating = false;
    });
  }
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
 * @param {Element} element
 * @param {Object=} properties
 */

function updateNativeProperties(element, properties) {
  // remove previous properties
  for (let p in properties) {
    // NOTE: for bc with shim, don't apply null values.
    if (p === null) {
      element.style.removeProperty(p);
    } else {
      element.style.setProperty(p, properties[p]);
    }
  }
}
/**
 * return true if `cssText` contains a mixin definition or consumption
 * @param {string} cssText
 * @return {boolean}
 */

function detectMixin(cssText) {
  const has = MIXIN_MATCH.test(cssText) || VAR_ASSIGN.test(cssText); // reset state of the regexes

  MIXIN_MATCH.lastIndex = 0;
  VAR_ASSIGN.lastIndex = 0;
  return has;
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/** @type {Promise<void>} */

let readyPromise = null;
/** @type {?function(?function())} */

let whenReady = window['HTMLImports'] && window['HTMLImports']['whenReady'] || null;
/** @type {function()} */

let resolveFn;
/**
 * @param {?function()} callback
 */

function documentWait(callback) {
  requestAnimationFrame(function () {
    if (whenReady) {
      whenReady(callback);
    } else {
      if (!readyPromise) {
        readyPromise = new Promise(resolve => {
          resolveFn = resolve;
        });

        if (document.readyState === 'complete') {
          resolveFn();
        } else {
          document.addEventListener('readystatechange', () => {
            if (document.readyState === 'complete') {
              resolveFn();
            }
          });
        }
      }

      readyPromise.then(function () {
        callback && callback();
      });
    }
  });
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const SEEN_MARKER = '__seenByShadyCSS';
const CACHED_STYLE = '__shadyCSSCachedStyle';
/** @type {?function(!HTMLStyleElement)} */

let transformFn = null;
/** @type {?function()} */

let validateFn = null;
/**
This interface is provided to add document-level <style> elements to ShadyCSS for processing.
These styles must be processed by ShadyCSS to simulate ShadowRoot upper-bound encapsulation from outside styles
In addition, these styles may also need to be processed for @apply rules and CSS Custom Properties

To add document-level styles to ShadyCSS, one can call `ShadyCSS.addDocumentStyle(styleElement)` or `ShadyCSS.addDocumentStyle({getStyle: () => styleElement})`

In addition, if the process used to discover document-level styles can be synchronously flushed, one should set `ShadyCSS.documentStyleFlush`.
This function will be called when calculating styles.

An example usage of the document-level styling api can be found in `examples/document-style-lib.js`

@unrestricted
*/

class CustomStyleInterface {
  constructor() {
    /** @type {!Array<!CustomStyleProvider>} */
    this['customStyles'] = [];
    this['enqueued'] = false; // NOTE(dfreedm): use quotes here to prevent closure inlining to `function(){}`;

    documentWait(() => {
      if (window['ShadyCSS']['flushCustomStyles']) {
        window['ShadyCSS']['flushCustomStyles']();
      }
    });
  }
  /**
   * Queue a validation for new custom styles to batch style recalculations
   */


  enqueueDocumentValidation() {
    if (this['enqueued'] || !validateFn) {
      return;
    }

    this['enqueued'] = true;
    documentWait(validateFn);
  }
  /**
   * @param {!HTMLStyleElement} style
   */


  addCustomStyle(style) {
    if (!style[SEEN_MARKER]) {
      style[SEEN_MARKER] = true;
      this['customStyles'].push(style);
      this.enqueueDocumentValidation();
    }
  }
  /**
   * @param {!CustomStyleProvider} customStyle
   * @return {HTMLStyleElement}
   */


  getStyleForCustomStyle(customStyle) {
    if (customStyle[CACHED_STYLE]) {
      return customStyle[CACHED_STYLE];
    }

    let style;

    if (customStyle['getStyle']) {
      style = customStyle['getStyle']();
    } else {
      style = customStyle;
    }

    return style;
  }
  /**
   * @return {!Array<!CustomStyleProvider>}
   */


  processStyles() {
    const cs = this['customStyles'];

    for (let i = 0; i < cs.length; i++) {
      const customStyle = cs[i];

      if (customStyle[CACHED_STYLE]) {
        continue;
      }

      const style = this.getStyleForCustomStyle(customStyle);

      if (style) {
        // HTMLImports polyfill may have cloned the style into the main document,
        // which is referenced with __appliedElement.
        const styleToTransform =
        /** @type {!HTMLStyleElement} */
        style['__appliedElement'] || style;

        if (transformFn) {
          transformFn(styleToTransform);
        }

        customStyle[CACHED_STYLE] = styleToTransform;
      }
    }

    return cs;
  }

}
/* eslint-disable no-self-assign */

CustomStyleInterface.prototype['addCustomStyle'] = CustomStyleInterface.prototype.addCustomStyle;
CustomStyleInterface.prototype['getStyleForCustomStyle'] = CustomStyleInterface.prototype.getStyleForCustomStyle;
CustomStyleInterface.prototype['processStyles'] = CustomStyleInterface.prototype.processStyles;
/* eslint-enable no-self-assign */

Object.defineProperties(CustomStyleInterface.prototype, {
  'transformCallback': {
    /** @return {?function(!HTMLStyleElement)} */
    get() {
      return transformFn;
    },

    /** @param {?function(!HTMLStyleElement)} fn */
    set(fn) {
      transformFn = fn;
    }

  },
  'validateCallback': {
    /** @return {?function()} */
    get() {
      return validateFn;
    },

    /**
     * @param {?function()} fn
     * @this {CustomStyleInterface}
     */
    set(fn) {
      let needsEnqueue = false;

      if (!validateFn) {
        needsEnqueue = true;
      }

      validateFn = fn;

      if (needsEnqueue) {
        this.enqueueDocumentValidation();
      }
    }

  }
});

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/** @type {!Object<string, string>} */

const adoptedCssTextMap = {};
/**
 * @const {StyleCache}
 */

const styleCache = new StyleCache();
class ScopingShim {
  constructor() {
    this._scopeCounter = {};
    this._documentOwner =
    /** @type {!HTMLElement} */
    document.documentElement;
    let ast = new StyleNode();
    ast['rules'] = [];
    this._documentOwnerStyleInfo = StyleInfo.set(this._documentOwner, new StyleInfo(ast));
    this._elementsHaveApplied = false;
    /** @type {?Object} */

    this._applyShim = null;
    /** @type {?CustomStyleInterfaceInterface} */

    this._customStyleInterface = null;
  }

  flush() {
    flush();
  }

  _generateScopeSelector(name) {
    let id = this._scopeCounter[name] = (this._scopeCounter[name] || 0) + 1;
    return `${name}-${id}`;
  }

  getStyleAst(style) {
    return rulesForStyle(style);
  }

  styleAstToString(ast) {
    return toCssText(ast);
  }

  _gatherStyles(template) {
    return gatherStyleText(template.content);
  }
  /**
   * Prepare the styling and template for the given element type
   *
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   * @param {string=} typeExtension
   */


  prepareTemplate(template, elementName, typeExtension) {
    this.prepareTemplateDom(template, elementName);
    this.prepareTemplateStyles(template, elementName, typeExtension);
  }
  /**
   * Prepare styling for the given element type
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   * @param {string=} typeExtension
   */


  prepareTemplateStyles(template, elementName, typeExtension) {
    if (template._prepared || disableRuntime) {
      return;
    } // style placeholders are only used when ShadyDOM is active


    if (!nativeShadow) {
      ensureStylePlaceholder(elementName);
    }

    template._prepared = true;
    template.name = elementName;
    template.extends = typeExtension;
    templateMap[elementName] = template;
    let cssBuild = getCssBuild(template);
    const optimalBuild = isOptimalCssBuild(cssBuild);
    let info = {
      is: elementName,
      extends: typeExtension
    };
    let cssText = this._gatherStyles(template) + (adoptedCssTextMap[elementName] || ''); // check if the styling has mixin definitions or uses

    this._ensure();

    if (!optimalBuild) {
      let hasMixins = !cssBuild && detectMixin(cssText);
      let ast = parse$1(cssText); // only run the applyshim transforms if there is a mixin involved

      if (hasMixins && nativeCssVariables && this._applyShim) {
        this._applyShim['transformRules'](ast, elementName);
      }

      template['_styleAst'] = ast;
    }

    let ownPropertyNames = [];

    if (!nativeCssVariables) {
      ownPropertyNames = StyleProperties$1.decorateStyles(template['_styleAst']);
    }

    if (!ownPropertyNames.length || nativeCssVariables) {
      let root = nativeShadow ? template.content : null;
      let placeholder = getStylePlaceholder(elementName);

      let style = this._generateStaticStyle(info, template['_styleAst'], root, placeholder, cssBuild, optimalBuild ? cssText : '');

      template._style = style;
    }

    template._ownPropertyNames = ownPropertyNames;
  }
  /**
   * @param {!Array<string>} cssTextArray
   * @param {string} elementName
   */


  prepareAdoptedCssText(cssTextArray, elementName) {
    adoptedCssTextMap[elementName] = cssTextArray.join(' ');
  }
  /**
   * Prepare template for the given element type
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   */


  prepareTemplateDom(template, elementName) {
    if (disableRuntime) {
      return;
    }

    const cssBuild = getCssBuild(template);

    if (!nativeShadow && cssBuild !== 'shady' && !template._domPrepared) {
      template._domPrepared = true;
      StyleTransformer$1.domAddScope(template.content, elementName);
    }
  }
  /**
   * @param {!{is: string, extends: (string|undefined)}} info
   * @param {!StyleNode} rules
   * @param {DocumentFragment} shadowroot
   * @param {Node} placeholder
   * @param {string} cssBuild
   * @param {string=} cssText
   * @return {?HTMLStyleElement}
   */


  _generateStaticStyle(info, rules, shadowroot, placeholder, cssBuild, cssText) {
    cssText = StyleTransformer$1.elementStyles(info, rules, null, cssBuild, cssText);

    if (cssText.length) {
      return applyCss(cssText, info.is, shadowroot, placeholder);
    }

    return null;
  }

  _prepareHost(host) {
    const {
      is,
      typeExtension
    } = getIsExtends(host);
    const placeholder = getStylePlaceholder(is);
    const template = templateMap[is];

    if (!template) {
      return;
    }

    const ast = template['_styleAst'];
    const ownStylePropertyNames = template._ownPropertyNames;
    const cssBuild = getCssBuild(template);
    const styleInfo = new StyleInfo(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild);
    StyleInfo.set(host, styleInfo);
    return styleInfo;
  }

  _ensureApplyShim() {
    if (this._applyShim) {
      return;
    } else if (window.ShadyCSS && window.ShadyCSS.ApplyShim) {
      this._applyShim =
      /** @type {!Object} */
      window.ShadyCSS.ApplyShim;
      this._applyShim['invalidCallback'] = invalidate;
    }
  }

  _ensureCustomStyleInterface() {
    if (this._customStyleInterface) {
      return;
    } else if (window.ShadyCSS && window.ShadyCSS.CustomStyleInterface) {
      this._customStyleInterface =
      /** @type {!CustomStyleInterfaceInterface} */
      window.ShadyCSS.CustomStyleInterface;
      /** @type {function(!HTMLStyleElement)} */

      this._customStyleInterface['transformCallback'] = style => {
        this.transformCustomStyleForDocument(style);
      };

      this._customStyleInterface['validateCallback'] = () => {
        requestAnimationFrame(() => {
          if (this._customStyleInterface['enqueued'] || this._elementsHaveApplied) {
            this.flushCustomStyles();
          }
        });
      };
    }
  }

  _ensure() {
    this._ensureApplyShim();

    this._ensureCustomStyleInterface();
  }
  /**
   * Flush and apply custom styles to document
   */


  flushCustomStyles() {
    if (disableRuntime) {
      return;
    }

    this._ensure();

    if (!this._customStyleInterface) {
      return;
    }

    let customStyles = this._customStyleInterface['processStyles'](); // early return if custom-styles don't need validation


    if (!this._customStyleInterface['enqueued']) {
      return;
    } // bail if custom styles are built optimally


    if (isOptimalCssBuild(this._documentOwnerStyleInfo.cssBuild)) {
      return;
    }

    if (!nativeCssVariables) {
      this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);

      this._applyCustomStyles(customStyles);

      if (this._elementsHaveApplied) {
        // if custom elements have upgraded and there are no native css variables, we must recalculate the whole tree
        this.styleDocument();
      }
    } else if (!this._documentOwnerStyleInfo.cssBuild) {
      this._revalidateCustomStyleApplyShim(customStyles);
    }

    this._customStyleInterface['enqueued'] = false;
  }
  /**
   * Apply styles for the given element
   *
   * @param {!HTMLElement} host
   * @param {Object=} overrideProps
   */


  styleElement(host, overrideProps) {
    if (disableRuntime) {
      if (overrideProps) {
        if (!StyleInfo.get(host)) {
          StyleInfo.set(host, new StyleInfo(null));
        }

        const styleInfo =
        /** @type {!StyleInfo} */
        StyleInfo.get(host);

        this._mixOverrideStyleProps(styleInfo, overrideProps);

        this.styleElementNativeVariables(host, styleInfo);
      }

      return;
    }

    const styleInfo = StyleInfo.get(host) || this._prepareHost(host); // if there is no style info at this point, bail


    if (!styleInfo) {
      return;
    } // Only trip the `elementsHaveApplied` flag if a node other that the root document has `applyStyle` called


    if (!this._isRootOwner(host)) {
      this._elementsHaveApplied = true;
    }

    if (overrideProps) {
      this._mixOverrideStyleProps(styleInfo, overrideProps);
    }

    if (!nativeCssVariables) {
      this.styleElementShimVariables(host, styleInfo);
    } else {
      this.styleElementNativeVariables(host, styleInfo);
    }
  }
  /**
   * @param {!StyleInfo} styleInfo
   * @param {Object} overrideProps
   */


  _mixOverrideStyleProps(styleInfo, overrideProps) {
    styleInfo.overrideStyleProperties = styleInfo.overrideStyleProperties || {};
    Object.assign(styleInfo.overrideStyleProperties, overrideProps);
  }
  /**
   * @param {!HTMLElement} host
   * @param {!StyleInfo} styleInfo
   */


  styleElementShimVariables(host, styleInfo) {
    this.flush();

    this._updateProperties(host, styleInfo);

    if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {
      this._applyStyleProperties(host, styleInfo);
    }
  }
  /**
   * @param {!HTMLElement} host
   * @param {!StyleInfo} styleInfo
   */


  styleElementNativeVariables(host, styleInfo) {
    const {
      is
    } = getIsExtends(host);

    if (styleInfo.overrideStyleProperties) {
      updateNativeProperties(host, styleInfo.overrideStyleProperties);
    }

    const template = templateMap[is]; // bail early if there is no shadowroot for this element

    if (!template && !this._isRootOwner(host)) {
      return;
    } // bail early if the template was built with polymer-css-build


    if (template && elementHasBuiltCss(template)) {
      return;
    }

    if (template && template._style && !templateIsValid(template)) {
      // update template
      if (!templateIsValidating(template)) {
        this._ensure();

        this._applyShim && this._applyShim['transformRules'](template['_styleAst'], is);
        template._style.textContent = StyleTransformer$1.elementStyles(host, styleInfo.styleRules);
        startValidatingTemplate(template);
      } // update instance if native shadowdom


      if (nativeShadow) {
        let root = host.shadowRoot;

        if (root) {
          let style = root.querySelector('style');

          if (style) {
            style.textContent = StyleTransformer$1.elementStyles(host, styleInfo.styleRules);
          }
        }
      }

      styleInfo.styleRules = template['_styleAst'];
    }
  }

  _styleOwnerForNode(node) {
    let root = wrap$1(node).getRootNode();
    let host = root.host;

    if (host) {
      if (StyleInfo.get(host) || this._prepareHost(host)) {
        return host;
      } else {
        return this._styleOwnerForNode(host);
      }
    }

    return this._documentOwner;
  }

  _isRootOwner(node) {
    return node === this._documentOwner;
  }

  _applyStyleProperties(host, styleInfo) {
    let is = getIsExtends(host).is;
    let cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);
    let cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;
    let cachedStyle = cacheEntry ? cacheEntry.styleElement : null;
    let oldScopeSelector = styleInfo.scopeSelector; // only generate new scope if cached style is not found

    styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);
    let style = StyleProperties$1.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);

    if (!nativeShadow) {
      StyleProperties$1.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);
    }

    if (!cacheEntry) {
      styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);
    }

    return style;
  }

  _updateProperties(host, styleInfo) {
    let owner = this._styleOwnerForNode(host);

    let ownerStyleInfo = StyleInfo.get(owner);
    let ownerProperties = ownerStyleInfo.styleProperties; // style owner has not updated properties yet
    // go up the chain and force property update,
    // except if the owner is the document

    if (owner !== this._documentOwner && !ownerProperties) {
      this._updateProperties(owner, ownerStyleInfo);

      ownerProperties = ownerStyleInfo.styleProperties;
    }

    let props = Object.create(ownerProperties || null);
    let hostAndRootProps = StyleProperties$1.hostAndRootPropertiesForScope(host, styleInfo.styleRules, styleInfo.cssBuild);
    let propertyData = StyleProperties$1.propertyDataFromStyles(ownerStyleInfo.styleRules, host);
    let propertiesMatchingHost = propertyData.properties;
    Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);

    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);

    StyleProperties$1.reify(props);
    styleInfo.styleProperties = props;
  }

  _mixinOverrideStyles(props, overrides) {
    for (let p in overrides) {
      let v = overrides[p]; // skip override props if they are not truthy or 0
      // in order to fall back to inherited values

      if (v || v === 0) {
        props[p] = v;
      }
    }
  }
  /**
   * Update styles of the whole document
   *
   * @param {Object=} properties
   */


  styleDocument(properties) {
    this.styleSubtree(this._documentOwner, properties);
  }
  /**
   * Update styles of a subtree
   *
   * @param {!HTMLElement} host
   * @param {Object=} properties
   */


  styleSubtree(host, properties) {
    const wrappedHost = wrap$1(host);
    let root = wrappedHost.shadowRoot;

    if (root || this._isRootOwner(host)) {
      this.styleElement(host, properties);
    } // process the shadowdom children of `host`


    let shadowChildren = root && (
    /** @type {!ParentNode} */
    root.children || root.childNodes);

    if (shadowChildren) {
      for (let i = 0; i < shadowChildren.length; i++) {
        let c =
        /** @type {!HTMLElement} */
        shadowChildren[i];
        this.styleSubtree(c);
      }
    } else {
      // process the lightdom children of `host`
      let children = wrappedHost.children || wrappedHost.childNodes;

      if (children) {
        for (let i = 0; i < children.length; i++) {
          let c =
          /** @type {!HTMLElement} */
          children[i];
          this.styleSubtree(c);
        }
      }
    }
  }
  /* Custom Style operations */


  _revalidateCustomStyleApplyShim(customStyles) {
    for (let i = 0; i < customStyles.length; i++) {
      let c = customStyles[i];

      let s = this._customStyleInterface['getStyleForCustomStyle'](c);

      if (s) {
        this._revalidateApplyShim(s);
      }
    }
  }

  _applyCustomStyles(customStyles) {
    for (let i = 0; i < customStyles.length; i++) {
      let c = customStyles[i];

      let s = this._customStyleInterface['getStyleForCustomStyle'](c);

      if (s) {
        StyleProperties$1.applyCustomStyle(s, this._documentOwnerStyleInfo.styleProperties);
      }
    }
  }

  transformCustomStyleForDocument(style) {
    const cssBuild = getCssBuild(style);

    if (cssBuild !== this._documentOwnerStyleInfo.cssBuild) {
      this._documentOwnerStyleInfo.cssBuild = cssBuild;
    }

    if (isOptimalCssBuild(cssBuild)) {
      return;
    }

    let ast = rulesForStyle(style);
    forEachRule(ast, rule => {
      if (nativeShadow) {
        StyleTransformer$1.normalizeRootSelector(rule);
      } else {
        StyleTransformer$1.documentRule(rule);
      }

      if (nativeCssVariables && cssBuild === '') {
        this._ensure();

        this._applyShim && this._applyShim['transformRule'](rule);
      }
    });

    if (nativeCssVariables) {
      style.textContent = toCssText(ast);
    } else {
      this._documentOwnerStyleInfo.styleRules['rules'].push(ast);
    }
  }

  _revalidateApplyShim(style) {
    if (nativeCssVariables && this._applyShim) {
      let ast = rulesForStyle(style);

      this._ensure();

      this._applyShim['transformRules'](ast);

      style.textContent = toCssText(ast);
    }
  }

  getComputedStyleValue(element, property) {
    let value;

    if (!nativeCssVariables) {
      // element is either a style host, or an ancestor of a style host
      let styleInfo = StyleInfo.get(element) || StyleInfo.get(this._styleOwnerForNode(element));
      value = styleInfo.styleProperties[property];
    } // fall back to the property value from the computed styling


    value = value || window.getComputedStyle(element).getPropertyValue(property); // trim whitespace that can come after the `:` in css
    // example: padding: 2px -> " 2px"

    return value ? value.trim() : '';
  } // given an element and a classString, replaces
  // the element's class with the provided classString and adds
  // any necessary ShadyCSS static and property based scoping selectors


  setElementClass(element, classString) {
    let root = wrap$1(element).getRootNode();
    let classes = classString ? classString.split(/\s/) : [];
    let scopeName = root.host && root.host.localName; // If no scope, try to discover scope name from existing class.
    // This can occur if, for example, a template stamped element that
    // has been scoped is manipulated when not in a root.

    if (!scopeName) {
      var classAttr = element.getAttribute('class');

      if (classAttr) {
        let k$ = classAttr.split(/\s/);

        for (let i = 0; i < k$.length; i++) {
          if (k$[i] === StyleTransformer$1.SCOPE_NAME) {
            scopeName = k$[i + 1];
            break;
          }
        }
      }
    }

    if (scopeName) {
      classes.push(StyleTransformer$1.SCOPE_NAME, scopeName);
    }

    if (!nativeCssVariables) {
      let styleInfo = StyleInfo.get(element);

      if (styleInfo && styleInfo.scopeSelector) {
        classes.push(StyleProperties$1.XSCOPE_NAME, styleInfo.scopeSelector);
      }
    }

    setElementClassRaw(element, classes.join(' '));
  }

  _styleInfoForNode(node) {
    return StyleInfo.get(node);
  }
  /**
   * @param {!Element} node
   * @param {string} scope
   */


  scopeNode(node, scope) {
    StyleTransformer$1.element(node, scope);
  }
  /**
   * @param {!Element} node
   * @param {string} scope
   */


  unscopeNode(node, scope) {
    StyleTransformer$1.element(node, scope, true);
  }
  /**
   * @param {!Node} node
   * @return {string}
   */


  scopeForNode(node) {
    return getOwnerScope(node);
  }
  /**
   * @param {!Element} node
   * @return {string}
   */


  currentScopeForNode(node) {
    return getCurrentScope(node);
  }

}
/* exports */

/* eslint-disable no-self-assign */

ScopingShim.prototype['flush'] = ScopingShim.prototype.flush;
ScopingShim.prototype['prepareTemplate'] = ScopingShim.prototype.prepareTemplate;
ScopingShim.prototype['styleElement'] = ScopingShim.prototype.styleElement;
ScopingShim.prototype['styleDocument'] = ScopingShim.prototype.styleDocument;
ScopingShim.prototype['styleSubtree'] = ScopingShim.prototype.styleSubtree;
ScopingShim.prototype['getComputedStyleValue'] = ScopingShim.prototype.getComputedStyleValue;
ScopingShim.prototype['setElementClass'] = ScopingShim.prototype.setElementClass;
ScopingShim.prototype['_styleInfoForNode'] = ScopingShim.prototype._styleInfoForNode;
ScopingShim.prototype['transformCustomStyleForDocument'] = ScopingShim.prototype.transformCustomStyleForDocument;
ScopingShim.prototype['getStyleAst'] = ScopingShim.prototype.getStyleAst;
ScopingShim.prototype['styleAstToString'] = ScopingShim.prototype.styleAstToString;
ScopingShim.prototype['flushCustomStyles'] = ScopingShim.prototype.flushCustomStyles;
ScopingShim.prototype['scopeNode'] = ScopingShim.prototype.scopeNode;
ScopingShim.prototype['unscopeNode'] = ScopingShim.prototype.unscopeNode;
ScopingShim.prototype['scopeForNode'] = ScopingShim.prototype.scopeForNode;
ScopingShim.prototype['currentScopeForNode'] = ScopingShim.prototype.currentScopeForNode;
ScopingShim.prototype['prepareAdoptedCssText'] = ScopingShim.prototype.prepareAdoptedCssText;
/* eslint-enable no-self-assign */

Object.defineProperties(ScopingShim.prototype, {
  'nativeShadow': {
    get() {
      return nativeShadow;
    }

  },
  'nativeCss': {
    get() {
      return nativeCssVariables;
    }

  }
});

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/* global win, window */
// glob is a temporary fix to allow our es-modules to work.

var glob = typeof win === 'undefined' ? window : win,
    doc = glob.document,
    SVG_NS = 'http://www.w3.org/2000/svg',
    userAgent = glob.navigator && glob.navigator.userAgent || '',
    svg = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
    isMS = /(edge|msie|trident)/i.test(userAgent) && !glob.opera,
    isFirefox = userAgent.indexOf('Firefox') !== -1,
    isChrome = userAgent.indexOf('Chrome') !== -1,
    hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4 // issue #38
;
var Highcharts = glob.Highcharts ? glob.Highcharts.error(16, true) : {
  product: '@product.name@',
  version: '@product.version@',
  deg2rad: Math.PI * 2 / 360,
  doc: doc,
  hasBidiBug: hasBidiBug,
  hasTouch: doc && doc.documentElement.ontouchstart !== undefined,
  isMS: isMS,
  isWebKit: userAgent.indexOf('AppleWebKit') !== -1,
  isFirefox: isFirefox,
  isChrome: isChrome,
  isSafari: !isChrome && userAgent.indexOf('Safari') !== -1,
  isTouchDevice: /(Mobile|Android|Windows Phone)/.test(userAgent),
  SVG_NS: SVG_NS,
  chartCount: 0,
  seriesTypes: {},
  symbolSizes: {},
  svg: svg,
  win: glob,
  marginNames: ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],
  noop: function () {
    return undefined;
  },

  /**
   * An array containing the current chart objects in the page. A chart's
   * position in the array is preserved throughout the page's lifetime. When
   * a chart is destroyed, the array item becomes `undefined`.
   *
   * @name Highcharts.charts
   * @type {Array<Highcharts.Chart>}
   */
  charts: []
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * The Highcharts object is the placeholder for all other members, and various
 * utility functions. The most important member of the namespace would be the
 * chart constructor.
 *
 * @example
 * var chart = Highcharts.chart('container', { ... });
 *
 * @namespace Highcharts
 */

Highcharts.timers = [];
var charts = Highcharts.charts,
    doc$1 = Highcharts.doc,
    win$1 = Highcharts.win;
/**
 * Provide error messages for debugging, with links to online explanation. This
 * function can be overridden to provide custom error handling.
 *
 * @sample highcharts/chart/highcharts-error/
 *         Custom error handler
 *
 * @function Highcharts.error
 *
 * @param {number|string} code
 *        The error code. See
 *        [errors.xml]{@link https://github.com/highcharts/highcharts/blob/master/errors/errors.xml}
 *        for available codes. If it is a string, the error message is printed
 *        directly in the console.
 *
 * @param {boolean} [stop=false]
 *        Whether to throw an error or just log a warning in the console.
 */

Highcharts.error = function (code, stop) {
  var msg = Highcharts.isNumber(code) ? 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code : code;

  if (stop) {
    throw new Error(msg);
  } // else ...


  if (win$1.console) {
    console.log(msg); // eslint-disable-line no-console
  }
};
/**
 * An animator object used internally. One instance applies to one property
 * (attribute or style prop) on one element. Animation is always initiated
 * through {@link SVGElement#animate}.
 *
 * @example
 * var rect = renderer.rect(0, 0, 10, 10).add();
 * rect.animate({ width: 100 });
 *
 * @private
 * @class Highcharts.Fx
 *
 * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} elem
 *        The element to animate.
 *
 * @param {Highcharts.AnimationOptionsObject} options
 *        Animation options.
 *
 * @param {string} prop
 *        The single attribute or CSS property to animate.
 */


Highcharts.Fx = function (elem, options, prop) {
  this.options = options;
  this.elem = elem;
  this.prop = prop;
};

Highcharts.Fx.prototype = {
  /**
   * Set the current step of a path definition on SVGElement.
   *
   * @function Highcharts.Fx#dSetter
   */
  dSetter: function () {
    var start = this.paths[0],
        end = this.paths[1],
        ret = [],
        now = this.now,
        i = start.length,
        startVal; // Land on the final path without adjustment points appended in the ends

    if (now === 1) {
      ret = this.toD;
    } else if (i === end.length && now < 1) {
      while (i--) {
        startVal = parseFloat(start[i]);
        ret[i] = isNaN(startVal) ? // a letter instruction like M or L
        end[i] : now * parseFloat(end[i] - startVal) + startVal;
      } // If animation is finished or length not matching, land on right value

    } else {
      ret = end;
    }

    this.elem.attr('d', ret, null, true);
  },

  /**
   * Update the element with the current animation step.
   *
   * @function Highcharts.Fx#update
   */
  update: function () {
    var elem = this.elem,
        prop = this.prop,
        // if destroyed, it is null
    now = this.now,
        step = this.options.step; // Animation setter defined from outside

    if (this[prop + 'Setter']) {
      this[prop + 'Setter'](); // Other animations on SVGElement
    } else if (elem.attr) {
      if (elem.element) {
        elem.attr(prop, now, null, true);
      } // HTML styles, raw HTML content like container size

    } else {
      elem.style[prop] = now + this.unit;
    }

    if (step) {
      step.call(elem, now, this);
    }
  },

  /**
   * Run an animation.
   *
   * @function Highcharts.Fx#run
   *
   * @param {number} from
   *        The current value, value to start from.
   *
   * @param {number} to
   *        The end value, value to land on.
   *
   * @param {string} [unit]
   *        The property unit, for example `px`.
   */
  run: function (from, to, unit) {
    var self = this,
        options = self.options,
        timer = function (gotoEnd) {
      return timer.stopped ? false : self.step(gotoEnd);
    },
        requestAnimationFrame = win$1.requestAnimationFrame || function (step) {
      setTimeout(step, 13);
    },
        step = function () {
      for (var i = 0; i < Highcharts.timers.length; i++) {
        if (!Highcharts.timers[i]()) {
          Highcharts.timers.splice(i--, 1);
        }
      }

      if (Highcharts.timers.length) {
        requestAnimationFrame(step);
      }
    };

    if (from === to && !this.elem['forceAnimate:' + this.prop]) {
      delete options.curAnim[this.prop];

      if (options.complete && Highcharts.keys(options.curAnim).length === 0) {
        options.complete.call(this.elem);
      }
    } else {
      // #7166
      this.startTime = +new Date();
      this.start = from;
      this.end = to;
      this.unit = unit;
      this.now = this.start;
      this.pos = 0;
      timer.elem = this.elem;
      timer.prop = this.prop;

      if (timer() && Highcharts.timers.push(timer) === 1) {
        requestAnimationFrame(step);
      }
    }
  },

  /**
   * Run a single step in the animation.
   *
   * @function Highcharts.Fx#step
   *
   * @param {boolean} [gotoEnd]
   *        Whether to go to the endpoint of the animation after abort.
   *
   * @return {boolean}
   *         Returns `true` if animation continues.
   */
  step: function (gotoEnd) {
    var t = +new Date(),
        ret,
        done,
        options = this.options,
        elem = this.elem,
        complete = options.complete,
        duration = options.duration,
        curAnim = options.curAnim;

    if (elem.attr && !elem.element) {
      // #2616, element is destroyed
      ret = false;
    } else if (gotoEnd || t >= duration + this.startTime) {
      this.now = this.end;
      this.pos = 1;
      this.update();
      curAnim[this.prop] = true;
      done = true;
      Highcharts.objectEach(curAnim, function (val) {
        if (val !== true) {
          done = false;
        }
      });

      if (done && complete) {
        complete.call(elem);
      }

      ret = false;
    } else {
      this.pos = options.easing((t - this.startTime) / duration);
      this.now = this.start + (this.end - this.start) * this.pos;
      this.update();
      ret = true;
    }

    return ret;
  },

  /**
   * Prepare start and end values so that the path can be animated one to one.
   *
   * @function Highcharts.Fx#initPath
   *
   * @param {Highcharts.SVGElement} elem
   *        The SVGElement item.
   *
   * @param {string} fromD
   *        Starting path definition.
   *
   * @param {Highcharts.SVGPathArray} toD
   *        Ending path definition.
   *
   * @return {Array<Highcharts.SVGPathArray>}
   *         An array containing start and end paths in array form so that
   *         they can be animated in parallel.
   */
  initPath: function (elem, fromD, toD) {
    fromD = fromD || '';
    var shift,
        startX = elem.startX,
        endX = elem.endX,
        bezier = fromD.indexOf('C') > -1,
        numParams = bezier ? 7 : 3,
        fullLength,
        slice,
        i,
        start = fromD.split(' '),
        end = toD.slice(),
        // copy
    isArea = elem.isArea,
        positionFactor = isArea ? 2 : 1,
        reverse;
    /**
     * In splines make moveTo and lineTo points have six parameters like
     * bezier curves, to allow animation one-to-one.
     */

    function sixify(arr) {
      var isOperator, nextIsOperator;
      i = arr.length;

      while (i--) {
        // Fill in dummy coordinates only if the next operator comes
        // three places behind (#5788)
        isOperator = arr[i] === 'M' || arr[i] === 'L';
        nextIsOperator = /[a-zA-Z]/.test(arr[i + 3]);

        if (isOperator && nextIsOperator) {
          arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
        }
      }
    }
    /**
     * Insert an array at the given position of another array
     */


    function insertSlice(arr, subArr, index) {
      [].splice.apply(arr, [index, 0].concat(subArr));
    }
    /**
     * If shifting points, prepend a dummy point to the end path.
     */


    function prepend(arr, other) {
      while (arr.length < fullLength) {
        // Move to, line to or curve to?
        arr[0] = other[fullLength - arr.length]; // Prepend a copy of the first point

        insertSlice(arr, arr.slice(0, numParams), 0); // For areas, the bottom path goes back again to the left, so we
        // need to append a copy of the last point.

        if (isArea) {
          insertSlice(arr, arr.slice(arr.length - numParams), arr.length);
          i--;
        }
      }

      arr[0] = 'M';
    }
    /**
     * Copy and append last point until the length matches the end length.
     */


    function append(arr, other) {
      var i = (fullLength - arr.length) / numParams;

      while (i > 0 && i--) {
        // Pull out the slice that is going to be appended or inserted.
        // In a line graph, the positionFactor is 1, and the last point
        // is sliced out. In an area graph, the positionFactor is 2,
        // causing the middle two points to be sliced out, since an area
        // path starts at left, follows the upper path then turns and
        // follows the bottom back.
        slice = arr.slice().splice(arr.length / positionFactor - numParams, numParams * positionFactor); // Move to, line to or curve to?

        slice[0] = other[fullLength - numParams - i * numParams]; // Disable first control point

        if (bezier) {
          slice[numParams - 6] = slice[numParams - 2];
          slice[numParams - 5] = slice[numParams - 1];
        } // Now insert the slice, either in the middle (for areas) or at
        // the end (for lines)


        insertSlice(arr, slice, arr.length / positionFactor);

        if (isArea) {
          i--;
        }
      }
    }

    if (bezier) {
      sixify(start);
      sixify(end);
    } // For sideways animation, find out how much we need to shift to get the
    // start path Xs to match the end path Xs.


    if (startX && endX) {
      for (i = 0; i < startX.length; i++) {
        // Moving left, new points coming in on right
        if (startX[i] === endX[0]) {
          shift = i;
          break; // Moving right
        } else if (startX[0] === endX[endX.length - startX.length + i]) {
          shift = i;
          reverse = true;
          break;
        }
      }

      if (shift === undefined) {
        start = [];
      }
    }

    if (start.length && Highcharts.isNumber(shift)) {
      // The common target length for the start and end array, where both
      // arrays are padded in opposite ends
      fullLength = end.length + shift * positionFactor * numParams;

      if (!reverse) {
        prepend(end, start);
        append(start, end);
      } else {
        prepend(start, end);
        append(end, start);
      }
    }

    return [start, end];
  },

  /**
   * Handle animation of the color attributes directly.
   *
   * @function Highcharts.Fx#fillSetter
   */
  fillSetter: function () {
    Highcharts.Fx.prototype.strokeSetter.apply(this, arguments);
  },

  /**
   * Handle animation of the color attributes directly.
   *
   * @function Highcharts.Fx#strokeSetter
   */
  strokeSetter: function () {
    this.elem.attr(this.prop, Highcharts.color(this.start).tweenTo(Highcharts.color(this.end), this.pos), null, true);
  }
}; // End of Fx prototype

/**
 * Utility function to deep merge two or more objects and return a third object.
 * The merge function can also be used with a single object argument to create a
 * deep copy of an object.
 *
 * @function Highcharts.merge
 *
 * @param {*} a
 *        The first object to extend. When only this is given, the function
 *        returns a deep copy.
 *
 * @param {*} [n]
 *        An object to merge into the previous one.
 *
 * @return {*}
 *         The merged object. If the first argument is true, the return is the
 *         same as the second argument.
 */

/**
* Utility function to deep merge two or more objects and return a third object.
* If the first argument is true, the contents of the second object is copied
* into the first object. The merge function can also be used with a single
* object argument to create a deep copy of an object.
*
* @function Highcharts.merge
*
* @param {boolean} extend
*        Whether to extend the left-side object (a) or return a whole new
*        object.
*
* @param {*} a
*        The first object to extend. When only this is given, the function
*        returns a deep copy.
*
* @param {*} [n]
*        An object to merge into the previous one.
*
* @return {*}
*         The merged object. If the first argument is true, the return is the
*         same as the second argument.
*/

Highcharts.merge = function () {
  var i,
      args = arguments,
      len,
      ret = {},
      doCopy = function (copy, original) {
    // An object is replacing a primitive
    if (typeof copy !== 'object') {
      copy = {};
    }

    Highcharts.objectEach(original, function (value, key) {
      // Copy the contents of objects, but not arrays or DOM nodes
      if (Highcharts.isObject(value, true) && !Highcharts.isClass(value) && !Highcharts.isDOMElement(value)) {
        copy[key] = doCopy(copy[key] || {}, value); // Primitives and arrays are copied over directly
      } else {
        copy[key] = original[key];
      }
    });
    return copy;
  }; // If first argument is true, copy into the existing object. Used in
  // setOptions.


  if (args[0] === true) {
    ret = args[1];
    args = Array.prototype.slice.call(args, 2);
  } // For each argument, extend the return


  len = args.length;

  for (i = 0; i < len; i++) {
    ret = doCopy(ret, args[i]);
  }

  return ret;
};
/**
 * Shortcut for parseInt
 *
 * @private
 * @function Highcharts.pInt
 *
 * @param {*} s
 *
 * @param {number} mag
 *        Magnitude
 *
 * @return {number}
 */


Highcharts.pInt = function (s, mag) {
  return parseInt(s, mag || 10);
};
/**
 * Utility function to check for string type.
 *
 * @function Highcharts.isString
 *
 * @param {*} s
 *        The item to check.
 *
 * @return {boolean}
 *         True if the argument is a string.
 */


Highcharts.isString = function (s) {
  return typeof s === 'string';
};
/**
 * Utility function to check if an item is an array.
 *
 * @function Highcharts.isArray
 *
 * @param {*} obj
 *        The item to check.
 *
 * @return {boolean}
 *         True if the argument is an array.
 */


Highcharts.isArray = function (obj) {
  var str = Object.prototype.toString.call(obj);
  return str === '[object Array]' || str === '[object Array Iterator]';
};
/**
 * Utility function to check if an item is of type object.
 *
 * @function Highcharts.isObject
 *
 * @param {*} obj
 *        The item to check.
 *
 * @param {boolean} [strict=false]
 *        Also checks that the object is not an array.
 *
 * @return {boolean}
 *         True if the argument is an object.
 */


Highcharts.isObject = function (obj, strict) {
  return !!obj && typeof obj === 'object' && (!strict || !Highcharts.isArray(obj));
};
/**
 * Utility function to check if an Object is a HTML Element.
 *
 * @function Highcharts.isDOMElement
 *
 * @param {*} obj
 *        The item to check.
 *
 * @return {boolean}
 *         True if the argument is a HTML Element.
 */


Highcharts.isDOMElement = function (obj) {
  return Highcharts.isObject(obj) && typeof obj.nodeType === 'number';
};
/**
 * Utility function to check if an Object is an class.
 *
 * @function Highcharts.isClass
 *
 * @param {*} obj
 *        The item to check.
 *
 * @return {boolean}
 *         True if the argument is an class.
 */


Highcharts.isClass = function (obj) {
  var c = obj && obj.constructor;
  return !!(Highcharts.isObject(obj, true) && !Highcharts.isDOMElement(obj) && c && c.name && c.name !== 'Object');
};
/**
 * Utility function to check if an item is a number and it is finite (not NaN,
 * Infinity or -Infinity).
 *
 * @function Highcharts.isNumber
 *
 * @param {*} n
 *        The item to check.
 *
 * @return {boolean}
 *         True if the item is a finite number
 */


Highcharts.isNumber = function (n) {
  return typeof n === 'number' && !isNaN(n) && n < Infinity && n > -Infinity;
};
/**
 * Remove the last occurence of an item from an array.
 *
 * @function Highcharts.erase
 *
 * @param {Array} arr
 *        The array.
 *
 * @param {*} item
 *        The item to remove.
 */


Highcharts.erase = function (arr, item) {
  var i = arr.length;

  while (i--) {
    if (arr[i] === item) {
      arr.splice(i, 1);
      break;
    }
  }
};
/**
 * Check if an object is null or undefined.
 *
 * @function Highcharts.defined
 *
 * @param {*} obj
 *        The object to check.
 *
 * @return {boolean}
 *         False if the object is null or undefined, otherwise true.
 */


Highcharts.defined = function (obj) {
  return obj !== undefined && obj !== null;
};
/**
 * Set or get an attribute or an object of attributes. To use as a setter, pass
 * a key and a value, or let the second argument be a collection of keys and
 * values. To use as a getter, pass only a string as the second argument.
 *
 * @function Highcharts.attr
 *
 * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} elem
 *        The DOM element to receive the attribute(s).
 *
 * @param {string|Highcharts.HTMLAttributes|Highcharts.SVGAttributes} [prop]
 *        The property or an object of key-value pairs.
 *
 * @param {string} [value]
 *        The value if a single property is set.
 *
 * @return {*}
 *         When used as a getter, return the value.
 */


Highcharts.attr = function (elem, prop, value) {
  var ret; // if the prop is a string

  if (Highcharts.isString(prop)) {
    // set the value
    if (Highcharts.defined(value)) {
      elem.setAttribute(prop, value); // get the value
    } else if (elem && elem.getAttribute) {
      ret = elem.getAttribute(prop); // IE7 and below cannot get class through getAttribute (#7850)

      if (!ret && prop === 'class') {
        ret = elem.getAttribute(prop + 'Name');
      }
    } // else if prop is defined, it is a hash of key/value pairs

  } else if (Highcharts.defined(prop) && Highcharts.isObject(prop)) {
    Highcharts.objectEach(prop, function (val, key) {
      elem.setAttribute(key, val);
    });
  }

  return ret;
};
/**
 * Check if an element is an array, and if not, make it into an array.
 *
 * @function Highcharts.splat
 *
 * @param {*} obj
 *        The object to splat.
 *
 * @return {Array}
 *         The produced or original array.
 */


Highcharts.splat = function (obj) {
  return Highcharts.isArray(obj) ? obj : [obj];
};
/**
 * Set a timeout if the delay is given, otherwise perform the function
 * synchronously.
 *
 * @function Highcharts.syncTimeout
 *
 * @param {Function} fn
 *        The function callback.
 *
 * @param {number} delay
 *        Delay in milliseconds.
 *
 * @param {*} [context]
 *        The context.
 *
 * @return {number}
 *         An identifier for the timeout that can later be cleared with
 *         Highcharts.clearTimeout.
 */


Highcharts.syncTimeout = function (fn, delay, context) {
  if (delay) {
    return setTimeout(fn, delay, context);
  }

  fn.call(0, context);
};
/**
 * Internal clear timeout. The function checks that the `id` was not removed
 * (e.g. by `chart.destroy()`). For the details see
 * [issue #7901](https://github.com/highcharts/highcharts/issues/7901).
 *
 * @function Highcharts.clearTimeout
 *
 * @param {number} id
 *        Id of a timeout.
 */


Highcharts.clearTimeout = function (id) {
  if (Highcharts.defined(id)) {
    clearTimeout(id);
  }
};
/**
 * Utility function to extend an object with the members of another.
 *
 * @function Highcharts.extend
 *
 * @param {Highcharts.Dictionary<*>} a
 *        The object to be extended.
 *
 * @param {Highcharts.Dictionary<*>} b
 *        The object to add to the first one.
 *
 * @return {Highcharts.Dictionary<*>}
 *         Object a, the original object.
 */


Highcharts.extend = function (a, b) {
  var n;

  if (!a) {
    a = {};
  }

  for (n in b) {
    a[n] = b[n];
  }

  return a;
};
/**
 * Return the first value that is not null or undefined.
 *
 * @function Highcharts.pick
 *
 * @param {...*} items
 *        Variable number of arguments to inspect.
 *
 * @return {*}
 *         The value of the first argument that is not null or undefined.
 */


Highcharts.pick = function () {
  var args = arguments,
      i,
      arg,
      length = args.length;

  for (i = 0; i < length; i++) {
    arg = args[i];

    if (arg !== undefined && arg !== null) {
      return arg;
    }
  }
};
/**
 * Set CSS on a given element.
 *
 * @function Highcharts.css
 *
 * @param {Highcharts.HTMLDOMElement} el
 *        An HTML DOM element.
 *
 * @param {Highcharts.CSSObject} styles
 *        Style object with camel case property names.
 */


Highcharts.css = function (el, styles) {
  if (Highcharts.isMS && !Highcharts.svg) {
    // #2686
    if (styles && styles.opacity !== undefined) {
      styles.filter = 'alpha(opacity=' + styles.opacity * 100 + ')';
    }
  }

  Highcharts.extend(el.style, styles);
};
/**
 * Utility function to create an HTML element with attributes and styles.
 *
 * @function Highcharts.createElement
 *
 * @param {string} tag
 *        The HTML tag.
 *
 * @param {Highcharts.HTMLAttributes} [attribs]
 *        Attributes as an object of key-value pairs.
 *
 * @param {Highcharts.CSSObject} [styles]
 *        Styles as an object of key-value pairs.
 *
 * @param {Highcharts.HTMLDOMElement} [parent]
 *        The parent HTML object.
 *
 * @param {boolean} [nopad=false]
 *        If true, remove all padding, border and margin.
 *
 * @return {Highcharts.HTMLDOMElement}
 *         The created DOM element.
 */


Highcharts.createElement = function (tag, attribs, styles, parent, nopad) {
  var el = doc$1.createElement(tag),
      css = Highcharts.css;

  if (attribs) {
    Highcharts.extend(el, attribs);
  }

  if (nopad) {
    css(el, {
      padding: 0,
      border: 'none',
      margin: 0
    });
  }

  if (styles) {
    css(el, styles);
  }

  if (parent) {
    parent.appendChild(el);
  }

  return el;
};
/**
 * Extend a prototyped class by new members.
 *
 * @function Highcharts.extendClass
 *
 * @param {*} parent
 *        The parent prototype to inherit.
 *
 * @param {Highcharts.Dictionary<*>} members
 *        A collection of prototype members to add or override compared to the
 *        parent prototype.
 *
 * @return {*}
 *         A new prototype.
 */


Highcharts.extendClass = function (parent, members) {
  var object = function () {};

  object.prototype = new parent(); // eslint-disable-line new-cap

  Highcharts.extend(object.prototype, members);
  return object;
};
/**
 * Left-pad a string to a given length by adding a character repetetively.
 *
 * @function Highcharts.pad
 *
 * @param {number} number
 *        The input string or number.
 *
 * @param {number} length
 *        The desired string length.
 *
 * @param {string} [padder=0]
 *        The character to pad with.
 *
 * @return {string}
 *         The padded string.
 */


Highcharts.pad = function (number, length, padder) {
  return new Array((length || 2) + 1 - String(number).replace('-', '').length).join(padder || 0) + number;
};
/**
 * Return a length based on either the integer value, or a percentage of a base.
 *
 * @function Highcharts.relativeLength
 *
 * @param {Highcharts.RelativeSize} value
 *        A percentage string or a number.
 *
 * @param {number} base
 *        The full length that represents 100%.
 *
 * @param {number} [offset=0]
 *        A pixel offset to apply for percentage values. Used internally in
 *        axis positioning.
 *
 * @return {number}
 *         The computed length.
 */


Highcharts.relativeLength = function (value, base, offset) {
  return /%$/.test(value) ? base * parseFloat(value) / 100 + (offset || 0) : parseFloat(value);
};
/**
 * Wrap a method with extended functionality, preserving the original function.
 *
 * @function Highcharts.wrap
 *
 * @param {*} obj
 *        The context object that the method belongs to. In real cases, this is
 *        often a prototype.
 *
 * @param {string} method
 *        The name of the method to extend.
 *
 * @param {Function} func
 *        A wrapper function callback. This function is called with the same
 *        arguments as the original function, except that the original function
 *        is unshifted and passed as the first argument.
 */


Highcharts.wrap = function (obj, method, func) {
  var proceed = obj[method];

  obj[method] = function () {
    var args = Array.prototype.slice.call(arguments),
        outerArgs = arguments,
        ctx = this,
        ret;

    ctx.proceed = function () {
      proceed.apply(ctx, arguments.length ? arguments : outerArgs);
    };

    args.unshift(proceed);
    ret = func.apply(this, args);
    ctx.proceed = null;
    return ret;
  };
};
/**
 * Format a single variable. Similar to sprintf, without the % prefix.
 *
 * @example
 * formatSingle('.2f', 5); // => '5.00'.
 *
 * @function Highcharts.formatSingle
 *
 * @param {string} format
 *        The format string.
 *
 * @param {*} val
 *        The value.
 *
 * @param {Highcharts.Time} [time]
 *        A `Time` instance that determines the date formatting, for example
 *        for applying time zone corrections to the formatted date.
 *
 * @return {string}
 *         The formatted representation of the value.
 */


Highcharts.formatSingle = function (format, val, time) {
  var floatRegex = /f$/,
      decRegex = /\.([0-9])/,
      lang = Highcharts.defaultOptions.lang,
      decimals;

  if (floatRegex.test(format)) {
    // float
    decimals = format.match(decRegex);
    decimals = decimals ? decimals[1] : -1;

    if (val !== null) {
      val = Highcharts.numberFormat(val, decimals, lang.decimalPoint, format.indexOf(',') > -1 ? lang.thousandsSep : '');
    }
  } else {
    val = (time || Highcharts.time).dateFormat(format, val);
  }

  return val;
};
/**
 * Format a string according to a subset of the rules of Python's String.format
 * method.
 *
 * @example
 * var s = Highcharts.format(
 *     'The {color} fox was {len:.2f} feet long',
 *     { color: 'red', len: Math.PI }
 * );
 * // => The red fox was 3.14 feet long
 *
 * @function Highcharts.format
 *
 * @param {string} str
 *        The string to format.
 *
 * @param {*} ctx
 *        The context, a collection of key-value pairs where each key is
 *        replaced by its value.
 *
 * @param {Highcharts.Time} [time]
 *        A `Time` instance that determines the date formatting, for example
 *        for applying time zone corrections to the formatted date.
 *
 * @return {string}
 *         The formatted string.
 */


Highcharts.format = function (str, ctx, time) {
  var splitter = '{',
      isInside = false,
      segment,
      valueAndFormat,
      path,
      i,
      len,
      ret = [],
      val,
      index;

  while (str) {
    index = str.indexOf(splitter);

    if (index === -1) {
      break;
    }

    segment = str.slice(0, index);

    if (isInside) {
      // we're on the closing bracket looking back
      valueAndFormat = segment.split(':');
      path = valueAndFormat.shift().split('.'); // get first and leave

      len = path.length;
      val = ctx; // Assign deeper paths

      for (i = 0; i < len; i++) {
        if (val) {
          val = val[path[i]];
        }
      } // Format the replacement


      if (valueAndFormat.length) {
        val = Highcharts.formatSingle(valueAndFormat.join(':'), val, time);
      } // Push the result and advance the cursor


      ret.push(val);
    } else {
      ret.push(segment);
    }

    str = str.slice(index + 1); // the rest

    isInside = !isInside; // toggle

    splitter = isInside ? '}' : '{'; // now look for next matching bracket
  }

  ret.push(str);
  return ret.join('');
};
/**
 * Get the magnitude of a number.
 *
 * @function Highcharts.getMagnitude
 *
 * @param {number} number
 *        The number.
 *
 * @return {number}
 *         The magnitude, where 1-9 are magnitude 1, 10-99 magnitude 2 etc.
 */


Highcharts.getMagnitude = function (num) {
  return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
};
/**
 * Take an interval and normalize it to multiples of round numbers.
 *
 * @deprecated
 * @function Highcharts.normalizeTickInterval
 *
 * @param {number} interval
 *        The raw, un-rounded interval.
 *
 * @param {Array} [multiples]
 *        Allowed multiples.
 *
 * @param {number} [magnitude]
 *        The magnitude of the number.
 *
 * @param {boolean} [allowDecimals]
 *        Whether to allow decimals.
 *
 * @param {boolean} [hasTickAmount]
 *        If it has tickAmount, avoid landing on tick intervals lower than
 *        original.
 *
 * @return {number}
 *         The normalized interval.
 *
 * @todo
 * Move this function to the Axis prototype. It is here only for historical
 * reasons.
 */


Highcharts.normalizeTickInterval = function (interval, multiples, magnitude, allowDecimals, hasTickAmount) {
  var normalized,
      i,
      retInterval = interval; // round to a tenfold of 1, 2, 2.5 or 5

  magnitude = Highcharts.pick(magnitude, 1);
  normalized = interval / magnitude; // multiples for a linear scale

  if (!multiples) {
    multiples = hasTickAmount ? // Finer grained ticks when the tick amount is hard set, including
    // when alignTicks is true on multiple axes (#4580).
    [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : // Else, let ticks fall on rounder numbers
    [1, 2, 2.5, 5, 10]; // the allowDecimals option

    if (allowDecimals === false) {
      if (magnitude === 1) {
        multiples = Highcharts.grep(multiples, function (num) {
          return num % 1 === 0;
        });
      } else if (magnitude <= 0.1) {
        multiples = [1 / magnitude];
      }
    }
  } // normalize the interval to the nearest multiple


  for (i = 0; i < multiples.length; i++) {
    retInterval = multiples[i]; // only allow tick amounts smaller than natural

    if (hasTickAmount && retInterval * magnitude >= interval || !hasTickAmount && normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
      break;
    }
  } // Multiply back to the correct magnitude. Correct floats to appropriate
  // precision (#6085).


  retInterval = Highcharts.correctFloat(retInterval * magnitude, -Math.round(Math.log(0.001) / Math.LN10));
  return retInterval;
};
/**
 * Sort an object array and keep the order of equal items. The ECMAScript
 * standard does not specify the behaviour when items are equal.
 *
 * @function Highcharts.stableSort
 *
 * @param {Array} arr
 *        The array to sort.
 *
 * @param {Function} sortFunction
 *        The function to sort it with, like with regular Array.prototype.sort.
 */


Highcharts.stableSort = function (arr, sortFunction) {
  var length = arr.length,
      sortValue,
      i; // Add index to each item

  for (i = 0; i < length; i++) {
    arr[i].safeI = i; // stable sort index
  }

  arr.sort(function (a, b) {
    sortValue = sortFunction(a, b);
    return sortValue === 0 ? a.safeI - b.safeI : sortValue;
  }); // Remove index from items

  for (i = 0; i < length; i++) {
    delete arr[i].safeI; // stable sort index
  }
};
/**
 * Non-recursive method to find the lowest member of an array. `Math.min` raises
 * a maximum call stack size exceeded error in Chrome when trying to apply more
 * than 150.000 points. This method is slightly slower, but safe.
 *
 * @function Highcharts.arrayMin
 *
 * @param {Array} data
 *        An array of numbers.
 *
 * @return {number}
 *         The lowest number.
 */


Highcharts.arrayMin = function (data) {
  var i = data.length,
      min = data[0];

  while (i--) {
    if (data[i] < min) {
      min = data[i];
    }
  }

  return min;
};
/**
 * Non-recursive method to find the lowest member of an array. `Math.max` raises
 * a maximum call stack size exceeded error in Chrome when trying to apply more
 * than 150.000 points. This method is slightly slower, but safe.
 *
 * @function Highcharts.arrayMax
 *
 * @param {Array} data
 *        An array of numbers.
 *
 * @return {number}
 *         The highest number.
 */


Highcharts.arrayMax = function (data) {
  var i = data.length,
      max = data[0];

  while (i--) {
    if (data[i] > max) {
      max = data[i];
    }
  }

  return max;
};
/**
 * Utility method that destroys any SVGElement instances that are properties on
 * the given object. It loops all properties and invokes destroy if there is a
 * destroy method. The property is then delete.
 *
 * @function Highcharts.destroyObjectProperties
 *
 * @param {*} obj
 *        The object to destroy properties on.
 *
 * @param {*} [except]
 *        Exception, do not destroy this property, only delete it.
 */


Highcharts.destroyObjectProperties = function (obj, except) {
  Highcharts.objectEach(obj, function (val, n) {
    // If the object is non-null and destroy is defined
    if (val && val !== except && val.destroy) {
      // Invoke the destroy
      val.destroy();
    } // Delete the property from the object.


    delete obj[n];
  });
};
/**
 * Discard a HTML element by moving it to the bin and delete.
 *
 * @function Highcharts.discardElement
 *
 * @param {Highcharts.HTMLDOMElement} element
 *        The HTML node to discard.
 */


Highcharts.discardElement = function (element) {
  var garbageBin = Highcharts.garbageBin; // create a garbage bin element, not part of the DOM

  if (!garbageBin) {
    garbageBin = Highcharts.createElement('div');
  } // move the node and empty bin


  if (element) {
    garbageBin.appendChild(element);
  }

  garbageBin.innerHTML = '';
};
/**
 * Fix JS round off float errors.
 *
 * @function Highcharts.correctFloat
 *
 * @param {number} num
 *        A float number to fix.
 *
 * @param {number} [prec=14]
 *        The precision.
 *
 * @return {number}
 *         The corrected float number.
 */


Highcharts.correctFloat = function (num, prec) {
  return parseFloat(num.toPrecision(prec || 14));
};
/**
 * Set the global animation to either a given value, or fall back to the given
 * chart's animation option.
 *
 * @function Highcharts.setAnimation
 *
 * @param {boolean|Highcharts.AnimationOptionsObject} animation
 *        The animation object.
 *
 * @param {Highcharts.Chart} chart
 *        The chart instance.
 *
 * @todo
 * This function always relates to a chart, and sets a property on the renderer,
 * so it should be moved to the SVGRenderer.
 */


Highcharts.setAnimation = function (animation, chart) {
  chart.renderer.globalAnimation = Highcharts.pick(animation, chart.options.chart.animation, true);
};
/**
 * Get the animation in object form, where a disabled animation is always
 * returned as `{ duration: 0 }`.
 *
 * @function Highcharts.animObject
 *
 * @param {boolean|Highcharts.AnimationOptionsObject} animation
 *        An animation setting. Can be an object with duration, complete and
 *        easing properties, or a boolean to enable or disable.
 *
 * @return {Highcharts.AnimationOptionsObject}
 *         An object with at least a duration property.
 */


Highcharts.animObject = function (animation) {
  return Highcharts.isObject(animation) ? Highcharts.merge(animation) : {
    duration: animation ? 500 : 0
  };
};
/**
 * The time unit lookup
 *
 * @ignore
 */


Highcharts.timeUnits = {
  millisecond: 1,
  second: 1000,
  minute: 60000,
  hour: 3600000,
  day: 24 * 3600000,
  week: 7 * 24 * 3600000,
  month: 28 * 24 * 3600000,
  year: 364 * 24 * 3600000
};
/**
 * Format a number and return a string based on input settings.
 *
 * @sample highcharts/members/highcharts-numberformat/
 *         Custom number format
 *
 * @function Highcharts.numberFormat
 *
 * @param {number} number
 *        The input number to format.
 *
 * @param {number} decimals
 *        The amount of decimals. A value of -1 preserves the amount in the
 *        input number.
 *
 * @param {string} [decimalPoint]
 *        The decimal point, defaults to the one given in the lang options, or
 *        a dot.
 *
 * @param {string} [thousandsSep]
 *        The thousands separator, defaults to the one given in the lang
 *        options, or a space character.
 *
 * @return {string}
 *         The formatted number.
 */

Highcharts.numberFormat = function (number, decimals, decimalPoint, thousandsSep) {
  number = +number || 0;
  decimals = +decimals;
  var lang = Highcharts.defaultOptions.lang,
      origDec = (number.toString().split('.')[1] || '').split('e')[0].length,
      strinteger,
      thousands,
      ret,
      roundedNumber,
      exponent = number.toString().split('e'),
      fractionDigits;

  if (decimals === -1) {
    // Preserve decimals. Not huge numbers (#3793).
    decimals = Math.min(origDec, 20);
  } else if (!Highcharts.isNumber(decimals)) {
    decimals = 2;
  } else if (decimals && exponent[1] && exponent[1] < 0) {
    // Expose decimals from exponential notation (#7042)
    fractionDigits = decimals + +exponent[1];

    if (fractionDigits >= 0) {
      // remove too small part of the number while keeping the notation
      exponent[0] = (+exponent[0]).toExponential(fractionDigits).split('e')[0];
      decimals = fractionDigits;
    } else {
      // fractionDigits < 0
      exponent[0] = exponent[0].split('.')[0] || 0;

      if (decimals < 20) {
        // use number instead of exponential notation (#7405)
        number = (exponent[0] * Math.pow(10, exponent[1])).toFixed(decimals);
      } else {
        // or zero
        number = 0;
      }

      exponent[1] = 0;
    }
  } // Add another decimal to avoid rounding errors of float numbers. (#4573)
  // Then use toFixed to handle rounding.


  roundedNumber = (Math.abs(exponent[1] ? exponent[0] : number) + Math.pow(10, -Math.max(decimals, origDec) - 1)).toFixed(decimals); // A string containing the positive integer component of the number

  strinteger = String(Highcharts.pInt(roundedNumber)); // Leftover after grouping into thousands. Can be 0, 1 or 2.

  thousands = strinteger.length > 3 ? strinteger.length % 3 : 0; // Language

  decimalPoint = Highcharts.pick(decimalPoint, lang.decimalPoint);
  thousandsSep = Highcharts.pick(thousandsSep, lang.thousandsSep); // Start building the return

  ret = number < 0 ? '-' : ''; // Add the leftover after grouping into thousands. For example, in the
  // number 42 000 000, this line adds 42.

  ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : ''; // Add the remaining thousands groups, joined by the thousands separator

  ret += strinteger.substr(thousands).replace(/(\d{3})(?=\d)/g, '$1' + thousandsSep); // Add the decimal point and the decimal component

  if (decimals) {
    // Get the decimal component
    ret += decimalPoint + roundedNumber.slice(-decimals);
  }

  if (exponent[1] && +ret !== 0) {
    ret += 'e' + exponent[1];
  }

  return ret;
};
/**
 * Easing definition
 *
 * @private
 * @function Math.easeInOutSine
 *
 * @param {number} pos
 *        Current position, ranging from 0 to 1.
 *
 * @return {number}
 */


Math.easeInOutSine = function (pos) {
  return -0.5 * (Math.cos(Math.PI * pos) - 1);
};
/**
 * Get the computed CSS value for given element and property, only for numerical
 * properties. For width and height, the dimension of the inner box (excluding
 * padding) is returned. Used for fitting the chart within the container.
 *
 * @function Highcharts.getStyle
 *
 * @param {Highcharts.HTMLDOMElement} el
 *        An HTML element.
 *
 * @param {string} prop
 *        The property name.
 *
 * @param {boolean} [toInt=true]
 *        Parse to integer.
 *
 * @return {number}
 *         The numeric value.
 */


Highcharts.getStyle = function (el, prop, toInt) {
  var style; // For width and height, return the actual inner pixel size (#4913)

  if (prop === 'width') {
    return Math.max(0, // #8377
    Math.min(el.offsetWidth, el.scrollWidth) - Highcharts.getStyle(el, 'padding-left') - Highcharts.getStyle(el, 'padding-right'));
  } else if (prop === 'height') {
    return Math.max(0, // #8377
    Math.min(el.offsetHeight, el.scrollHeight) - Highcharts.getStyle(el, 'padding-top') - Highcharts.getStyle(el, 'padding-bottom'));
  }

  if (!win$1.getComputedStyle) {
    // SVG not supported, forgot to load oldie.js?
    Highcharts.error(27, true);
  } // Otherwise, get the computed style


  style = win$1.getComputedStyle(el, undefined);

  if (style) {
    style = style.getPropertyValue(prop);

    if (Highcharts.pick(toInt, prop !== 'opacity')) {
      style = Highcharts.pInt(style);
    }
  }

  return style;
};
/**
 * Search for an item in an array.
 *
 * @function Highcharts.inArray
 *
 * @param {*} item
 *        The item to search for.
 *
 * @param {Array} arr
 *        The array or node collection to search in.
 *
 * @param {number} [fromIndex=0]
 *        The index to start searching from.
 *
 * @return {number}
 *         The index within the array, or -1 if not found.
 */


Highcharts.inArray = function (item, arr, fromIndex) {
  return (Highcharts.indexOfPolyfill || Array.prototype.indexOf).call(arr, item, fromIndex);
};
/**
 * Filter an array by a callback.
 *
 * @function Highcharts.grep
 *
 * @param {Array} arr
 *        The array to filter.
 *
 * @param {Function} callback
 *        The callback function. The function receives the item as the first
 *        argument. Return `true` if the item is to be preserved.
 *
 * @return {Array}
 *         A new, filtered array.
 */


Highcharts.grep = function (arr, callback) {
  return (Highcharts.filterPolyfill || Array.prototype.filter).call(arr, callback);
};
/**
 * Return the value of the first element in the array that satisfies the
 * provided testing function.
 *
 * @function Highcharts.find
 *
 * @param {Array} arr
 *        The array to test.
 *
 * @param {Function} callback
 *        The callback function. The function receives the item as the first
 *        argument. Return `true` if this item satisfies the condition.
 *
 * @return {*}
 *         The value of the element.
 */


Highcharts.find = Array.prototype.find ? function (arr, callback) {
  return arr.find(callback);
} : // Legacy implementation. PhantomJS, IE <= 11 etc. #7223.
function (arr, fn) {
  var i,
      length = arr.length;

  for (i = 0; i < length; i++) {
    if (fn(arr[i], i)) {
      return arr[i];
    }
  }
};
/**
 * Test whether at least one element in the array passes the test implemented by
 * the provided function.
 *
 * @function Highcharts.some
 *
 * @param {Array} arr
 *        The array to test
 *
 * @param {Function} fn
 *        The function to run on each item. Return truty to pass the test.
 *        Receives arguments `currentValue`, `index` and `array`.
 *
 * @param {*} ctx
 *        The context.
 *
 * @return {boolean}
 */

Highcharts.some = function (arr, fn, ctx) {
  return (Highcharts.somePolyfill || Array.prototype.some).call(arr, fn, ctx);
};
/**
 * Map an array by a callback.
 *
 * @function Highcharts.map
 *
 * @param {Array} arr
 *        The array to map.
 *
 * @param {Function} fn
 *        The callback function. Return the new value for the new array.
 *
 * @return {Array}
 *         A new array item with modified items.
 */


Highcharts.map = function (arr, fn) {
  var results = [],
      i = 0,
      len = arr.length;

  for (; i < len; i++) {
    results[i] = fn.call(arr[i], arr[i], i, arr);
  }

  return results;
};
/**
 * Returns an array of a given object's own properties.
 *
 * @function Highcharts.keys
 *
 * @param {*} obj
 *        The object of which the properties are to be returned.
 *
 * @return {Array<string>}
 *         An array of strings that represents all the properties.
 */


Highcharts.keys = function (obj) {
  return (Highcharts.keysPolyfill || Object.keys).call(undefined, obj);
};
/**
 * Reduce an array to a single value.
 *
 * @function Highcharts.reduce
 *
 * @param {Array<*>} arr
 *        The array to reduce.
 *
 * @param {Function} fn
 *        The callback function. Return the reduced value. Receives 4
 *        arguments: Accumulated/reduced value, current value, current array
 *        index, and the array.
 *
 * @param {*} initialValue
 *        The initial value of the accumulator.
 *
 * @return {*}
 *         The reduced value.
 */


Highcharts.reduce = function (arr, func, initialValue) {
  var fn = Highcharts.reducePolyfill || Array.prototype.reduce;
  return fn.apply(arr, arguments.length > 2 ? [func, initialValue] : [func]);
};
/**
 * Get the element's offset position, corrected for `overflow: auto`.
 *
 * @function Highcharts.offset
 *
 * @param {Highcharts.HTMLDOMElement} el
 *        The HTML element.
 *
 * @return {Highcharts.OffsetObject}
 *         An object containing `left` and `top` properties for the position in
 *         the page.
 */


Highcharts.offset = function (el) {
  var docElem = doc$1.documentElement,
      box = el.parentElement || el.parentNode ? el.getBoundingClientRect() : {
    top: 0,
    left: 0
  };
  return {
    top: box.top + (win$1.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
    left: box.left + (win$1.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
  };
};
/**
 * Stop running animation.
 *
 * @function Highcharts.stop
 *
 * @param {Highcharts.SVGElement} el
 *        The SVGElement to stop animation on.
 *
 * @param {string} [prop]
 *        The property to stop animating. If given, the stop method will stop a
 *        single property from animating, while others continue.
 *
 * @todo
 * A possible extension to this would be to stop a single property, when
 * we want to continue animating others. Then assign the prop to the timer
 * in the Fx.run method, and check for the prop here. This would be an
 * improvement in all cases where we stop the animation from .attr. Instead of
 * stopping everything, we can just stop the actual attributes we're setting.
 */


Highcharts.stop = function (el, prop) {
  var i = Highcharts.timers.length; // Remove timers related to this element (#4519)

  while (i--) {
    if (Highcharts.timers[i].elem === el && (!prop || prop === Highcharts.timers[i].prop)) {
      Highcharts.timers[i].stopped = true; // #4667
    }
  }
};
/**
 * Iterate over an array.
 *
 * @function Highcharts.each<T>
 *
 * @param {Array<T>} arr
 *        The array to iterate over.
 *
 * @param {Highcharts.EachCallbackFunction<T>} fn
 *        The iterator callback. It passes three arguments:
 *        * item - The array item.
 *        * index - The item's index in the array.
 *        * arr - The array that each is being applied to.
 *
 * @param {*} [ctx]
 *        The context.
 */


Highcharts.each = function (arr, fn, ctx) {
  // modern browsers
  return (Highcharts.forEachPolyfill || Array.prototype.forEach).call(arr, fn, ctx);
};
/**
 * Iterate over object key pairs in an object.
 *
 * @function Highcharts.objectEach
 *
 * @param {*} obj
 *        The object to iterate over.
 *
 * @param {Highcharts.ObjectEachCallbackFunction} fn
 *        The iterator callback. It passes three arguments:
 *        * value - The property value.
 *        * key - The property key.
 *        * obj - The object that objectEach is being applied to.
 *
 * @param {*} [ctx]
 *        The context.
 */


Highcharts.objectEach = function (obj, fn, ctx) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn.call(ctx || obj[key], obj[key], key, obj);
    }
  }
};
/**
 * Add an event listener.
 *
 * @function Highcharts.addEvent
 *
 * @param {*} el
 *        The element or object to add a listener to. It can be a
 *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.
 *
 * @param {string} type
 *        The event type.
 *
 * @param {Highcharts.EventCallbackFunction} fn
 *        The function callback to execute when the event is fired.
 *
 * @param {Highcharts.Dictionary<*>} options
 *        Event options
 *
 * @param {number} options.order
 *        The order the event handler should be called. This opens for having
 *        one handler be called before another, independent of in which order
 *        they were added.
 *
 * @return {Function}
 *         A callback function to remove the added event.
 */


Highcharts.addEvent = function (el, type, fn, options) {
  var events,
      addEventListener = el.addEventListener || Highcharts.addEventListenerPolyfill; // If we're setting events directly on the constructor, use a separate
  // collection, `protoEvents` to distinguish it from the item events in
  // `hcEvents`.

  if (typeof el === 'function' && el.prototype) {
    events = el.prototype.protoEvents = el.prototype.protoEvents || {};
  } else {
    events = el.hcEvents = el.hcEvents || {};
  } // Allow click events added to points, otherwise they will be prevented by
  // the TouchPointer.pinch function after a pinch zoom operation (#7091).


  if (Highcharts.Point && el instanceof Highcharts.Point && el.series && el.series.chart) {
    el.series.chart.runTrackerClick = true;
  } // Handle DOM events


  if (addEventListener) {
    addEventListener.call(el, type, fn, false);
  }

  if (!events[type]) {
    events[type] = [];
  }

  events[type].push(fn); // Order the calls

  if (options && Highcharts.isNumber(options.order)) {
    fn.order = options.order;
    events[type].sort(function (a, b) {
      return a.order - b.order;
    });
  } // Return a function that can be called to remove this event.


  return function () {
    Highcharts.removeEvent(el, type, fn);
  };
};
/**
 * Remove an event that was added with {@link Highcharts#addEvent}.
 *
 * @function Highcharts.removeEvent
 *
 * @param {*} el
 *        The element to remove events on.
 *
 * @param {string} [type]
 *        The type of events to remove. If undefined, all events are removed
 *        from the element.
 *
 * @param {Function} [fn]
 *        The specific callback to remove. If undefined, all events that match
 *        the element and optionally the type are removed.
 */


Highcharts.removeEvent = function (el, type, fn) {
  var events, index;

  function removeOneEvent(type, fn) {
    var removeEventListener = el.removeEventListener || Highcharts.removeEventListenerPolyfill;

    if (removeEventListener) {
      removeEventListener.call(el, type, fn, false);
    }
  }

  function removeAllEvents(eventCollection) {
    var types, len;

    if (!el.nodeName) {
      return; // break on non-DOM events
    }

    if (type) {
      types = {};
      types[type] = true;
    } else {
      types = eventCollection;
    }

    Highcharts.objectEach(types, function (val, n) {
      if (eventCollection[n]) {
        len = eventCollection[n].length;

        while (len--) {
          removeOneEvent(n, eventCollection[n][len]);
        }
      }
    });
  }

  Highcharts.each(['protoEvents', 'hcEvents'], function (coll) {
    var eventCollection = el[coll];

    if (eventCollection) {
      if (type) {
        events = eventCollection[type] || [];

        if (fn) {
          index = Highcharts.inArray(fn, events);

          if (index > -1) {
            events.splice(index, 1);
            eventCollection[type] = events;
          }

          removeOneEvent(type, fn);
        } else {
          removeAllEvents(eventCollection);
          eventCollection[type] = [];
        }
      } else {
        removeAllEvents(eventCollection);
        el[coll] = {};
      }
    }
  });
};
/**
 * Fire an event that was registered with {@link Highcharts#addEvent}.
 *
 * @function Highcharts.fireEvent
 *
 * @param {*} el
 *        The object to fire the event on. It can be a {@link HTMLDOMElement},
 *        an {@link SVGElement} or any other object.
 *
 * @param {string} type
 *        The type of event.
 *
 * @param {Highcharts.Dictionary<*>} [eventArguments]
 *        Custom event arguments that are passed on as an argument to the event
 *        handler.
 *
 * @param {Function} [defaultFunction]
 *        The default function to execute if the other listeners haven't
 *        returned false.
 */


Highcharts.fireEvent = function (el, type, eventArguments, defaultFunction) {
  var e, events, len, i, fn;
  eventArguments = eventArguments || {};

  if (doc$1.createEvent && (el.dispatchEvent || el.fireEvent)) {
    e = doc$1.createEvent('Events');
    e.initEvent(type, true, true);
    Highcharts.extend(e, eventArguments);

    if (el.dispatchEvent) {
      el.dispatchEvent(e);
    } else {
      el.fireEvent(type, e);
    }
  } else {
    Highcharts.each(['protoEvents', 'hcEvents'], function (coll) {
      if (el[coll]) {
        events = el[coll][type] || [];
        len = events.length;

        if (!eventArguments.target) {
          // We're running a custom event
          Highcharts.extend(eventArguments, {
            // Attach a simple preventDefault function to skip
            // default handler if called. The built-in
            // defaultPrevented property is not overwritable (#5112)
            preventDefault: function () {
              eventArguments.defaultPrevented = true;
            },
            // Setting target to native events fails with clicking
            // the zoom-out button in Chrome.
            target: el,
            // If the type is not set, we're running a custom event
            // (#2297). If it is set, we're running a browser event,
            // and setting it will cause en error in IE8 (#2465).
            type: type
          });
        }

        for (i = 0; i < len; i++) {
          fn = events[i]; // If the event handler return false, prevent the default
          // handler from executing

          if (fn && fn.call(el, eventArguments) === false) {
            eventArguments.preventDefault();
          }
        }
      }
    });
  } // Run the default if not prevented


  if (defaultFunction && !eventArguments.defaultPrevented) {
    defaultFunction.call(el, eventArguments);
  }
};
/**
 * The global animate method, which uses Fx to create individual animators.
 *
 * @function Highcharts.animate
 *
 * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} el
 *        The element to animate.
 *
 * @param {Highcharts.HTMLAttributes|Highcharts.SVGAttributes} params
 *        An object containing key-value pairs of the properties to animate.
 *        Supports numeric as pixel-based CSS properties for HTML objects and
 *        attributes for SVGElements.
 *
 * @param {Highcharts.AnimationOptionsObject} [opt]
 *        Animation options.
 */


Highcharts.animate = function (el, params, opt) {
  var start,
      unit = '',
      end,
      fx,
      args;

  if (!Highcharts.isObject(opt)) {
    // Number or undefined/null
    args = arguments;
    opt = {
      duration: args[2],
      easing: args[3],
      complete: args[4]
    };
  }

  if (!Highcharts.isNumber(opt.duration)) {
    opt.duration = 400;
  }

  opt.easing = typeof opt.easing === 'function' ? opt.easing : Math[opt.easing] || Math.easeInOutSine;
  opt.curAnim = Highcharts.merge(params);
  Highcharts.objectEach(params, function (val, prop) {
    // Stop current running animation of this property
    Highcharts.stop(el, prop);
    fx = new Highcharts.Fx(el, opt, prop);
    end = null;

    if (prop === 'd') {
      fx.paths = fx.initPath(el, el.d, params.d);
      fx.toD = params.d;
      start = 0;
      end = 1;
    } else if (el.attr) {
      start = el.attr(prop);
    } else {
      start = parseFloat(Highcharts.getStyle(el, prop)) || 0;

      if (prop !== 'opacity') {
        unit = 'px';
      }
    }

    if (!end) {
      end = val;
    }

    if (end && end.match && end.match('px')) {
      end = end.replace(/px/g, ''); // #4351
    }

    fx.run(start, end, unit);
  });
};
/**
 * Factory to create new series prototypes.
 *
 * @function Highcharts.seriesType
 *
 * @param {string} type
 *        The series type name.
 *
 * @param {string} parent
 *        The parent series type name. Use `line` to inherit from the basic
 *        {@link Series} object.
 *
 * @param {*} options
 *        The additional default options that is merged with the parent's
 *        options.
 *
 * @param {*} props
 *        The properties (functions and primitives) to set on the new
 *        prototype.
 *
 * @param {*} [pointProps]
 *        Members for a series-specific extension of the {@link Point}
 *        prototype if needed.
 *
 * @return {Highcharts.Series}
 *         The newly created prototype as extended from {@link Series} or its
 *         derivatives.
 */
// docs: add to API + extending Highcharts


Highcharts.seriesType = function (type, parent, options, props, pointProps) {
  var defaultOptions = Highcharts.getOptions(),
      seriesTypes = Highcharts.seriesTypes; // Merge the options

  defaultOptions.plotOptions[type] = Highcharts.merge(defaultOptions.plotOptions[parent], options); // Create the class

  seriesTypes[type] = Highcharts.extendClass(seriesTypes[parent] || function () {}, props);
  seriesTypes[type].prototype.type = type; // Create the point class if needed

  if (pointProps) {
    seriesTypes[type].prototype.pointClass = Highcharts.extendClass(Highcharts.Point, pointProps);
  }

  return seriesTypes[type];
};
/**
 * Get a unique key for using in internal element id's and pointers. The key is
 * composed of a random hash specific to this Highcharts instance, and a
 * counter.
 *
 * @example
 * var id = H.uniqueKey(); // => 'highcharts-x45f6hp-0'
 *
 * @function Highcharts.uniqueKey
 *
 * @return {string}
 *         A unique key.
 */


Highcharts.uniqueKey = function () {
  var uniqueKeyHash = Math.random().toString(36).substring(2, 9),
      idCounter = 0;
  return function () {
    return 'highcharts-' + uniqueKeyHash + '-' + idCounter++;
  };
}(); // Register Highcharts as a plugin in jQuery


if (win$1.jQuery) {
  /**
   * Highcharts-extended JQuery.
   *
   * @external JQuery
   */

  /**
   * Factory function to create a chart in the current JQuery selector
   * element.
   *
   * @function external:JQuery#highcharts
   *
   * @param {"Chart"|"Map"|"StockChart"|string} [className]
   *        Name of the factory class in the Highcharts namespace.
   *
   * @param {Highcharts.Options} options
   *        The chart options structure.
   *
   * @param {Highcharts.ChartCallbackFunction} [callback]
   *        Function to run when the chart has loaded and and all external
   *        images are loaded. Defining a [chart.event.load
   *        ](https://api.highcharts.com/highcharts/chart.events.load) handler
   *        is equivalent.
   *
   * @return {JQuery}
   *         The current JQuery selector.
   */
  win$1.jQuery.fn.highcharts = function () {
    var args = [].slice.call(arguments);

    if (this[0]) {
      // this[0] is the renderTo div
      // Create the chart
      if (args[0]) {
        new Highcharts[// eslint-disable-line no-new
        // Constructor defaults to Chart
        Highcharts.isString(args[0]) ? args.shift() : 'Chart'](this[0], args[0], args[1]);
        return this;
      } // When called without parameters or with the return argument,
      // return an existing chart


      return charts[Highcharts.attr(this[0], 'data-highcharts-chart')];
    }
  };
}

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var each = Highcharts.each,
    isNumber = Highcharts.isNumber,
    map = Highcharts.map,
    merge = Highcharts.merge,
    pInt = Highcharts.pInt;
/**
 * Handle color operations. The object methods are chainable.
 *
 * @ignore
 * @class Highcharts.Color
 *
 * @param {Highcharts.ColorString} input
 *        The input color in either rbga or hex format
 */

Highcharts.Color = function (input) {
  // Backwards compatibility, allow instanciation without new
  if (!(this instanceof Highcharts.Color)) {
    return new Highcharts.Color(input);
  } // Initialize


  this.init(input);
};

Highcharts.Color.prototype = {
  // Collection of parsers. This can be extended from the outside by pushing
  // parsers to Highcharts.Color.prototype.parsers.
  parsers: [{
    // RGBA color
    regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
    // eslint-disable-line security/detect-unsafe-regex
    parse: function (result) {
      return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
    }
  }, {
    // RGB color
    regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
    parse: function (result) {
      return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
    }
  }],
  // Collection of named colors. Can be extended from the outside by adding
  // colors to Highcharts.Color.prototype.names.
  names: {
    white: '#ffffff',
    black: '#000000'
  },

  /**
   * Parse the input color to rgba array
   *
   * @private
   * @function Highcharts.Color#init
   *
   * @param  {Highcharts.ColorString} input
   *         The input color in either rbga or hex format
   *
   * @return {void}
   */
  init: function (input) {
    var result, rgba, i, parser, len;
    this.input = input = this.names[input && input.toLowerCase ? input.toLowerCase() : ''] || input; // Gradients

    if (input && input.stops) {
      this.stops = map(input.stops, function (stop) {
        return new Highcharts.Color(stop[1]);
      }); // Solid colors
    } else {
      // Bitmasking as input[0] is not working for legacy IE.
      if (input && input.charAt && input.charAt() === '#') {
        len = input.length;
        input = parseInt(input.substr(1), 16); // Handle long-form, e.g. #AABBCC

        if (len === 7) {
          rgba = [(input & 0xFF0000) >> 16, (input & 0xFF00) >> 8, input & 0xFF, 1]; // Handle short-form, e.g. #ABC
          // In short form, the value is assumed to be the same
          // for both nibbles for each component. e.g. #ABC = #AABBCC
        } else if (len === 4) {
          rgba = [(input & 0xF00) >> 4 | (input & 0xF00) >> 8, (input & 0xF0) >> 4 | input & 0xF0, (input & 0xF) << 4 | input & 0xF, 1];
        }
      } // Otherwise, check regex parsers


      if (!rgba) {
        i = this.parsers.length;

        while (i-- && !rgba) {
          parser = this.parsers[i];
          result = parser.regex.exec(input);

          if (result) {
            rgba = parser.parse(result);
          }
        }
      }
    }

    this.rgba = rgba || [];
  },

  /**
   * Return the color in the specified format
   *
   * @function Highcharts.Color#get
   *
   * @param  {string} format
   *         Possible values are 'a', 'rgb', undefined
   *
   * @return {Highcharts.ColorString}
   *         This color as a string.
   */
  get: function (format) {
    var input = this.input,
        rgba = this.rgba,
        ret;

    if (this.stops) {
      ret = merge(input);
      ret.stops = [].concat(ret.stops);
      each(this.stops, function (stop, i) {
        ret.stops[i] = [ret.stops[i][0], stop.get(format)];
      }); // it's NaN if gradient colors on a column chart
    } else if (rgba && isNumber(rgba[0])) {
      if (format === 'rgb' || !format && rgba[3] === 1) {
        ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
      } else if (format === 'a') {
        ret = rgba[3];
      } else {
        ret = 'rgba(' + rgba.join(',') + ')';
      }
    } else {
      ret = input;
    }

    return ret;
  },

  /**
   * Brighten the color instance.
   *
   * @function Highcharts.Color#brighten
   *
   * @param  {number} alpha
   *         The alpha value.
   *
   * @return {Highcharts.ColorString}
   *         This color with modifications.
   */
  brighten: function (alpha) {
    var i,
        rgba = this.rgba;

    if (this.stops) {
      each(this.stops, function (stop) {
        stop.brighten(alpha);
      });
    } else if (isNumber(alpha) && alpha !== 0) {
      for (i = 0; i < 3; i++) {
        rgba[i] += pInt(alpha * 255);

        if (rgba[i] < 0) {
          rgba[i] = 0;
        }

        if (rgba[i] > 255) {
          rgba[i] = 255;
        }
      }
    }

    return this;
  },

  /**
   * Set the color's opacity to a given alpha value.
   *
   * @function Highcharts.Color#setOpacity
   *
   * @param  {number} alpha
   *         Opacity between 0 and 1.
   *
   * @return {Highcharts.ColorString}
   *         Color with modifications.
   */
  setOpacity: function (alpha) {
    this.rgba[3] = alpha;
    return this;
  },

  /**
   * Return an intermediate color between two colors.
   *
   * @function Highcharts.Color#tweenTo
   *
   * @param  {Highcharts.Color} to
   *         The color object to tween to.
   *
   * @param  {number} pos
   *         The intermediate position, where 0 is the from color (current
   *         color item), and 1 is the `to` color.
   *
   * @return {Highcharts.ColorString}
   *         The intermediate color in rgba notation.
   */
  tweenTo: function (to, pos) {
    // Check for has alpha, because rgba colors perform worse due to lack of
    // support in WebKit.
    var fromRgba = this.rgba,
        toRgba = to.rgba,
        hasAlpha,
        ret; // Unsupported color, return to-color (#3920, #7034)

    if (!toRgba.length || !fromRgba || !fromRgba.length) {
      ret = to.input || 'none'; // Interpolate
    } else {
      hasAlpha = toRgba[3] !== 1 || fromRgba[3] !== 1;
      ret = (hasAlpha ? 'rgba(' : 'rgb(') + Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) + ',' + Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) + ',' + Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) + (hasAlpha ? ',' + (toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos)) : '') + ')';
    }

    return ret;
  }
};

Highcharts.color = function (input) {
  return new Highcharts.Color(input);
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var SVGElement,
    SVGRenderer,
    addEvent = Highcharts.addEvent,
    animate$1 = Highcharts.animate,
    attr = Highcharts.attr,
    charts$1 = Highcharts.charts,
    color = Highcharts.color,
    css = Highcharts.css,
    createElement = Highcharts.createElement,
    defined = Highcharts.defined,
    deg2rad = Highcharts.deg2rad,
    destroyObjectProperties = Highcharts.destroyObjectProperties,
    doc$2 = Highcharts.doc,
    each$1 = Highcharts.each,
    extend = Highcharts.extend,
    erase = Highcharts.erase,
    grep = Highcharts.grep,
    hasTouch = Highcharts.hasTouch,
    inArray = Highcharts.inArray,
    isArray = Highcharts.isArray,
    isFirefox$1 = Highcharts.isFirefox,
    isMS$1 = Highcharts.isMS,
    isObject$1 = Highcharts.isObject,
    isString$1 = Highcharts.isString,
    isWebKit = Highcharts.isWebKit,
    merge$1 = Highcharts.merge,
    noop = Highcharts.noop,
    objectEach = Highcharts.objectEach,
    pick = Highcharts.pick,
    pInt$1 = Highcharts.pInt,
    removeEvent = Highcharts.removeEvent,
    splat = Highcharts.splat,
    stop = Highcharts.stop,
    svg$1 = Highcharts.svg,
    SVG_NS$1 = Highcharts.SVG_NS,
    symbolSizes = Highcharts.symbolSizes,
    win$2 = Highcharts.win;
/**
 * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the
 * rendering layer of Highcharts. Combined with the {@link
 * Highcharts.SVGRenderer} object, these prototypes allow freeform annotation
 * in the charts or even in HTML pages without instanciating a chart. The
 * SVGElement can also wrap HTML labels, when `text` or `label` elements are
 * created with the `useHTML` parameter.
 *
 * The SVGElement instances are created through factory functions on the
 * {@link Highcharts.SVGRenderer} object, like
 * [rect]{@link Highcharts.SVGRenderer#rect}, [path]{@link
 * Highcharts.SVGRenderer#path}, [text]{@link Highcharts.SVGRenderer#text},
 * [label]{@link Highcharts.SVGRenderer#label}, [g]{@link
 * Highcharts.SVGRenderer#g} and more.
 *
 * @class
 * @name Highcharts.SVGElement
 */

SVGElement = Highcharts.SVGElement = function () {
  return this;
};

extend(SVGElement.prototype,
/** @lends Highcharts.SVGElement.prototype */
{
  // Default base for animation
  opacity: 1,
  SVG_NS: SVG_NS$1,

  /**
   * For labels, these CSS properties are applied to the `text` node directly.
   *
   * @private
   * @name Highcharts.SVGElement#textProps
   * @type {Array<string>}
   */
  textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily', 'fontStyle', 'color', 'lineHeight', 'width', 'textAlign', 'textDecoration', 'textOverflow', 'textOutline', 'cursor'],

  /**
   * Initialize the SVG element. This function only exists to make the
   * initiation process overridable. It should not be called directly.
   *
   * @function Highcharts.SVGElement#init
   *
   * @param {Highcharts.SVGRenderer} renderer
   *        The SVGRenderer instance to initialize to.
   *
   * @param {string} nodeName
   *        The SVG node name.
   */
  init: function (renderer, nodeName) {
    /**
     * The primary DOM node. Each `SVGElement` instance wraps a main DOM
     * node, but may also represent more nodes.
     *
     * @name Highcharts.SVGElement#element
     * @type {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement}
     */
    this.element = nodeName === 'span' ? createElement(nodeName) : doc$2.createElementNS(this.SVG_NS, nodeName);
    /**
     * The renderer that the SVGElement belongs to.
     *
     * @name Highcharts.SVGElement#renderer
     * @type {Highcharts.SVGRenderer}
     */

    this.renderer = renderer;
  },

  /**
   * Animate to given attributes or CSS properties.
   *
   * @sample highcharts/members/element-on/
   *         Setting some attributes by animation
   *
   * @function Highcharts.SVGElement#animate
   *
   * @param {Highcharts.SVGAttributes} params
   *        SVG attributes or CSS to animate.
   *
   * @param {Highcharts.AnimationOptionsObject} [options]
   *        Animation options.
   *
   * @param {Function} [complete]
   *        Function to perform at the end of animation.
   *
   * @return {Highcharts.SVGElement}
   *         Returns the SVGElement for chaining.
   */
  animate: function (params, options, complete) {
    var animOptions = Highcharts.animObject(pick(options, this.renderer.globalAnimation, true));

    if (animOptions.duration !== 0) {
      // allows using a callback with the global animation without
      // overwriting it
      if (complete) {
        animOptions.complete = complete;
      }

      animate$1(this, params, animOptions);
    } else {
      this.attr(params, null, complete);

      if (animOptions.step) {
        animOptions.step.call(this);
      }
    }

    return this;
  },

  /**
   * Build and apply an SVG gradient out of a common JavaScript configuration
   * object. This function is called from the attribute setters. An event
   * hook is added for supporting other complex color types.
   *
   * @private
   * @function Highcharts.SVGElement#complexColor
   *
   * @param {Highcharts.GradientColorObject} color
   *        The gradient options structure.
   *
   * @param {string} prop
   *        The property to apply, can either be `fill` or `stroke`.
   *
   * @param {Highcharts.SVGDOMElement} elem
   *        SVG DOM element to apply the gradient on.
   */
  complexColor: function (color, prop, elem) {
    var renderer = this.renderer,
        colorObject,
        gradName,
        gradAttr,
        radAttr,
        gradients,
        gradientObject,
        stops,
        stopColor,
        stopOpacity,
        radialReference,
        id,
        key = [],
        value;
    Highcharts.fireEvent(this.renderer, 'complexColor', {
      args: arguments
    }, function () {
      // Apply linear or radial gradients
      if (color.radialGradient) {
        gradName = 'radialGradient';
      } else if (color.linearGradient) {
        gradName = 'linearGradient';
      }

      if (gradName) {
        gradAttr = color[gradName];
        gradients = renderer.gradients;
        stops = color.stops;
        radialReference = elem.radialReference; // Keep < 2.2 kompatibility

        if (isArray(gradAttr)) {
          color[gradName] = gradAttr = {
            x1: gradAttr[0],
            y1: gradAttr[1],
            x2: gradAttr[2],
            y2: gradAttr[3],
            gradientUnits: 'userSpaceOnUse'
          };
        } // Correct the radial gradient for the radial reference system


        if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {
          // Save the radial attributes for updating
          radAttr = gradAttr;
          gradAttr = merge$1(gradAttr, renderer.getRadialAttr(radialReference, radAttr), {
            gradientUnits: 'userSpaceOnUse'
          });
        } // Build the unique key to detect whether we need to create a
        // new element (#1282)


        objectEach(gradAttr, function (val, n) {
          if (n !== 'id') {
            key.push(n, val);
          }
        });
        objectEach(stops, function (val) {
          key.push(val);
        });
        key = key.join(','); // Check if a gradient object with the same config object is
        // created within this renderer

        if (gradients[key]) {
          id = gradients[key].attr('id');
        } else {
          // Set the id and create the element
          gradAttr.id = id = Highcharts.uniqueKey();
          gradients[key] = gradientObject = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);
          gradientObject.radAttr = radAttr; // The gradient needs to keep a list of stops to be able to
          // destroy them

          gradientObject.stops = [];
          each$1(stops, function (stop) {
            var stopObject;

            if (stop[1].indexOf('rgba') === 0) {
              colorObject = Highcharts.color(stop[1]);
              stopColor = colorObject.get('rgb');
              stopOpacity = colorObject.get('a');
            } else {
              stopColor = stop[1];
              stopOpacity = 1;
            }

            stopObject = renderer.createElement('stop').attr({
              offset: stop[0],
              'stop-color': stopColor,
              'stop-opacity': stopOpacity
            }).add(gradientObject); // Add the stop element to the gradient

            gradientObject.stops.push(stopObject);
          });
        } // Set the reference to the gradient object


        value = 'url(' + renderer.url + '#' + id + ')';
        elem.setAttribute(prop, value);
        elem.gradient = key; // Allow the color to be concatenated into tooltips formatters
        // etc. (#2995)

        color.toString = function () {
          return value;
        };
      }
    });
  },

  /**
   * Apply a text outline through a custom CSS property, by copying the text
   * element and apply stroke to the copy. Used internally. Contrast checks at
   * {@link https://jsfiddle.net/highcharts/43soe9m1/2/}.
   *
   * @example
   * // Specific color
   * text.css({
   *    textOutline: '1px black'
   * });
   * // Automatic contrast
   * text.css({
   *    color: '#000000', // black text
   *    textOutline: '1px contrast' // => white outline
   * });
   *
   * @private
   * @function Highcharts.SVGElement#applyTextOutline
   *
   * @param {string} textOutline
   *        A custom CSS `text-outline` setting, defined by `width color`.
   */
  applyTextOutline: function (textOutline) {
    var elem = this.element,
        tspans,
        tspan,
        hasContrast = textOutline.indexOf('contrast') !== -1,
        styles = {},
        color,
        strokeWidth,
        firstRealChild,
        i; // When the text shadow is set to contrast, use dark stroke for light
    // text and vice versa.

    if (hasContrast) {
      styles.textOutline = textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
    } // Extract the stroke width and color


    textOutline = textOutline.split(' ');
    color = textOutline[textOutline.length - 1];
    strokeWidth = textOutline[0];

    if (strokeWidth && strokeWidth !== 'none' && Highcharts.svg) {
      this.fakeTS = true; // Fake text shadow

      tspans = [].slice.call(elem.getElementsByTagName('tspan')); // In order to get the right y position of the clone,
      // copy over the y setter

      this.ySetter = this.xSetter; // Since the stroke is applied on center of the actual outline, we
      // need to double it to get the correct stroke-width outside the
      // glyphs.

      strokeWidth = strokeWidth.replace(/(^[\d\.]+)(.*?)$/g, function (match, digit, unit) {
        return 2 * digit + unit;
      }); // Remove shadows from previous runs. Iterate from the end to
      // support removing items inside the cycle (#6472).

      i = tspans.length;

      while (i--) {
        tspan = tspans[i];

        if (tspan.getAttribute('class') === 'highcharts-text-outline') {
          // Remove then erase
          erase(tspans, elem.removeChild(tspan));
        }
      } // For each of the tspans, create a stroked copy behind it.


      firstRealChild = elem.firstChild;
      each$1(tspans, function (tspan, y) {
        var clone; // Let the first line start at the correct X position

        if (y === 0) {
          tspan.setAttribute('x', elem.getAttribute('x'));
          y = elem.getAttribute('y');
          tspan.setAttribute('y', y || 0);

          if (y === null) {
            elem.setAttribute('y', 0);
          }
        } // Create the clone and apply outline properties


        clone = tspan.cloneNode(1);
        attr(clone, {
          'class': 'highcharts-text-outline',
          'fill': color,
          'stroke': color,
          'stroke-width': strokeWidth,
          'stroke-linejoin': 'round'
        });
        elem.insertBefore(clone, firstRealChild);
      });
    }
  },

  /**
   * Apply native and custom attributes to the SVG elements.
   *
   * In order to set the rotation center for rotation, set x and y to 0 and
   * use `translateX` and `translateY` attributes to position the element
   * instead.
   *
   * Attributes frequently used in Highcharts are `fill`, `stroke`,
   * `stroke-width`.
   *
   * @sample highcharts/members/renderer-rect/
   *         Setting some attributes
   *
   * @example
   * // Set multiple attributes
   * element.attr({
   *     stroke: 'red',
   *     fill: 'blue',
   *     x: 10,
   *     y: 10
   * });
   *
   * // Set a single attribute
   * element.attr('stroke', 'red');
   *
   * // Get an attribute
   * element.attr('stroke'); // => 'red'
   *
   * @function Highcharts.SVGElement#attr
   *
   * @param {string|Highcharts.SVGAttributes} [hash]
   *        The native and custom SVG attributes.
   *
   * @param {string} [val]
   *        If the type of the first argument is `string`, the second can be a
   *        value, which will serve as a single attribute setter. If the first
   *        argument is a string and the second is undefined, the function
   *        serves as a getter and the current value of the property is
   *        returned.
   *
   * @param {Function} [complete]
   *        A callback function to execute after setting the attributes. This
   *        makes the function compliant and interchangeable with the
   *        {@link SVGElement#animate} function.
   *
   * @param {boolean} [continueAnimation=true]
   *        Used internally when `.attr` is called as part of an animation
   *        step. Otherwise, calling `.attr` for an attribute will stop
   *        animation for that attribute.
   *
   * @return {number|string|Highcharts.SVGElement}
   *         If used as a setter, it returns the current
   *         {@link Highcharts.SVGElement} so the calls can be chained. If
   *         used as a getter, the current value of the attribute is returned.
   */
  attr: function (hash, val, complete, continueAnimation) {
    var key,
        element = this.element,
        hasSetSymbolSize,
        ret = this,
        skipAttr,
        setter; // single key-value pair

    if (typeof hash === 'string' && val !== undefined) {
      key = hash;
      hash = {};
      hash[key] = val;
    } // used as a getter: first argument is a string, second is undefined


    if (typeof hash === 'string') {
      ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element); // setter
    } else {
      objectEach(hash, function eachAttribute(val, key) {
        skipAttr = false; // Unless .attr is from the animator update, stop current
        // running animation of this property

        if (!continueAnimation) {
          stop(this, key);
        } // Special handling of symbol attributes


        if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(key)) {
          if (!hasSetSymbolSize) {
            this.symbolAttr(hash);
            hasSetSymbolSize = true;
          }

          skipAttr = true;
        }

        if (this.rotation && (key === 'x' || key === 'y')) {
          this.doTransform = true;
        }

        if (!skipAttr) {
          setter = this[key + 'Setter'] || this._defaultSetter;
          setter.call(this, val, key, element);
        }
      }, this);
      this.afterSetters();
    } // In accordance with animate, run a complete callback


    if (complete) {
      complete.call(this);
    }

    return ret;
  },

  /**
   * This method is executed in the end of `attr()`, after setting all
   * attributes in the hash. In can be used to efficiently consolidate
   * multiple attributes in one SVG property -- e.g., translate, rotate and
   * scale are merged in one "transform" attribute in the SVG node.
   *
   * @private
   * @function Highcharts.SVGElement#afterSetters
   */
  afterSetters: function () {
    // Update transform. Do this outside the loop to prevent redundant
    // updating for batch setting of attributes.
    if (this.doTransform) {
      this.updateTransform();
      this.doTransform = false;
    }
  },

  /**
   * Add a class name to an element.
   *
   * @function Highcharts.SVGElement#addClass
   *
   * @param {string} className
   *        The new class name to add.
   *
   * @param {boolean} [replace=false]
   *        When true, the existing class name(s) will be overwritten with
   *        the new one. When false, the new one is added.
   *
   * @return {Highcharts.SVGElement}
   *         Return the SVG element for chainability.
   */
  addClass: function (className, replace) {
    var currentClassName = this.attr('class') || '';

    if (currentClassName.indexOf(className) === -1) {
      if (!replace) {
        className = (currentClassName + (currentClassName ? ' ' : '') + className).replace('  ', ' ');
      }

      this.attr('class', className);
    }

    return this;
  },

  /**
   * Check if an element has the given class name.
   *
   * @function Highcharts.SVGElement#hasClass
   *
   * @param {string} className
   *        The class name to check for.
   *
   * @return {boolean}
   *         Whether the class name is found.
   */
  hasClass: function (className) {
    return inArray(className, (this.attr('class') || '').split(' ')) !== -1;
  },

  /**
   * Remove a class name from the element.
   *
   * @function Highcharts.SVGElement#removeClass
   *
   * @param {string|RegExp} className
   *        The class name to remove.
   *
   * @return {Highcharts.SVGElement} Returns the SVG element for chainability.
   */
  removeClass: function (className) {
    return this.attr('class', (this.attr('class') || '').replace(className, ''));
  },

  /**
   * If one of the symbol size affecting parameters are changed,
   * check all the others only once for each call to an element's
   * .attr() method
   *
   * @private
   * @function Highcharts.SVGElement#symbolAttr
   *
   * @param {Highcharts.Dictionary<number|string>} hash
   *        The attributes to set.
   */
  symbolAttr: function (hash) {
    var wrapper = this;
    each$1(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {
      wrapper[key] = pick(hash[key], wrapper[key]);
    });
    wrapper.attr({
      d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
    });
  },

  /**
   * Apply a clipping rectangle to this element.
   *
   * @function Highcharts.SVGElement#clip
   *
   * @param {Highcharts.ClipRectElement} [clipRect]
   *        The clipping rectangle. If skipped, the current clip is removed.
   *
   * @return {Highcharts.SVGElement}
   *         Returns the SVG element to allow chaining.
   */
  clip: function (clipRect) {
    return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : 'none');
  },

  /**
   * Calculate the coordinates needed for drawing a rectangle crisply and
   * return the calculated attributes.
   *
   * @function Highcharts.SVGElement#crisp
   *
   * @param {Highcharts.RectangleObject} rect
   *        Rectangle to crisp.
   *
   * @param {number} [strokeWidth]
   *        The stroke width to consider when computing crisp positioning. It
   *        can also be set directly on the rect parameter.
   *
   * @return {Highcharts.RectangleObject}
   *         The modified rectangle arguments.
   */
  crisp: function (rect, strokeWidth) {
    var wrapper = this,
        normalizer;
    strokeWidth = strokeWidth || rect.strokeWidth || 0; // Math.round because strokeWidth can sometimes have roundoff errors

    normalizer = Math.round(strokeWidth) % 2 / 2; // normalize for crisp edges

    rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;
    rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;
    rect.width = Math.floor((rect.width || wrapper.width || 0) - 2 * normalizer);
    rect.height = Math.floor((rect.height || wrapper.height || 0) - 2 * normalizer);

    if (defined(rect.strokeWidth)) {
      rect.strokeWidth = strokeWidth;
    }

    return rect;
  },

  /**
   * Set styles for the element. In addition to CSS styles supported by
   * native SVG and HTML elements, there are also some custom made for
   * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text
   * elements.
   *
   * @sample highcharts/members/renderer-text-on-chart/
   *         Styled text
   *
   * @function Highcharts.SVGElement#css
   *
   * @param {Highcharts.CSSObject} styles
   *        The new CSS styles.
   *
   * @return {Highcharts.SVGElement}
   *         Return the SVG element for chaining.
   */
  css: function (styles) {
    var oldStyles = this.styles,
        newStyles = {},
        elem = this.element,
        textWidth,
        serializedCss = '',
        hyphenate,
        hasNew = !oldStyles,
        // These CSS properties are interpreted internally by the SVG
    // renderer, but are not supported by SVG and should not be added to
    // the DOM. In styled mode, no CSS should find its way to the DOM
    // whatsoever (#6173, #6474).
    svgPseudoProps = ['textOutline', 'textOverflow', 'width']; // convert legacy

    if (styles && styles.color) {
      styles.fill = styles.color;
    } // Filter out existing styles to increase performance (#2640)


    if (oldStyles) {
      objectEach(styles, function (style, n) {
        if (style !== oldStyles[n]) {
          newStyles[n] = style;
          hasNew = true;
        }
      });
    }

    if (hasNew) {
      // Merge the new styles with the old ones
      if (oldStyles) {
        styles = extend(oldStyles, newStyles);
      } // Get the text width from style


      if (styles) {
        // Previously set, unset it (#8234)
        if (styles.width === null || styles.width === 'auto') {
          delete this.textWidth; // Apply new
        } else if (elem.nodeName.toLowerCase() === 'text' && styles.width) {
          textWidth = this.textWidth = pInt$1(styles.width);
        }
      } // store object


      this.styles = styles;

      if (textWidth && !svg$1 && this.renderer.forExport) {
        delete styles.width;
      } // Serialize and set style attribute


      if (elem.namespaceURI === this.SVG_NS) {
        // #7633
        hyphenate = function (a, b) {
          return '-' + b.toLowerCase();
        };

        objectEach(styles, function (style, n) {
          if (inArray(n, svgPseudoProps) === -1) {
            serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + style + ';';
          }
        });

        if (serializedCss) {
          attr(elem, 'style', serializedCss); // #1881
        }
      } else {
        css(elem, styles);
      }

      if (this.added) {
        // Rebuild text after added. Cache mechanisms in the buildText
        // will prevent building if there are no significant changes.
        if (this.element.nodeName === 'text') {
          this.renderer.buildText(this);
        } // Apply text outline after added


        if (styles && styles.textOutline) {
          this.applyTextOutline(styles.textOutline);
        }
      }
    }

    return this;
  },

  /**
   * Get the computed style. Only in styled mode.
   *
   * @example
   * chart.series[0].points[0].graphic.getStyle('stroke-width'); // => '1px'
   *
   * @function Highcharts.SVGElement#getStyle
   *
   * @param {string} prop
   *        The property name to check for.
   *
   * @return {string}
   *         The current computed value.
   */
  getStyle: function (prop) {
    return win$2.getComputedStyle(this.element || this, '').getPropertyValue(prop);
  },

  /**
   * Get the computed stroke width in pixel values. This is used extensively
   * when drawing shapes to ensure the shapes are rendered crisp and
   * positioned correctly relative to each other. Using
   * `shape-rendering: crispEdges` leaves us less control over positioning,
   * for example when we want to stack columns next to each other, or position
   * things pixel-perfectly within the plot box.
   *
   * The common pattern when placing a shape is:
   * - Create the SVGElement and add it to the DOM. In styled mode, it will
   *   now receive a stroke width from the style sheet. In classic mode we
   *   will add the `stroke-width` attribute.
   * - Read the computed `elem.strokeWidth()`.
   * - Place it based on the stroke width.
   *
   * @function Highcharts.SVGElement#strokeWidth
   *
   * @return {number}
   *         The stroke width in pixels. Even if the given stroke widtch (in
   *         CSS or by attributes) is based on `em` or other units, the pixel
   *         size is returned.
   */
  strokeWidth: function () {
    var val = this.getStyle('stroke-width'),
        ret,
        dummy; // Read pixel values directly

    if (val.indexOf('px') === val.length - 2) {
      ret = pInt$1(val); // Other values like em, pt etc need to be measured
    } else {
      dummy = doc$2.createElementNS(SVG_NS$1, 'rect');
      attr(dummy, {
        'width': val,
        'stroke-width': 0
      });
      this.element.parentNode.appendChild(dummy);
      ret = dummy.getBBox().width;
      dummy.parentNode.removeChild(dummy);
    }

    return ret;
  },

  /**
   * Add an event listener. This is a simple setter that replaces all other
   * events of the same type, opposed to the {@link Highcharts#addEvent}
   * function.
   *
   * @sample highcharts/members/element-on/
   *         A clickable rectangle
   *
   * @function Highcharts.SVGElement#on
   *
   * @param {string} eventType
   *        The event type. If the type is `click`, Highcharts will internally
   *        translate it to a `touchstart` event on touch devices, to prevent
   *        the browser from waiting for a click event from firing.
   *
   * @param {Function} handler
   *        The handler callback.
   *
   * @return {Highcharts.SVGElement}
   *         The SVGElement for chaining.
   */
  on: function (eventType, handler) {
    var svgElement = this,
        element = svgElement.element; // touch

    if (hasTouch && eventType === 'click') {
      element.ontouchstart = function (e) {
        svgElement.touchEventFired = Date.now(); // #2269

        e.preventDefault();
        handler.call(element, e);
      };

      element.onclick = function (e) {
        if (win$2.navigator.userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) {
          handler.call(element, e);
        }
      };
    } else {
      // simplest possible event model for internal use
      element['on' + eventType] = handler;
    }

    return this;
  },

  /**
   * Set the coordinates needed to draw a consistent radial gradient across
   * a shape regardless of positioning inside the chart. Used on pie slices
   * to make all the slices have the same radial reference point.
   *
   * @function Highcharts.SVGElement#setRadialReference
   *
   * @param {Array<number>} coordinates
   *        The center reference. The format is `[centerX, centerY, diameter]`
   *        in pixels.
   *
   * @return {Highcharts.SVGElement}
   *         Returns the SVGElement for chaining.
   */
  setRadialReference: function (coordinates) {
    var existingGradient = this.renderer.gradients[this.element.gradient];
    this.element.radialReference = coordinates; // On redrawing objects with an existing gradient, the gradient needs
    // to be repositioned (#3801)

    if (existingGradient && existingGradient.radAttr) {
      existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));
    }

    return this;
  },

  /**
   * Move an object and its children by x and y values.
   *
   * @function Highcharts.SVGElement#translate
   *
   * @param {number} x
   *        The x value.
   *
   * @param {number} y
   *        The y value.
   */
  translate: function (x, y) {
    return this.attr({
      translateX: x,
      translateY: y
    });
  },

  /**
   * Invert a group, rotate and flip. This is used internally on inverted
   * charts, where the points and graphs are drawn as if not inverted, then
   * the series group elements are inverted.
   *
   * @function Highcharts.SVGElement#invert
   *
   * @param {boolean} inverted
   *        Whether to invert or not. An inverted shape can be un-inverted by
   *        setting it to false.
   *
   * @return {Highcharts.SVGElement}
   *         Return the SVGElement for chaining.
   */
  invert: function (inverted) {
    var wrapper = this;
    wrapper.inverted = inverted;
    wrapper.updateTransform();
    return wrapper;
  },

  /**
   * Update the transform attribute based on internal properties. Deals with
   * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`
   * attributes and updates the SVG `transform` attribute.
   *
   * @private
   * @function Highcharts.SVGElement#updateTransform
   */
  updateTransform: function () {
    var wrapper = this,
        translateX = wrapper.translateX || 0,
        translateY = wrapper.translateY || 0,
        scaleX = wrapper.scaleX,
        scaleY = wrapper.scaleY,
        inverted = wrapper.inverted,
        rotation = wrapper.rotation,
        matrix = wrapper.matrix,
        element = wrapper.element,
        transform; // Flipping affects translate as adjustment for flipping around the
    // group's axis

    if (inverted) {
      translateX += wrapper.width;
      translateY += wrapper.height;
    } // Apply translate. Nearly all transformed elements have translation,
    // so instead of checking for translate = 0, do it always (#1767,
    // #1846).


    transform = ['translate(' + translateX + ',' + translateY + ')']; // apply matrix

    if (defined(matrix)) {
      transform.push('matrix(' + matrix.join(',') + ')');
    } // apply rotation


    if (inverted) {
      transform.push('rotate(90) scale(-1,1)');
    } else if (rotation) {
      // text rotation
      transform.push('rotate(' + rotation + ' ' + pick(this.rotationOriginX, element.getAttribute('x'), 0) + ' ' + pick(this.rotationOriginY, element.getAttribute('y') || 0) + ')');
    } // apply scale


    if (defined(scaleX) || defined(scaleY)) {
      transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');
    }

    if (transform.length) {
      element.setAttribute('transform', transform.join(' '));
    }
  },

  /**
   * Bring the element to the front. Alternatively, a new zIndex can be set.
   *
   * @sample highcharts/members/element-tofront/
   *         Click an element to bring it to front
   *
   * @function Highcharts.SVGElement#toFront
   *
   * @return {Highcharts.SVGElement}
   *         Returns the SVGElement for chaining.
   */
  toFront: function () {
    var element = this.element;
    element.parentNode.appendChild(element);
    return this;
  },

  /**
   * Align the element relative to the chart or another box.
   *
   * @function Highcharts.SVGElement#align
   *
   * @param {Highcharts.AlignObject} [alignOptions]
   *        The alignment options. The function can be called without this
   *        parameter in order to re-align an element after the box has been
   *        updated.
   *
   * @param {boolean} [alignByTranslate]
   *        Align element by translation.
   *
   * @param {string|Highcharts.BBoxObject} [box]
   *        The box to align to, needs a width and height. When the box is a
   *        string, it refers to an object in the Renderer. For example, when
   *        box is `spacingBox`, it refers to `Renderer.spacingBox` which
   *        holds `width`, `height`, `x` and `y` properties.
   *
   * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.
   */
  align: function (alignOptions, alignByTranslate, box) {
    var align,
        vAlign,
        x,
        y,
        attribs = {},
        alignTo,
        renderer = this.renderer,
        alignedObjects = renderer.alignedObjects,
        alignFactor,
        vAlignFactor; // First call on instanciate

    if (alignOptions) {
      this.alignOptions = alignOptions;
      this.alignByTranslate = alignByTranslate;

      if (!box || isString$1(box)) {
        this.alignTo = alignTo = box || 'renderer'; // prevent duplicates, like legendGroup after resize

        erase(alignedObjects, this);
        alignedObjects.push(this);
        box = null; // reassign it below
      } // When called on resize, no arguments are supplied

    } else {
      alignOptions = this.alignOptions;
      alignByTranslate = this.alignByTranslate;
      alignTo = this.alignTo;
    }

    box = pick(box, renderer[alignTo], renderer); // Assign variables

    align = alignOptions.align;
    vAlign = alignOptions.verticalAlign;
    x = (box.x || 0) + (alignOptions.x || 0); // default: left align

    y = (box.y || 0) + (alignOptions.y || 0); // default: top align
    // Align

    if (align === 'right') {
      alignFactor = 1;
    } else if (align === 'center') {
      alignFactor = 2;
    }

    if (alignFactor) {
      x += (box.width - (alignOptions.width || 0)) / alignFactor;
    }

    attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x); // Vertical align

    if (vAlign === 'bottom') {
      vAlignFactor = 1;
    } else if (vAlign === 'middle') {
      vAlignFactor = 2;
    }

    if (vAlignFactor) {
      y += (box.height - (alignOptions.height || 0)) / vAlignFactor;
    }

    attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y); // Animate only if already placed

    this[this.placed ? 'animate' : 'attr'](attribs);
    this.placed = true;
    this.alignAttr = attribs;
    return this;
  },

  /**
   * Get the bounding box (width, height, x and y) for the element. Generally
   * used to get rendered text size. Since this is called a lot in charts,
   * the results are cached based on text properties, in order to save DOM
   * traffic. The returned bounding box includes the rotation, so for example
   * a single text line of rotation 90 will report a greater height, and a
   * width corresponding to the line-height.
   *
   * @sample highcharts/members/renderer-on-chart/
   *         Draw a rectangle based on a text's bounding box
   *
   * @function Highcharts.SVGElement#getBBox
   *
   * @param {boolean} [reload]
   *        Skip the cache and get the updated DOM bouding box.
   *
   * @param {number} [rot]
   *        Override the element's rotation. This is internally used on axis
   *        labels with a value of 0 to find out what the bounding box would
   *        be have been if it were not rotated.
   *
   * @return {Highcharts.BBoxObject}
   *         The bounding box with `x`, `y`, `width` and `height` properties.
   */
  getBBox: function (reload, rot) {
    var wrapper = this,
        bBox,
        // = wrapper.bBox,
    renderer = wrapper.renderer,
        width,
        height,
        rotation,
        rad,
        element = wrapper.element,
        styles = wrapper.styles,
        fontSize,
        textStr = wrapper.textStr,
        toggleTextShadowShim,
        cache = renderer.cache,
        cacheKeys = renderer.cacheKeys,
        cacheKey;
    rotation = pick(rot, wrapper.rotation);
    rad = rotation * deg2rad;
    fontSize = element && SVGElement.prototype.getStyle.call(element, 'font-size'); // Avoid undefined and null (#7316)

    if (defined(textStr)) {
      cacheKey = textStr.toString(); // Since numbers are monospaced, and numerical labels appear a lot
      // in a chart, we assume that a label of n characters has the same
      // bounding box as others of the same length. Unless there is inner
      // HTML in the label. In that case, leave the numbers as is (#5899).

      if (cacheKey.indexOf('<') === -1) {
        cacheKey = cacheKey.replace(/[0-9]/g, '0');
      } // Properties that affect bounding box


      cacheKey += ['', rotation || 0, fontSize, wrapper.textWidth, // #7874, also useHTML
      styles && styles.textOverflow // #5968
      ].join(',');
    }

    if (cacheKey && !reload) {
      bBox = cache[cacheKey];
    } // No cache found


    if (!bBox) {
      // SVG elements
      if (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {
        try {
          // Fails in Firefox if the container has display: none.
          // When the text shadow shim is used, we need to hide the
          // fake shadows to get the correct bounding box (#3872)
          toggleTextShadowShim = this.fakeTS && function (display) {
            each$1(element.querySelectorAll('.highcharts-text-outline'), function (tspan) {
              tspan.style.display = display;
            });
          }; // Workaround for #3842, Firefox reporting wrong bounding
          // box for shadows


          if (toggleTextShadowShim) {
            toggleTextShadowShim('none');
          }

          bBox = element.getBBox ? // SVG: use extend because IE9 is not allowed to change
          // width and height in case of rotation (below)
          extend({}, element.getBBox()) : {
            // Legacy IE in export mode
            width: element.offsetWidth,
            height: element.offsetHeight
          }; // #3842

          if (toggleTextShadowShim) {
            toggleTextShadowShim('');
          }
        } catch (e) {} // If the bBox is not set, the try-catch block above failed. The
        // other condition is for Opera that returns a width of
        // -Infinity on hidden elements.


        if (!bBox || bBox.width < 0) {
          bBox = {
            width: 0,
            height: 0
          };
        } // VML Renderer or useHTML within SVG

      } else {
        bBox = wrapper.htmlGetBBox();
      } // True SVG elements as well as HTML elements in modern browsers
      // using the .useHTML option need to compensated for rotation


      if (renderer.isSVG) {
        width = bBox.width;
        height = bBox.height; // Workaround for wrong bounding box in IE, Edge and Chrome on
        // Windows. With Highcharts' default font, IE and Edge report
        // a box height of 16.899 and Chrome rounds it to 17. If this
        // stands uncorrected, it results in more padding added below
        // the text than above when adding a label border or background.
        // Also vertical positioning is affected.
        // https://jsfiddle.net/highcharts/em37nvuj/
        // (#1101, #1505, #1669, #2568, #6213).

        if (styles && styles.fontSize === '11px' && Math.round(height) === 17) {
          bBox.height = height = 14;
        } // Adjust for rotated text


        if (rotation) {
          bBox.width = Math.abs(height * Math.sin(rad)) + Math.abs(width * Math.cos(rad));
          bBox.height = Math.abs(height * Math.cos(rad)) + Math.abs(width * Math.sin(rad));
        }
      } // Cache it. When loading a chart in a hidden iframe in Firefox and
      // IE/Edge, the bounding box height is 0, so don't cache it (#5620).


      if (cacheKey && bBox.height > 0) {
        // Rotate (#4681)
        while (cacheKeys.length > 250) {
          delete cache[cacheKeys.shift()];
        }

        if (!cache[cacheKey]) {
          cacheKeys.push(cacheKey);
        }

        cache[cacheKey] = bBox;
      }
    }

    return bBox;
  },

  /**
   * Show the element after it has been hidden.
   *
   * @function Highcharts.SVGElement#show
   *
   * @param {boolean} [inherit=false]
   *        Set the visibility attribute to `inherit` rather than `visible`.
   *        The difference is that an element with `visibility="visible"`
   *        will be visible even if the parent is hidden.
   *
   * @return {Highcharts.SVGElement}
   *         Returns the SVGElement for chaining.
   */
  show: function (inherit) {
    return this.attr({
      visibility: inherit ? 'inherit' : 'visible'
    });
  },

  /**
   * Hide the element, equivalent to setting the `visibility` attribute to
   * `hidden`.
   *
   * @function Highcharts.SVGElement#hide
   *
   * @return {Highcharts.SVGElement}
   *         Returns the SVGElement for chaining.
   */
  hide: function () {
    return this.attr({
      visibility: 'hidden'
    });
  },

  /**
   * Fade out an element by animating its opacity down to 0, and hide it on
   * complete. Used internally for the tooltip.
   *
   * @function Highcharts.SVGElement#fadeOut
   *
   * @param {number} [duration=150]
   *        The fade duration in milliseconds.
   */
  fadeOut: function (duration) {
    var elemWrapper = this;
    elemWrapper.animate({
      opacity: 0
    }, {
      duration: duration || 150,
      complete: function () {
        // #3088, assuming we're only using this for tooltips
        elemWrapper.attr({
          y: -9999
        });
      }
    });
  },

  /**
   * Add the element to the DOM. All elements must be added this way.
   *
   * @sample highcharts/members/renderer-g
   *         Elements added to a group
   *
   * @function Highcharts.SVGElement#add
   *
   * @param {Highcharts.SVGElement|Highcharts.SVGDOMElement} [parent]
   *        The parent item to add it to. If undefined, the element is added
   *        to the {@link Highcharts.SVGRenderer.box}.
   *
   * @return {Highcharts.SVGElement}
   *         Returns the SVGElement for chaining.
   */
  add: function (parent) {
    var renderer = this.renderer,
        element = this.element,
        inserted;

    if (parent) {
      this.parentGroup = parent;
    } // mark as inverted


    this.parentInverted = parent && parent.inverted; // build formatted text

    if (this.textStr !== undefined) {
      renderer.buildText(this);
    } // Mark as added


    this.added = true; // If we're adding to renderer root, or other elements in the group
    // have a z index, we need to handle it

    if (!parent || parent.handleZ || this.zIndex) {
      inserted = this.zIndexSetter();
    } // If zIndex is not handled, append at the end


    if (!inserted) {
      (parent ? parent.element : renderer.box).appendChild(element);
    } // fire an event for internal hooks


    if (this.onAdd) {
      this.onAdd();
    }

    return this;
  },

  /**
   * Removes an element from the DOM.
   *
   * @private
   * @function Highcharts.SVGElement#safeRemoveChild
   *
   * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element
   *        The DOM node to remove.
   */
  safeRemoveChild: function (element) {
    var parentNode = element.parentNode;

    if (parentNode) {
      parentNode.removeChild(element);
    }
  },

  /**
   * Destroy the element and element wrapper and clear up the DOM and event
   * hooks.
   *
   * @function Highcharts.SVGElement#destroy
   */
  destroy: function () {
    var wrapper = this,
        element = wrapper.element || {},
        parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,
        grandParent,
        ownerSVGElement = element.ownerSVGElement,
        i,
        clipPath = wrapper.clipPath; // remove events

    element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
    stop(wrapper); // stop running animations

    if (clipPath && ownerSVGElement) {
      // Look for existing references to this clipPath and remove them
      // before destroying the element (#6196).
      each$1( // The upper case version is for Edge
      ownerSVGElement.querySelectorAll('[clip-path],[CLIP-PATH]'), function (el) {
        var clipPathAttr = el.getAttribute('clip-path'),
            clipPathId = clipPath.element.id; // Include the closing paranthesis in the test to rule out
        // id's from 10 and above (#6550). Edge puts quotes inside
        // the url, others not.

        if (clipPathAttr.indexOf('(#' + clipPathId + ')') > -1 || clipPathAttr.indexOf('("#' + clipPathId + '")') > -1) {
          el.removeAttribute('clip-path');
        }
      });
      wrapper.clipPath = clipPath.destroy();
    } // Destroy stops in case this is a gradient object


    if (wrapper.stops) {
      for (i = 0; i < wrapper.stops.length; i++) {
        wrapper.stops[i] = wrapper.stops[i].destroy();
      }

      wrapper.stops = null;
    } // remove element


    wrapper.safeRemoveChild(element); // In case of useHTML, clean up empty containers emulating SVG groups
    // (#1960, #2393, #2697).

    while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
      grandParent = parentToClean.parentGroup;
      wrapper.safeRemoveChild(parentToClean.div);
      delete parentToClean.div;
      parentToClean = grandParent;
    } // remove from alignObjects


    if (wrapper.alignTo) {
      erase(wrapper.renderer.alignedObjects, wrapper);
    }

    objectEach(wrapper, function (val, key) {
      delete wrapper[key];
    });
    return null;
  },

  /**
   * @private
   * @function Highcharts.SVGElement#xGetter
   *
   * @param {string} key
   *
   * @return {number|string|null}
   */
  xGetter: function (key) {
    if (this.element.nodeName === 'circle') {
      if (key === 'x') {
        key = 'cx';
      } else if (key === 'y') {
        key = 'cy';
      }
    }

    return this._defaultGetter(key);
  },

  /**
   * Get the current value of an attribute or pseudo attribute,
   * used mainly for animation. Called internally from
   * the {@link Highcharts.SVGRenderer#attr} function.
   *
   * @private
   * @function Highcharts.SVGElement#_defaultGetter
   *
   * @param {string} key
   *        Property key.
   *
   * @return {number|string|null}
   *         Property value.
   */
  _defaultGetter: function (key) {
    var ret = pick(this[key + 'Value'], // align getter
    this[key], this.element ? this.element.getAttribute(key) : null, 0);

    if (/^[\-0-9\.]+$/.test(ret)) {
      // is numerical
      ret = parseFloat(ret);
    }

    return ret;
  },

  /**
   * @private
   * @function Highcharts.SVGElement#dSettter
   *
   * @param {number|string|Highcharts.SVGPathArray} value
   *
   * @param {string} key
   *
   * @param {Highcharts.SVGDOMElement} element
   */
  dSetter: function (value, key, element) {
    if (value && value.join) {
      // join path
      value = value.join(' ');
    }

    if (/(NaN| {2}|^$)/.test(value)) {
      value = 'M 0 0';
    } // Check for cache before resetting. Resetting causes disturbance in the
    // DOM, causing flickering in some cases in Edge/IE (#6747). Also
    // possible performance gain.


    if (this[key] !== value) {
      element.setAttribute(key, value);
      this[key] = value;
    }
  },

  /**
   * @private
   * @function Highcharts.SVGElement#alignSetter
   *
   * @param {"start"|"middle"|"end"} value
   */
  alignSetter: function (value) {
    var convert = {
      left: 'start',
      center: 'middle',
      right: 'end'
    };
    this.alignValue = value;
    this.element.setAttribute('text-anchor', convert[value]);
  },

  /**
   * @private
   * @function Highcharts.SVGElement#opacitySetter
   *
   * @param {string} value
   *
   * @param {string} key
   *
   * @param {Highcharts.SVGDOMElement} element
   */
  opacitySetter: function (value, key, element) {
    this[key] = value;
    element.setAttribute(key, value);
  },

  /**
   * @private
   * @function Highcharts.SVGElement#titleSetter
   *
   * @param {string} value
   */
  titleSetter: function (value) {
    var titleNode = this.element.getElementsByTagName('title')[0];

    if (!titleNode) {
      titleNode = doc$2.createElementNS(this.SVG_NS, 'title');
      this.element.appendChild(titleNode);
    } // Remove text content if it exists


    if (titleNode.firstChild) {
      titleNode.removeChild(titleNode.firstChild);
    }

    titleNode.appendChild(doc$2.createTextNode( // #3276, #3895
    String(pick(value), '').replace(/<[^>]*>/g, '').replace(/&lt;/g, '<').replace(/&gt;/g, '>')));
  },

  /**
   * @private
   * @function Highcharts.SVGElement#textSetter
   *
   * @param {string} value
   */
  textSetter: function (value) {
    if (value !== this.textStr) {
      // Delete bBox memo when the text changes
      delete this.bBox;
      this.textStr = value;

      if (this.added) {
        this.renderer.buildText(this);
      }
    }
  },

  /**
   * @private
   * @function Highcharts.SVGElement#fillSetter
   *
   * @param {Highcharts.Color|Highcharts.ColorString} value
   *
   * @param {string} key
   *
   * @param {Highcharts.SVGDOMElement} element
   */
  fillSetter: function (value, key, element) {
    if (typeof value === 'string') {
      element.setAttribute(key, value);
    } else if (value) {
      this.complexColor(value, key, element);
    }
  },

  /**
   * @private
   * @function Highcharts.SVGElement#visibilitySetter
   *
   * @param {string} value
   *
   * @param {string} key
   *
   * @param {Highcharts.SVGDOMElement} element
   */
  visibilitySetter: function (value, key, element) {
    // IE9-11 doesn't handle visibilty:inherit well, so we remove the
    // attribute instead (#2881, #3909)
    if (value === 'inherit') {
      element.removeAttribute(key);
    } else if (this[key] !== value) {
      // #6747
      element.setAttribute(key, value);
    }

    this[key] = value;
  },

  /**
   * @private
   * @function Highcharts.SVGElement#zIndexSetter
   *
   * @param {string} value
   *
   * @param {string} key
   *
   * @return {boolean}
   */
  zIndexSetter: function (value, key) {
    var renderer = this.renderer,
        parentGroup = this.parentGroup,
        parentWrapper = parentGroup || renderer,
        parentNode = parentWrapper.element || renderer.box,
        childNodes,
        otherElement,
        otherZIndex,
        element = this.element,
        inserted,
        undefinedOtherZIndex,
        svgParent = parentNode === renderer.box,
        run = this.added,
        i;

    if (defined(value)) {
      // So we can read it for other elements in the group
      element.setAttribute('data-z-index', value);
      value = +value;

      if (this[key] === value) {
        // Only update when needed (#3865)
        run = false;
      }
    } else if (defined(this[key])) {
      element.removeAttribute('data-z-index');
    }

    this[key] = value; // Insert according to this and other elements' zIndex. Before .add() is
    // called, nothing is done. Then on add, or by later calls to
    // zIndexSetter, the node is placed on the right place in the DOM.

    if (run) {
      value = this.zIndex;

      if (value && parentGroup) {
        parentGroup.handleZ = true;
      }

      childNodes = parentNode.childNodes;

      for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {
        otherElement = childNodes[i];
        otherZIndex = otherElement.getAttribute('data-z-index');
        undefinedOtherZIndex = !defined(otherZIndex);

        if (otherElement !== element) {
          if ( // Negative zIndex versus no zIndex:
          // On all levels except the highest. If the parent is
          // <svg>, then we don't want to put items before <desc>
          // or <defs>
          value < 0 && undefinedOtherZIndex && !svgParent && !i) {
            parentNode.insertBefore(element, childNodes[i]);
            inserted = true;
          } else if ( // Insert after the first element with a lower zIndex
          pInt$1(otherZIndex) <= value || // If negative zIndex, add this before first undefined
          // zIndex element
          undefinedOtherZIndex && (!defined(value) || value >= 0)) {
            parentNode.insertBefore(element, childNodes[i + 1] || null // null for oldIE export
            );
            inserted = true;
          }
        }
      }

      if (!inserted) {
        parentNode.insertBefore(element, childNodes[svgParent ? 3 : 0] || null // null for oldIE
        );
        inserted = true;
      }
    }

    return inserted;
  },

  /**
   * @private
   * @function Highcharts.SVGElement#_defaultSetter
   *
   * @param {string} value
   *
   * @param {string} key
   *
   * @param {Highcharts.SVGDOMElement} element
   */
  _defaultSetter: function (value, key, element) {
    element.setAttribute(key, value);
  }
}); // Some shared setters and getters

SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;

SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = SVGElement.prototype.rotationOriginXSetter = SVGElement.prototype.rotationOriginYSetter = SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = SVGElement.prototype.matrixSetter = function (value, key) {
  this[key] = value;
  this.doTransform = true;
};
/**
 * Allows direct access to the Highcharts rendering layer in order to draw
 * primitive shapes like circles, rectangles, paths or text directly on a chart,
 * or independent from any chart. The SVGRenderer represents a wrapper object
 * for SVG in modern browsers. Through the VMLRenderer, part of the `oldie.js`
 * module, it also brings vector graphics to IE <= 8.
 *
 * An existing chart's renderer can be accessed through {@link Chart.renderer}.
 * The renderer can also be used completely decoupled from a chart.
 *
 * @sample highcharts/members/renderer-on-chart
 *         Annotating a chart programmatically.
 * @sample highcharts/members/renderer-basic
 *         Independent SVG drawing.
 *
 * @example
 * // Use directly without a chart object.
 * var renderer = new Highcharts.Renderer(parentNode, 600, 400);
 *
 * @class
 * @name Highcharts.SVGRenderer
 *
 * @param {Highcharts.HTMLDOMElement} container
 *        Where to put the SVG in the web page.
 *
 * @param {number} width
 *        The width of the SVG.
 *
 * @param {number} height
 *        The height of the SVG.
 *
 * @param {boolean} [forExport=false]
 *        Whether the rendered content is intended for export.
 *
 * @param {boolean} [allowHTML=true]
 *        Whether the renderer is allowed to include HTML text, which will be
 *        projected on top of the SVG.
 */


SVGRenderer = Highcharts.SVGRenderer = function () {
  this.init.apply(this, arguments);
};

extend(SVGRenderer.prototype,
/** @lends Highcharts.SVGRenderer.prototype */
{
  /**
   * A pointer to the renderer's associated Element class. The VMLRenderer
   * will have a pointer to VMLElement here.
   *
   * @name Highcharts.SVGRenderer#Element
   * @type {Highcharts.SVGElement}
   */
  Element: SVGElement,
  SVG_NS: SVG_NS$1,

  /**
   * Initialize the SVGRenderer. Overridable initiator function that takes
   * the same parameters as the constructor.
   *
   * @function Highcharts.SVGRenderer#init
   *
   * @param {Highcharts.HTMLDOMElement} container
   *        Where to put the SVG in the web page.
   *
   * @param {number} width
   *        The width of the SVG.
   *
   * @param {number} height
   *        The height of the SVG.
   *
   * @param {boolean} [forExport=false]
   *        Whether the rendered content is intended for export.
   *
   * @param {boolean} [allowHTML=true]
   *        Whether the renderer is allowed to include HTML text, which will
   *        be projected on top of the SVG.
   */
  init: function (container, width, height, style, forExport, allowHTML) {
    var renderer = this,
        boxWrapper,
        element,
        desc;
    boxWrapper = renderer.createElement('svg').attr({
      'version': '1.1',
      'class': 'highcharts-root'
    });
    element = boxWrapper.element;
    container.appendChild(element); // Always use ltr on the container, otherwise text-anchor will be
    // flipped and text appear outside labels, buttons, tooltip etc (#3482)

    attr(container, 'dir', 'ltr'); // For browsers other than IE, add the namespace attribute (#1978)

    if (container.innerHTML.indexOf('xmlns') === -1) {
      attr(element, 'xmlns', this.SVG_NS);
    } // object properties


    renderer.isSVG = true;
    /**
     * The root `svg` node of the renderer.
     *
     * @name Highcharts.SVGRenderer#box
     * @type {Highcharts.SVGDOMElement}
     */

    this.box = element;
    /**
     * The wrapper for the root `svg` node of the renderer.
     *
     * @name Highcharts.SVGRenderer#boxWrapper
     * @type {Highcharts.SVGElement}
     */

    this.boxWrapper = boxWrapper;
    renderer.alignedObjects = [];
    /**
     * Page url used for internal references.
     *
     * @private
     * @name Highcharts.SVGRenderer#url
     * @type {string}
     */
    // #24, #672, #1070

    this.url = (isFirefox$1 || isWebKit) && doc$2.getElementsByTagName('base').length ? win$2.location.href.split('#')[0] // remove the hash
    .replace(/<[^>]*>/g, '') // wing cut HTML
    // escape parantheses and quotes
    .replace(/([\('\)])/g, '\\$1') // replace spaces (needed for Safari only)
    .replace(/ /g, '%20') : ''; // Add description

    desc = this.createElement('desc').add();
    desc.element.appendChild(doc$2.createTextNode('Created with @product.name@ @product.version@'));
    /**
     * A pointer to the `defs` node of the root SVG.
     *
     * @name Highcharts.SVGRenderer#defs
     * @type {Highcharts.SVGElement}
     */

    renderer.defs = this.createElement('defs').add();
    renderer.allowHTML = allowHTML;
    renderer.forExport = forExport;
    renderer.gradients = {}; // Object where gradient SvgElements are stored

    renderer.cache = {}; // Cache for numerical bounding boxes

    renderer.cacheKeys = [];
    renderer.imgCount = 0;
    renderer.setSize(width, height, false); // Issue 110 workaround:
    // In Firefox, if a div is positioned by percentage, its pixel position
    // may land between pixels. The container itself doesn't display this,
    // but an SVG element inside this container will be drawn at subpixel
    // precision. In order to draw sharp lines, this must be compensated
    // for. This doesn't seem to work inside iframes though (like in
    // jsFiddle).

    var subPixelFix, rect;

    if (isFirefox$1 && container.getBoundingClientRect) {
      subPixelFix = function () {
        css(container, {
          left: 0,
          top: 0
        });
        rect = container.getBoundingClientRect();
        css(container, {
          left: Math.ceil(rect.left) - rect.left + 'px',
          top: Math.ceil(rect.top) - rect.top + 'px'
        });
      }; // run the fix now


      subPixelFix(); // run it on resize

      renderer.unSubPixelFix = addEvent(win$2, 'resize', subPixelFix);
    }
  },

  /**
   * General method for adding a definition to the SVG `defs` tag. Can be used
   * for gradients, fills, filters etc. Styled mode only. A hook for adding
   * general definitions to the SVG's defs tag. Definitions can be referenced
   * from the CSS by its `id`. Read more in
   * {@link https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns|gradients, shadows and patterns}.
   * Styled mode only.
   *
   * @function Highcharts.SVGRenderer#definition
   *
   * @param {Highcharts.SVGDefinitionObject} def
   *        A serialized form of an SVG definition, including children.
   *
   * @return {Highcharts.SVGElement}
   *         The inserted node.
   */
  definition: function (def) {
    var ren = this;

    function recurse(config, parent) {
      var ret;
      each$1(splat(config), function (item) {
        var node = ren.createElement(item.tagName),
            attr = {}; // Set attributes

        objectEach(item, function (val, key) {
          if (key !== 'tagName' && key !== 'children' && key !== 'textContent') {
            attr[key] = val;
          }
        });
        node.attr(attr); // Add to the tree

        node.add(parent || ren.defs); // Add text content

        if (item.textContent) {
          node.element.appendChild(doc$2.createTextNode(item.textContent));
        } // Recurse


        recurse(item.children || [], node);
        ret = node;
      }); // Return last node added (on top level it's the only one)

      return ret;
    }

    return recurse(def);
  },

  /**
   * Detect whether the renderer is hidden. This happens when one of the
   * parent elements has `display: none`. Used internally to detect when we
   * needto render preliminarily in another div to get the text bounding boxes
   * right.
   *
   * @function Highcharts.SVGRenderer#isHidden
   *
   * @return {boolean}
   *         True if it is hidden.
   */
  isHidden: function () {
    // #608
    return !this.boxWrapper.getBBox().width;
  },

  /**
   * Destroys the renderer and its allocated members.
   *
   * @function Highcharts.SVGRenderer#destroy
   */
  destroy: function () {
    var renderer = this,
        rendererDefs = renderer.defs;
    renderer.box = null;
    renderer.boxWrapper = renderer.boxWrapper.destroy(); // Call destroy on all gradient elements

    destroyObjectProperties(renderer.gradients || {});
    renderer.gradients = null; // Defs are null in VMLRenderer
    // Otherwise, destroy them here.

    if (rendererDefs) {
      renderer.defs = rendererDefs.destroy();
    } // Remove sub pixel fix handler (#982)


    if (renderer.unSubPixelFix) {
      renderer.unSubPixelFix();
    }

    renderer.alignedObjects = null;
    return null;
  },

  /**
   * Create a wrapper for an SVG element. Serves as a factory for
   * {@link SVGElement}, but this function is itself mostly called from
   * primitive factories like {@link SVGRenderer#path}, {@link
   * SVGRenderer#rect} or {@link SVGRenderer#text}.
   *
   * @function Highcharts.SVGRenderer#createElement
   *
   * @param {string} nodeName
   *        The node name, for example `rect`, `g` etc.
   *
   * @return {Highcharts.SVGElement}
   *         The generated SVGElement.
   */
  createElement: function (nodeName) {
    var wrapper = new this.Element();
    wrapper.init(this, nodeName);
    return wrapper;
  },

  /**
   * Dummy function for plugins, called every time the renderer is updated.
   * Prior to Highcharts 5, this was used for the canvg renderer.
   *
   * @deprecated
   * @function Highcharts.SVGRenderer#draw
   */
  draw: noop,

  /**
   * Get converted radial gradient attributes according to the radial
   * reference. Used internally from the {@link SVGElement#colorGradient}
   * function.
   *
   * @private
   * @function Highcharts.SVGRenderer#getRadialAttr
   *
   * @param {Array<number>} radialReference
   *
   * @param {Highcharts.SVGAttributes} gradAttr
   *
   * @return {Highcharts.SVGAttributes}
   */
  getRadialAttr: function (radialReference, gradAttr) {
    return {
      cx: radialReference[0] - radialReference[2] / 2 + gradAttr.cx * radialReference[2],
      cy: radialReference[1] - radialReference[2] / 2 + gradAttr.cy * radialReference[2],
      r: gradAttr.r * radialReference[2]
    };
  },

  /**
   * Truncate the text node contents to a given length. Used when the css
   * width is set. If the `textOverflow` is `ellipsis`, the text is truncated
   * character by character to the given length. If not, the text is
   * word-wrapped line by line.
   *
   * @private
   * @function Highcharts.SVGRenderer#truncate
   *
   * @param {Highcharts.SVGElement} wrapper
   *
   * @param {Highcharts.SVGDOMElement} tspan
   *
   * @param {string} text
   *
   * @param {Array.<string>} words
   *
   * @param {number} width
   *
   * @param {Function} getString
   *
   * @return {boolean}
   *         True if tspan is too long.
   */
  truncate: function (wrapper, tspan, text, words, startAt, width, getString) {
    var renderer = this,
        rotation = wrapper.rotation,
        str,
        // Word wrap can not be truncated to shorter than one word, ellipsis
    // text can be completely blank.
    minIndex = words ? 1 : 0,
        maxIndex = (text || words).length,
        currentIndex = maxIndex,
        // Cache the lengths to avoid checking the same twice
    lengths = [],
        updateTSpan = function (s) {
      if (tspan.firstChild) {
        tspan.removeChild(tspan.firstChild);
      }

      if (s) {
        tspan.appendChild(doc$2.createTextNode(s));
      }
    },
        getSubStringLength = function (charEnd, concatenatedEnd) {
      // charEnd is useed when finding the character-by-character
      // break for ellipsis, concatenatedEnd is used for word-by-word
      // break for word wrapping.
      var end = concatenatedEnd || charEnd;

      if (lengths[end] === undefined) {
        // Modern browsers
        if (tspan.getSubStringLength) {
          // Fails with DOM exception on unit-tests/legend/members
          // of unknown reason. Desired width is 0, text content
          // is "5" and end is 1.
          try {
            lengths[end] = startAt + tspan.getSubStringLength(0, words ? end + 1 : end);
          } catch (e) {} // Legacy

        } else {
          updateTSpan(getString(text || words, charEnd));
          lengths[end] = startAt + renderer.getSpanWidth(wrapper, tspan);
        }
      }

      return lengths[end];
    },
        actualWidth,
        truncated;

    wrapper.rotation = 0; // discard rotation when computing box

    actualWidth = getSubStringLength(tspan.textContent.length);
    truncated = startAt + actualWidth > width;

    if (truncated) {
      // Do a binary search for the index where to truncate the text
      while (minIndex <= maxIndex) {
        currentIndex = Math.ceil((minIndex + maxIndex) / 2); // When checking words for word-wrap, we need to build the
        // string and measure the subStringLength at the concatenated
        // word length.

        if (words) {
          str = getString(words, currentIndex);
        }

        actualWidth = getSubStringLength(currentIndex, str && str.length - 1);

        if (minIndex === maxIndex) {
          // Complete
          minIndex = maxIndex + 1;
        } else if (actualWidth > width) {
          // Too large. Set max index to current.
          maxIndex = currentIndex - 1;
        } else {
          // Within width. Set min index to current.
          minIndex = currentIndex;
        }
      } // If max index was 0 it means the shortest possible text was also
      // too large. For ellipsis that means only the ellipsis, while for
      // word wrap it means the whole first word.


      if (maxIndex === 0) {
        // Remove ellipsis
        updateTSpan(''); // If the new text length is one less than the original, we don't
        // need the ellipsis
      } else if (!(text && maxIndex === text.length - 1)) {
        updateTSpan(str || getString(text || words, currentIndex));
      }
    } // When doing line wrapping, prepare for the next line by removing the
    // items from this line.


    if (words) {
      words.splice(0, currentIndex);
    }

    wrapper.actualWidth = actualWidth;
    wrapper.rotation = rotation; // Apply rotation again.

    return truncated;
  },

  /**
   * A collection of characters mapped to HTML entities. When `useHTML` on an
   * element is true, these entities will be rendered correctly by HTML. In
   * the SVG pseudo-HTML, they need to be unescaped back to simple characters,
   * so for example `&lt;` will render as `<`.
   *
   * @example
   * // Add support for unescaping quotes
   * Highcharts.SVGRenderer.prototype.escapes['"'] = '&quot;';
   *
   * @name Highcharts.SVGRenderer#escapes
   * @type {Highcharts.Dictionary<string>}
   */
  escapes: {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    "'": '&#39;',
    // eslint-disable-line quotes
    '"': '&quot;'
  },

  /**
   * Parse a simple HTML string into SVG tspans. Called internally when text
   * is set on an SVGElement. The function supports a subset of HTML tags, CSS
   * text features like `width`, `text-overflow`, `white-space`, and also
   * attributes like `href` and `style`.
   *
   * @private
   * @function Highcharts.SVGRenderer#buildText
   *
   * @param {Highcharts.SVGElement} wrapper
   *        The parent SVGElement.
   */
  buildText: function (wrapper) {
    var textNode = wrapper.element,
        renderer = this,
        forExport = renderer.forExport,
        textStr = pick(wrapper.textStr, '').toString(),
        hasMarkup = textStr.indexOf('<') !== -1,
        lines,
        childNodes = textNode.childNodes,
        truncated,
        parentX = attr(textNode, 'x'),
        textStyles = wrapper.styles,
        width = wrapper.textWidth,
        textLineHeight = textStyles && textStyles.lineHeight,
        textOutline = textStyles && textStyles.textOutline,
        ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
        noWrap = textStyles && textStyles.whiteSpace === 'nowrap',
        fontSize = textStyles && textStyles.fontSize,
        textCache,
        isSubsequentLine,
        i = childNodes.length,
        tempParent = width && !wrapper.added && this.box,
        getLineHeight = function (tspan) {
      var fontSizeStyle;
      return textLineHeight ? pInt$1(textLineHeight) : renderer.fontMetrics(fontSizeStyle, // Get the computed size from parent if not explicit
      tspan.getAttribute('style') ? tspan : textNode).h;
    },
        unescapeEntities = function (inputStr, except) {
      objectEach(renderer.escapes, function (value, key) {
        if (!except || inArray(value, except) === -1) {
          inputStr = inputStr.toString().replace(new RegExp(value, 'g'), // eslint-disable-line security/detect-non-literal-regexp
          key);
        }
      });
      return inputStr;
    },
        parseAttribute = function (s, attr) {
      var start, delimiter;
      start = s.indexOf('<');
      s = s.substring(start, s.indexOf('>') - start);
      start = s.indexOf(attr + '=');

      if (start !== -1) {
        start = start + attr.length + 1;
        delimiter = s.charAt(start);

        if (delimiter === '"' || delimiter === "'") {
          // eslint-disable-line quotes
          s = s.substring(start + 1);
          return s.substring(0, s.indexOf(delimiter));
        }
      }
    }; // The buildText code is quite heavy, so if we're not changing something
    // that affects the text, skip it (#6113).


    textCache = [textStr, ellipsis, noWrap, textLineHeight, textOutline, fontSize, width].join(',');

    if (textCache === wrapper.textCache) {
      return;
    }

    wrapper.textCache = textCache; // Remove old text

    while (i--) {
      textNode.removeChild(childNodes[i]);
    } // Skip tspans, add text directly to text node. The forceTSpan is a hook
    // used in text outline hack.


    if (!hasMarkup && !textOutline && !ellipsis && !width && textStr.indexOf(' ') === -1) {
      textNode.appendChild(doc$2.createTextNode(unescapeEntities(textStr))); // Complex strings, add more logic
    } else {
      if (tempParent) {
        // attach it to the DOM to read offset width
        tempParent.appendChild(textNode);
      }

      if (hasMarkup) {
        lines = textStr.replace(/<(b|strong)>/g, '<span class="highcharts-strong">').replace(/<(i|em)>/g, '<span class="highcharts-emphasized">').replace(/<a/g, '<span').replace(/<\/(b|strong|i|em|a)>/g, '</span>').split(/<br.*?>/g);
      } else {
        lines = [textStr];
      } // Trim empty lines (#5261)


      lines = grep(lines, function (line) {
        return line !== '';
      }); // build the lines

      each$1(lines, function buildTextLines(line, lineNo) {
        var spans,
            spanNo = 0,
            lineLength = 0;
        line = line // Trim to prevent useless/costly process on the spaces
        // (#5258)
        .replace(/^\s+|\s+$/g, '').replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
        spans = line.split('|||');
        each$1(spans, function buildTextSpans(span) {
          if (span !== '' || spans.length === 1) {
            var attributes = {},
                tspan = doc$2.createElementNS(renderer.SVG_NS, 'tspan'),
                classAttribute,
                styleAttribute,
                // #390
            hrefAttribute;
            classAttribute = parseAttribute(span, 'class');

            if (classAttribute) {
              attr(tspan, 'class', classAttribute);
            }

            styleAttribute = parseAttribute(span, 'style');

            if (styleAttribute) {
              styleAttribute = styleAttribute.replace(/(;| |^)color([ :])/, '$1fill$2');
              attr(tspan, 'style', styleAttribute);
            } // Not for export - #1529


            hrefAttribute = parseAttribute(span, 'href');

            if (hrefAttribute && !forExport) {
              attr(tspan, 'onclick', 'location.href=\"' + hrefAttribute + '\"');
              attr(tspan, 'class', 'highcharts-anchor');
            } // Strip away unsupported HTML tags (#7126)


            span = unescapeEntities(span.replace(/<[a-zA-Z\/](.|\n)*?>/g, '') || ' '); // Nested tags aren't supported, and cause crash in
            // Safari (#1596)

            if (span !== ' ') {
              // add the text node
              tspan.appendChild(doc$2.createTextNode(span)); // First span in a line, align it to the left

              if (!spanNo) {
                if (lineNo && parentX !== null) {
                  attributes.x = parentX;
                }
              } else {
                attributes.dx = 0; // #16
              } // add attributes


              attr(tspan, attributes); // Append it

              textNode.appendChild(tspan); // first span on subsequent line, add the line
              // height

              if (!spanNo && isSubsequentLine) {
                // allow getting the right offset height in
                // exporting in IE
                if (!svg$1 && forExport) {
                  css(tspan, {
                    display: 'block'
                  });
                } // Set the line height based on the font size of
                // either the text element or the tspan element


                attr(tspan, 'dy', getLineHeight(tspan));
              } // Check width and apply soft breaks or ellipsis


              if (width) {
                var words = span.replace(/([^\^])-/g, '$1- ').split(' '),
                    // #1273
                hasWhiteSpace = !noWrap && (spans.length > 1 || lineNo || words.length > 1),
                    wrapLineNo = 0,
                    dy = getLineHeight(tspan);

                if (ellipsis) {
                  truncated = renderer.truncate(wrapper, tspan, span, undefined, 0, // Target width
                  Math.max(0, // Substract the font face to make
                  // room for the ellipsis itself
                  width - parseInt(fontSize || 12, 10)), // Build the text to test for
                  function (text, currentIndex) {
                    return text.substring(0, currentIndex) + '\u2026';
                  });
                } else if (hasWhiteSpace) {
                  while (words.length) {
                    // For subsequent lines, create tspans
                    // with the same style attributes as the
                    // parent text node.
                    if (words.length && !noWrap && wrapLineNo > 0) {
                      tspan = doc$2.createElementNS(SVG_NS$1, 'tspan');
                      attr(tspan, {
                        dy: dy,
                        x: parentX
                      });

                      if (styleAttribute) {
                        // #390
                        attr(tspan, 'style', styleAttribute);
                      } // Start by appending the full
                      // remaining text


                      tspan.appendChild(doc$2.createTextNode(words.join(' ').replace(/- /g, '-')));
                      textNode.appendChild(tspan);
                    } // For each line, truncate the remaining
                    // words into the line length.


                    renderer.truncate(wrapper, tspan, null, words, wrapLineNo === 0 ? lineLength : 0, width, // Build the text to test for
                    function (text, currentIndex) {
                      return words.slice(0, currentIndex).join(' ').replace(/- /g, '-');
                    });
                    lineLength = wrapper.actualWidth;
                    wrapLineNo++;
                  }
                }
              }

              spanNo++;
            }
          }
        }); // To avoid beginning lines that doesn't add to the textNode
        // (#6144)

        isSubsequentLine = isSubsequentLine || textNode.childNodes.length;
      });

      if (ellipsis && truncated) {
        wrapper.attr('title', unescapeEntities(wrapper.textStr, ['&lt;', '&gt;']) // #7179
        );
      }

      if (tempParent) {
        tempParent.removeChild(textNode);
      } // Apply the text outline


      if (textOutline && wrapper.applyTextOutline) {
        wrapper.applyTextOutline(textOutline);
      }
    }
  },

  /**
   * Returns white for dark colors and black for bright colors.
   *
   * @function Highcharts.SVGRenderer#getContrast
   *
   * @param {Highcharts.ColorString} rgba
   *        The color to get the contrast for.
   *
   * @return {string}
   *         The contrast color, either `#000000` or `#FFFFFF`.
   */
  getContrast: function (rgba) {
    rgba = color(rgba).rgba; // The threshold may be discussed. Here's a proposal for adding
    // different weight to the color channels (#6216)

    rgba[0] *= 1; // red

    rgba[1] *= 1.2; // green

    rgba[2] *= 0.5; // blue

    return rgba[0] + rgba[1] + rgba[2] > 1.8 * 255 ? '#000000' : '#FFFFFF';
  },

  /**
   * Create a button with preset states.
   *
   * @function Highcharts.SVGRenderer#button
   *
   * @param {string} text
   *        The text or HTML to draw.
   *
   * @param {number} x
   *        The x position of the button's left side.
   *
   * @param {number} y
   *        The y position of the button's top side.
   *
   * @param {Function} callback
   *        The function to execute on button click or touch.
   *
   * @param {Highcharts.SVGAttributes} [normalState]
   *        SVG attributes for the normal state.
   *
   * @param {Highcharts.SVGAttributes} [hoverState]
   *        SVG attributes for the hover state.
   *
   * @param {Highcharts.SVGAttributes} [pressedState]
   *        SVG attributes for the pressed state.
   *
   * @param {Highcharts.SVGAttributes} [disabledState]
   *        SVG attributes for the disabled state.
   *
   * @param {Highcharts.SymbolKey} [shape=rect]
   *        The shape type.
   *
   * @return {Highcharts.SVGElement}
   *         The button element.
   */
  button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
    var label = this.label(text, x, y, shape, null, null, null, null, 'button'),
        curState = 0; // Default, non-stylable attributes

    label.attr(merge$1({
      'padding': 8,
      'r': 2
    }, normalState)); // Add the events. IE9 and IE10 need mouseover and mouseout to funciton
    // (#667).

    addEvent(label.element, isMS$1 ? 'mouseover' : 'mouseenter', function () {
      if (curState !== 3) {
        label.setState(1);
      }
    });
    addEvent(label.element, isMS$1 ? 'mouseout' : 'mouseleave', function () {
      if (curState !== 3) {
        label.setState(curState);
      }
    });

    label.setState = function (state) {
      // Hover state is temporary, don't record it
      if (state !== 1) {
        label.state = curState = state;
      } // Update visuals


      label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass('highcharts-button-' + ['normal', 'hover', 'pressed', 'disabled'][state || 0]);
    };

    return label.on('click', function (e) {
      if (curState !== 3) {
        callback.call(label, e);
      }
    });
  },

  /**
   * Make a straight line crisper by not spilling out to neighbour pixels.
   *
   * @function Highcharts.SVGRenderer#crispLine
   *
   * @param {Highcharts.SVGPathArray} points
   *        The original points on the format `['M', 0, 0, 'L', 100, 0]`.
   *
   * @param {number} width
   *        The width of the line.
   *
   * @return {Highcharts.SVGPathArray}
   *         The original points array, but modified to render crisply.
   */
  crispLine: function (points, width) {
    // normalize to a crisp line
    if (points[1] === points[4]) {
      // Substract due to #1129. Now bottom and left axis gridlines behave
      // the same.
      points[1] = points[4] = Math.round(points[1]) - width % 2 / 2;
    }

    if (points[2] === points[5]) {
      points[2] = points[5] = Math.round(points[2]) + width % 2 / 2;
    }

    return points;
  },

  /**
   * Draw a path, wraps the SVG `path` element.
   *
   * @sample highcharts/members/renderer-path-on-chart/
   *         Draw a path in a chart
   * @sample highcharts/members/renderer-path/
   *         Draw a path independent from a chart
   *
   * @example
   * var path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])
   *     .attr({ stroke: '#ff00ff' })
   *     .add();
   *
   * @function Highcharts.SVGRenderer#path
   *
   * @param {Highcharts.SVGPathArray} [path]
   *        An SVG path definition in array form.
   *
   * @return {Highcharts.SVGElement}
   *         The generated wrapper element.
   *
   */

  /**
  * Draw a path, wraps the SVG `path` element.
  *
  * @function Highcharts.SVGRenderer#path
  *
  * @param {Highcharts.SVGAttributes} [attribs]
  *        The initial attributes.
  *
  * @return {Highcharts.SVGElement}
  *         The generated wrapper element.
  */
  path: function (path) {
    var attribs = {};

    if (isArray(path)) {
      attribs.d = path;
    } else if (isObject$1(path)) {
      // attributes
      extend(attribs, path);
    }

    return this.createElement('path').attr(attribs);
  },

  /**
   * Draw a circle, wraps the SVG `circle` element.
   *
   * @sample highcharts/members/renderer-circle/
   *         Drawing a circle
   *
   * @function Highcharts.SVGRenderer#circle
   *
   * @param {number} [x]
   *        The center x position.
   *
   * @param {number} [y]
   *        The center y position.
   *
   * @param {number} [r]
   *        The radius.
   *
   * @return {Highcharts.SVGElement}
   *         The generated wrapper element.
   */

  /**
  * Draw a circle, wraps the SVG `circle` element.
  *
  * @function Highcharts.SVGRenderer#circle
  *
  * @param {Highcharts.SVGAttributes} [attribs]
  *        The initial attributes.
  *
  * @return {Highcharts.SVGElement}
  *         The generated wrapper element.
  */
  circle: function (x, y, r) {
    var attribs = isObject$1(x) ? x : {
      x: x,
      y: y,
      r: r
    },
        wrapper = this.createElement('circle'); // Setting x or y translates to cx and cy

    wrapper.xSetter = wrapper.ySetter = function (value, key, element) {
      element.setAttribute('c' + key, value);
    };

    return wrapper.attr(attribs);
  },

  /**
   * Draw and return an arc.
   *
   * @sample highcharts/members/renderer-arc/
   *         Drawing an arc
   *
   * @function Highcharts.SVGRenderer#arc
   *
   * @param {number} [x=0]
   *        Center X position.
   *
   * @param {number} [y=0]
   *        Center Y position.
   *
   * @param {number} [r=0]
   *        The outer radius of the arc.
   *
   * @param {number} [innerR=0]
   *        Inner radius like used in donut charts.
   *
   * @param {number} [start=0]
   *        The starting angle of the arc in radians, where 0 is to the right
   *         and `-Math.PI/2` is up.
   *
   * @param {number} [end=0]
   *        The ending angle of the arc in radians, where 0 is to the right
   *        and `-Math.PI/2` is up.
   *
   * @return {Highcharts.SVGElement}
   *         The generated wrapper element.
   */

  /**
  * Draw and return an arc. Overloaded function that takes arguments object.
  *
  * @function Highcharts.SVGRenderer#arc
  *
  * @param {Highcharts.SVGAttributes} attribs
  *        Initial SVG attributes.
  *
  * @return {Highcharts.SVGElement}
  *         The generated wrapper element.
  */
  arc: function (x, y, r, innerR, start, end) {
    var arc, options;

    if (isObject$1(x)) {
      options = x;
      y = options.y;
      r = options.r;
      innerR = options.innerR;
      start = options.start;
      end = options.end;
      x = options.x;
    } else {
      options = {
        innerR: innerR,
        start: start,
        end: end
      };
    } // Arcs are defined as symbols for the ability to set
    // attributes in attr and animate


    arc = this.symbol('arc', x, y, r, r, options);
    arc.r = r; // #959

    return arc;
  },

  /**
   * Draw and return a rectangle.
   *
   * @function Highcharts.SVGRenderer#rect
   *
   * @param {number} [x]
   *        Left position.
   *
   * @param {number} [y]
   *        Top position.
   *
   * @param {number} [width]
   *        Width of the rectangle.
   *
   * @param {number} [height]
   *        Height of the rectangle.
   *
   * @param {number} [r]
   *        Border corner radius.
   *
   * @param {number} [strokeWidth]
   *        A stroke width can be supplied to allow crisp drawing.
   *
   * @return {Highcharts.SVGElement}
   *         The generated wrapper element.
   */

  /**
  * Draw and return a rectangle.
  *
  * @sample highcharts/members/renderer-rect-on-chart/
  *         Draw a rectangle in a chart
  * @sample highcharts/members/renderer-rect/
  *         Draw a rectangle independent from a chart
  *
  * @function Highcharts.SVGRenderer#rect
  *
  * @param {Highcharts.SVGAttributes} [attributes]
  *        General SVG attributes for the rectangle.
  *
  * @return {Highcharts.SVGElement}
  *         The generated wrapper element.
  */
  rect: function (x, y, width, height, r, strokeWidth) {
    r = isObject$1(x) ? x.r : r;
    var wrapper = this.createElement('rect'),
        attribs = isObject$1(x) ? x : x === undefined ? {} : {
      x: x,
      y: y,
      width: Math.max(width, 0),
      height: Math.max(height, 0)
    };

    if (r) {
      attribs.r = r;
    }

    wrapper.rSetter = function (value, key, element) {
      attr(element, {
        rx: value,
        ry: value
      });
    };

    return wrapper.attr(attribs);
  },

  /**
   * Resize the {@link SVGRenderer#box} and re-align all aligned child
   * elements.
   *
   * @sample highcharts/members/renderer-g/
   *         Show and hide grouped objects
   *
   * @function Highcharts.SVGRenderer#setSize
   *
   * @param {number} width
   *        The new pixel width.
   *
   * @param {number} height
   *        The new pixel height.
   *
   * @param {boolean|Highcharts.AnimationOptionsObject} [animate=true]
   *        Whether and how to animate.
   */
  setSize: function (width, height, animate) {
    var renderer = this,
        alignedObjects = renderer.alignedObjects,
        i = alignedObjects.length;
    renderer.width = width;
    renderer.height = height;
    renderer.boxWrapper.animate({
      width: width,
      height: height
    }, {
      step: function () {
        this.attr({
          viewBox: '0 0 ' + this.attr('width') + ' ' + this.attr('height')
        });
      },
      duration: pick(animate, true) ? undefined : 0
    });

    while (i--) {
      alignedObjects[i].align();
    }
  },

  /**
   * Create and return an svg group element. Child
   * {@link Highcharts.SVGElement} objects are added to the group by using the
   * group as the first parameter in {@link Highcharts.SVGElement#add|add()}.
   *
   * @function Highcharts.SVGRenderer#g
   *
   * @param {string} [name]
   *        The group will be given a class name of `highcharts-{name}`. This
   *        can be used for styling and scripting.
   *
   * @return {Highcharts.SVGElement}
   *         The generated wrapper element.
   */
  g: function (name) {
    var elem = this.createElement('g');
    return name ? elem.attr({
      'class': 'highcharts-' + name
    }) : elem;
  },

  /**
   * Display an image.
   *
   * @sample highcharts/members/renderer-image-on-chart/
   *         Add an image in a chart
   * @sample highcharts/members/renderer-image/
   *         Add an image independent of a chart
   *
   * @function Highcharts.SVGRenderer#image
   *
   * @param {string} src
   *        The image source.
   *
   * @param {number} [x]
   *        The X position.
   *
   * @param {number} [y]
   *        The Y position.
   *
   * @param {number} [width]
   *        The image width. If omitted, it defaults to the image file width.
   *
   * @param {number} [height]
   *        The image height. If omitted it defaults to the image file
   *        height.
   *
   * @param {Function} [onload]
   *        Event handler for image load.
   *
   * @return {Highcharts.SVGElement}
   *         The generated wrapper element.
   */
  image: function (src, x, y, width, height, onload) {
    var attribs = {
      preserveAspectRatio: 'none'
    },
        elemWrapper,
        dummy,
        setSVGImageSource = function (el, src) {
      // Set the href in the xlink namespace
      if (el.setAttributeNS) {
        el.setAttributeNS('http://www.w3.org/1999/xlink', 'href', src);
      } else {
        // could be exporting in IE
        // using href throws "not supported" in ie7 and under,
        // requries regex shim to fix later
        el.setAttribute('hc-svg-href', src);
      }
    },
        onDummyLoad = function (e) {
      setSVGImageSource(elemWrapper.element, src);
      onload.call(elemWrapper, e);
    }; // optional properties


    if (arguments.length > 1) {
      extend(attribs, {
        x: x,
        y: y,
        width: width,
        height: height
      });
    }

    elemWrapper = this.createElement('image').attr(attribs); // Add load event if supplied

    if (onload) {
      // We have to use a dummy HTML image since IE support for SVG image
      // load events is very buggy. First set a transparent src, wait for
      // dummy to load, and then add the real src to the SVG image.
      setSVGImageSource(elemWrapper.element, 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=='
      /* eslint-disable-line */
      );
      dummy = new win$2.Image();
      addEvent(dummy, 'load', onDummyLoad);
      dummy.src = src;

      if (dummy.complete) {
        onDummyLoad({});
      }
    } else {
      setSVGImageSource(elemWrapper.element, src);
    }

    return elemWrapper;
  },

  /**
   * Draw a symbol out of pre-defined shape paths from
   * {@link SVGRenderer#symbols}.
   * It is used in Highcharts for point makers, which cake a `symbol` option,
   * and label and button backgrounds like in the tooltip and stock flags.
   *
   * @function Highcharts.SVGRenderer#symbol
   *
   * @param {symbol} symbol
   *        The symbol name.
   *
   * @param {number} x
   *        The X coordinate for the top left position.
   *
   * @param {number} y
   *        The Y coordinate for the top left position.
   *
   * @param {number} width
   *        The pixel width.
   *
   * @param {number} height
   *        The pixel height.
   *
   * @param {Highcharts.SymbolOptionsObject} [options]
   *        Additional options, depending on the actual symbol drawn.
   *
   * @return {Highcharts.SVGElement}
   */
  symbol: function (symbol, x, y, width, height, options) {
    var ren = this,
        obj,
        imageRegex = /^url\((.*?)\)$/,
        isImage = imageRegex.test(symbol),
        sym = !isImage && (this.symbols[symbol] ? symbol : 'circle'),
        // get the symbol definition function
    symbolFn = sym && this.symbols[sym],
        // check if there's a path defined for this symbol
    path = defined(x) && symbolFn && symbolFn.call(this.symbols, Math.round(x), Math.round(y), width, height, options),
        imageSrc,
        centerImage;

    if (symbolFn) {
      obj = this.path(path); // expando properties for use in animate and attr

      extend(obj, {
        symbolName: sym,
        x: x,
        y: y,
        width: width,
        height: height
      });

      if (options) {
        extend(obj, options);
      } // Image symbols

    } else if (isImage) {
      imageSrc = symbol.match(imageRegex)[1]; // Create the image synchronously, add attribs async

      obj = this.image(imageSrc); // The image width is not always the same as the symbol width. The
      // image may be centered within the symbol, as is the case when
      // image shapes are used as label backgrounds, for example in flags.

      obj.imgwidth = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].width, options && options.width);
      obj.imgheight = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].height, options && options.height);
      /**
       * Set the size and position
       */

      centerImage = function () {
        obj.attr({
          width: obj.width,
          height: obj.height
        });
      };
      /**
       * Width and height setters that take both the image's physical size
       * and the label size into consideration, and translates the image
       * to center within the label.
       */


      each$1(['width', 'height'], function (key) {
        obj[key + 'Setter'] = function (value, key) {
          var attribs = {},
              imgSize = this['img' + key],
              trans = key === 'width' ? 'translateX' : 'translateY';
          this[key] = value;

          if (defined(imgSize)) {
            if (this.element) {
              this.element.setAttribute(key, imgSize);
            }

            if (!this.alignByTranslate) {
              attribs[trans] = ((this[key] || 0) - imgSize) / 2;
              this.attr(attribs);
            }
          }
        };
      });

      if (defined(x)) {
        obj.attr({
          x: x,
          y: y
        });
      }

      obj.isImg = true;

      if (defined(obj.imgwidth) && defined(obj.imgheight)) {
        centerImage();
      } else {
        // Initialize image to be 0 size so export will still function
        // if there's no cached sizes.
        obj.attr({
          width: 0,
          height: 0
        }); // Create a dummy JavaScript image to get the width and height.

        createElement('img', {
          onload: function () {
            var chart = charts$1[ren.chartIndex]; // Special case for SVGs on IE11, the width is not
            // accessible until the image is part of the DOM
            // (#2854).

            if (this.width === 0) {
              css(this, {
                position: 'absolute',
                top: '-999em'
              });
              doc$2.body.appendChild(this);
            } // Center the image


            symbolSizes[imageSrc] = {
              // Cache for next
              width: this.width,
              height: this.height
            };
            obj.imgwidth = this.width;
            obj.imgheight = this.height;

            if (obj.element) {
              centerImage();
            } // Clean up after #2854 workaround.


            if (this.parentNode) {
              this.parentNode.removeChild(this);
            } // Fire the load event when all external images are
            // loaded


            ren.imgCount--;

            if (!ren.imgCount && chart && chart.onload) {
              chart.onload();
            }
          },
          src: imageSrc
        });
        this.imgCount++;
      }
    }

    return obj;
  },

  /**
   * An extendable collection of functions for defining symbol paths.
   *
   * @name Highcharts.SVGRenderer#symbols
   * @type {Highcharts.SymbolDictionary}
   */
  symbols: {
    'circle': function (x, y, w, h) {
      // Return a full arc
      return this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {
        start: 0,
        end: Math.PI * 2,
        open: false
      });
    },
    'square': function (x, y, w, h) {
      return ['M', x, y, 'L', x + w, y, x + w, y + h, x, y + h, 'Z'];
    },
    'triangle': function (x, y, w, h) {
      return ['M', x + w / 2, y, 'L', x + w, y + h, x, y + h, 'Z'];
    },
    'triangle-down': function (x, y, w, h) {
      return ['M', x, y, 'L', x + w, y, x + w / 2, y + h, 'Z'];
    },
    'diamond': function (x, y, w, h) {
      return ['M', x + w / 2, y, 'L', x + w, y + h / 2, x + w / 2, y + h, x, y + h / 2, 'Z'];
    },
    'arc': function (x, y, w, h, options) {
      var start = options.start,
          rx = options.r || w,
          ry = options.r || h || w,
          proximity = 0.001,
          fullCircle = Math.abs(options.end - options.start - 2 * Math.PI) < proximity,
          // Substract a small number to prevent cos and sin of start and
      // end from becoming equal on 360 arcs (related: #1561)
      end = options.end - proximity,
          innerRadius = options.innerR,
          open = pick(options.open, fullCircle),
          cosStart = Math.cos(start),
          sinStart = Math.sin(start),
          cosEnd = Math.cos(end),
          sinEnd = Math.sin(end),
          // Proximity takes care of rounding errors around PI (#6971)
      longArc = options.end - start - Math.PI < proximity ? 0 : 1,
          arc;
      arc = ['M', x + rx * cosStart, y + ry * sinStart, 'A', // arcTo
      rx, // x radius
      ry, // y radius
      0, // slanting
      longArc, // long or short arc
      1, // clockwise
      x + rx * cosEnd, y + ry * sinEnd];

      if (defined(innerRadius)) {
        arc.push(open ? 'M' : 'L', x + innerRadius * cosEnd, y + innerRadius * sinEnd, 'A', // arcTo
        innerRadius, // x radius
        innerRadius, // y radius
        0, // slanting
        longArc, // long or short arc
        0, // clockwise
        x + innerRadius * cosStart, y + innerRadius * sinStart);
      }

      arc.push(open ? '' : 'Z'); // close

      return arc;
    },

    /**
     * Callout shape used for default tooltips, also used for rounded
     * rectangles in VML
     */
    'callout': function (x, y, w, h, options) {
      var arrowLength = 6,
          halfDistance = 6,
          r = Math.min(options && options.r || 0, w, h),
          safeDistance = r + halfDistance,
          anchorX = options && options.anchorX,
          anchorY = options && options.anchorY,
          path;
      path = ['M', x + r, y, 'L', x + w - r, y, // top side
      'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
      'L', x + w, y + h - r, // right side
      'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-rgt
      'L', x + r, y + h, // bottom side
      'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
      'L', x, y + r, // left side
      'C', x, y, x, y, x + r, y // top-left corner
      ]; // Anchor on right side

      if (anchorX && anchorX > w) {
        // Chevron
        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
          path.splice(13, 3, 'L', x + w, anchorY - halfDistance, x + w + arrowLength, anchorY, x + w, anchorY + halfDistance, x + w, y + h - r); // Simple connector
        } else {
          path.splice(13, 3, 'L', x + w, h / 2, anchorX, anchorY, x + w, h / 2, x + w, y + h - r);
        } // Anchor on left side

      } else if (anchorX && anchorX < 0) {
        // Chevron
        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
          path.splice(33, 3, 'L', x, anchorY + halfDistance, x - arrowLength, anchorY, x, anchorY - halfDistance, x, y + r); // Simple connector
        } else {
          path.splice(33, 3, 'L', x, h / 2, anchorX, anchorY, x, h / 2, x, y + r);
        }
      } else if ( // replace bottom
      anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) {
        path.splice(23, 3, 'L', anchorX + halfDistance, y + h, anchorX, y + h + arrowLength, anchorX - halfDistance, y + h, x + r, y + h);
      } else if ( // replace top
      anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) {
        path.splice(3, 3, 'L', anchorX - halfDistance, y, anchorX, y - arrowLength, anchorX + halfDistance, y, w - r, y);
      }

      return path;
    }
  },

  /**
   * Define a clipping rectangle. The clipping rectangle is later applied
   * to {@link SVGElement} objects through the {@link SVGElement#clip}
   * function.
   *
   * @example
   * var circle = renderer.circle(100, 100, 100)
   *     .attr({ fill: 'red' })
   *     .add();
   * var clipRect = renderer.clipRect(100, 100, 100, 100);
   *
   * // Leave only the lower right quarter visible
   * circle.clip(clipRect);
   *
   * @function Highcharts.SVGRenderer#clipRect
   *
   * @param {string} id
   *
   * @param {number} x
   *
   * @param {number} y
   *
   * @param {number} width
   *
   * @param {number} height
   *
   * @return {Highcharts.ClipRectElement}
   *         A clipping rectangle.
   */
  clipRect: function (x, y, width, height) {
    var wrapper,
        id = Highcharts.uniqueKey(),
        clipPath = this.createElement('clipPath').attr({
      id: id
    }).add(this.defs);
    wrapper = this.rect(x, y, width, height, 0).add(clipPath);
    wrapper.id = id;
    wrapper.clipPath = clipPath;
    wrapper.count = 0;
    return wrapper;
  },

  /**
   * Draw text. The text can contain a subset of HTML, like spans and anchors
   * and some basic text styling of these. For more advanced features like
   * border and background, use {@link Highcharts.SVGRenderer#label} instead.
   * To update the text after render, run `text.attr({ text: 'New text' })`.
   *
   * @sample highcharts/members/renderer-text-on-chart/
   *         Annotate the chart freely
   * @sample highcharts/members/renderer-on-chart/
   *         Annotate with a border and in response to the data
   * @sample highcharts/members/renderer-text/
   *         Formatted text
   *
   * @function Highcharts.SVGRenderer#text
   *
   * @param {string} str
   *        The text of (subset) HTML to draw.
   *
   * @param {number} x
   *        The x position of the text's lower left corner.
   *
   * @param {number} y
   *        The y position of the text's lower left corner.
   *
   * @param {boolean} [useHTML=false]
   *        Use HTML to render the text.
   *
   * @return {Highcharts.SVGElement}
   *         The text object.
   */
  text: function (str, x, y, useHTML) {
    // declare variables
    var renderer = this,
        wrapper,
        attribs = {};

    if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
      return renderer.html(str, x, y);
    }

    attribs.x = Math.round(x || 0); // X always needed for line-wrap logic

    if (y) {
      attribs.y = Math.round(y);
    }

    if (str || str === 0) {
      attribs.text = str;
    }

    wrapper = renderer.createElement('text').attr(attribs);

    if (!useHTML) {
      wrapper.xSetter = function (value, key, element) {
        var tspans = element.getElementsByTagName('tspan'),
            tspan,
            parentVal = element.getAttribute(key),
            i;

        for (i = 0; i < tspans.length; i++) {
          tspan = tspans[i]; // If the x values are equal, the tspan represents a
          // linebreak

          if (tspan.getAttribute(key) === parentVal) {
            tspan.setAttribute(key, value);
          }
        }

        element.setAttribute(key, value);
      };
    }

    return wrapper;
  },

  /**
   * Utility to return the baseline offset and total line height from the font
   * size.
   *
   * @function Highcharts.SVGRenderer#fontMetrics
   *
   * @param {string} [fontSize]
   *        The current font size to inspect. If not given, the font size
   *        will be found from the DOM element.
   *
   * @param {Highcharts.SVGElement|Highcharts.SVGDOMElement} [elem]
   *        The element to inspect for a current font size.
   *
   * @return {Highcharts.FontMetricsObject}
   *         The font metrics.
   */
  fontMetrics: function (fontSize, elem) {
    var lineHeight, baseline;
    fontSize = elem && SVGElement.prototype.getStyle.call(elem, 'font-size'); // Handle different units

    if (/px/.test(fontSize)) {
      fontSize = pInt$1(fontSize);
    } else if (/em/.test(fontSize)) {
      // The em unit depends on parent items
      fontSize = parseFloat(fontSize) * (elem ? this.fontMetrics(null, elem.parentNode).f : 16);
    } else {
      fontSize = 12;
    } // Empirical values found by comparing font size and bounding box
    // height. Applies to the default font family.
    // https://jsfiddle.net/highcharts/7xvn7/


    lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);
    baseline = Math.round(lineHeight * 0.8);
    return {
      h: lineHeight,
      b: baseline,
      f: fontSize
    };
  },

  /**
   * Correct X and Y positioning of a label for rotation (#1764).
   *
   * @private
   * @function Highcharts.SVGRenderer#rotCorr
   *
   * @param {number} baseline
   *
   * @param {number} rotation
   *
   * @param {boolean} alterY
   */
  rotCorr: function (baseline, rotation, alterY) {
    var y = baseline;

    if (rotation && alterY) {
      y = Math.max(y * Math.cos(rotation * deg2rad), 4);
    }

    return {
      x: -baseline / 3 * Math.sin(rotation * deg2rad),
      y: y
    };
  },

  /**
   * Draw a label, which is an extended text element with support for border
   * and background. Highcharts creates a `g` element with a text and a `path`
   * or `rect` inside, to make it behave somewhat like a HTML div. Border and
   * background are set through `stroke`, `stroke-width` and `fill` attributes
   * using the {@link Highcharts.SVGElement#attr|attr} method. To update the
   * text after render, run `label.attr({ text: 'New text' })`.
   *
   * @sample highcharts/members/renderer-label-on-chart/
   *         A label on the chart
   *
   * @function Highcharts.SVGRenderer#label
   *
   * @param {string} str
   *        The initial text string or (subset) HTML to render.
   *
   * @param {number} x
   *        The x position of the label's left side.
   *
   * @param {number} y
   *        The y position of the label's top side or baseline, depending on
   *        the `baseline` parameter.
   *
   * @param {string} [shape='rect']
   *        The shape of the label's border/background, if any. Defaults to
   *        `rect`. Other possible values are `callout` or other shapes
   *        defined in {@link Highcharts.SVGRenderer#symbols}.
   *
   * @param {string} [shape='rect']
   *        The shape of the label's border/background, if any. Defaults to
   *        `rect`. Other possible values are `callout` or other shapes
   *        defined in {@link Highcharts.SVGRenderer#symbols}.
   *
   * @param {number} [anchorX]
   *        In case the `shape` has a pointer, like a flag, this is the
   *        coordinates it should be pinned to.
   *
   * @param {number} [anchorY]
   *        In case the `shape` has a pointer, like a flag, this is the
   *        coordinates it should be pinned to.
   *
   * @param {boolean} [useHTML=false]
   *        Wether to use HTML to render the label.
   *
   * @param {boolean} [baseline=false]
   *        Whether to position the label relative to the text baseline,
   *        like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the
   *        upper border of the rectangle.
   *
   * @param {string} [className]
   *        Class name for the group.
   *
   * @return {Highcharts.SVGElement}
   *         The generated label.
   */
  label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
    var renderer = this,
        wrapper = renderer.g(className !== 'button' && 'label'),
        text = wrapper.text = renderer.text('', 0, 0, useHTML).attr({
      zIndex: 1
    }),
        box,
        bBox,
        alignFactor = 0,
        padding = 3,
        paddingLeft = 0,
        width,
        height,
        wrapperX,
        wrapperY,
        textAlign,
        deferredAttr = {},
        strokeWidth,
        baselineOffset,
        hasBGImage = /^url\((.*?)\)$/.test(shape),
        needsBox = hasBGImage,
        getCrispAdjust,
        updateBoxSize,
        updateTextPadding,
        boxAttr;

    if (className) {
      wrapper.addClass('highcharts-' + className);
    }

    needsBox = true; // for styling

    getCrispAdjust = function () {
      return box.strokeWidth() % 2 / 2;
    };
    /*
     * This function runs after the label is added to the DOM (when the
     * bounding box is available), and after the text of the label is
     * updated to detect the new bounding box and reflect it in the border
     * box.
     */


    updateBoxSize = function () {
      var style = text.element.style,
          crispAdjust,
          attribs = {};
      bBox = (width === undefined || height === undefined || textAlign) && defined(text.textStr) && text.getBBox(); // #3295 && 3514 box failure when string equals 0

      wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
      wrapper.height = (height || bBox.height || 0) + 2 * padding; // Update the label-scoped y offset

      baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;

      if (needsBox) {
        // Create the border box if it is not already present
        if (!box) {
          // Symbol definition exists (#5324)
          wrapper.box = box = renderer.symbols[shape] || hasBGImage ? renderer.symbol(shape) : renderer.rect();
          box.addClass( // Don't use label className for buttons
          (className === 'button' ? '' : 'highcharts-label-box') + (className ? ' highcharts-' + className + '-box' : ''));
          box.add(wrapper);
          crispAdjust = getCrispAdjust();
          attribs.x = crispAdjust;
          attribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;
        } // Apply the box attributes


        attribs.width = Math.round(wrapper.width);
        attribs.height = Math.round(wrapper.height);
        box.attr(extend(attribs, deferredAttr));
        deferredAttr = {};
      }
    };
    /*
     * This function runs after setting text or padding, but only if padding
     * is changed.
     */


    updateTextPadding = function () {
      var textX = paddingLeft + padding,
          textY; // determin y based on the baseline

      textY = baseline ? 0 : baselineOffset; // compensate for alignment

      if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {
        textX += {
          center: 0.5,
          right: 1
        }[textAlign] * (width - bBox.width);
      } // update if anything changed


      if (textX !== text.x || textY !== text.y) {
        text.attr('x', textX); // #8159 - prevent misplaced data labels in treemap
        // (useHTML: true)

        if (text.hasBoxWidthChanged) {
          bBox = text.getBBox(true);
          updateBoxSize();
        }

        if (textY !== undefined) {
          text.attr('y', textY);
        }
      } // record current values


      text.x = textX;
      text.y = textY;
    };
    /*
     * Set a box attribute, or defer it if the box is not yet created
     */


    boxAttr = function (key, value) {
      if (box) {
        box.attr(key, value);
      } else {
        deferredAttr[key] = value;
      }
    };
    /*
     * After the text element is added, get the desired size of the border
     * box and add it before the text in the DOM.
     */


    wrapper.onAdd = function () {
      text.add(wrapper);
      wrapper.attr({
        // Alignment is available now  (#3295, 0 not rendered if given
        // as a value)
        text: str || str === 0 ? str : '',
        x: x,
        y: y
      });

      if (box && defined(anchorX)) {
        wrapper.attr({
          anchorX: anchorX,
          anchorY: anchorY
        });
      }
    };
    /*
     * Add specific attribute setters.
     */
    // only change local variables


    wrapper.widthSetter = function (value) {
      width = Highcharts.isNumber(value) ? value : null; // width:auto => null
    };

    wrapper.heightSetter = function (value) {
      height = value;
    };

    wrapper['text-alignSetter'] = function (value) {
      textAlign = value;
    };

    wrapper.paddingSetter = function (value) {
      if (defined(value) && value !== padding) {
        padding = wrapper.padding = value;
        updateTextPadding();
      }
    };

    wrapper.paddingLeftSetter = function (value) {
      if (defined(value) && value !== paddingLeft) {
        paddingLeft = value;
        updateTextPadding();
      }
    }; // change local variable and prevent setting attribute on the group


    wrapper.alignSetter = function (value) {
      value = {
        left: 0,
        center: 0.5,
        right: 1
      }[value];

      if (value !== alignFactor) {
        alignFactor = value; // Bounding box exists, means we're dynamically changing

        if (bBox) {
          wrapper.attr({
            x: wrapperX
          }); // #5134
        }
      }
    }; // apply these to the box and the text alike


    wrapper.textSetter = function (value) {
      if (value !== undefined) {
        text.textSetter(value);
      }

      updateBoxSize();
      updateTextPadding();
    }; // apply these to the box but not to the text


    wrapper['stroke-widthSetter'] = function (value, key) {
      if (value) {
        needsBox = true;
      }

      strokeWidth = this['stroke-width'] = value;
      boxAttr(key, value);
    };

    wrapper.rSetter = function (value, key) {
      boxAttr(key, value);
    };

    wrapper.anchorXSetter = function (value, key) {
      anchorX = wrapper.anchorX = value;
      boxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);
    };

    wrapper.anchorYSetter = function (value, key) {
      anchorY = wrapper.anchorY = value;
      boxAttr(key, value - wrapperY);
    }; // rename attributes


    wrapper.xSetter = function (value) {
      wrapper.x = value; // for animation getter

      if (alignFactor) {
        value -= alignFactor * ((width || bBox.width) + 2 * padding); // Force animation even when setting to the same value (#7898)

        wrapper['forceAnimate:x'] = true;
      }

      wrapperX = Math.round(value);
      wrapper.attr('translateX', wrapperX);
    };

    wrapper.ySetter = function (value) {
      wrapperY = wrapper.y = Math.round(value);
      wrapper.attr('translateY', wrapperY);
    }; // Redirect certain methods to either the box or the text


    var baseCss = wrapper.css;
    return extend(wrapper, {
      /*
       * Pick up some properties and apply them to the text instead of the
       * wrapper.
       */
      css: function (styles) {
        if (styles) {
          var textStyles = {}; // Create a copy to avoid altering the original object
          // (#537)

          styles = merge$1(styles);
          each$1(wrapper.textProps, function (prop) {
            if (styles[prop] !== undefined) {
              textStyles[prop] = styles[prop];
              delete styles[prop];
            }
          });
          text.css(textStyles);

          if ('width' in textStyles) {
            updateBoxSize();
          }
        }

        return baseCss.call(wrapper, styles);
      },

      /*
       * Return the bounding box of the box, not the group.
       */
      getBBox: function () {
        return {
          width: bBox.width + 2 * padding,
          height: bBox.height + 2 * padding,
          x: bBox.x - padding,
          y: bBox.y - padding
        };
      },

      /*
       * Destroy and release memory.
       */
      destroy: function () {
        // Added by button implementation
        removeEvent(wrapper.element, 'mouseenter');
        removeEvent(wrapper.element, 'mouseleave');

        if (text) {
          text = text.destroy();
        }

        if (box) {
          box = box.destroy();
        } // Call base implementation to destroy the rest


        SVGElement.prototype.destroy.call(wrapper); // Release local pointers (#1298)

        wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
      }
    });
  }
}); // end SVGRenderer
// general renderer

Highcharts.Renderer = SVGRenderer;

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var attr$1 = Highcharts.attr,
    createElement$1 = Highcharts.createElement,
    css$1 = Highcharts.css,
    defined$1 = Highcharts.defined,
    each$2 = Highcharts.each,
    extend$1 = Highcharts.extend,
    isFirefox$2 = Highcharts.isFirefox,
    isMS$2 = Highcharts.isMS,
    isWebKit$1 = Highcharts.isWebKit,
    pick$1 = Highcharts.pick,
    pInt$2 = Highcharts.pInt,
    SVGElement$1 = Highcharts.SVGElement,
    SVGRenderer$1 = Highcharts.SVGRenderer,
    win$3 = Highcharts.win,
    wrap$2 = Highcharts.wrap; // Extend SvgElement for useHTML option

extend$1(SVGElement$1.prototype,
/** @lends SVGElement.prototype */
{
  /**
   * Apply CSS to HTML elements. This is used in text within SVG rendering and
   * by the VML renderer
   */
  htmlCss: function (styles) {
    var wrapper = this,
        element = wrapper.element,
        // When setting or unsetting the width style, we need to update
    // transform (#8809)
    isSettingWidth = element.tagName === 'SPAN' && styles && 'width' in styles,
        textWidth = pick$1(isSettingWidth && styles.width, undefined);

    if (isSettingWidth) {
      delete styles.width;
      wrapper.textWidth = textWidth;
      wrapper.htmlUpdateTransform();
    }

    if (styles && styles.textOverflow === 'ellipsis') {
      styles.whiteSpace = 'nowrap';
      styles.overflow = 'hidden';
    }

    wrapper.styles = extend$1(wrapper.styles, styles);
    css$1(wrapper.element, styles);
    return wrapper;
  },

  /**
   * VML and useHTML method for calculating the bounding box based on offsets
   * @param {Boolean} refresh Whether to force a fresh value from the DOM or
   * to use the cached value.
   *
   * @return {Object} A hash containing values for x, y, width and height
   */
  htmlGetBBox: function () {
    var wrapper = this,
        element = wrapper.element;
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  },

  /**
   * VML override private method to update elements based on internal
   * properties based on SVG transform
   */
  htmlUpdateTransform: function () {
    // aligning non added elements is expensive
    if (!this.added) {
      this.alignOnAdd = true;
      return;
    }

    var wrapper = this,
        renderer = wrapper.renderer,
        elem = wrapper.element,
        translateX = wrapper.translateX || 0,
        translateY = wrapper.translateY || 0,
        x = wrapper.x || 0,
        y = wrapper.y || 0,
        align = wrapper.textAlign || 'left',
        alignCorrection = {
      left: 0,
      center: 0.5,
      right: 1
    }[align],
        styles = wrapper.styles,
        whiteSpace = styles && styles.whiteSpace;

    function getTextPxLength() {
      // Reset multiline/ellipsis in order to read width (#4928,
      // #5417)
      css$1(elem, {
        width: '',
        whiteSpace: whiteSpace || 'nowrap'
      });
      return elem.offsetWidth;
    } // apply translate


    css$1(elem, {
      marginLeft: translateX,
      marginTop: translateY
    }); // apply inversion

    if (wrapper.inverted) {
      // wrapper is a group
      each$2(elem.childNodes, function (child) {
        renderer.invertChild(child, elem);
      });
    }

    if (elem.tagName === 'SPAN') {
      var rotation = wrapper.rotation,
          baseline,
          textWidth = wrapper.textWidth && pInt$2(wrapper.textWidth),
          currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(','); // Update textWidth. Use the memoized textPxLength if possible, to
      // avoid the getTextPxLength function using elem.offsetWidth.
      // Calling offsetWidth affects rendering time as it forces layout
      // (#7656).

      if (textWidth !== wrapper.oldTextWidth && (textWidth > wrapper.oldTextWidth || (wrapper.textPxLength || getTextPxLength()) > textWidth) && /[ \-]/.test(elem.textContent || elem.innerText)) {
        // #983, #1254
        css$1(elem, {
          width: textWidth + 'px',
          display: 'block',
          whiteSpace: whiteSpace || 'normal' // #3331

        });
        wrapper.oldTextWidth = textWidth;
        wrapper.hasBoxWidthChanged = true; // #8159
      } else {
        wrapper.hasBoxWidthChanged = false; // #8159
      } // Do the calculations and DOM access only if properties changed


      if (currentTextTransform !== wrapper.cTT) {
        baseline = renderer.fontMetrics(elem.style.fontSize).b; // Renderer specific handling of span rotation, but only if we
        // have something to update.

        if (defined$1(rotation) && (rotation !== (wrapper.oldRotation || 0) || align !== wrapper.oldAlign)) {
          wrapper.setSpanRotation(rotation, alignCorrection, baseline);
        }

        wrapper.getSpanCorrection( // Avoid elem.offsetWidth if we can, it affects rendering
        // time heavily (#7656)
        !defined$1(rotation) && wrapper.textPxLength || // #7920
        elem.offsetWidth, baseline, alignCorrection, rotation, align);
      } // apply position with correction


      css$1(elem, {
        left: x + (wrapper.xCorr || 0) + 'px',
        top: y + (wrapper.yCorr || 0) + 'px'
      }); // record current text transform

      wrapper.cTT = currentTextTransform;
      wrapper.oldRotation = rotation;
      wrapper.oldAlign = align;
    }
  },

  /**
   * Set the rotation of an individual HTML span
   */
  setSpanRotation: function (rotation, alignCorrection, baseline) {
    var rotationStyle = {},
        cssTransformKey = this.renderer.getTransformKey();
    rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';
    rotationStyle[cssTransformKey + (isFirefox$2 ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = alignCorrection * 100 + '% ' + baseline + 'px';
    css$1(this.element, rotationStyle);
  },

  /**
   * Get the correction in X and Y positioning as the element is rotated.
   */
  getSpanCorrection: function (width, baseline, alignCorrection) {
    this.xCorr = -width * alignCorrection;
    this.yCorr = -baseline;
  }
}); // Extend SvgRenderer for useHTML option.

extend$1(SVGRenderer$1.prototype,
/** @lends SVGRenderer.prototype */
{
  getTransformKey: function () {
    return isMS$2 && !/Edge/.test(win$3.navigator.userAgent) ? '-ms-transform' : isWebKit$1 ? '-webkit-transform' : isFirefox$2 ? 'MozTransform' : win$3.opera ? '-o-transform' : '';
  },

  /**
   * Create HTML text node. This is used by the VML renderer as well as the
   * SVG renderer through the useHTML option.
   *
   * @param {String} str
   * @param {Number} x
   * @param {Number} y
   */
  html: function (str, x, y) {
    var wrapper = this.createElement('span'),
        element = wrapper.element,
        renderer = wrapper.renderer,
        isSVG = renderer.isSVG,
        addSetters = function (element, style) {
      // These properties are set as attributes on the SVG group, and
      // as identical CSS properties on the div. (#3542)
      each$2(['opacity', 'visibility'], function (prop) {
        wrap$2(element, prop + 'Setter', function (proceed, value, key, elem) {
          proceed.call(this, value, key, elem);
          style[key] = value;
        });
      });
      element.addedSetters = true;
    }; // Text setter


    wrapper.textSetter = function (value) {
      if (value !== element.innerHTML) {
        delete this.bBox;
      }

      this.textStr = value;
      element.innerHTML = pick$1(value, '');
      wrapper.doTransform = true;
    }; // Add setters for the element itself (#4938)


    if (isSVG) {
      // #4938, only for HTML within SVG
      addSetters(wrapper, wrapper.element.style);
    } // Various setters which rely on update transform


    wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {
      if (key === 'align') {
        // Do not overwrite the SVGElement.align method. Same as VML.
        key = 'textAlign';
      }

      wrapper[key] = value;
      wrapper.doTransform = true;
    }; // Runs at the end of .attr()


    wrapper.afterSetters = function () {
      // Update transform. Do this outside the loop to prevent redundant
      // updating for batch setting of attributes.
      if (this.doTransform) {
        this.htmlUpdateTransform();
        this.doTransform = false;
      }
    }; // Set the default attributes


    wrapper.attr({
      text: str,
      x: Math.round(x),
      y: Math.round(y)
    }).css({
      position: 'absolute'
    }); // Keep the whiteSpace style outside the wrapper.styles collection

    element.style.whiteSpace = 'nowrap'; // Use the HTML specific .css method

    wrapper.css = wrapper.htmlCss; // This is specific for HTML within SVG

    if (isSVG) {
      wrapper.add = function (svgGroupWrapper) {
        var htmlGroup,
            container = renderer.box.parentNode,
            parentGroup,
            parents = [];
        this.parentGroup = svgGroupWrapper; // Create a mock group to hold the HTML elements

        if (svgGroupWrapper) {
          htmlGroup = svgGroupWrapper.div;

          if (!htmlGroup) {
            // Read the parent chain into an array and read from top
            // down
            parentGroup = svgGroupWrapper;

            while (parentGroup) {
              parents.push(parentGroup); // Move up to the next parent group

              parentGroup = parentGroup.parentGroup;
            } // Ensure dynamically updating position when any parent
            // is translated


            each$2(parents.reverse(), function (parentGroup) {
              var htmlGroupStyle,
                  cls = attr$1(parentGroup.element, 'class'); // Common translate setter for X and Y on the HTML
              // group. Reverted the fix for #6957 du to
              // positioning problems and offline export (#7254,
              // #7280, #7529)

              function translateSetter(value, key) {
                parentGroup[key] = value;

                if (key === 'translateX') {
                  htmlGroupStyle.left = value + 'px';
                } else {
                  htmlGroupStyle.top = value + 'px';
                }

                parentGroup.doTransform = true;
              }

              if (cls) {
                cls = {
                  className: cls
                };
              } // else null
              // Create a HTML div and append it to the parent div
              // to emulate the SVG group structure


              htmlGroup = parentGroup.div = parentGroup.div || createElement$1('div', cls, {
                position: 'absolute',
                left: (parentGroup.translateX || 0) + 'px',
                top: (parentGroup.translateY || 0) + 'px',
                display: parentGroup.display,
                opacity: parentGroup.opacity,
                // #5075
                pointerEvents: parentGroup.styles && parentGroup.styles.pointerEvents // #5595
                // the top group is appended to container

              }, htmlGroup || container); // Shortcut

              htmlGroupStyle = htmlGroup.style; // Set listeners to update the HTML div's position
              // whenever the SVG group position is changed.

              extend$1(parentGroup, {
                // (#7287) Pass htmlGroup to use
                // the related group
                classSetter: function (htmlGroup) {
                  return function (value) {
                    this.element.setAttribute('class', value);
                    htmlGroup.className = value;
                  };
                }(htmlGroup),
                on: function () {
                  if (parents[0].div) {
                    // #6418
                    wrapper.on.apply({
                      element: parents[0].div
                    }, arguments);
                  }

                  return parentGroup;
                },
                translateXSetter: translateSetter,
                translateYSetter: translateSetter
              });

              if (!parentGroup.addedSetters) {
                addSetters(parentGroup, htmlGroupStyle);
              }
            });
          }
        } else {
          htmlGroup = container;
        }

        htmlGroup.appendChild(element); // Shared with VML:

        wrapper.added = true;

        if (wrapper.alignOnAdd) {
          wrapper.htmlUpdateTransform();
        }

        return wrapper;
      };
    }

    return wrapper;
  }
});

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var H = Highcharts,
    defined$2 = H.defined,
    each$3 = H.each,
    extend$2 = H.extend,
    merge$2 = H.merge,
    pick$2 = H.pick,
    timeUnits = H.timeUnits,
    win$4 = H.win;
/**
 * The Time class. Time settings are applied in general for each page using
 * `Highcharts.setOptions`, or individually for each Chart item through the
 * [time](https://api.highcharts.com/highcharts/time) options set.
 *
 * The Time object is available from
 * [Chart.time](http://api.highcharts.com/class-reference/Highcharts.Chart#.time),
 * which refers to  `Highcharts.time` if no individual time settings are
 * applied.
 *
 * @example
 * // Apply time settings globally
 * Highcharts.setOptions({
 *     time: {
 *         timezone: 'Europe/London'
 *     }
 * });
 *
 * // Apply time settings by instance
 * var chart = Highcharts.chart('container', {
 *     time: {
 *         timezone: 'America/New_York'
 *     },
 *     series: [{
 *         data: [1, 4, 3, 5]
 *     }]
 * });
 *
 * // Use the Time object
 * console.log(
 *        'Current time in New York',
 *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
 * );
 *
 * @class
 * @name Highcharts.Time
 *
 * @param {Highcharts.TimeOptions} options
 *        Time options as defined in [chart.options.time](/highcharts/time).
 *
 * @since 6.0.5
 */

Highcharts.Time = function (options) {
  this.update(options, false);
};

Highcharts.Time.prototype = {
  /**
   * Time options that can apply globally or to individual charts. These
   * settings affect how `datetime` axes are laid out, how tooltips are
   * formatted, how series
   * [pointIntervalUnit](#plotOptions.series.pointIntervalUnit) works and how
   * the Highstock range selector handles time.
   *
   * The common use case is that all charts in the same Highcharts object
   * share the same time settings, in which case the global settings are set
   * using `setOptions`.
   *
   * ```js
   * // Apply time settings globally
   * Highcharts.setOptions({
   *     time: {
   *         timezone: 'Europe/London'
   *     }
   * });
   * // Apply time settings by instance
   * var chart = Highcharts.chart('container', {
   *     time: {
   *         timezone: 'America/New_York'
   *     },
   *     series: [{
   *         data: [1, 4, 3, 5]
   *     }]
   * });
   *
   * // Use the Time object
   * console.log(
   *        'Current time in New York',
   *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
   * );
   * ```
   *
   * Since v6.0.5, the time options were moved from the `global` obect to the
   * `time` object, and time options can be set on each individual chart.
   *
   * @sample {highcharts|highstock}
   *         highcharts/time/timezone/
   *         Set the timezone globally
   * @sample {highcharts}
   *         highcharts/time/individual/
   *         Set the timezone per chart instance
   * @sample {highstock}
   *         stock/time/individual/
   *         Set the timezone per chart instance
   *
   * @since     6.0.5
   * @apioption time
   */

  /**
   * Whether to use UTC time for axis scaling, tickmark placement and
   * time display in `Highcharts.dateFormat`. Advantages of using UTC
   * is that the time displays equally regardless of the user agent's
   * time zone settings. Local time can be used when the data is loaded
   * in real time or when correct Daylight Saving Time transitions are
   * required.
   *
   * @sample {highcharts} highcharts/time/useutc-true/
   *         True by default
   * @sample {highcharts} highcharts/time/useutc-false/
   *         False
   *
   * @type      {boolean}
   * @default   true
   * @apioption time.useUTC
   */

  /**
   * A custom `Date` class for advanced date handling. For example,
   * [JDate](https://github.com/tahajahangir/jdate) can be hooked in to
   * handle Jalali dates.
   *
   * @type      {*}
   * @since     4.0.4
   * @product   highcharts highstock
   * @apioption time.Date
   */

  /**
   * A callback to return the time zone offset for a given datetime. It
   * takes the timestamp in terms of milliseconds since January 1 1970,
   * and returns the timezone offset in minutes. This provides a hook
   * for drawing time based charts in specific time zones using their
   * local DST crossover dates, with the help of external libraries.
   *
   * @see [global.timezoneOffset](#global.timezoneOffset)
   *
   * @sample {highcharts|highstock} highcharts/time/gettimezoneoffset/
   *         Use moment.js to draw Oslo time regardless of browser locale
   *
   * @type      {Function}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption time.getTimezoneOffset
   */

  /**
   * Requires [moment.js](http://momentjs.com/). If the timezone option
   * is specified, it creates a default
   * [getTimezoneOffset](#time.getTimezoneOffset) function that looks
   * up the specified timezone in moment.js. If moment.js is not included,
   * this throws a Highcharts error in the console, but does not crash the
   * chart.
   *
   * @see [getTimezoneOffset](#time.getTimezoneOffset)
   *
   * @sample {highcharts|highstock} highcharts/time/timezone/
   *         Europe/Oslo
   *
   * @type      {string}
   * @since     5.0.7
   * @product   highcharts highstock
   * @apioption time.timezone
   */

  /**
   * The timezone offset in minutes. Positive values are west, negative
   * values are east of UTC, as in the ECMAScript
   * [getTimezoneOffset](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)
   * method. Use this to display UTC based data in a predefined time zone.
   *
   * @see [time.getTimezoneOffset](#time.getTimezoneOffset)
   *
   * @sample {highcharts|highstock} highcharts/time/timezoneoffset/
   *         Timezone offset
   *
   * @type      {number}
   * @default   0
   * @since     3.0.8
   * @product   highcharts highstock
   * @apioption time.timezoneOffset
   */
  defaultOptions: {},

  /**
   * Update the Time object with current options. It is called internally on
   * initiating Highcharts, after running `Highcharts.setOptions` and on
   * `Chart.update`.
   *
   * @private
   * @function Highcharts.Time#update
   *
   * @param {Highcharts.TimeOptions} options
   */
  update: function (options) {
    var useUTC = pick$2(options && options.useUTC, true),
        time = this;
    this.options = options = merge$2(true, this.options || {}, options); // Allow using a different Date class

    this.Date = options.Date || win$4.Date;
    this.useUTC = useUTC;
    this.timezoneOffset = useUTC && options.timezoneOffset;
    /**
     * Get the time zone offset based on the current timezone information as
     * set in the global options.
     *
     * @function Highcharts.Time#getTimezoneOffset
     *
     * @param {number} timestamp
     *        The JavaScript timestamp to inspect.
     *
     * @return {number}
     *         The timezone offset in minutes compared to UTC.
     */

    this.getTimezoneOffset = this.timezoneOffsetFunction();
    /*
     * The time object has options allowing for variable time zones, meaning
     * the axis ticks or series data needs to consider this.
     */

    this.variableTimezone = !!(!useUTC || options.getTimezoneOffset || options.timezone); // UTC time with timezone handling

    if (this.variableTimezone || this.timezoneOffset) {
      this.get = function (unit, date) {
        var realMs = date.getTime(),
            ms = realMs - time.getTimezoneOffset(date),
            ret;
        date.setTime(ms); // Temporary adjust to timezone

        ret = date['getUTC' + unit]();
        date.setTime(realMs); // Reset

        return ret;
      };

      this.set = function (unit, date, value) {
        var ms, offset, newOffset; // For lower order time units, just set it directly using local
        // time

        if (unit === 'Milliseconds' || unit === 'Seconds' || // If we're dealting with minutes, we only need to
        // consider timezone if we're in Indian time zones with
        // half-hour offsets (#8768).
        unit === 'Minutes' && date.getTimezoneOffset() % 60 === 0) {
          date['set' + unit](value); // Higher order time units need to take the time zone into
          // account
        } else {
          // Adjust by timezone
          offset = time.getTimezoneOffset(date);
          ms = date.getTime() - offset;
          date.setTime(ms);
          date['setUTC' + unit](value);
          newOffset = time.getTimezoneOffset(date);
          ms = date.getTime() + newOffset;
          date.setTime(ms);
        }
      }; // UTC time with no timezone handling

    } else if (useUTC) {
      this.get = function (unit, date) {
        return date['getUTC' + unit]();
      };

      this.set = function (unit, date, value) {
        return date['setUTC' + unit](value);
      }; // Local time

    } else {
      this.get = function (unit, date) {
        return date['get' + unit]();
      };

      this.set = function (unit, date, value) {
        return date['set' + unit](value);
      };
    }
  },

  /**
   * Make a time and returns milliseconds. Interprets the inputs as UTC time,
   * local time or a specific timezone time depending on the current time
   * settings.
   *
   * @function Highcharts.Time#makeTime
   *
   * @param {number} year
   *        The year
   *
   * @param {number} month
   *        The month. Zero-based, so January is 0.
   *
   * @param {number} [date=1]
   *        The day of the month
   *
   * @param {number} [hours=0]
   *        The hour of the day, 0-23.
   *
   * @param {number} [minutes=0]
   *        The minutes
   *
   * @param {number} [seconds=0]
   *        The seconds
   *
   * @return {number}
   *         The time in milliseconds since January 1st 1970.
   */
  makeTime: function (year, month, date, hours, minutes, seconds) {
    var d, offset, newOffset;

    if (this.useUTC) {
      d = this.Date.UTC.apply(0, arguments);
      offset = this.getTimezoneOffset(d);
      d += offset;
      newOffset = this.getTimezoneOffset(d);

      if (offset !== newOffset) {
        d += newOffset - offset; // A special case for transitioning from summer time to winter time.
        // When the clock is set back, the same time is repeated twice, i.e.
        // 02:30 am is repeated since the clock is set back from 3 am to
        // 2 am. We need to make the same time as local Date does.
      } else if (offset - 36e5 === this.getTimezoneOffset(d - 36e5) && !H.isSafari) {
        d -= 36e5;
      }
    } else {
      d = new this.Date(year, month, pick$2(date, 1), pick$2(hours, 0), pick$2(minutes, 0), pick$2(seconds, 0)).getTime();
    }

    return d;
  },

  /**
   * Sets the getTimezoneOffset function. If the `timezone` option is set, a
   * default getTimezoneOffset function with that timezone is returned. If
   * a `getTimezoneOffset` option is defined, it is returned. If neither are
   * specified, the function using the `timezoneOffset` option or 0 offset is
   * returned.
   *
   * @private
   * @function Highcharts.Time#timezoneOffsetFunction
   *
   * @return {Function}
   *         A getTimezoneOffset function
   */
  timezoneOffsetFunction: function () {
    var time = this,
        options = this.options,
        moment = win$4.moment;

    if (!this.useUTC) {
      return function (timestamp) {
        return new Date(timestamp).getTimezoneOffset() * 60000;
      };
    }

    if (options.timezone) {
      if (!moment) {
        // getTimezoneOffset-function stays undefined because it depends
        // on Moment.js
        H.error(25);
      } else {
        return function (timestamp) {
          return -moment.tz(timestamp, options.timezone).utcOffset() * 60000;
        };
      }
    } // If not timezone is set, look for the getTimezoneOffset callback


    if (this.useUTC && options.getTimezoneOffset) {
      return function (timestamp) {
        return options.getTimezoneOffset(timestamp) * 60000;
      };
    } // Last, use the `timezoneOffset` option if set


    return function () {
      return (time.timezoneOffset || 0) * 60000;
    };
  },

  /**
   * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970)
   * into a human readable date string. The format is a subset of the formats
   * for PHP's [strftime](http://www.php.net/manual/en/function.strftime.php)
   * function. Additional formats can be given in the
   * {@link Highcharts.dateFormats} hook.
   *
   * @function Highcharts.Time#dateFormat
   *
   * @param {string} [format]
   *        The desired format where various time representations are
   *        prefixed with %.
   *
   * @param {number} timestamp
   *        The JavaScript timestamp.
   *
   * @param {boolean} [capitalize=false]
   *        Upper case first letter in the return.
   *
   * @return {string}
   *         The formatted date.
   */
  dateFormat: function (format, timestamp, capitalize) {
    if (!H.defined(timestamp) || isNaN(timestamp)) {
      return H.defaultOptions.lang.invalidDate || '';
    }

    format = H.pick(format, '%Y-%m-%d %H:%M:%S');
    var time = this,
        date = new this.Date(timestamp),
        // get the basic time values
    hours = this.get('Hours', date),
        day = this.get('Day', date),
        dayOfMonth = this.get('Date', date),
        month = this.get('Month', date),
        fullYear = this.get('FullYear', date),
        lang = H.defaultOptions.lang,
        langWeekdays = lang.weekdays,
        shortWeekdays = lang.shortWeekdays,
        pad = H.pad,
        // List all format keys. Custom formats can be added from the
    // outside.
    replacements = H.extend({
      // Day
      // Short weekday, like 'Mon'
      'a': shortWeekdays ? shortWeekdays[day] : langWeekdays[day].substr(0, 3),
      // Long weekday, like 'Monday'
      'A': langWeekdays[day],
      // Two digit day of the month, 01 to 31
      'd': pad(dayOfMonth),
      // Day of the month, 1 through 31
      'e': pad(dayOfMonth, 2, ' '),
      'w': day,
      // Week (none implemented)
      // 'W': weekNumber(),
      // Month
      // Short month, like 'Jan'
      'b': lang.shortMonths[month],
      // Long month, like 'January'
      'B': lang.months[month],
      // Two digit month number, 01 through 12
      'm': pad(month + 1),
      // Month number, 1 through 12 (#8150)
      'o': month + 1,
      // Year
      // Two digits year, like 09 for 2009
      'y': fullYear.toString().substr(2, 2),
      // Four digits year, like 2009
      'Y': fullYear,
      // Time
      // Two digits hours in 24h format, 00 through 23
      'H': pad(hours),
      // Hours in 24h format, 0 through 23
      'k': hours,
      // Two digits hours in 12h format, 00 through 11
      'I': pad(hours % 12 || 12),
      // Hours in 12h format, 1 through 12
      'l': hours % 12 || 12,
      // Two digits minutes, 00 through 59
      'M': pad(time.get('Minutes', date)),
      // Upper case AM or PM
      'p': hours < 12 ? 'AM' : 'PM',
      // Lower case AM or PM
      'P': hours < 12 ? 'am' : 'pm',
      // Two digits seconds, 00 through  59
      'S': pad(date.getSeconds()),
      // Milliseconds (naming from Ruby)
      'L': pad(Math.floor(timestamp % 1000), 3)
    },
    /**
     * A hook for defining additional date format specifiers. New
     * specifiers are defined as key-value pairs by using the
     * specifier as key, and a function which takes the timestamp as
     * value. This function returns the formatted portion of the
     * date.
     *
     * @sample highcharts/global/dateformats/
     *         Adding support for week number
     *
     * @name Highcharts.dateFormats
     * @type {Highcharts.Dictionary<Function>}
     */
    H.dateFormats); // Do the replaces

    H.objectEach(replacements, function (val, key) {
      // Regex would do it in one line, but this is faster
      while (format.indexOf('%' + key) !== -1) {
        format = format.replace('%' + key, typeof val === 'function' ? val.call(time, timestamp) : val);
      }
    }); // Optionally capitalize the string and return

    return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
  },

  /**
   * Return an array with time positions distributed on round time values
   * right and right after min and max. Used in datetime axes as well as for
   * grouping data on a datetime axis.
   *
   * @function Highcharts.Time#getTimeTicks
   *
   * @param {Highcharts.NormalizedIntervalObject} normalizedInterval
   *        The interval in axis values (ms) and the count
   *
   * @param {number} [min]
   *        The minimum in axis values
   *
   * @param {number} [max]
   *        The maximum in axis values
   *
   * @param {number} [startOfWeek=1]
   *
   * @return {Highcharts.TimeTicksObject}
   */
  getTimeTicks: function (normalizedInterval, min, max, startOfWeek) {
    var time = this,
        Date = time.Date,
        tickPositions = [],
        i,
        higherRanks = {},
        minYear,
        // used in months and years as a basis for Date.UTC()
    // When crossing DST, use the max. Resolves #6278.
    minDate = new Date(min),
        interval = normalizedInterval.unitRange,
        count = normalizedInterval.count || 1,
        variableDayLength,
        minDay;
    startOfWeek = pick$2(startOfWeek, 1);

    if (defined$2(min)) {
      // #1300
      time.set('Milliseconds', minDate, interval >= timeUnits.second ? 0 : // #3935
      count * Math.floor(time.get('Milliseconds', minDate) / count)); // #3652, #3654

      if (interval >= timeUnits.second) {
        // second
        time.set('Seconds', minDate, interval >= timeUnits.minute ? 0 : // #3935
        count * Math.floor(time.get('Seconds', minDate) / count));
      }

      if (interval >= timeUnits.minute) {
        // minute
        time.set('Minutes', minDate, interval >= timeUnits.hour ? 0 : count * Math.floor(time.get('Minutes', minDate) / count));
      }

      if (interval >= timeUnits.hour) {
        // hour
        time.set('Hours', minDate, interval >= timeUnits.day ? 0 : count * Math.floor(time.get('Hours', minDate) / count));
      }

      if (interval >= timeUnits.day) {
        // day
        time.set('Date', minDate, interval >= timeUnits.month ? 1 : count * Math.floor(time.get('Date', minDate) / count));
      }

      if (interval >= timeUnits.month) {
        // month
        time.set('Month', minDate, interval >= timeUnits.year ? 0 : count * Math.floor(time.get('Month', minDate) / count));
        minYear = time.get('FullYear', minDate);
      }

      if (interval >= timeUnits.year) {
        // year
        minYear -= minYear % count;
        time.set('FullYear', minDate, minYear);
      } // week is a special case that runs outside the hierarchy


      if (interval === timeUnits.week) {
        // get start of current week, independent of count
        minDay = time.get('Day', minDate);
        time.set('Date', minDate, time.get('Date', minDate) - minDay + startOfWeek + ( // We don't want to skip days that are before
        // startOfWeek (#7051)
        minDay < startOfWeek ? -7 : 0));
      } // Get basics for variable time spans


      minYear = time.get('FullYear', minDate);
      var minMonth = time.get('Month', minDate),
          minDateDate = time.get('Date', minDate),
          minHours = time.get('Hours', minDate); // Redefine min to the floored/rounded minimum time (#7432)

      min = minDate.getTime(); // Handle local timezone offset

      if (time.variableTimezone) {
        // Detect whether we need to take the DST crossover into
        // consideration. If we're crossing over DST, the day length may
        // be 23h or 25h and we need to compute the exact clock time for
        // each tick instead of just adding hours. This comes at a cost,
        // so first we find out if it is needed (#4951).
        variableDayLength = // Long range, assume we're crossing over.
        max - min > 4 * timeUnits.month || // Short range, check if min and max are in different time
        // zones.
        time.getTimezoneOffset(min) !== time.getTimezoneOffset(max);
      } // Iterate and add tick positions at appropriate values


      var t = minDate.getTime();
      i = 1;

      while (t < max) {
        tickPositions.push(t); // if the interval is years, use Date.UTC to increase years

        if (interval === timeUnits.year) {
          t = time.makeTime(minYear + i * count, 0); // if the interval is months, use Date.UTC to increase months
        } else if (interval === timeUnits.month) {
          t = time.makeTime(minYear, minMonth + i * count); // if we're using global time, the interval is not fixed as it
          // jumps one hour at the DST crossover
        } else if (variableDayLength && (interval === timeUnits.day || interval === timeUnits.week)) {
          t = time.makeTime(minYear, minMonth, minDateDate + i * count * (interval === timeUnits.day ? 1 : 7));
        } else if (variableDayLength && interval === timeUnits.hour && count > 1) {
          // make sure higher ranks are preserved across DST (#6797,
          // #7621)
          t = time.makeTime(minYear, minMonth, minDateDate, minHours + i * count); // else, the interval is fixed and we use simple addition
        } else {
          t += interval * count;
        }

        i++;
      } // push the last time


      tickPositions.push(t); // Handle higher ranks. Mark new days if the time is on midnight
      // (#950, #1649, #1760, #3349). Use a reasonable dropout threshold
      // to prevent looping over dense data grouping (#6156).

      if (interval <= timeUnits.hour && tickPositions.length < 10000) {
        each$3(tickPositions, function (t) {
          if ( // Speed optimization, no need to run dateFormat unless
          // we're on a full or half hour
          t % 1800000 === 0 && // Check for local or global midnight
          time.dateFormat('%H%M%S%L', t) === '000000000') {
            higherRanks[t] = 'day';
          }
        });
      }
    } // record information on the chosen unit - for dynamic label formatter


    tickPositions.info = extend$2(normalizedInterval, {
      higherRanks: higherRanks,
      totalRange: interval * count
    });
    return tickPositions;
  }
}; // end of Time

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var color$1 = Highcharts.color,
    isTouchDevice = Highcharts.isTouchDevice,
    merge$3 = Highcharts.merge,
    svg$2 = Highcharts.svg;
/* ****************************************************************************
 * Handle the options                                                         *
 *****************************************************************************/

/**
 * Global default settings.
 *
 * @name Highcharts.defaultOptions
 * @type {Highcharts.Options}
 */

/**
* @optionparent
*/

Highcharts.defaultOptions = {
  /**
   * Styled mode only. Configuration object for adding SVG definitions for
   * reusable elements. See [gradients, shadows and
   * patterns](https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns)
   * for more information and code examples.
   *
   * @type      {*}
   * @since     5.0.0
   * @apioption defs
   */

  /**
   * @ignore-option
   */
  symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],

  /**
   * The language object is global and it can't be set on each chart
   * initiation. Instead, use `Highcharts.setOptions` to set it before any
   * chart is initialized.
   *
   * <pre>Highcharts.setOptions({
   *     lang: {
   *         months: [
   *             'Janvier', 'Février', 'Mars', 'Avril',
   *             'Mai', 'Juin', 'Juillet', 'Août',
   *             'Septembre', 'Octobre', 'Novembre', 'Décembre'
   *         ],
   *         weekdays: [
   *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',
   *             'Jeudi', 'Vendredi', 'Samedi'
   *         ]
   *     }
   * });</pre>
   */
  lang: {
    /**
     * The loading text that appears when the chart is set into the loading
     * state following a call to `chart.showLoading`.
     */
    loading: 'Loading...',

    /**
     * An array containing the months names. Corresponds to the `%B` format
     * in `Highcharts.dateFormat()`.
     *
     * @type    {Array<string>}
     * @default ["January", "February", "March", "April", "May", "June",
     *          "July", "August", "September", "October", "November",
     *          "December"]
     */
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],

    /**
     * An array containing the months names in abbreviated form. Corresponds
     * to the `%b` format in `Highcharts.dateFormat()`.
     *
     * @type    {Array<string>}
     * @default ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
     *          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
     */
    shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],

    /**
     * An array containing the weekday names.
     *
     * @type    {Array<string>}
     * @default ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
     *          "Friday", "Saturday"]
     */
    weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],

    /**
     * Short week days, starting Sunday. If not specified, Highcharts uses
     * the first three letters of the `lang.weekdays` option.
     *
     * @sample highcharts/lang/shortweekdays/
     *         Finnish two-letter abbreviations
     *
     * @type      {Array<string>}
     * @since     4.2.4
     * @apioption lang.shortWeekdays
     */

    /**
     * What to show in a date field for invalid dates. Defaults to an empty
     * string.
     *
     * @type      {string}
     * @since     4.1.8
     * @product   highcharts highstock
     * @apioption lang.invalidDate
     */

    /**
     * The title appearing on hovering the zoom in button. The text itself
     * defaults to "+" and can be changed in the button options.
     *
     * @type      {string}
     * @default   Zoom in
     * @product   highmaps
     * @apioption lang.zoomIn
     */

    /**
     * The title appearing on hovering the zoom out button. The text itself
     * defaults to "-" and can be changed in the button options.
     *
     * @type      {string}
     * @default   Zoom out
     * @product   highmaps
     * @apioption lang.zoomOut
     */

    /**
     * The default decimal point used in the `Highcharts.numberFormat`
     * method unless otherwise specified in the function arguments.
     *
     * @since 1.2.2
     */
    decimalPoint: '.',

    /**
     * [Metric prefixes](http://en.wikipedia.org/wiki/Metric_prefix) used
     * to shorten high numbers in axis labels. Replacing any of the
     * positions with `null` causes the full number to be written. Setting
     * `numericSymbols` to `null` disables shortening altogether.
     *
     * @sample {highcharts} highcharts/lang/numericsymbols/
     *         Replacing the symbols with text
     * @sample {highstock} highcharts/lang/numericsymbols/
     *         Replacing the symbols with text
     *
     * @type    {Array<string>}
     * @default ["k", "M", "G", "T", "P", "E"]
     * @since   2.3.0
     */
    numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'],

    /**
     * The magnitude of [numericSymbols](#lang.numericSymbol) replacements.
     * Use 10000 for Japanese, Korean and various Chinese locales, which
     * use symbols for 10^4, 10^8 and 10^12.
     *
     * @sample highcharts/lang/numericsymbolmagnitude/
     *         10000 magnitude for Japanese
     *
     * @type      {number}
     * @default   1000
     * @since     5.0.3
     * @apioption lang.numericSymbolMagnitude
     */

    /**
     * The text for the label appearing when a chart is zoomed.
     *
     * @since 1.2.4
     */
    resetZoom: 'Reset zoom',

    /**
     * The tooltip title for the label appearing when a chart is zoomed.
     *
     * @since 1.2.4
     */
    resetZoomTitle: 'Reset zoom level 1:1',

    /**
     * The default thousands separator used in the `Highcharts.numberFormat`
     * method unless otherwise specified in the function arguments. Since
     * Highcharts 4.1 it defaults to a single space character, which is
     * compatible with ISO and works across Anglo-American and continental
     * European languages.
     *
     * The default is a single space.
     *
     * @default \u0020
     * @since   1.2.2
     */
    thousandsSep: ' '
  },

  /**
   * Global options that don't apply to each chart. These options, like
   * the `lang` options, must be set using the `Highcharts.setOptions`
   * method.
   *
   * <pre>Highcharts.setOptions({
   *     global: {
   *         useUTC: false
   *     }
   * });</pre>
   *
   */

  /**
   * _Canvg rendering for Android 2.x is removed as of Highcharts 5.0\.
   * Use the [libURL](#exporting.libURL) option to configure exporting._
   *
   * The URL to the additional file to lazy load for Android 2.x devices.
   * These devices don't support SVG, so we download a helper file that
   * contains [canvg](http://code.google.com/p/canvg/), its dependency
   * rbcolor, and our own CanVG Renderer class. To avoid hotlinking to
   * our site, you can install canvas-tools.js on your own server and
   * change this option accordingly.
   *
   * @deprecated
   *
   * @type      {string}
   * @default   http://code.highcharts.com/{version}/modules/canvas-tools.js
   * @product   highcharts highmaps
   * @apioption global.canvasToolsURL
   */

  /**
   * This option is deprecated since v6.0.5. Instead, use
   * [time.useUTC](#time.useUTC) that supports individual time settings
   * per chart.
   *
   * @deprecated
   *
   * @type      {boolean}
   * @apioption global.useUTC
   */

  /**
   * This option is deprecated since v6.0.5. Instead, use
   * [time.Date](#time.Date) that supports individual time settings
   * per chart.
   *
   * @deprecated
   *
   * @type      {Function}
   * @product   highcharts highstock
   * @apioption global.Date
   */

  /**
   * This option is deprecated since v6.0.5. Instead, use
   * [time.getTimezoneOffset](#time.getTimezoneOffset) that supports
   * individual time settings per chart.
   *
   * @deprecated
   *
   * @type      {Function}
   * @product   highcharts highstock
   * @apioption global.getTimezoneOffset
   */

  /**
   * This option is deprecated since v6.0.5. Instead, use
   * [time.timezone](#time.timezone) that supports individual time
   * settings per chart.
   *
   * @deprecated
   *
   * @type      {string}
   * @product   highcharts highstock
   * @apioption global.timezone
   */

  /**
   * This option is deprecated since v6.0.5. Instead, use
   * [time.timezoneOffset](#time.timezoneOffset) that supports individual
   * time settings per chart.
   *
   * @deprecated
   *
   * @type      {number}
   * @product   highcharts highstock
   * @apioption global.timezoneOffset
   */
  global: {},
  time: Highcharts.Time.prototype.defaultOptions,

  /**
   * General options for the chart.
   */
  chart: {
    /**
     * Default `mapData` for all series. If set to a string, it functions
     * as an index into the `Highcharts.maps` array. Otherwise it is
     * interpreted s map data.
     *
     * @see [mapData](#series.map.mapData)
     *
     * @type      {string|Array<*>}
     * @since     5.0.0
     * @product   highmaps
     * @apioption chart.map
     */

    /**
     * Set lat/lon transformation definitions for the chart. If not defined,
     * these are extracted from the map data.
     *
     * @type      {*}
     * @since     5.0.0
     * @product   highmaps
     * @apioption chart.mapTransforms
     */

    /**
     * When using multiple axis, the ticks of two or more opposite axes
     * will automatically be aligned by adding ticks to the axis or axes
     * with the least ticks, as if `tickAmount` were specified.
     *
     * This can be prevented by setting `alignTicks` to false. If the grid
     * lines look messy, it's a good idea to hide them for the secondary
     * axis by setting `gridLineWidth` to 0.
     *
     * If `startOnTick` or `endOnTick` in an Axis options are set to false,
     * then the `alignTicks ` will be disabled for the Axis.
     *
     * Disabled for logarithmic axes.
     *
     * @sample {highcharts} highcharts/chart/alignticks-true/
     *         True by default
     * @sample {highcharts} highcharts/chart/alignticks-false/
     *         False
     * @sample {highstock} stock/chart/alignticks-true/
     *         True by default
     * @sample {highstock} stock/chart/alignticks-false/
     *         False
     *
     * @type      {boolean}
     * @default   true
     * @product   highcharts highstock
     * @apioption chart.alignTicks
     */

    /**
     * Set the overall animation for all chart updating. Animation can be
     * disabled throughout the chart by setting it to false here. It can
     * be overridden for each individual API method as a function parameter.
     * The only animation not affected by this option is the initial series
     * animation, see [plotOptions.series.animation](
     * #plotOptions.series.animation).
     *
     * The animation can either be set as a boolean or a configuration
     * object. If `true`, it will use the 'swing' jQuery easing and a
     * duration of 500 ms. If used as a configuration object, the following
     * properties are supported:
     *
     * <dl>
     *
     * <dt>duration</dt>
     *
     * <dd>The duration of the animation in milliseconds.</dd>
     *
     * <dt>easing</dt>
     *
     * <dd>A string reference to an easing function set on the `Math`
     * object. See [the easing
     * demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-animation-easing/).
     * </dd>
     *
     * </dl>
     *
     * @sample {highcharts} highcharts/chart/animation-none/
     *         Updating with no animation
     * @sample {highcharts} highcharts/chart/animation-duration/
     *         With a longer duration
     * @sample {highcharts} highcharts/chart/animation-easing/
     *         With a jQuery UI easing
     * @sample {highmaps} maps/chart/animation-none/
     *         Updating with no animation
     * @sample {highmaps} maps/chart/animation-duration/
     *         With a longer duration
     *
     * @type      {boolean|Highcharts.AnimationOptionsObject}
     * @default   true
     * @apioption chart.animation
     */

    /**
     * A CSS class name to apply to the charts container `div`, allowing
     * unique CSS styling for each chart.
     *
     * @type      {string}
     * @apioption chart.className
     */

    /**
     * Event listeners for the chart.
     *
     * @apioption chart.events
     */

    /**
     * Fires when a series is added to the chart after load time, using
     * the `addSeries` method. One parameter, `event`, is passed to the
     * function, containing common event information.
     * Through `event.options` you can access the series options that was
     * passed to the `addSeries` method. Returning false prevents the series
     * from being added.
     *
     * @sample {highcharts} highcharts/chart/events-addseries/
     *         Alert on add series
     * @sample {highstock} stock/chart/events-addseries/
     *         Alert on add series
     *
     * @type      {Function}
     * @since     1.2.0
     * @context   Highcharts.Chart
     * @apioption chart.events.addSeries
     */

    /**
     * Fires when clicking on the plot background. One parameter, `event`,
     * is passed to the function, containing common event information.
     *
     * Information on the clicked spot can be found through `event.xAxis`
     * and `event.yAxis`, which are arrays containing the axes of each
     * dimension and each axis' value at the clicked spot. The primary axes
     * are `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
     * datetime axis is milliseconds since 1970-01-01 00:00:00.
     *
     * <pre>click: function(e) {
     *     console.log(
     *         Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', e.xAxis[0].value),
     *         e.yAxis[0].value
     *     )
     * }</pre>
     *
     * @sample {highcharts} highcharts/chart/events-click/
     *         Alert coordinates on click
     * @sample {highcharts} highcharts/chart/events-container/
     *         Alternatively, attach event to container
     * @sample {highstock} stock/chart/events-click/
     *         Alert coordinates on click
     * @sample {highstock} highcharts/chart/events-container/
     *         Alternatively, attach event to container
     * @sample {highmaps} maps/chart/events-click/
     *         Record coordinates on click
     * @sample {highmaps} highcharts/chart/events-container/
     *         Alternatively, attach event to container
     *
     * @type      {Function}
     * @since     1.2.0
     * @context   Highcharts.Chart
     * @apioption chart.events.click
     */

    /**
     * Fires when the chart is finished loading. Since v4.2.2, it also waits
     * for images to be loaded, for example from point markers. One
     * parameter, `event`, is passed to the function, containing common
     * event information.
     *
     * There is also a second parameter to the chart constructor where a
     * callback function can be passed to be executed on chart.load.
     *
     * @sample {highcharts} highcharts/chart/events-load/
     *         Alert on chart load
     * @sample {highstock} stock/chart/events-load/
     *         Alert on chart load
     * @sample {highmaps} maps/chart/events-load/
     *         Add series on chart load
     *
     * @type      {Function}
     * @context   Highcharts.Chart
     * @apioption chart.events.load
     */

    /**
     * Fires when the chart is redrawn, either after a call to
     * `chart.redraw()` or after an axis, series or point is modified with
     * the `redraw` option set to true. One parameter, `event`, is passed to
     * the function, containing common event information.
     *
     * @sample {highcharts} highcharts/chart/events-redraw/
     *         Alert on chart redraw
     * @sample {highstock} stock/chart/events-redraw/
     *         Alert on chart redraw when adding a series or moving the
     *         zoomed range
     * @sample {highmaps} maps/chart/events-redraw/
     *         Set subtitle on chart redraw
     *
     * @type      {Function}
     * @since     1.2.0
     * @context   Highcharts.Chart
     * @apioption chart.events.redraw
     */

    /**
     * Fires after initial load of the chart (directly after the `load`
     * event), and after each redraw (directly after the `redraw` event).
     *
     * @type      {Function}
     * @since     5.0.7
     * @context   Highcharts.Chart
     * @apioption chart.events.render
     */

    /**
     * Fires when an area of the chart has been selected. Selection is
     * enabled by setting the chart's zoomType. One parameter, `event`, is
     * passed to the function, containing common event information. The
     * default action for the selection event is to zoom the chart to the
     * selected area. It can be prevented by calling
     * `event.preventDefault()`.
     *
     * Information on the selected area can be found through `event.xAxis`
     * and `event.yAxis`, which are arrays containing the axes of each
     * dimension and each axis' min and max values. The primary axes are
     * `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
     * datetime axis is milliseconds since 1970-01-01 00:00:00.
     *
     * <pre>selection: function(event) {
     *     // log the min and max of the primary, datetime x-axis
     *     console.log(
     *         Highcharts.dateFormat(
     *             '%Y-%m-%d %H:%M:%S',
     *             event.xAxis[0].min
     *         ),
     *         Highcharts.dateFormat(
     *             '%Y-%m-%d %H:%M:%S',
     *             event.xAxis[0].max
     *         )
     *     );
     *     // log the min and max of the y axis
     *     console.log(event.yAxis[0].min, event.yAxis[0].max);
     * }</pre>
     *
     * @sample {highcharts} highcharts/chart/events-selection/
     *         Report on selection and reset
     * @sample {highcharts} highcharts/chart/events-selection-points/
     *         Select a range of points through a drag selection
     * @sample {highstock} stock/chart/events-selection/
     *         Report on selection and reset
     * @sample {highstock} highcharts/chart/events-selection-points/
     *         Select a range of points through a drag selection
     *         (Highcharts)
     *
     * @type      {Function}
     * @apioption chart.events.selection
     */

    /**
     * The margin between the outer edge of the chart and the plot area.
     * The numbers in the array designate top, right, bottom and left
     * respectively. Use the options `marginTop`, `marginRight`,
     * `marginBottom` and `marginLeft` for shorthand setting of one option.
     *
     * By default there is no margin. The actual space is dynamically
     * calculated from the offset of axis labels, axis title, title,
     * subtitle and legend in addition to the `spacingTop`, `spacingRight`,
     * `spacingBottom` and `spacingLeft` options.
     *
     * @sample {highcharts} highcharts/chart/margins-zero/
     *         Zero margins
     * @sample {highstock} stock/chart/margin-zero/
     *         Zero margins
     *
     * @type      {number|Array<number>}
     * @apioption chart.margin
     */

    /**
     * The margin between the bottom outer edge of the chart and the plot
     * area. Use this to set a fixed pixel value for the margin as opposed
     * to the default dynamic margin. See also `spacingBottom`.
     *
     * @sample {highcharts} highcharts/chart/marginbottom/
     *         100px bottom margin
     * @sample {highstock} stock/chart/marginbottom/
     *         100px bottom margin
     * @sample {highmaps} maps/chart/margin/
     *         100px margins
     *
     * @type      {number}
     * @since     2.0
     * @apioption chart.marginBottom
     */

    /**
     * The margin between the left outer edge of the chart and the plot
     * area. Use this to set a fixed pixel value for the margin as opposed
     * to the default dynamic margin. See also `spacingLeft`.
     *
     * @sample {highcharts} highcharts/chart/marginleft/
     *         150px left margin
     * @sample {highstock} stock/chart/marginleft/
     *         150px left margin
     * @sample {highmaps} maps/chart/margin/
     *         100px margins
     *
     * @type      {number}
     * @since     2.0
     * @apioption chart.marginLeft
     */

    /**
     * The margin between the right outer edge of the chart and the plot
     * area. Use this to set a fixed pixel value for the margin as opposed
     * to the default dynamic margin. See also `spacingRight`.
     *
     * @sample {highcharts} highcharts/chart/marginright/
     *         100px right margin
     * @sample {highstock} stock/chart/marginright/
     *         100px right margin
     * @sample {highmaps} maps/chart/margin/
     *         100px margins
     *
     * @type      {number}
     * @since     2.0
     * @apioption chart.marginRight
     */

    /**
     * The margin between the top outer edge of the chart and the plot area.
     * Use this to set a fixed pixel value for the margin as opposed to
     * the default dynamic margin. See also `spacingTop`.
     *
     * @sample {highcharts} highcharts/chart/margintop/ 100px top margin
     * @sample {highstock} stock/chart/margintop/
     *         100px top margin
     * @sample {highmaps} maps/chart/margin/
     *         100px margins
     *
     * @type      {number}
     * @since     2.0
     * @apioption chart.marginTop
     */

    /**
     * Allows setting a key to switch between zooming and panning. Can be
     * one of `alt`, `ctrl`, `meta` (the command key on Mac and Windows
     * key on Windows) or `shift`. The keys are mapped directly to the key
     * properties of the click event argument (`event.altKey`,
     * `event.ctrlKey`, `event.metaKey` and `event.shiftKey`).
     *
     * @type       {string}
     * @since      4.0.3
     * @product    highcharts
     * @validvalue ["alt", "ctrl", "meta", "shift"]
     * @apioption  chart.panKey
     */

    /**
     * Allow panning in a chart. Best used with [panKey](#chart.panKey)
     * to combine zooming and panning.
     *
     * On touch devices, when the [tooltip.followTouchMove](
     * #tooltip.followTouchMove) option is `true` (default), panning
     * requires two fingers. To allow panning with one finger, set
     * `followTouchMove` to `false`.
     *
     * @sample {highcharts} highcharts/chart/pankey/ Zooming and panning
     *
     * @type      {boolean}
     * @default   {highcharts} false
     * @default   {highstock} true
     * @since     4.0.3
     * @product   highcharts highstock
     * @apioption chart.panning
     */

    /**
     * Equivalent to [zoomType](#chart.zoomType), but for multitouch
     * gestures only. By default, the `pinchType` is the same as the
     * `zoomType` setting. However, pinching can be enabled separately in
     * some cases, for example in stock charts where a mouse drag pans the
     * chart, while pinching is enabled. When [tooltip.followTouchMove](
     * #tooltip.followTouchMove) is true, pinchType only applies to
     * two-finger touches.
     *
     * @type       {string}
     * @default    {highcharts} undefined
     * @default    {highstock} x
     * @since      3.0
     * @product    highcharts highstock
     * @validvalue ["x", "y", "xy"]
     * @apioption  chart.pinchType
     */

    /**
     * The corner radius of the outer chart border.
     *
     * @sample {highcharts} highcharts/chart/borderradius/
     *         20px radius
     * @sample {highstock} stock/chart/border/
     *         10px radius
     * @sample {highmaps} maps/chart/border/
     *         Border options
     *
     */
    borderRadius: 0,

    /**
     * In styled mode, this sets how many colors the class names
     * should rotate between. With ten colors, series (or points) are
     * given class names like `highcharts-color-0`, `highcharts-color-0`
     * [...] `highcharts-color-9`. The equivalent in non-styled mode
     * is to set colors using the [colors](#colors) setting.
     *
     * @since      5.0.0
     */
    colorCount: 10,

    /**
     * Alias of `type`.
     *
     * @sample {highcharts} highcharts/chart/defaultseriestype/
     *         Bar
     *
     * @deprecated
     *
     * @product highcharts
     */
    defaultSeriesType: 'line',

    /**
     * If true, the axes will scale to the remaining visible series once
     * one series is hidden. If false, hiding and showing a series will
     * not affect the axes or the other series. For stacks, once one series
     * within the stack is hidden, the rest of the stack will close in
     * around it even if the axis is not affected.
     *
     * @sample {highcharts} highcharts/chart/ignorehiddenseries-true/
     *         True by default
     * @sample {highcharts} highcharts/chart/ignorehiddenseries-false/
     *         False
     * @sample {highcharts} highcharts/chart/ignorehiddenseries-true-stacked/
     *         True with stack
     * @sample {highstock} stock/chart/ignorehiddenseries-true/
     *         True by default
     * @sample {highstock} stock/chart/ignorehiddenseries-false/
     *         False
     *
     * @since   1.2.0
     * @product highcharts highstock
     */
    ignoreHiddenSeries: true,

    /**
     * Whether to invert the axes so that the x axis is vertical and y axis
     * is horizontal. When `true`, the x axis is [reversed](#xAxis.reversed)
     * by default.
     *
     * @productdesc {highcharts}
     * If a bar series is present in the chart, it will be inverted
     * automatically. Inverting the chart doesn't have an effect if there
     * are no cartesian series in the chart, or if the chart is
     * [polar](#chart.polar).
     *
     * @sample {highcharts} highcharts/chart/inverted/
     *         Inverted line
     * @sample {highstock} stock/navigator/inverted/
     *         Inverted stock chart
     *
     * @type      {boolean}
     * @default   false
     * @product   highcharts highstock
     * @apioption chart.inverted
     */

    /**
     * The distance between the outer edge of the chart and the content,
     * like title or legend, or axis title and labels if present. The
     * numbers in the array designate top, right, bottom and left
     * respectively. Use the options spacingTop, spacingRight, spacingBottom
     * and spacingLeft options for shorthand setting of one option.
     *
     * @type    {Array<number>}
     * @see     [chart.margin](#chart.margin)
     * @default [10, 10, 15, 10]
     * @since   3.0.6
     */
    spacing: [10, 10, 15, 10],

    /**
     * The button that appears after a selection zoom, allowing the user
     * to reset zoom.
     */
    resetZoomButton: {
      /**
       * What frame the button should be placed related to. Can be either
       * `plot` or `chart`
       *
       * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
       *         Relative to the chart
       * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
       *         Relative to the chart
       *
       * @type       {string}
       * @default    plot
       * @since      2.2
       * @validvalue ["plot", "chart"]
       * @apioption  chart.resetZoomButton.relativeTo
       */

      /**
       * A collection of attributes for the button. The object takes SVG
       * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
       * border radius. The theme also supports `style`, a collection of
       * CSS properties for the text. Equivalent attributes for the hover
       * state are given in `theme.states.hover`.
       *
       * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
       *         Theming the button
       * @sample {highstock} highcharts/chart/resetzoombutton-theme/
       *         Theming the button
       *
       * @since 2.2
       */
      theme: {
        /**
         * The Z index for the reset zoom button. The default value
         * places it below the tooltip that has Z index 7.
         */
        zIndex: 6
      },

      /**
       * The position of the button.
       *
       * @sample {highcharts} highcharts/chart/resetzoombutton-position/
       *         Above the plot area
       * @sample {highstock} highcharts/chart/resetzoombutton-position/
       *         Above the plot area
       * @sample {highmaps} highcharts/chart/resetzoombutton-position/
       *         Above the plot area
       *
       * @since 2.2
       */
      position: {
        /**
         * The horizontal alignment of the button.
         */
        align: 'right',

        /**
         * The horizontal offset of the button.
         */
        x: -10,

        /**
         * The vertical alignment of the button.
         *
         * @type       {string}
         * @default    top
         * @validvalue ["top", "middle", "bottom"]
         * @apioption  chart.resetZoomButton.position.verticalAlign
         */

        /**
         * The vertical offset of the button.
         */
        y: 10
      }
    },

    /**
     * The pixel width of the plot area border.
     *
     * @sample {highcharts} highcharts/chart/plotborderwidth/
     *         1px border
     * @sample {highstock} stock/chart/plotborder/
     *         2px border
     * @sample {highmaps} maps/chart/plotborder/
     *         Plot border options
     *
     * @type      {number}
     * @default   0
     * @apioption chart.plotBorderWidth
     */

    /**
     * Whether to apply a drop shadow to the plot area. Requires that
     * plotBackgroundColor be set. The shadow can be an object configuration
     * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
     *
     * @sample {highcharts} highcharts/chart/plotshadow/
     *         Plot shadow
     * @sample {highstock} stock/chart/plotshadow/
     *         Plot shadow
     * @sample {highmaps} maps/chart/plotborder/
     *         Plot border options
     *
     * @type      {boolean|Highcharts.CSSObject}
     * @default   false
     * @apioption chart.plotShadow
     */

    /**
     * When true, cartesian charts like line, spline, area and column are
     * transformed into the polar coordinate system. Requires
     * `highcharts-more.js`.
     *
     * @sample {highcharts} highcharts/demo/polar/
     *         Polar chart
     * @sample {highcharts} highcharts/demo/polar-wind-rose/
     *         Wind rose, stacked polar column chart
     * @sample {highcharts} highcharts/demo/polar-spider/
     *         Spider web chart
     * @sample {highcharts} highcharts/parallel-coordinates/polar/
     *         Star plot, multivariate data in a polar chart
     *
     * @type      {boolean}
     * @default   false
     * @since     2.3.0
     * @product   highcharts
     * @apioption chart.polar
     */

    /**
     * Whether to reflow the chart to fit the width of the container div
     * on resizing the window.
     *
     * @sample {highcharts} highcharts/chart/reflow-true/
     *         True by default
     * @sample {highcharts} highcharts/chart/reflow-false/
     *         False
     * @sample {highstock} stock/chart/reflow-true/
     *         True by default
     * @sample {highstock} stock/chart/reflow-false/
     *         False
     * @sample {highmaps} maps/chart/reflow-true/
     *         True by default
     * @sample {highmaps} maps/chart/reflow-false/
     *         False
     *
     * @type      {boolean}
     * @default   true
     * @since     2.1
     * @apioption chart.reflow
     */

    /**
     * The HTML element where the chart will be rendered. If it is a string,
     * the element by that id is used. The HTML element can also be passed
     * by direct reference, or as the first argument of the chart
     * constructor, in which case the option is not needed.
     *
     * @sample {highcharts} highcharts/chart/reflow-true/
     *         String
     * @sample {highcharts} highcharts/chart/renderto-object/
     *         Object reference
     * @sample {highcharts} highcharts/chart/renderto-jquery/
     *         Object reference through jQuery
     * @sample {highstock} stock/chart/renderto-string/
     *         String
     * @sample {highstock} stock/chart/renderto-object/
     *         Object reference
     * @sample {highstock} stock/chart/renderto-jquery/
     *         Object reference through jQuery
     *
     * @type      {string|Highcharts.SVGDOMElement}
     * @apioption chart.renderTo
     */

    /**
     * The background color of the marker square when selecting (zooming
     * in on) an area of the chart.
     *
     * @see In styled mode, the selection marker fill is set with the
     *      `.highcharts-selection-marker` class.
     *
     * @type      {Highcharts.ColorString}
     * @default   rgba(51,92,173,0.25)
     * @since     2.1.7
     * @apioption chart.selectionMarkerFill
     */

    /**
     * Whether to apply a drop shadow to the outer chart area. Requires
     * that backgroundColor be set. The shadow can be an object
     * configuration containing `color`, `offsetX`, `offsetY`, `opacity` and
     * `width`.
     *
     * @sample {highcharts} highcharts/chart/shadow/
     *         Shadow
     * @sample {highstock} stock/chart/shadow/
     *         Shadow
     * @sample {highmaps} maps/chart/border/
     *         Chart border and shadow
     *
     * @type      {boolean|Highcharts.CSSObject}
     * @default   false
     * @apioption chart.shadow
     */

    /**
     * Whether to show the axes initially. This only applies to empty charts
     * where series are added dynamically, as axes are automatically added
     * to cartesian series.
     *
     * @sample {highcharts} highcharts/chart/showaxes-false/
     *         False by default
     * @sample {highcharts} highcharts/chart/showaxes-true/
     *         True
     *
     * @type      {boolean}
     * @since     1.2.5
     * @product   highcharts
     * @apioption chart.showAxes
     */

    /**
     * The space between the bottom edge of the chart and the content (plot
     * area, axis title and labels, title, subtitle or legend in top
     * position).
     *
     * @sample {highcharts} highcharts/chart/spacingbottom/
     *         Spacing bottom set to 100
     * @sample {highstock} stock/chart/spacingbottom/
     *         Spacing bottom set to 100
     * @sample {highmaps} maps/chart/spacing/
     *         Spacing 100 all around
     *
     * @type      {number}
     * @default   15
     * @since     2.1
     * @apioption chart.spacingBottom
     */

    /**
     * The space between the left edge of the chart and the content (plot
     * area, axis title and labels, title, subtitle or legend in top
     * position).
     *
     * @sample {highcharts} highcharts/chart/spacingleft/
     *         Spacing left set to 100
     * @sample {highstock} stock/chart/spacingleft/
     *         Spacing left set to 100
     * @sample {highmaps} maps/chart/spacing/
     *         Spacing 100 all around
     *
     * @type      {number}
     * @default   10
     * @since     2.1
     * @apioption chart.spacingLeft
     */

    /**
     * The space between the right edge of the chart and the content (plot
     * area, axis title and labels, title, subtitle or legend in top
     * position).
     *
     * @sample {highcharts} highcharts/chart/spacingright-100/
     *         Spacing set to 100
     * @sample {highcharts} highcharts/chart/spacingright-legend/
     *         Legend in right position with default spacing
     * @sample {highstock} stock/chart/spacingright/
     *         Spacing set to 100
     * @sample {highmaps} maps/chart/spacing/
     *         Spacing 100 all around
     *
     * @type      {number}
     * @default   10
     * @since     2.1
     * @apioption chart.spacingRight
     */

    /**
     * The space between the top edge of the chart and the content (plot
     * area, axis title and labels, title, subtitle or legend in top
     * position).
     *
     * @sample {highcharts} highcharts/chart/spacingtop-100/
     *         A top spacing of 100
     * @sample {highcharts} highcharts/chart/spacingtop-10/
     *         Floating chart title makes the plot area align to the default
     *         spacingTop of 10.
     * @sample {highstock} stock/chart/spacingtop/
     *         A top spacing of 100
     * @sample {highmaps} maps/chart/spacing/
     *         Spacing 100 all around
     *
     * @type      {number}
     * @default   10
     * @since     2.1
     * @apioption chart.spacingTop
     */

    /**
     * Additional CSS styles to apply inline to the container `div`. Note
     * that since the default font styles are applied in the renderer, it
     * is ignorant of the individual chart options and must be set globally.
     *
     * @see    In styled mode, general chart styles can be set with the
     *         `.highcharts-root` class.
     * @sample {highcharts} highcharts/chart/style-serif-font/
     *         Using a serif type font
     * @sample {highcharts} highcharts/css/em/
     *         Styled mode with relative font sizes
     * @sample {highstock} stock/chart/style/
     *         Using a serif type font
     * @sample {highmaps} maps/chart/style-serif-font/
     *         Using a serif type font
     *
     * @type      {Highcharts.CSSObject}
     * @default   {"fontFamily": "\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif","fontSize":"12px"}
     * @apioption chart.style
     */

    /**
     * The default series type for the chart. Can be any of the chart types
     * listed under [plotOptions](#plotOptions).
     *
     * @sample {highcharts} highcharts/chart/type-bar/
     *         Bar
     * @sample {highstock} stock/chart/type/
     *         Areaspline
     * @sample {highmaps} maps/chart/type-mapline/
     *         Mapline
     *
     * @type       {string}
     * @default    {highcharts} line
     * @default    {highstock} line
     * @default    {highmaps} map
     * @since      2.1.0
     * @validvalue ["line", "spline", "column", "bar", "area", "areaspline",
     *             "pie", "arearange", "areasplinerange", "boxplot",
     *             "bubble", "columnrange", "errorbar", "funnel", "gauge",
     *             "heatmap", "polygon", "pyramid", "scatter", "solidgauge",
     *             "treemap", "waterfall"]
     * @apioption  chart.type
     */

    /**
     * Decides in what dimensions the user can zoom by dragging the mouse.
     * Can be one of `x`, `y` or `xy`.
     *
     * @see [panKey](#chart.panKey)
     *
     * @sample {highcharts} highcharts/chart/zoomtype-none/
     *         None by default
     * @sample {highcharts} highcharts/chart/zoomtype-x/
     *         X
     * @sample {highcharts} highcharts/chart/zoomtype-y/
     *         Y
     * @sample {highcharts} highcharts/chart/zoomtype-xy/
     *         Xy
     * @sample {highstock} stock/demo/basic-line/
     *         None by default
     * @sample {highstock} stock/chart/zoomtype-x/
     *         X
     * @sample {highstock} stock/chart/zoomtype-y/
     *         Y
     * @sample {highstock} stock/chart/zoomtype-xy/
     *         Xy
     *
     * @type       {string}
     * @product    highcharts highstock
     * @validvalue ["x", "y", "xy"]
     * @apioption  chart.zoomType
     */

    /**
     * An explicit width for the chart. By default (when `null`) the width
     * is calculated from the offset width of the containing element.
     *
     * @sample {highcharts} highcharts/chart/width/
     *         800px wide
     * @sample {highstock} stock/chart/width/
     *         800px wide
     * @sample {highmaps} maps/chart/size/
     *         Chart with explicit size
     *
     * @type {number|null}
     */
    width: null,

    /**
     * An explicit height for the chart. If a _number_, the height is
     * given in pixels. If given a _percentage string_ (for example
     * `'56%'`), the height is given as the percentage of the actual chart
     * width. This allows for preserving the aspect ratio across responsive
     * sizes.
     *
     * By default (when `null`) the height is calculated from the offset
     * height of the containing element, or 400 pixels if the containing
     * element's height is 0.
     *
     * @sample {highcharts} highcharts/chart/height/
     *         500px height
     * @sample {highstock} stock/chart/height/
     *         300px height
     * @sample {highmaps} maps/chart/size/
     *         Chart with explicit size
     * @sample highcharts/chart/height-percent/
     *         Highcharts with percentage height
     *
     * @type {number|string|null}
     */
    height: null
  },

  /**
   * The chart's main title.
   *
   * @sample {highmaps} maps/title/title/
   *         Title options demonstrated
   */
  title: {
    /**
     * When the title is floating, the plot area will not move to make space
     * for it.
     *
     * @sample {highcharts} highcharts/chart/zoomtype-none/
     *         False by default
     * @sample {highcharts} highcharts/title/floating/
     *         True - title on top of the plot area
     * @sample {highstock} stock/chart/title-floating/
     *         True - title on top of the plot area
     *
     * @type      {boolean}
     * @default   false
     * @since     2.1
     * @apioption title.floating
     */

    /**
     * CSS styles for the title. Use this for font styling, but use `align`,
     * `x` and `y` for text alignment.
     *
     * In styled mode, the title style is given in the `.highcharts-title`
     * class.
     *
     * @sample {highcharts} highcharts/title/style/
     *         Custom color and weight
     * @sample {highstock} stock/chart/title-style/
     *         Custom color and weight
     * @sample highcharts/css/titles/
     *         Styled mode
     *
     * @type      {Highcharts.CSSObject}
     * @default   {highcharts|highmaps} { "color": "#333333", "fontSize": "18px" }
     * @default   {highstock} { "color": "#333333", "fontSize": "16px" }
     * @apioption title.style
     */

    /**
     * Whether to
     * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the text.
     *
     * @type      {boolean}
     * @default   false
     * @apioption title.useHTML
     */

    /**
     * The vertical alignment of the title. Can be one of `"top"`,
     * `"middle"` and `"bottom"`. When a value is given, the title behaves
     * as if [floating](#title.floating) were `true`.
     *
     * @sample {highcharts} highcharts/title/verticalalign/
     *         Chart title in bottom right corner
     * @sample {highstock} stock/chart/title-verticalalign/
     *         Chart title in bottom right corner
     *
     * @type       {string}
     * @since      2.1
     * @validvalue ["top", "middle", "bottom"]
     * @apioption  title.verticalAlign
     */

    /**
     * The x position of the title relative to the alignment within
     * `chart.spacingLeft` and `chart.spacingRight`.
     *
     * @sample {highcharts} highcharts/title/align/
     *         Aligned to the plot area (x = 70px = margin left - spacing
     *         left)
     * @sample {highstock} stock/chart/title-align/
     *         Aligned to the plot area (x = 50px = margin left - spacing
     *         left)
     *
     * @type      {number}
     * @default   0
     * @since     2.0
     * @apioption title.x
     */

    /**
     * The y position of the title relative to the alignment within
     * [chart.spacingTop](#chart.spacingTop) and [chart.spacingBottom](
     * #chart.spacingBottom). By default it depends on the font size.
     *
     * @sample {highcharts} highcharts/title/y/
     *         Title inside the plot area
     * @sample {highstock} stock/chart/title-verticalalign/
     *         Chart title in bottom right corner
     *
     * @type      {number}
     * @since     2.0
     * @apioption title.y
     */

    /**
     * The title of the chart. To disable the title, set the `text` to
     * `undefined`.
     *
     * @sample {highcharts} highcharts/title/text/
     *         Custom title
     * @sample {highstock} stock/chart/title-text/
     *         Custom title
     *
     * @default {highcharts|highmaps} Chart title
     * @default {highstock} undefined
     */
    text: 'Chart title',

    /**
     * The horizontal alignment of the title. Can be one of "left", "center"
     * and "right".
     *
     * @sample {highcharts} highcharts/title/align/
     *         Aligned to the plot area (x = 70px = margin left - spacing
     *         left)
     * @sample {highstock} stock/chart/title-align/
     *         Aligned to the plot area (x = 50px = margin left - spacing
     *         left)
     *
     * @since      2.0
     * @validvalue ["left", "center", "right"]
     */
    align: 'center',

    /**
     * The margin between the title and the plot area, or if a subtitle
     * is present, the margin between the subtitle and the plot area.
     *
     * @sample {highcharts} highcharts/title/margin-50/
     *         A chart title margin of 50
     * @sample {highcharts} highcharts/title/margin-subtitle/
     *         The same margin applied with a subtitle
     * @sample {highstock} stock/chart/title-margin/
     *         A chart title margin of 50
     *
     * @since 2.1
     */
    margin: 15,

    /**
     * Adjustment made to the title width, normally to reserve space for
     * the exporting burger menu.
     *
     * @sample highcharts/title/widthadjust/
     *         Wider menu, greater padding
     *
     * @since 4.2.5
     */
    widthAdjust: -44
  },

  /**
   * The chart's subtitle. This can be used both to display a subtitle below
   * the main title, and to display random text anywhere in the chart. The
   * subtitle can be updated after chart initialization through the
   * `Chart.setTitle` method.
   *
   * @sample {highmaps} maps/title/subtitle/
   *         Subtitle options demonstrated
   */
  subtitle: {
    /**
     * When the subtitle is floating, the plot area will not move to make
     * space for it.
     *
     * @sample {highcharts} highcharts/subtitle/floating/
     *         Floating title and subtitle
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote floating at bottom right of plot area
     *
     * @type      {boolean}
     * @default   false
     * @since     2.1
     * @apioption subtitle.floating
     */

    /**
     * CSS styles for the title.
     *
     * In styled mode, the subtitle style is given in the
     * `.highcharts-subtitle` class.
     *
     * @sample {highcharts} highcharts/subtitle/style/
     *         Custom color and weight
     * @sample {highcharts} highcharts/css/titles/
     *         Styled mode
     * @sample {highstock} stock/chart/subtitle-style
     *         Custom color and weight
     * @sample {highstock} highcharts/css/titles/
     *         Styled mode
     * @sample {highmaps} highcharts/css/titles/
     *         Styled mode
     *
     * @type      {Highcharts.CSSObject}
     * @default   {"color": "#666666"}
     * @apioption subtitle.style
     */

    /**
     * Whether to
     * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the text.
     *
     * @type      {boolean}
     * @default   false
     * @apioption subtitle.useHTML
     */

    /**
     * The vertical alignment of the title. Can be one of "top", "middle"
     * and "bottom". When a value is given, the title behaves as floating.
     *
     * @sample {highcharts} highcharts/subtitle/verticalalign/
     *         Footnote at the bottom right of plot area
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote at the bottom right of plot area
     *
     * @type       {string}
     * @since      2.1
     * @validvalue ["top", "middle", "bottom"]
     * @apioption  subtitle.verticalAlign
     */

    /**
     * The x position of the subtitle relative to the alignment within
     * `chart.spacingLeft` and `chart.spacingRight`.
     *
     * @sample {highcharts} highcharts/subtitle/align/
     *         Footnote at right of plot area
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote at the bottom right of plot area
     *
     * @type      {number}
     * @default   0
     * @since     2.0
     * @apioption subtitle.x
     */

    /**
     * The y position of the subtitle relative to the alignment within
     * `chart.spacingTop` and `chart.spacingBottom`. By default the subtitle
     * is laid out below the title unless the title is floating.
     *
     * @sample {highcharts} highcharts/subtitle/verticalalign/
     *         Footnote at the bottom right of plot area
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote at the bottom right of plot area
     *
     * @type      {number}
     * @since     2.0
     * @apioption subtitle.y
     */

    /**
     * The subtitle of the chart.
     *
     * @sample {highcharts|highstock} highcharts/subtitle/text/
     *         Custom subtitle
     * @sample {highcharts|highstock} highcharts/subtitle/text-formatted/
     *         Formatted and linked text.
     */
    text: '',

    /**
     * The horizontal alignment of the subtitle. Can be one of "left",
     *  "center" and "right".
     *
     * @sample {highcharts} highcharts/subtitle/align/
     *         Footnote at right of plot area
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote at bottom right of plot area
     *
     * @since      2.0
     * @validvalue ["left", "center", "right"]
     */
    align: 'center',

    /**
     * Adjustment made to the subtitle width, normally to reserve space
     * for the exporting burger menu.
     *
     * @see [title.widthAdjust](#title.widthAdjust)
     *
     * @sample highcharts/title/widthadjust/
     *         Wider menu, greater padding
     *
     * @since 4.2.5
     */
    widthAdjust: -44
  },

  /**
   * The plotOptions is a wrapper object for config objects for each series
   * type. The config objects for each series can also be overridden for
   * each series item as given in the series array.
   *
   * Configuration options for the series are given in three levels. Options
   * for all series in a chart are given in the [plotOptions.series](
   * #plotOptions.series) object. Then options for all series of a specific
   * type are given in the plotOptions of that type, for example
   * `plotOptions.line`. Next, options for one single series are given in
   * [the series array](#series).
   */
  plotOptions: {},

  /**
   * HTML labels that can be positioned anywhere in the chart area.
   */
  labels: {
    /**
     * An HTML label that can be positioned anywhere in the chart area.
     *
     * @type      {Array<*>}
     * @apioption labels.items
     */

    /**
     * Inner HTML or text for the label.
     *
     * @type      {string}
     * @apioption labels.items.html
     */

    /**
     * CSS styles for each label. To position the label, use left and top
     * like this:
     *
     * <pre>style: {
     *     left: '100px',
     *     top: '100px'
     * }</pre>
     *
     * @type      {Highcharts.CSSObject}
     * @apioption labels.items.style
     */

    /**
     * Shared CSS styles for all labels.
     *
     * @type    {Highcharts.CSSObject}
     * @default {"color": "#333333", "position": "absolute"}
     */
    style: {
      /**
       * @ignore
       */
      position: 'absolute',

      /**
       * @ignore
       */
      color: '#333333'
    }
  },

  /**
   * The legend is a box containing a symbol and name for each series
   * item or point item in the chart. Each series (or points in case
   * of pie charts) is represented by a symbol and its name in the legend.
   *
   * It is possible to override the symbol creator function and create
   * [custom legend symbols](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/studies/legend-custom-symbol/).
   *
   * @productdesc {highmaps}
   * A Highmaps legend by default contains one legend item per series, but if
   * a `colorAxis` is defined, the axis will be displayed in the legend.
   * Either as a gradient, or as multiple legend items for `dataClasses`.
   */
  legend: {
    /**
     * The background color of the legend.
     *
     * @see In styled mode, the legend background fill can be applied with
     *      the `.highcharts-legend-box` class.
     *
     * @sample {highcharts} highcharts/legend/backgroundcolor/
     *         Yellowish background
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     *
     * @type      {Highcharts.ColorString}
     * @apioption legend.backgroundColor
     */

    /**
     * The width of the drawn border around the legend.
     *
     * @see In styled mode, the legend border stroke width can be applied
     *      with the `.highcharts-legend-box` class.
     *
     * @sample {highcharts} highcharts/legend/borderwidth/
     *         2px border width
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     *
     * @type      {number}
     * @default   0
     * @apioption legend.borderWidth
     */

    /**
     * Enable or disable the legend. There is also a series-specific option,
     * [showInLegend](#plotOptions.series.showInLegend), that can hide the
     * series from the legend. In some series types this is `false` by
     * default, so it must set to `true` in order to show the legend for the
     * series.
     *
     * @sample {highcharts} highcharts/legend/enabled-false/ Legend disabled
     * @sample {highstock} stock/legend/align/ Various legend options
     * @sample {highmaps} maps/legend/enabled-false/ Legend disabled
     *
     * @default {highstock} false
     * @default {highmaps} true
     */
    enabled: true,

    /**
     * The horizontal alignment of the legend box within the chart area.
     * Valid values are `left`, `center` and `right`.
     *
     * In the case that the legend is aligned in a corner position, the
     * `layout` option will determine whether to place it above/below
     * or on the side of the plot area.
     *
     * @sample {highcharts} highcharts/legend/align/
     *         Legend at the right of the chart
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/alignment/
     *         Legend alignment
     *
     * @since      2.0
     * @validvalue ["left", "center", "right"]
     */
    align: 'center',

    /**
     * If the [layout](legend.layout) is `horizontal` and the legend items
     * span over two lines or more, whether to align the items into vertical
     * columns. Setting this to `false` makes room for more items, but will
     * look more messy.
     *
     * @since 6.1.0
     */
    alignColumns: true,

    /**
     * When the legend is floating, the plot area ignores it and is allowed
     * to be placed below it.
     *
     * @sample {highcharts} highcharts/legend/floating-false/
     *         False by default
     * @sample {highcharts} highcharts/legend/floating-true/
     *         True
     * @sample {highmaps} maps/legend/alignment/
     *         Floating legend
     *
     * @type      {boolean}
     * @default   false
     * @since     2.1
     * @apioption legend.floating
     */

    /**
     * The layout of the legend items. Can be one of `horizontal` or
     * `vertical` or `proximate`. When `proximate`, the legend items will be
     * placed as close as possible to the graphs they're representing,
     * except in inverted charts or when the legend position doesn't allow
     * it.
     *
     * @sample {highcharts} highcharts/legend/layout-horizontal/
     *         Horizontal by default
     * @sample {highcharts} highcharts/legend/layout-vertical/
     *         Vertical
     * @sample highcharts/legend/layout-proximate
     *         Labels proximate to the data
     * @sample {highstock} stock/legend/layout-horizontal/
     *         Horizontal by default
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Vertical with data classes
     * @sample {highmaps} maps/legend/layout-vertical/
     *         Vertical with color axis gradient
     *
     * @validvalue ["horizontal", "vertical", "proximate"]
     */
    layout: 'horizontal',

    /**
     * In a legend with horizontal layout, the itemDistance defines the
     * pixel distance between each item.
     *
     * @sample {highcharts} highcharts/legend/layout-horizontal/
     *         50px item distance
     * @sample {highstock} highcharts/legend/layout-horizontal/
     *         50px item distance
     *
     * @type      {number}
     * @default   {highcharts} 20
     * @default   {highstock} 20
     * @default   {highmaps} 8
     * @since     3.0.3
     * @apioption legend.itemDistance
     */

    /**
     * The pixel bottom margin for each legend item.
     *
     * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     *
     * @type      {number}
     * @default   0
     * @since     2.2.0
     * @apioption legend.itemMarginBottom
     */

    /**
     * The pixel top margin for each legend item.
     *
     * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     *
     * @type      {number}
     * @default   0
     * @since     2.2.0
     * @apioption legend.itemMarginTop
     */

    /**
     * The width for each legend item. By default the items are laid out
     * successively. In a [horizontal layout](legend.layout), if the items
     * are laid out across two rows or more, they will be vertically aligned
     * depending on the [legend.alignColumns](legend.alignColumns) option.
     *
     * @sample {highcharts} highcharts/legend/itemwidth-default/
     *         Undefined by default
     * @sample {highcharts} highcharts/legend/itemwidth-80/
     *         80 for aligned legend items
     *
     * @type      {number}
     * @since     2.0
     * @apioption legend.itemWidth
     */

    /**
     * A [format string](https://www.highcharts.com/docs/chart-concepts/
     * labels-and-string-formatting) for each legend label. Available
     * variables relates to properties on the series, or the point in case
     * of pies.
     *
     * @type      {string}
     * @default   {name}
     * @since     1.3
     * @apioption legend.labelFormat
     */

    /**
     * Callback function to format each of the series' labels. The `this`
     * keyword refers to the series object, or the point object in case
     * of pie charts. By default the series or point name is printed.
     *
     * @productdesc {highmaps}
     * In Highmaps the context can also be a data class in case of a
     * `colorAxis`.
     *
     * @sample {highcharts} highcharts/legend/labelformatter/
     *         Add text
     * @sample {highmaps} maps/legend/labelformatter/
     *         Data classes with label formatter
     *
     * @context {Highcharts.Series|Highcharts.Point}
     */
    labelFormatter: function () {
      return this.name;
    },

    /**
     * Line height for the legend items. Deprecated as of 2.1\. Instead,
     * the line height for each item can be set using itemStyle.lineHeight,
     * and the padding between items using `itemMarginTop` and
     * `itemMarginBottom`.
     *
     * @sample {highcharts} highcharts/legend/lineheight/
     *         Setting padding
     *
     * @deprecated
     *
     * @type      {number}
     * @default   16
     * @since     2.0
     * @product   highcharts
     * @apioption legend.lineHeight
     */

    /**
     * If the plot area sized is calculated automatically and the legend
     * is not floating, the legend margin is the space between the legend
     * and the axis labels or plot area.
     *
     * @sample {highcharts} highcharts/legend/margin-default/
     *         12 pixels by default
     * @sample {highcharts} highcharts/legend/margin-30/
     *         30 pixels
     *
     * @type      {number}
     * @default   12
     * @since     2.1
     * @apioption legend.margin
     */

    /**
     * Maximum pixel height for the legend. When the maximum height is
     * extended, navigation will show.
     *
     * @type      {number}
     * @since     2.3.0
     * @apioption legend.maxHeight
     */

    /**
     * The color of the drawn border around the legend.
     *
     * @see In styled mode, the legend border stroke can be applied with the
     *      `.highcharts-legend-box` class.
     *
     * @sample {highcharts} highcharts/legend/bordercolor/
     *         Brown border
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     *
     * @type {Highcharts.ColorString}
     */
    borderColor: '#999999',

    /**
     * The border corner radius of the legend.
     *
     * @sample {highcharts} highcharts/legend/borderradius-default/
     *         Square by default
     * @sample {highcharts} highcharts/legend/borderradius-round/
     *         5px rounded
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     */
    borderRadius: 0,

    /**
     * Options for the paging or navigation appearing when the legend
     * is overflown. Navigation works well on screen, but not in static
     * exported images. One way of working around that is to
     * [increase the chart height in
     * export](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/legend/navigation-enabled-false/).
     */
    navigation: {
      /**
       * How to animate the pages when navigating up or down. A value of
       * `true` applies the default navigation given in the
       * `chart.animation` option. Additional options can be given as an
       * object containing values for easing and duration.
       *
       * @sample {highcharts} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       * @sample {highstock} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       *
       * @type      {boolean|Highcharts.AnimationObject}
       * @default   true
       * @since     2.2.4
       * @apioption legend.navigation.animation
       */

      /**
       * The pixel size of the up and down arrows in the legend paging
       * navigation.
       *
       * @sample {highcharts} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       * @sample {highstock} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       *
       * @type      {number}
       * @default   12
       * @since     2.2.4
       * @apioption legend.navigation.arrowSize
       */

      /**
       * Whether to enable the legend navigation. In most cases, disabling
       * the navigation results in an unwanted overflow.
       *
       * See also the [adapt chart to legend](
       * https://www.highcharts.com/products/plugin-registry/single/8/Adapt-Chart-To-Legend)
       * plugin for a solution to extend the chart height to make room for
       * the legend, optionally in exported charts only.
       *
       * @type      {boolean}
       * @default   true
       * @since     4.2.4
       * @apioption legend.navigation.enabled
       */

      /**
       * Text styles for the legend page navigation.
       *
       * @see In styled mode, the navigation items are styled with the
       *      `.highcharts-legend-navigation` class.
       *
       * @sample {highcharts} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       * @sample {highstock} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       *
       * @type      {Highcharts.CSSObject}
       * @since     2.2.4
       * @apioption legend.navigation.style
       */
    },

    /**
     * The inner padding of the legend box.
     *
     * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     *
     * @type      {number}
     * @default   8
     * @since     2.2.0
     * @apioption legend.padding
     */

    /**
     * Whether to reverse the order of the legend items compared to the
     * order of the series or points as defined in the configuration object.
     *
     * @see [yAxis.reversedStacks](#yAxis.reversedStacks),
     *      [series.legendIndex](#series.legendIndex)
     *
     * @sample {highcharts} highcharts/legend/reversed/
     *         Stacked bar with reversed legend
     *
     * @type      {boolean}
     * @default   false
     * @since     1.2.5
     * @apioption legend.reversed
     */

    /**
     * Whether to show the symbol on the right side of the text rather than
     * the left side. This is common in Arabic and Hebraic.
     *
     * @sample {highcharts} highcharts/legend/rtl/
     *         Symbol to the right
     *
     * @type      {boolean}
     * @default   false
     * @since     2.2
     * @apioption legend.rtl
     */

    /**
     * CSS styles for the legend area. In the 1.x versions the position
     * of the legend area was determined by CSS. In 2.x, the position is
     * determined by properties like `align`, `verticalAlign`, `x` and `y`,
     * but the styles are still parsed for backwards compatibility.
     *
     * @deprecated
     *
     * @type      {Highcharts.CSSObject}
     * @product   highcharts highstock
     * @apioption legend.style
     */

    /**
     * Default styling for the checkbox next to a legend item when
     * `showCheckbox` is true.
     *
     * @type {Highcharts.CSSObject}
     * @default {"width": "13px", "height": "13px", "position":"absolute"}
     */
    itemCheckboxStyle: {
      /**
       * @ignore
       */
      position: 'absolute',

      /**
       * @ignore
       */
      width: '13px',
      // for IE precision

      /**
       * @ignore
       */
      height: '13px'
    },
    // itemWidth: undefined,

    /**
     * When this is true, the legend symbol width will be the same as
     * the symbol height, which in turn defaults to the font size of the
     * legend items.
     *
     * @since 5.0.0
     */
    squareSymbol: true,

    /**
     * The pixel height of the symbol for series types that use a rectangle
     * in the legend. Defaults to the font size of legend items.
     *
     * @productdesc {highmaps}
     * In Highmaps, when the symbol is the gradient of a vertical color
     * axis, the height defaults to 200.
     *
     * @sample {highmaps} maps/legend/layout-vertical-sized/
     *         Sized vertical gradient
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         No distance between data classes
     *
     * @type      {number}
     * @since     3.0.8
     * @apioption legend.symbolHeight
     */

    /**
     * The border radius of the symbol for series types that use a rectangle
     * in the legend. Defaults to half the `symbolHeight`.
     *
     * @sample {highcharts} highcharts/legend/symbolradius/
     *         Round symbols
     * @sample {highstock} highcharts/legend/symbolradius/
     *         Round symbols
     * @sample {highmaps} highcharts/legend/symbolradius/
     *         Round symbols
     *
     * @type      {number}
     * @since     3.0.8
     * @apioption legend.symbolRadius
     */

    /**
     * The pixel width of the legend item symbol. When the `squareSymbol`
     * option is set, this defaults to the `symbolHeight`, otherwise 16.
     *
     * @productdesc {highmaps}
     * In Highmaps, when the symbol is the gradient of a horizontal color
     * axis, the width defaults to 200.
     *
     * @sample {highcharts} highcharts/legend/symbolwidth/
     *         Greater symbol width and padding
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     * @sample {highmaps} maps/legend/layout-vertical-sized/
     *         Sized vertical gradient
     *
     * @type      {number}
     * @apioption legend.symbolWidth
     */

    /**
     * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/
     * labels-and-string-formatting#html) to render the legend item texts.
     *
     * Prior to 4.1.7, when using HTML, [legend.navigation](
     * #legend.navigation) was disabled.
     *
     * @type      {boolean}
     * @default   false
     * @apioption legend.useHTML
     */

    /**
     * The width of the legend box.
     *
     * @sample {highcharts} highcharts/legend/width/
     *         Aligned to the plot area
     *
     * @type      {number}
     * @since     2.0
     * @apioption legend.width
     */

    /**
     * The pixel padding between the legend item symbol and the legend
     * item text.
     *
     * @sample {highcharts} highcharts/legend/symbolpadding/
     *         Greater symbol width and padding
     */
    symbolPadding: 5,

    /**
     * The vertical alignment of the legend box. Can be one of `top`,
     * `middle` or `bottom`. Vertical position can be further determined
     * by the `y` option.
     *
     * In the case that the legend is aligned in a corner position, the
     * `layout` option will determine whether to place it above/below
     * or on the side of the plot area.
     *
     * When the [layout](#legend.layout) option is `proximate`, the
     * `verticalAlign` option doesn't apply.
     *
     * @sample {highcharts} highcharts/legend/verticalalign/
     *         Legend 100px from the top of the chart
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/alignment/
     *         Legend alignment
     *
     * @since      2.0
     * @validvalue ["top", "middle", "bottom"]
     */
    verticalAlign: 'bottom',
    // width: undefined,

    /**
     * The x offset of the legend relative to its horizontal alignment
     * `align` within chart.spacingLeft and chart.spacingRight. Negative
     * x moves it to the left, positive x moves it to the right.
     *
     * @sample {highcharts} highcharts/legend/width/
     *         Aligned to the plot area
     *
     * @since 2.0
     */
    x: 0,

    /**
     * The vertical offset of the legend relative to it's vertical alignment
     * `verticalAlign` within chart.spacingTop and chart.spacingBottom.
     *  Negative y moves it up, positive y moves it down.
     *
     * @sample {highcharts} highcharts/legend/verticalalign/
     *         Legend 100px from the top of the chart
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/alignment/
     *         Legend alignment
     *
     * @since 2.0
     */
    y: 0,

    /**
     * A title to be added on top of the legend.
     *
     * @sample {highcharts} highcharts/legend/title/
     *         Legend title
     * @sample {highmaps} maps/legend/alignment/
     *         Legend with title
     *
     * @since 3.0
     */
    title: {
      /**
       * A text or HTML string for the title.
       *
       * @type      {string}
       * @since     3.0
       * @apioption legend.title.text
       */
    }
  },

  /**
   * The loading options control the appearance of the loading screen
   * that covers the plot area on chart operations. This screen only
   * appears after an explicit call to `chart.showLoading()`. It is a
   * utility for developers to communicate to the end user that something
   * is going on, for example while retrieving new data via an XHR connection.
   * The "Loading..." text itself is not part of this configuration
   * object, but part of the `lang` object.
   */
  loading: {
    /**
     * The duration in milliseconds of the fade out effect.
     *
     * @sample highcharts/loading/hideduration/
     *         Fade in and out over a second
     *
     * @type      {number}
     * @default   100
     * @since     1.2.0
     * @apioption loading.hideDuration
     */

    /**
     * The duration in milliseconds of the fade in effect.
     *
     * @sample highcharts/loading/hideduration/
     *         Fade in and out over a second
     *
     * @type      {number}
     * @default   100
     * @since     1.2.0
     * @apioption loading.showDuration
     */
  },

  /**
   * Options for the tooltip that appears when the user hovers over a
   * series or point.
   */
  tooltip: {
    /**
     * The color of the tooltip border. When `undefined`, the border takes
     * the color of the corresponding series or point.
     *
     * @sample {highcharts} highcharts/tooltip/bordercolor-default/
     *         Follow series by default
     * @sample {highcharts} highcharts/tooltip/bordercolor-black/
     *         Black border
     * @sample {highstock} stock/tooltip/general/
     *         Styled tooltip
     * @sample {highmaps} maps/tooltip/background-border/
     *         Background and border demo
     *
     * @type      {Highcharts.ColorString}
     * @apioption tooltip.borderColor
     */

    /**
     * Since 4.1, the crosshair definitions are moved to the Axis object
     * in order for a better separation from the tooltip. See
     * [xAxis.crosshair](#xAxis.crosshair)<a>.</a>
     *
     * @sample {highcharts} highcharts/tooltip/crosshairs-x/
     *         Enable a crosshair for the x value
     *
     * @deprecated
     *
     * @type      {*}
     * @default   true
     * @apioption tooltip.crosshairs
     */

    /**
     * Whether the tooltip should follow the mouse as it moves across
     * columns, pie slices and other point types with an extent. By default
     * it behaves this way for scatter, bubble and pie series by override
     * in the `plotOptions` for those series types.
     *
     * For touch moves to behave the same way, [followTouchMove](
     * #tooltip.followTouchMove) must be `true` also.
     *
     * @type      {boolean}
     * @default   {highcharts} false
     * @default   {highstock} false
     * @default   {highmaps} true
     * @since     3.0
     * @apioption tooltip.followPointer
     */

    /**
     * Whether the tooltip should update as the finger moves on a touch
     * device. If this is `true` and [chart.panning](#chart.panning) is
     * set,`followTouchMove` will take over one-finger touches, so the user
     * needs to use two fingers for zooming and panning.
     *
     * Note the difference to [followPointer](#tooltip.followPointer) that
     * only defines the _position_ of the tooltip. If `followPointer` is
     * false in for example a column series, the tooltip will show above or
     * below the column, but as `followTouchMove` is true, the tooltip will
     * jump from column to column as the user swipes across the plot area.
     *
     * @type      {boolean}
     * @default   {highcharts} true
     * @default   {highstock} true
     * @default   {highmaps} false
     * @since     3.0.1
     * @apioption tooltip.followTouchMove
     */

    /**
     * Callback function to format the text of the tooltip from scratch.
     * Return `false` to disable tooltip for a specific point on series.
     *
     * A subset of HTML is supported. Unless `useHTML` is true, the HTML of
     * the tooltip is parsed and converted to SVG, therefore this isn't a
     * complete HTML renderer. The following tags are supported: `<b>`,
     * `<strong>`, `<i>`, `<em>`, `<br/>`, `<span>`. Spans can be styled
     * with a `style` attribute, but only text-related CSS that is shared
     * with SVG is handled.
     *
     * Since version 2.1 the tooltip can be shared between multiple series
     * through the `shared` option. The available data in the formatter
     * differ a bit depending on whether the tooltip is shared or not. In
     * a shared tooltip, all properties except `x`, which is common for
     * all points, are kept in an array, `this.points`.
     *
     * Available data are:
     *
     * <dl>
     *
     * <dt>this.percentage (not shared) / this.points[i].percentage (shared)
     * </dt>
     *
     * <dd>Stacked series and pies only. The point's percentage of the
     * total.
     * </dd>
     *
     * <dt>this.point (not shared) / this.points[i].point (shared)</dt>
     *
     * <dd>The point object. The point name, if defined, is available
     * through `this.point.name`.</dd>
     *
     * <dt>this.points</dt>
     *
     * <dd>In a shared tooltip, this is an array containing all other
     * properties for each point.</dd>
     *
     * <dt>this.series (not shared) / this.points[i].series (shared)</dt>
     *
     * <dd>The series object. The series name is available through
     * `this.series.name`.</dd>
     *
     * <dt>this.total (not shared) / this.points[i].total (shared)</dt>
     *
     * <dd>Stacked series only. The total value at this point's x value.
     * </dd>
     *
     * <dt>this.x</dt>
     *
     * <dd>The x value. This property is the same regardless of the tooltip
     * being shared or not.</dd>
     *
     * <dt>this.y (not shared) / this.points[i].y (shared)</dt>
     *
     * <dd>The y value.</dd>
     *
     * </dl>
     *
     * @sample {highcharts} highcharts/tooltip/formatter-simple/
     *         Simple string formatting
     * @sample {highcharts} highcharts/tooltip/formatter-shared/
     *         Formatting with shared tooltip
     * @sample {highstock} stock/tooltip/formatter/
     *         Formatting with shared tooltip
     * @sample {highmaps} maps/tooltip/formatter/
     *         String formatting
     *
     * @type      {Function}
     * @apioption tooltip.formatter
     */

    /**
     * The number of milliseconds to wait until the tooltip is hidden when
     * mouse out from a point or chart.
     *
     * @type      {number}
     * @default   500
     * @since     3.0
     * @apioption tooltip.hideDelay
     */

    /**
     * Whether to allow the tooltip to render outside the chart's SVG
     * element box. By default (`false`), the tooltip is rendered within the
     * chart's SVG element, which results in the tooltip being aligned
     * inside the chart area. For small charts, this may result in clipping
     * or overlapping. When `true`, a separate SVG element is created and
     * overlaid on the page, allowing the tooltip to be aligned inside the
     * page itself.
     *
     * @sample highcharts/tooltip/outside
     *         Small charts with tooltips outside
     *
     * @type      {boolean}
     * @default   false
     * @since     6.1.1
     * @apioption tooltip.outside
     */

    /**
     * A callback function for formatting the HTML output for a single point
     * in the tooltip. Like the `pointFormat` string, but with more
     * flexibility.
     *
     * @type      {Function}
     * @since     4.1.0
     * @context   Highcharts.Point
     * @apioption tooltip.pointFormatter
     */

    /**
     * A callback function to place the tooltip in a default position. The
     * callback receives three parameters: `labelWidth`, `labelHeight` and
     * `point`, where point contains values for `plotX` and `plotY` telling
     * where the reference point is in the plot area. Add `chart.plotLeft`
     * and `chart.plotTop` to get the full coordinates.
     *
     * The return should be an object containing x and y values, for example
     * `{ x: 100, y: 100 }`.
     *
     * @sample {highcharts} highcharts/tooltip/positioner/
     *         A fixed tooltip position
     * @sample {highstock} stock/tooltip/positioner/
     *         A fixed tooltip position on top of the chart
     * @sample {highmaps} maps/tooltip/positioner/
     *         A fixed tooltip position
     *
     * @type      {Function}
     * @since     2.2.4
     * @apioption tooltip.positioner
     */

    /**
     * The name of a symbol to use for the border around the tooltip. Can
     * be one of: `"callout"`, `"circle"` or `"square"`.
     *
     * Custom callbacks for symbol path generation can also be added to
     * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
     * [series.marker.symbol](plotOptions.line.marker.symbol).
     *
     * @type       {string}
     * @default    callout
     * @since      4.0
     * @validvalue ["callout", "square"]
     * @apioption  tooltip.shape
     */

    /**
     * When the tooltip is shared, the entire plot area will capture mouse
     * movement or touch events. Tooltip texts for series types with ordered
     * data (not pie, scatter, flags etc) will be shown in a single bubble.
     * This is recommended for single series charts and for tablet/mobile
     * optimized charts.
     *
     * See also [tooltip.split](#tooltip.split), that is better suited for
     * charts with many series, especially line-type series. The
     * `tooltip.split` option takes precedence over `tooltip.shared`.
     *
     * @sample {highcharts} highcharts/tooltip/shared-false/
     *         False by default
     * @sample {highcharts} highcharts/tooltip/shared-true/
     *         True
     * @sample {highcharts} highcharts/tooltip/shared-x-crosshair/
     *         True with x axis crosshair
     * @sample {highcharts} highcharts/tooltip/shared-true-mixed-types/
     *         True with mixed series types
     *
     * @type      {boolean}
     * @default   false
     * @since     2.1
     * @product   highcharts highstock
     * @apioption tooltip.shared
     */

    /**
     * Split the tooltip into one label per series, with the header close
     * to the axis. This is recommended over [shared](#tooltip.shared)
     * tooltips for charts with multiple line series, generally making them
     * easier to read. This option takes precedence over `tooltip.shared`.
     *
     * @productdesc {highstock} In Highstock, tooltips are split by default
     * since v6.0.0. Stock charts typically contain multi-dimension points
     * and multiple panes, making split tooltips the preferred layout over
     * the previous `shared` tooltip.
     *
     * @sample highcharts/tooltip/split/
     *         Split tooltip
     *
     * @type      {boolean}
     * @default   {highcharts} false
     * @default   {highstock} true
     * @since     5.0.0
     * @product   highcharts highstock
     * @apioption tooltip.split
     */

    /**
     * Use HTML to render the contents of the tooltip instead of SVG. Using
     * HTML allows advanced formatting like tables and images in the
     * tooltip. It is also recommended for rtl languages as it works around
     * rtl bugs in early Firefox.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
     *         A table for value alignment
     * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
     *         Full HTML tooltip
     * @sample {highmaps} maps/tooltip/usehtml/
     *         Pure HTML tooltip
     *
     * @type      {boolean}
     * @default   false
     * @since     2.2
     * @apioption tooltip.useHTML
     */

    /**
     * How many decimals to show in each series' y value. This is
     * overridable in each series' tooltip options object. The default is to
     * preserve all decimals.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     * @sample {highmaps} maps/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     *
     * @type      {number}
     * @since     2.2
     * @apioption tooltip.valueDecimals
     */

    /**
     * A string to prepend to each series' y value. Overridable in each
     * series' tooltip options object.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     * @sample {highmaps} maps/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     *
     * @type      {string}
     * @since     2.2
     * @apioption tooltip.valuePrefix
     */

    /**
     * A string to append to each series' y value. Overridable in each
     * series' tooltip options object.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     * @sample {highmaps} maps/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     *
     * @type      {string}
     * @since     2.2
     * @apioption tooltip.valueSuffix
     */

    /**
     * The format for the date in the tooltip header if the X axis is a
     * datetime axis. The default is a best guess based on the smallest
     * distance between points in the chart.
     *
     * @sample {highcharts} highcharts/tooltip/xdateformat/
     *         A different format
     *
     * @type      {string}
     * @product   highcharts highstock
     * @apioption tooltip.xDateFormat
     */

    /**
     * How many decimals to show for the `point.change` value when the
     * `series.compare` option is set. This is overridable in each series'
     * tooltip options object. The default is to preserve all decimals.
     *
     * @type      {number}
     * @since     1.0.1
     * @product   highstock
     * @apioption tooltip.changeDecimals
     */

    /**
     * Enable or disable the tooltip.
     *
     * @sample {highcharts} highcharts/tooltip/enabled/
     *         Disabled
     * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
     *         Disable tooltip and show values on chart instead
     */
    enabled: true,

    /**
     * Enable or disable animation of the tooltip.
     *
     * @type       {boolean}
     * @default    true
     * @since      2.3.0
     */
    animation: svg$2,

    /**
     * The radius of the rounded border corners.
     *
     * @sample {highcharts} highcharts/tooltip/bordercolor-default/
     *         5px by default
     * @sample {highcharts} highcharts/tooltip/borderradius-0/
     *         Square borders
     * @sample {highmaps} maps/tooltip/background-border/
     *         Background and border demo
     */
    borderRadius: 3,

    /**
     * For series on a datetime axes, the date format in the tooltip's
     * header will by default be guessed based on the closest data points.
     * This member gives the default string representations used for
     * each unit. For an overview of the replacement codes, see
     * [dateFormat](/class-reference/Highcharts#dateFormat).
     *
     * @see [xAxis.dateTimeLabelFormats](#xAxis.dateTimeLabelFormats)
     *
     * @type    {Highcharts.Dictionary<string>}
     * @product highcharts highstock
     */
    dateTimeLabelFormats: {
      millisecond: '%A, %b %e, %H:%M:%S.%L',
      second: '%A, %b %e, %H:%M:%S',
      minute: '%A, %b %e, %H:%M',
      hour: '%A, %b %e, %H:%M',
      day: '%A, %b %e, %Y',
      week: 'Week from %A, %b %e, %Y',
      month: '%B %Y',
      year: '%Y'
    },

    /**
     * A string to append to the tooltip format.
     *
     * @sample {highcharts} highcharts/tooltip/footerformat/
     *         A table for value alignment
     * @sample {highmaps} maps/tooltip/format/
     *         Format demo
     *
     * @since 2.2
     */
    footerFormat: '',

    /**
     * Padding inside the tooltip, in pixels.
     *
     * @since      5.0.0
     */
    padding: 8,

    /**
     * Proximity snap for graphs or single points. It defaults to 10 for
     * mouse-powered devices and 25 for touch devices.
     *
     * Note that in most cases the whole plot area captures the mouse
     * movement, and in these cases `tooltip.snap` doesn't make sense. This
     * applies when [stickyTracking](#plotOptions.series.stickyTracking)
     * is `true` (default) and when the tooltip is [shared](#tooltip.shared)
     * or [split](#tooltip.split).
     *
     * @sample {highcharts} highcharts/tooltip/bordercolor-default/
     *         10 px by default
     * @sample {highcharts} highcharts/tooltip/snap-50/
     *         50 px on graph
     *
     * @type    {number}
     * @default 10/25
     * @since   1.2.0
     * @product highcharts highstock
     */
    snap: isTouchDevice ? 25 : 10,
    headerFormat: '<span class="highcharts-header">{point.key}</span><br/>',
    pointFormat: '<span class="highcharts-color-{point.colorIndex}">' + '\u25CF</span> {series.name}: <span class="highcharts-strong">' + '{point.y}</span><br/>'
  },

  /**
   * Highchart by default puts a credits label in the lower right corner
   * of the chart. This can be changed using these options.
   */
  credits: {
    /**
     * Credits for map source to be concatenated with conventional credit
     * text. By default this is a format string that collects copyright
     * information from the map if available.
     *
     * @see [mapTextFull](#credits.mapTextFull)
     * @see [text](#credits.text)
     *
     * @type      {string}
     * @default   \u00a9 <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>
     * @since     4.2.2
     * @product   highmaps
     * @apioption credits.mapText
     */

    /**
     * Detailed credits for map source to be displayed on hover of credits
     * text. By default this is a format string that collects copyright
     * information from the map if available.
     *
     * @see [mapText](#credits.mapText)
     * @see [text](#credits.text)
     *
     * @type      {string}
     * @default   {geojson.copyright}
     * @since     4.2.2
     * @product   highmaps
     * @apioption credits.mapTextFull
     */

    /**
     * Whether to show the credits text.
     *
     * @sample {highcharts} highcharts/credits/enabled-false/
     *         Credits disabled
     * @sample {highstock} stock/credits/enabled/
     *         Credits disabled
     * @sample {highmaps} maps/credits/enabled-false/
     *         Credits disabled
     */
    enabled: true,

    /**
     * The URL for the credits label.
     *
     * @sample {highcharts} highcharts/credits/href/
     *         Custom URL and text
     * @sample {highmaps} maps/credits/customized/
     *         Custom URL and text
     */
    href: 'https://www.highcharts.com',

    /**
     * Position configuration for the credits label.
     *
     * @sample {highcharts} highcharts/credits/position-left/
     *         Left aligned
     * @sample {highcharts} highcharts/credits/position-left/
     *         Left aligned
     * @sample {highmaps} maps/credits/customized/
     *         Left aligned
     * @sample {highmaps} maps/credits/customized/
     *         Left aligned
     *
     * @since 2.1
     */
    position: {
      /**
       * Horizontal alignment of the credits.
       *
       * @validvalue ["left", "center", "right"]
       */
      align: 'right',

      /**
       * Horizontal pixel offset of the credits.
       */
      x: -10,

      /**
       * Vertical alignment of the credits.
       *
       * @validvalue ["top", "middle", "bottom"]
       */
      verticalAlign: 'bottom',

      /**
       * Vertical pixel offset of the credits.
       */
      y: -5
    },

    /**
     * The text for the credits label.
     *
     * @productdesc {highmaps}
     * If a map is loaded as GeoJSON, the text defaults to
     * `Highcharts @ {map-credits}`. Otherwise, it defaults to
     * `Highcharts.com`.
     *
     * @sample {highcharts} highcharts/credits/href/
     *         Custom URL and text
     * @sample {highmaps} maps/credits/customized/
     *         Custom URL and text
     */
    text: 'Highcharts.com'
  }
};
/**
 * Merge the default options with custom options and return the new options
 * structure. Commonly used for defining reusable templates.
 *
 * @sample highcharts/global/useutc-false Setting a global option
 * @sample highcharts/members/setoptions Applying a global theme
 *
 * @function Highcharts.setOptions
 *
 * @param {Highcharts.Options} options
 *        The new custom chart options.
 *
 * @return {Highcharts.Options}
 *         Updated options.
 */

Highcharts.setOptions = function (options) {
  // Copy in the default options
  Highcharts.defaultOptions = merge$3(true, Highcharts.defaultOptions, options); // Update the time object

  Highcharts.time.update(merge$3(Highcharts.defaultOptions.global, Highcharts.defaultOptions.time), false);
  return Highcharts.defaultOptions;
};
/**
 * Get the updated default options. Until 3.0.7, merely exposing defaultOptions
 * for outside modules wasn't enough because the setOptions method created a new
 * object.
 *
 * @function Highcharts.getOptions
 *
 * @return {Highcharts.Options}
 */


Highcharts.getOptions = function () {
  return Highcharts.defaultOptions;
}; // Series defaults


Highcharts.defaultPlotOptions = Highcharts.defaultOptions.plotOptions;
/**
 * Global `Time` object with default options. Since v6.0.5, time settings can be
 * applied individually for each chart. If no individual settings apply, this
 * `Time` object is shared by all instances.
 *
 * @name Highcharts.time
 * @type {Highcharts.Time}
 */

Highcharts.time = new Highcharts.Time(merge$3(Highcharts.defaultOptions.global, Highcharts.defaultOptions.time));
/**
 * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970) into a
 * human readable date string. The format is a subset of the formats for PHP's
 * [strftime]{@link
 * http://www.php.net/manual/en/function.strftime.php} function. Additional
 * formats can be given in the {@link Highcharts.dateFormats} hook.
 *
 * Since v6.0.5, all internal dates are formatted through the
 * [Chart.time](Chart#time) instance to respect chart-level time settings. The
 * `Highcharts.dateFormat` function only reflects global time settings set with
 * `setOptions`.
 *
 * @function Highcharts.dateFormat
 *
 * @param {string} format
 *        The desired format where various time representations are prefixed
 *        with `%`.
 *
 * @param {number} timestamp
 *        The JavaScript timestamp.
 *
 * @param {boolean} [capitalize=false]
 *        Upper case first letter in the return.
 *
 * @return {string}
 *         The formatted date.
 */

Highcharts.dateFormat = function (format, timestamp, capitalize) {
  return Highcharts.time.dateFormat(format, timestamp, capitalize);
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var correctFloat = Highcharts.correctFloat,
    defined$3 = Highcharts.defined,
    destroyObjectProperties$1 = Highcharts.destroyObjectProperties,
    fireEvent = Highcharts.fireEvent,
    isNumber$1 = Highcharts.isNumber,
    merge$4 = Highcharts.merge,
    pick$3 = Highcharts.pick,
    deg2rad$1 = Highcharts.deg2rad;
/**
 * The Tick class
 * @ignore
 */

Highcharts.Tick = function (axis, pos, type, noLabel) {
  this.axis = axis;
  this.pos = pos;
  this.type = type || '';
  this.isNew = true;
  this.isNewLabel = true;

  if (!type && !noLabel) {
    this.addLabel();
  }
};

Highcharts.Tick.prototype = {
  /**
   * Write the tick label
   */
  addLabel: function () {
    var tick = this,
        axis = tick.axis,
        options = axis.options,
        chart = axis.chart,
        categories = axis.categories,
        names = axis.names,
        pos = tick.pos,
        labelOptions = options.labels,
        str,
        tickPositions = axis.tickPositions,
        isFirst = pos === tickPositions[0],
        isLast = pos === tickPositions[tickPositions.length - 1],
        value = categories ? pick$3(categories[pos], names[pos], pos) : pos,
        label = tick.label,
        tickPositionInfo = tickPositions.info,
        dateTimeLabelFormat,
        params; // Set the datetime label format. If a higher rank is set for this
    // position, use that. If not, use the general format.

    if (axis.isDatetimeAxis && tickPositionInfo) {
      dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
    } // set properties for access in render method


    tick.isFirst = isFirst;
    tick.isLast = isLast; // Get the string. Provide params both as scope (legacy) and as first
    // parameter which allows use in arrow functions (#8580).

    params = {
      axis: axis,
      chart: chart,
      isFirst: isFirst,
      isLast: isLast,
      dateTimeLabelFormat: dateTimeLabelFormat,
      value: axis.isLog ? correctFloat(axis.lin2log(value)) : value,
      pos: pos
    };
    str = axis.labelFormatter.call(params, params); // first call

    if (!defined$3(label)) {
      tick.label = label = defined$3(str) && labelOptions.enabled ? chart.renderer.text(str, 0, 0, labelOptions.useHTML).add(axis.labelGroup) : null; // Un-rotated length

      if (label) {
        label.textPxLength = label.getBBox().width;
      } // Base value to detect change for new calls to getBBox


      tick.rotation = 0; // update
    } else if (label && label.textStr !== str) {
      // When resetting text, also reset the width if dynamically set
      // (#8809)
      if (label.textWidth && !(labelOptions.style && labelOptions.style.width) && !label.styles.width) {
        label.css({
          width: null
        });
      }

      label.attr({
        text: str
      });
    }
  },

  /**
   * Get the offset height or width of the label
   */
  getLabelSize: function () {
    return this.label ? this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] : 0;
  },

  /**
   * Handle the label overflow by adjusting the labels to the left and right
   * edge, or hide them if they collide into the neighbour label.
   */
  handleOverflow: function (xy) {
    var tick = this,
        axis = this.axis,
        labelOptions = axis.options.labels,
        pxPos = xy.x,
        chartWidth = axis.chart.chartWidth,
        spacing = axis.chart.spacing,
        leftBound = pick$3(axis.labelLeft, Math.min(axis.pos, spacing[3])),
        rightBound = pick$3(axis.labelRight, Math.max(!axis.isRadial ? axis.pos + axis.len : 0, chartWidth - spacing[1])),
        label = this.label,
        rotation = this.rotation,
        factor = {
      left: 0,
      center: 0.5,
      right: 1
    }[axis.labelAlign || label.attr('align')],
        labelWidth = label.getBBox().width,
        slotWidth = axis.getSlotWidth(tick),
        modifiedSlotWidth = slotWidth,
        xCorrection = factor,
        goRight = 1,
        leftPos,
        rightPos,
        textWidth,
        css = {}; // Check if the label overshoots the chart spacing box. If it does, move
    // it. If it now overshoots the slotWidth, add ellipsis.

    if (!rotation && pick$3(labelOptions.overflow, 'justify') === 'justify') {
      leftPos = pxPos - factor * labelWidth;
      rightPos = pxPos + (1 - factor) * labelWidth;

      if (leftPos < leftBound) {
        modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
      } else if (rightPos > rightBound) {
        modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;
        goRight = -1;
      }

      modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177

      if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {
        xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));
      } // If the label width exceeds the available space, set a text width
      // to be picked up below. Also, if a width has been set before, we
      // need to set a new one because the reported labelWidth will be
      // limited by the box (#3938).


      if (labelWidth > modifiedSlotWidth || axis.autoRotation && (label.styles || {}).width) {
        textWidth = modifiedSlotWidth;
      } // Add ellipsis to prevent rotated labels to be clipped against the edge
      // of the chart

    } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
      textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad$1) - leftBound);
    } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
      textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad$1));
    }

    if (textWidth) {
      css.width = textWidth;

      if (!(labelOptions.style || {}).textOverflow) {
        css.textOverflow = 'ellipsis';
      }

      label.css(css);
    }
  },

  /**
   * Get the x and y position for ticks and labels
   */
  getPosition: function (horiz, tickPos, tickmarkOffset, old) {
    var axis = this.axis,
        chart = axis.chart,
        cHeight = old && chart.oldChartHeight || chart.chartHeight,
        pos;
    pos = {
      x: horiz ? Highcharts.correctFloat(axis.translate(tickPos + tickmarkOffset, null, null, old) + axis.transB) : axis.left + axis.offset + (axis.opposite ? (old && chart.oldChartWidth || chart.chartWidth) - axis.right - axis.left : 0),
      y: horiz ? cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : Highcharts.correctFloat(cHeight - axis.translate(tickPos + tickmarkOffset, null, null, old) - axis.transB)
    };
    fireEvent(this, 'afterGetPosition', {
      pos: pos
    });
    return pos;
  },

  /**
   * Get the x, y position of the tick label
   */
  getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
    var axis = this.axis,
        transA = axis.transA,
        reversed = axis.reversed,
        staggerLines = axis.staggerLines,
        rotCorr = axis.tickRotCorr || {
      x: 0,
      y: 0
    },
        yOffset = labelOptions.y,
        // Adjust for label alignment if we use reserveSpace: true (#5286)
    labelOffsetCorrection = !horiz && !axis.reserveSpaceDefault ? -axis.labelOffset * (axis.labelAlign === 'center' ? 0.5 : 1) : 0,
        line,
        pos = {};

    if (!defined$3(yOffset)) {
      if (axis.side === 0) {
        yOffset = label.rotation ? -8 : -label.getBBox().height;
      } else if (axis.side === 2) {
        yOffset = rotCorr.y + 8;
      } else {
        // #3140, #3140
        yOffset = Math.cos(label.rotation * deg2rad$1) * (rotCorr.y - label.getBBox(false, 0).height / 2);
      }
    }

    x = x + labelOptions.x + labelOffsetCorrection + rotCorr.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
    y = y + yOffset - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0); // Correct for staggered labels

    if (staggerLines) {
      line = index / (step || 1) % staggerLines;

      if (axis.opposite) {
        line = staggerLines - line - 1;
      }

      y += line * (axis.labelOffset / staggerLines);
    }

    pos.x = x;
    pos.y = Math.round(y);
    fireEvent(this, 'afterGetLabelPosition', {
      pos: pos
    });
    return pos;
  },

  /**
   * Extendible method to return the path of the marker
   */
  getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
    return renderer.crispLine(['M', x, y, 'L', x + (horiz ? 0 : -tickLength), y + (horiz ? tickLength : 0)], tickWidth);
  },

  /**
   * Renders the gridLine.
   * @param  {Boolean} old         Whether or not the tick is old
   * @param  {number} opacity      The opacity of the grid line
   * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1
   * @return {undefined}
   */
  renderGridLine: function (old, opacity, reverseCrisp) {
    var tick = this,
        axis = tick.axis,
        options = axis.options,
        gridLine = tick.gridLine,
        gridLinePath,
        attribs = {},
        pos = tick.pos,
        type = tick.type,
        tickmarkOffset = axis.tickmarkOffset,
        renderer = axis.chart.renderer;

    if (!gridLine) {
      if (!type) {
        attribs.zIndex = 1;
      }

      if (old) {
        attribs.opacity = 0;
      }

      tick.gridLine = gridLine = renderer.path().attr(attribs).addClass('highcharts-' + (type ? type + '-' : '') + 'grid-line').add(axis.gridGroup);
    } // If the parameter 'old' is set, the current call will be followed
    // by another call, therefore do not do any animations this time


    if (!old && gridLine) {
      gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLine.strokeWidth() * reverseCrisp, old, true);

      if (gridLinePath) {
        gridLine[tick.isNew ? 'attr' : 'animate']({
          d: gridLinePath,
          opacity: opacity
        });
      }
    }
  },

  /**
   * Renders the tick mark.
   * @param  {Object} xy           The position vector of the mark
   * @param  {number} xy.x         The x position of the mark
   * @param  {number} xy.y         The y position of the mark
   * @param  {number} opacity      The opacity of the mark
   * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1
   * @return {undefined}
   */
  renderMark: function (xy, opacity, reverseCrisp) {
    var tick = this,
        axis = tick.axis,
        options = axis.options,
        renderer = axis.chart.renderer,
        type = tick.type,
        tickPrefix = type ? type + 'Tick' : 'tick',
        tickSize = axis.tickSize(tickPrefix),
        mark = tick.mark,
        isNewMark = !mark,
        x = xy.x,
        y = xy.y;

    if (tickSize) {
      // negate the length
      if (axis.opposite) {
        tickSize[0] = -tickSize[0];
      } // First time, create it


      if (isNewMark) {
        tick.mark = mark = renderer.path().addClass('highcharts-' + (type ? type + '-' : '') + 'tick').add(axis.axisGroup);
      }

      mark[isNewMark ? 'attr' : 'animate']({
        d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth() * reverseCrisp, axis.horiz, renderer),
        opacity: opacity
      });
    }
  },

  /**
   * Renders the tick label.
   * Note: The label should already be created in init(), so it should only
   * have to be moved into place.
   * @param  {Object} xy      The position vector of the label
   * @param  {number} xy.x    The x position of the label
   * @param  {number} xy.y    The y position of the label
   * @param  {Boolean} old    Whether or not the tick is old
   * @param  {number} opacity The opacity of the label
   * @param  {number} index   The index of the tick
   * @return {undefined}
   */
  renderLabel: function (xy, old, opacity, index) {
    var tick = this,
        axis = tick.axis,
        horiz = axis.horiz,
        options = axis.options,
        label = tick.label,
        labelOptions = options.labels,
        step = labelOptions.step,
        tickmarkOffset = axis.tickmarkOffset,
        show = true,
        x = xy.x,
        y = xy.y;

    if (label && isNumber$1(x)) {
      label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step); // Apply show first and show last. If the tick is both first and
      // last, it is a single centered tick, in which case we show the
      // label anyway (#2100).

      if (tick.isFirst && !tick.isLast && !pick$3(options.showFirstLabel, 1) || tick.isLast && !tick.isFirst && !pick$3(options.showLastLabel, 1)) {
        show = false; // Handle label overflow and show or hide accordingly
      } else if (horiz && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
        tick.handleOverflow(xy);
      } // apply step


      if (step && index % step) {
        // show those indices dividable by step
        show = false;
      } // Set the new position, and show or hide


      if (show && isNumber$1(xy.y)) {
        xy.opacity = opacity;
        label[tick.isNewLabel ? 'attr' : 'animate'](xy);
        tick.isNewLabel = false;
      } else {
        label.attr('y', -9999); // #1338

        tick.isNewLabel = true;
      }
    }
  },

  /**
   * Put everything in place
   *
   * @param index {Number}
   * @param old {Boolean} Use old coordinates to prepare an animation into new
   *                      position
   */
  render: function (index, old, opacity) {
    var tick = this,
        axis = tick.axis,
        horiz = axis.horiz,
        pos = tick.pos,
        tickmarkOffset = axis.tickmarkOffset,
        xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
        x = xy.x,
        y = xy.y,
        reverseCrisp = horiz && x === axis.pos + axis.len || !horiz && y === axis.pos ? -1 : 1; // #1480, #1687

    opacity = pick$3(opacity, 1);
    this.isActive = true; // Create the grid line

    this.renderGridLine(old, opacity, reverseCrisp); // create the tick mark

    this.renderMark(xy, opacity, reverseCrisp); // the label is created on init - now move it into place

    this.renderLabel(xy, old, opacity, index);
    tick.isNew = false;
    Highcharts.fireEvent(this, 'afterRender');
  },

  /**
   * Destructor for the tick prototype
   */
  destroy: function () {
    destroyObjectProperties$1(this, this.axis);
  }
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$1 = Highcharts.addEvent,
    animObject = Highcharts.animObject,
    arrayMax = Highcharts.arrayMax,
    arrayMin = Highcharts.arrayMin,
    color$2 = Highcharts.color,
    correctFloat$1 = Highcharts.correctFloat,
    defaultOptions = Highcharts.defaultOptions,
    defined$4 = Highcharts.defined,
    deg2rad$2 = Highcharts.deg2rad,
    destroyObjectProperties$2 = Highcharts.destroyObjectProperties,
    each$4 = Highcharts.each,
    extend$3 = Highcharts.extend,
    fireEvent$1 = Highcharts.fireEvent,
    format = Highcharts.format,
    getMagnitude = Highcharts.getMagnitude,
    grep$1 = Highcharts.grep,
    inArray$1 = Highcharts.inArray,
    isArray$1 = Highcharts.isArray,
    isNumber$2 = Highcharts.isNumber,
    isString$2 = Highcharts.isString,
    merge$5 = Highcharts.merge,
    normalizeTickInterval = Highcharts.normalizeTickInterval,
    objectEach$1 = Highcharts.objectEach,
    pick$4 = Highcharts.pick,
    removeEvent$1 = Highcharts.removeEvent,
    splat$1 = Highcharts.splat,
    syncTimeout = Highcharts.syncTimeout,
    Tick = Highcharts.Tick;
/**
 * Create a new axis object. Called internally when instanciating a new chart or
 * adding axes by {@link Highcharts.Chart#addAxis}.
 *
 * A chart can have from 0 axes (pie chart) to multiples. In a normal, single
 * series cartesian chart, there is one X axis and one Y axis.
 *
 * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is
 * an array of Axis objects. If there is only one axis, it can be referenced
 * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same
 * pattern goes for Y axes.
 *
 * If you need to get the axes from a series object, use the `series.xAxis` and
 * `series.yAxis` properties. These are not arrays, as one series can only be
 * associated to one X and one Y axis.
 *
 * A third way to reference the axis programmatically is by `id`. Add an `id` in
 * the axis configuration options, and get the axis by
 * {@link Highcharts.Chart#get}.
 *
 * Configuration options for the axes are given in options.xAxis and
 * options.yAxis.
 *
 * @class
 * @name Highcharts.Axis
 *
 * @param {Highcharts.Chart} chart
 *        The Chart instance to apply the axis on.
 *
 * @param {Highcharts.AxisOptions} options
 *        Axis options.
 */

var Axis = function () {
  this.init.apply(this, arguments);
};

Highcharts.extend(Axis.prototype,
/** @lends Highcharts.Axis.prototype */
{
  /**
   * The X axis or category axis. Normally this is the horizontal axis,
   * though if the chart is inverted this is the vertical axis. In case of
   * multiple axes, the xAxis node is an array of configuration objects.
   *
   * See [the Axis object](/class-reference/Highcharts.Axis) for
   * programmatic access to the axis.
   *
   * @productdesc {highmaps}
   * In Highmaps, the axis is hidden, but it is used behind the scenes to
   * control features like zooming and panning. Zooming is in effect the same
   * as setting the extremes of one of the exes.
   *
   * @optionparent xAxis
   */
  defaultOptions: {
    /**
     * When using multiple axis, the ticks of two or more opposite axes
     * will automatically be aligned by adding ticks to the axis or axes
     * with the least ticks, as if `tickAmount` were specified.
     *
     * This can be prevented by setting `alignTicks` to false. If the grid
     * lines look messy, it's a good idea to hide them for the secondary
     * axis by setting `gridLineWidth` to 0.
     *
     * If `startOnTick` or `endOnTick` in an Axis options are set to false,
     * then the `alignTicks ` will be disabled for the Axis.
     *
     * Disabled for logarithmic axes.
     *
     * @type      {boolean}
     * @default   true
     * @product   highcharts highstock
     * @apioption xAxis.alignTicks
     */

    /**
     * Whether to allow decimals in this axis' ticks. When counting
     * integers, like persons or hits on a web page, decimals should
     * be avoided in the labels.
     *
     * @see [minTickInterval](#xAxis.minTickInterval)
     *
     * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-true/
     *         True by default
     * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-false/
     *         False
     *
     * @type      {boolean}
     * @default   true
     * @since     2.0
     * @apioption xAxis.allowDecimals
     */

    /**
     * When using an alternate grid color, a band is painted across the
     * plot area between every other grid line.
     *
     * @sample {highcharts} highcharts/yaxis/alternategridcolor/
     *         Alternate grid color on the Y axis
     * @sample {highstock} stock/xaxis/alternategridcolor/
     *         Alternate grid color on the Y axis
     *
     * @type      {Highcharts.ColorString}
     * @apioption xAxis.alternateGridColor
     */

    /**
     * An array defining breaks in the axis, the sections defined will be
     * left out and all the points shifted closer to each other.
     *
     * @productdesc {highcharts}
     * Requires that the broken-axis.js module is loaded.
     *
     * @sample {highcharts} highcharts/axisbreak/break-simple/
     *         Simple break
     * @sample {highcharts|highstock} highcharts/axisbreak/break-visualized/
     *         Advanced with callback
     * @sample {highstock} stock/demo/intraday-breaks/
     *         Break on nights and weekends
     *
     * @type      {Array<*>}
     * @since     4.1.0
     * @product   highcharts highstock
     * @apioption xAxis.breaks
     */

    /**
     * A number indicating how much space should be left between the start
     * and the end of the break. The break size is given in axis units,
     * so for instance on a `datetime` axis, a break size of 3600000 would
     * indicate the equivalent of an hour.
     *
     * @type      {number}
     * @default   0
     * @since     4.1.0
     * @product   highcharts highstock
     * @apioption xAxis.breaks.breakSize
     */

    /**
     * The point where the break starts.
     *
     * @type      {number}
     * @since     4.1.0
     * @product   highcharts highstock
     * @apioption xAxis.breaks.from
     */

    /**
     * Defines an interval after which the break appears again. By default
     * the breaks do not repeat.
     *
     * @type      {number}
     * @default   0
     * @since     4.1.0
     * @product   highcharts highstock
     * @apioption xAxis.breaks.repeat
     */

    /**
     * The point where the break ends.
     *
     * @type      {number}
     * @since     4.1.0
     * @product   highcharts highstock
     * @apioption xAxis.breaks.to
     */

    /**
     * If categories are present for the xAxis, names are used instead of
     * numbers for that axis. Since Highcharts 3.0, categories can also
     * be extracted by giving each point a [name](#series.data) and setting
     * axis [type](#xAxis.type) to `category`. However, if you have multiple
     * series, best practice remains defining the `categories` array.
     *
     * Example:
     *
     * <pre>categories: ['Apples', 'Bananas', 'Oranges']</pre>
     *
     * @sample {highcharts} highcharts/demo/line-labels/
     *         With
     * @sample {highcharts} highcharts/xaxis/categories/
     *         Without
     *
     * @type      {Array<string>}
     * @product   highcharts
     * @apioption xAxis.categories
     */

    /**
     * The highest allowed value for automatically computed axis extremes.
     *
     * @see [floor](#xAxis.floor)
     *
     * @sample {highcharts|highstock} highcharts/yaxis/floor-ceiling/
     *         Floor and ceiling
     *
     * @type       {number}
     * @since      4.0
     * @product    highcharts highstock
     * @apioption  xAxis.ceiling
     */

    /**
     * A class name that opens for styling the axis by CSS, especially in
     * Highcharts styled mode. The class name is applied to group elements
     * for the grid, axis elements and labels.
     *
     * @sample {highcharts|highstock|highmaps} highcharts/css/axis/
     *         Multiple axes with separate styling
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption xAxis.className
     */

    /**
     * Configure a crosshair that follows either the mouse pointer or the
     * hovered point.
     *
     * In styled mode, the crosshairs are styled in the
     * `.highcharts-crosshair`, `.highcharts-crosshair-thin` or
     * `.highcharts-xaxis-category` classes.
     *
     * @productdesc {highstock}
     * In Highstock, by default, the crosshair is enabled on the X axis and
     * disabled on the Y axis.
     *
     * @sample {highcharts} highcharts/xaxis/crosshair-both/
     *         Crosshair on both axes
     * @sample {highstock} stock/xaxis/crosshairs-xy/
     *         Crosshair on both axes
     * @sample {highmaps} highcharts/xaxis/crosshair-both/
     *         Crosshair on both axes
     *
     * @type      {boolean|*}
     * @default   false
     * @since     4.1
     * @apioption xAxis.crosshair
     */

    /**
     * A class name for the crosshair, especially as a hook for styling.
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption xAxis.crosshair.className
     */

    /**
     * The color of the crosshair. Defaults to `#cccccc` for numeric and
     * datetime axes, and `rgba(204,214,235,0.25)` for category axes, where
     * the crosshair by default highlights the whole category.
     *
     * @sample {highcharts|highstock|highmaps} highcharts/xaxis/crosshair-customized/
     *         Customized crosshairs
     *
     * @type      {Highcharts.ColorString}
     * @default   #cccccc
     * @since     4.1
     * @apioption xAxis.crosshair.color
     */

    /**
     * The dash style for the crosshair. See
     * [series.dashStyle](#plotOptions.series.dashStyle)
     * for possible values.
     *
     * @sample {highcharts|highmaps} highcharts/xaxis/crosshair-dotted/
     *         Dotted crosshair
     * @sample {highstock} stock/xaxis/crosshair-dashed/
     *         Dashed X axis crosshair
     *
     * @type       {string}
     * @default    Solid
     * @since      4.1
     * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
     *             "ShortDashDotDot", "Dot", "Dash" ,"LongDash", "DashDot",
     *             "LongDashDot", "LongDashDotDot"]
     * @apioption  xAxis.crosshair.dashStyle
     */

    /**
     * A label on the axis next to the crosshair.
     *
     * In styled mode, the label is styled with the
     * `.highcharts-crosshair-label` class.
     *
     * @sample {highstock} stock/xaxis/crosshair-label/
     *         Crosshair labels
     * @sample {highstock} highcharts/css/crosshair-label/
     *         Style mode
     *
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label
     */

    /**
     * Alignment of the label compared to the axis. Defaults to `left` for
     * right-side axes, `right` for left-side axes and `center` for
     * horizontal axes.
     *
     * @type      {string}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.align
     */

    /**
     * The background color for the label. Defaults to the related series
     * color, or `#666666` if that is not available.
     *
     * @type      {Highcharts.ColorString}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.backgroundColor
     */

    /**
     * The border color for the crosshair label
     *
     * @type      {Highcharts.ColorString}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.borderColor
     */

    /**
     * The border corner radius of the crosshair label.
     *
     * @type      {number}
     * @default   3
     * @since     2.1.10
     * @product   highstock
     * @apioption xAxis.crosshair.label.borderRadius
     */

    /**
     * The border width for the crosshair label.
     *
     * @type      {number}
     * @default   0
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.borderWidth
     */

    /**
     * A format string for the crosshair label. Defaults to `{value}` for
     * numeric axes and `{value:%b %d, %Y}` for datetime axes.
     *
     * @type      {string}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.format
     */

    /**
     * Formatter function for the label text.
     *
     * @type      {Highcharts.FormatterCallbackFunction}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.formatter
     */

    /**
     * Padding inside the crosshair label.
     *
     * @type      {number}
     * @default   8
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.padding
     */

    /**
     * The shape to use for the label box.
     *
     * @type      {string}
     * @default   callout
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.shape
     */

    /**
     * Text styles for the crosshair label.
     *
     * @type      {Highcharts.CSSObject}
     * @default   {"color": "white", "fontWeight": "normal", "fontSize": "11px", "textAlign": "center"}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.style
     */

    /**
     * Whether the crosshair should snap to the point or follow the pointer
     * independent of points.
     *
     * @sample {highcharts|highstock} highcharts/xaxis/crosshair-snap-false/
     *         True by default
     * @sample {highmaps} maps/demo/latlon-advanced/
     *         Snap is false
     *
     * @type      {boolean}
     * @default   true
     * @since     4.1
     * @apioption xAxis.crosshair.snap
     */

    /**
     * The pixel width of the crosshair. Defaults to 1 for numeric or
     * datetime axes, and for one category width for category axes.
     *
     * @sample {highcharts} highcharts/xaxis/crosshair-customized/
     *         Customized crosshairs
     * @sample {highstock} highcharts/xaxis/crosshair-customized/
     *         Customized crosshairs
     * @sample {highmaps} highcharts/xaxis/crosshair-customized/
     *         Customized crosshairs
     *
     * @type      {number}
     * @default   1
     * @since     4.1
     * @apioption xAxis.crosshair.width
     */

    /**
     * The Z index of the crosshair. Higher Z indices allow drawing the
     * crosshair on top of the series or behind the grid lines.
     *
     * @type      {number}
     * @default   2
     * @since     4.1
     * @apioption xAxis.crosshair.zIndex
     */

    /**
     * For a datetime axis, the scale will automatically adjust to the
     * appropriate unit. This member gives the default string
     * representations used for each unit. For intermediate values,
     * different units may be used, for example the `day` unit can be used
     * on midnight and `hour` unit be used for intermediate values on the
     * same axis. For an overview of the replacement codes, see
     * [dateFormat](/class-reference/Highcharts#dateFormat). Defaults to:
     *
     * <pre>{
     *     millisecond: '%H:%M:%S.%L',
     *     second: '%H:%M:%S',
     *     minute: '%H:%M',
     *     hour: '%H:%M',
     *     day: '%e. %b',
     *     week: '%e. %b',
     *     month: '%b \'%y',
     *     year: '%Y'
     * }</pre>
     *
     * @sample {highcharts} highcharts/xaxis/datetimelabelformats/
     *         Different day format on X axis
     * @sample {highstock} stock/xaxis/datetimelabelformats/
     *         More information in x axis labels
     *
     * @product highcharts highstock
     */
    dateTimeLabelFormats: {
      millisecond: '%H:%M:%S.%L',
      second: '%H:%M:%S',
      minute: '%H:%M',
      hour: '%H:%M',
      day: '%e. %b',
      week: '%e. %b',
      month: '%b \'%y',
      year: '%Y'
    },

    /**
     * _Requires Accessibility module_
     *
     * Description of the axis to screen reader users.
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption xAxis.description
     */

    /**
     * Whether to force the axis to end on a tick. Use this option with
     * the `maxPadding` option to control the axis end.
     *
     * @productdesc {highstock}
     * In Highstock, `endOnTick` is always false when the navigator is
     * enabled, to prevent jumpy scrolling.
     *
     * @sample {highcharts} highcharts/chart/reflow-true/
     *         True by default
     * @sample {highcharts} highcharts/yaxis/endontick/
     *         False
     * @sample {highstock} stock/demo/basic-line/
     *         True by default
     * @sample {highstock} stock/xaxis/endontick/
     *         False
     *
     * @since 1.2.0
     */
    endOnTick: false,

    /**
     * Event handlers for the axis.
     *
     * @type      {*}
     * @apioption xAxis.events
     */

    /**
     * An event fired after the breaks have rendered.
     *
     * @see [breaks](#xAxis.breaks)
     *
     * @sample {highcharts} highcharts/axisbreak/break-event/
     *         AfterBreak Event
     *
     * @type      {Function}
     * @since     4.1.0
     * @product   highcharts
     * @apioption xAxis.events.afterBreaks
     */

    /**
     * As opposed to the `setExtremes` event, this event fires after the
     * final min and max values are computed and corrected for `minRange`.
     *
     *
     * Fires when the minimum and maximum is set for the axis, either by
     * calling the `.setExtremes()` method or by selecting an area in the
     * chart. One parameter, `event`, is passed to the function, containing
     * common event information.
     *
     * The new user set minimum and maximum values can be found by
     * `event.min` and `event.max`. These reflect the axis minimum and
     * maximum in axis values. The actual data extremes are found in
     * `event.dataMin` and `event.dataMax`.
     *
     * @type      {Function}
     * @since     2.3
     * @context   Axis
     * @apioption xAxis.events.afterSetExtremes
     */

    /**
     * An event fired when a break from this axis occurs on a point.
     *
     * @see [breaks](#xAxis.breaks)
     *
     * @sample {highcharts} highcharts/axisbreak/break-visualized/
     *         Visualization of a Break
     *
     * @type      {Function}
     * @since     4.1.0
     * @product   highcharts
     * @context   Axis
     * @apioption xAxis.events.pointBreak
     */

    /**
     * An event fired when a point falls inside a break from this axis.
     *
     * @type      {Function}
     * @product   highcharts highstock
     * @context   Axis
     * @apioption xAxis.events.pointInBreak
     */

    /**
     * Fires when the minimum and maximum is set for the axis, either by
     * calling the `.setExtremes()` method or by selecting an area in the
     * chart. One parameter, `event`, is passed to the function,
     * containing common event information.
     *
     * The new user set minimum and maximum values can be found by
     * `event.min` and `event.max`. These reflect the axis minimum and
     * maximum in data values. When an axis is zoomed all the way out from
     * the "Reset zoom" button, `event.min` and `event.max` are null, and
     * the new extremes are set based on `this.dataMin` and `this.dataMax`.
     *
     * @sample {highstock} stock/xaxis/events-setextremes/
     *         Log new extremes on x axis
     *
     * @type      {Function}
     * @since     1.2.0
     * @context   Axis
     * @apioption xAxis.events.setExtremes
     */

    /**
     * The lowest allowed value for automatically computed axis extremes.
     *
     * @see [ceiling](#yAxis.ceiling)
     *
     * @sample {highcharts} highcharts/yaxis/floor-ceiling/
     *         Floor and ceiling
     * @sample {highstock} stock/demo/lazy-loading/
     *         Prevent negative stock price on Y axis
     *
     * @type      {number}
     * @since     4.0
     * @product   highcharts highstock
     * @apioption xAxis.floor
     */

    /**
     * The dash or dot style of the grid lines. For possible values, see
     * [this demonstration](https://jsfiddle.net/gh/get/library/pure/
     * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/
     * series-dashstyle-all/).
     *
     * @sample {highcharts} highcharts/yaxis/gridlinedashstyle/
     *         Long dashes
     * @sample {highstock} stock/xaxis/gridlinedashstyle/
     *         Long dashes
     *
     * @type       {string}
     * @default    Solid
     * @since      1.2
     * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
     *             "ShortDashDotDot", "Dot", "Dash" ,"LongDash", "DashDot",
     *             "LongDashDot", "LongDashDotDot"]
     * @apioption  xAxis.gridLineDashStyle
     */

    /**
     * The Z index of the grid lines.
     *
     * @sample {highcharts|highstock} highcharts/xaxis/gridzindex/
     *         A Z index of 4 renders the grid above the graph
     *
     * @type      {number}
     * @default   1
     * @product   highcharts highstock
     * @apioption xAxis.gridZIndex
     */

    /**
     * An id for the axis. This can be used after render time to get
     * a pointer to the axis object through `chart.get()`.
     *
     * @sample {highcharts} highcharts/xaxis/id/
     *         Get the object
     * @sample {highstock} stock/xaxis/id/
     *         Get the object
     *
     * @type      {string}
     * @since     1.2.0
     * @apioption xAxis.id
     */

    /**
     * The axis labels show the number or category for each tick.
     *
     * @productdesc {highmaps}
     * X and Y axis labels are by default disabled in Highmaps, but the
     * functionality is inherited from Highcharts and used on `colorAxis`,
     * and can be enabled on X and Y axes too.
     */
    labels: {
      /**
       * What part of the string the given position is anchored to.
       * If `left`, the left side of the string is at the axis position.
       * Can be one of `"left"`, `"center"` or `"right"`. Defaults to
       * an intelligent guess based on which side of the chart the axis
       * is on and the rotation of the label.
       *
       * @see [reserveSpace](#xAxis.labels.reserveSpace)
       *
       * @sample {highcharts} highcharts/xaxis/labels-align-left/
       *         Left
       * @sample {highcharts} highcharts/xaxis/labels-align-right/
       *         Right
       * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
       *         Left-aligned labels on a vertical category axis
       *
       * @type       {string}
       * @validvalue ["left", "center", "right"]
       * @apioption  xAxis.labels.align
       */

      /**
       * For horizontal axes, the allowed degrees of label rotation
       * to prevent overlapping labels. If there is enough space,
       * labels are not rotated. As the chart gets narrower, it
       * will start rotating the labels -45 degrees, then remove
       * every second label and try again with rotations 0 and -45 etc.
       * Set it to `false` to disable rotation, which will
       * cause the labels to word-wrap if possible.
       *
       * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-default/
       *         Default auto rotation of 0 or -45
       * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-0-90/
       *         Custom graded auto rotation
       *
       * @type      {Array<number>}
       * @default   [-45]
       * @since     4.1.0
       * @product   highcharts highstock
       * @apioption xAxis.labels.autoRotation
       */

      /**
       * When each category width is more than this many pixels, we don't
       * apply auto rotation. Instead, we lay out the axis label with word
       * wrap. A lower limit makes sense when the label contains multiple
       * short words that don't extend the available horizontal space for
       * each label.
       *
       * @sample {highcharts} highcharts/xaxis/labels-autorotationlimit/
       *         Lower limit
       *
       * @type      {number}
       * @default   80
       * @since     4.1.5
       * @product   highcharts
       * @apioption xAxis.labels.autoRotationLimit
       */

      /**
       * Polar charts only. The label's pixel distance from the perimeter
       * of the plot area.
       *
       * @type      {number}
       * @default   15
       * @product   highcharts
       * @apioption xAxis.labels.distance
       */

      /**
       * Enable or disable the axis labels.
       *
       * @sample {highcharts} highcharts/xaxis/labels-enabled/
       *         X axis labels disabled
       * @sample {highstock} stock/xaxis/labels-enabled/
       *         X axis labels disabled
       *
       * @default {highcharts|highstock} true
       * @default {highmaps} false
       */
      enabled: true,

      /**
       * A [format string](https://www.highcharts.com/docs/chart-
       * concepts/labels-and-string-formatting) for the axis label.
       *
       * @sample {highcharts|highstock} highcharts/yaxis/labels-format/
       *         Add units to Y axis label
       *
       * @type      {string}
       * @default   {value}
       * @since     3.0
       * @apioption xAxis.labels.format
       */

      /**
       * Callback JavaScript function to format the label. The value
       * is given by `this.value`. Additional properties for `this` are
       * `axis`, `chart`, `isFirst` and `isLast`. The value of the default
       * label formatter can be retrieved by calling
       * `this.axis.defaultLabelFormatter.call(this)` within the function.
       *
       * Defaults to:
       *
       * <pre>function() {
       *     return this.value;
       * }</pre>
       *
       * @sample {highcharts} highcharts/xaxis/labels-formatter-linked/
       *         Linked category names
       * @sample {highcharts} highcharts/xaxis/labels-formatter-extended/
       *         Modified numeric labels
       * @sample {highstock} stock/xaxis/labels-formatter/
       *         Added units on Y axis
       *
       * @type      {Function}
       * @apioption xAxis.labels.formatter
       */

      /**
       * Horizontal axis only. When `staggerLines` is not set,
       * `maxStaggerLines` defines how many lines the axis is allowed to
       * add to automatically avoid overlapping X labels. Set to `1` to
       * disable overlap detection.
       *
       * @deprecated
       * @type      {number}
       * @default   5
       * @since     1.3.3
       * @product   highstock highmaps
       * @apioption xAxis.labels.maxStaggerLines
       */

      /**
       * How to handle overflowing labels on horizontal axis. If set to
       * `"allow"`, it will not be aligned at all. By default it
       * `"justify"` labels inside the chart area. If there is room to
       * move it, it will be aligned to the edge, else it will be removed.
       *
       * @type       {boolean|string}
       * @default    justify
       * @since      2.2.5
       * @validvalue ["allow", "justify"]
       * @apioption  xAxis.labels.overflow
       */

      /**
       * The pixel padding for axis labels, to ensure white space between
       * them.
       *
       * @type      {number}
       * @default   5
       * @product   highcharts
       * @apioption xAxis.labels.padding
       */

      /**
       * Whether to reserve space for the labels. By default, space is
       * reserved for the labels in these cases:
       *
       * * On all horizontal axes.
       * * On vertical axes if `label.align` is `right` on a left-side
       * axis or `left` on a right-side axis.
       * * On vertical axes if `label.align` is `center`.
       *
       * This can be turned off when for example the labels are rendered
       * inside the plot area instead of outside.
       *
       * @see [labels.align](#xAxis.labels.align)
       *
       * @sample {highcharts} highcharts/xaxis/labels-reservespace/
       *         No reserved space, labels inside plot
       * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
       *         Left-aligned labels on a vertical category axis
       *
       * @type      {boolean}
       * @since     4.1.10
       * @product   highcharts
       * @apioption xAxis.labels.reserveSpace
       */

      /**
       * Rotation of the labels in degrees.
       *
       * @sample {highcharts} highcharts/xaxis/labels-rotation/
       *         X axis labels rotated 90°
       *
       * @type      {number}
       * @default   0
       * @apioption xAxis.labels.rotation
       */

      /**
       * Horizontal axes only. The number of lines to spread the labels
       * over to make room or tighter labels.
       *
       * @sample {highcharts} highcharts/xaxis/labels-staggerlines/
       *         Show labels over two lines
       * @sample {highstock} stock/xaxis/labels-staggerlines/
       *         Show labels over two lines
       *
       * @type      {number}
       * @since     2.1
       * @apioption xAxis.labels.staggerLines
       */

      /**
       * To show only every _n_'th label on the axis, set the step to _n_.
       * Setting the step to 2 shows every other label.
       *
       * By default, the step is calculated automatically to avoid
       * overlap. To prevent this, set it to 1\. This usually only
       * happens on a category axis, and is often a sign that you have
       * chosen the wrong axis type.
       *
       * Read more at
       * [Axis docs](https://www.highcharts.com/docs/chart-concepts/axes)
       * => What axis should I use?
       *
       * @sample {highcharts} highcharts/xaxis/labels-step/
       *         Showing only every other axis label on a categorized
       *         x-axis
       * @sample {highcharts} highcharts/xaxis/labels-step-auto/
       *         Auto steps on a category axis
       *
       * @type      {number}
       * @since     2.1
       * @apioption xAxis.labels.step
       */

      /**
       * Whether to [use HTML](https://www.highcharts.com/docs/chart-
       * concepts/labels-and-string-formatting#html) to render the labels.
       *
       * @type      {boolean}
       * @default   false
       * @apioption xAxis.labels.useHTML
       */

      /**
       * The x position offset of the label relative to the tick position
       * on the axis.
       *
       * @sample {highcharts} highcharts/xaxis/labels-x/
       *         Y axis labels placed on grid lines
       */
      x: 0
      /**
       * The y position offset of the label relative to the tick position
       * on the axis. The default makes it adapt to the font size on
       * bottom axis.
       *
       * @sample {highcharts} highcharts/xaxis/labels-x/
       *         Y axis labels placed on grid lines
       *
       * @type      {number}
       * @apioption xAxis.labels.y
       */

      /**
       * The Z index for the axis labels.
       *
       * @type      {number}
       * @default   7
       * @apioption xAxis.labels.zIndex
       */

    },

    /**
     * Index of another axis that this axis is linked to. When an axis is
     * linked to a master axis, it will take the same extremes as
     * the master, but as assigned by min or max or by setExtremes.
     * It can be used to show additional info, or to ease reading the
     * chart by duplicating the scales.
     *
     * @sample {highcharts} highcharts/xaxis/linkedto/
     *         Different string formats of the same date
     * @sample {highcharts} highcharts/yaxis/linkedto/
     *         Y values on both sides
     *
     * @type      {number}
     * @since     2.0.2
     * @product   highcharts highstock
     * @apioption xAxis.linkedTo
     */

    /**
     * The maximum value of the axis. If `null`, the max value is
     * automatically calculated.
     *
     * If the [endOnTick](#yAxis.endOnTick) option is true, the `max` value
     * might be rounded up.
     *
     * If a [tickAmount](#yAxis.tickAmount) is set, the axis may be extended
     * beyond the set max in order to reach the given number of ticks. The
     * same may happen in a chart with multiple axes, determined by [chart.
     * alignTicks](#chart), where a `tickAmount` is applied internally.
     *
     * @sample {highcharts} highcharts/yaxis/max-200/
     *         Y axis max of 200
     * @sample {highcharts} highcharts/yaxis/max-logarithmic/
     *         Y axis max on logarithmic axis
     * @sample {highstock} stock/xaxis/min-max/
     *         Fixed min and max on X axis
     * @sample {highmaps} maps/axis/min-max/
     *         Pre-zoomed to a specific area
     *
     * @type      {number}
     * @apioption xAxis.max
     */

    /**
     * Padding of the max value relative to the length of the axis. A
     * padding of 0.05 will make a 100px axis 5px longer. This is useful
     * when you don't want the highest data value to appear on the edge
     * of the plot area. When the axis' `max` option is set or a max extreme
     * is set using `axis.setExtremes()`, the maxPadding will be ignored.
     *
     * @sample {highcharts} highcharts/yaxis/maxpadding/
     *         Max padding of 0.25 on y axis
     * @sample {highstock} stock/xaxis/minpadding-maxpadding/
     *         Greater min- and maxPadding
     * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
     *         Add some padding
     *
     * @default   {highcharts} 0.01
     * @default   {highstock|highmaps} 0
     * @since     1.2.0
     */
    maxPadding: 0.01,

    /**
     * Deprecated. Use `minRange` instead.
     *
     * @deprecated
     * @type      {number}
     * @product   highcharts highstock
     * @apioption xAxis.maxZoom
     */

    /**
     * The minimum value of the axis. If `null` the min value is
     * automatically calculated.
     *
     * If the [startOnTick](#yAxis.startOnTick) option is true (default),
     * the `min` value might be rounded down.
     *
     * The automatically calculated minimum value is also affected by
     * [floor](#yAxis.floor), [softMin](#yAxis.softMin),
     * [minPadding](#yAxis.minPadding), [minRange](#yAxis.minRange)
     * as well as [series.threshold](#plotOptions.series.threshold)
     * and [series.softThreshold](#plotOptions.series.softThreshold).
     *
     * @sample {highcharts} highcharts/yaxis/min-startontick-false/
     *         -50 with startOnTick to false
     * @sample {highcharts} highcharts/yaxis/min-startontick-true/
     *         -50 with startOnTick true by default
     * @sample {highstock} stock/xaxis/min-max/
     *         Set min and max on X axis
     * @sample {highmaps} maps/axis/min-max/
     *         Pre-zoomed to a specific area
     *
     * @type      {number}
     * @apioption xAxis.min
     */

    /**
     * The dash or dot style of the minor grid lines. For possible values,
     * see [this demonstration](https://jsfiddle.net/gh/get/library/pure/
     * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/
     * series-dashstyle-all/).
     *
     * @sample {highcharts} highcharts/yaxis/minorgridlinedashstyle/
     *         Long dashes on minor grid lines
     * @sample {highstock} stock/xaxis/minorgridlinedashstyle/
     *         Long dashes on minor grid lines
     *
     * @type       {string}
     * @default    Solid
     * @since      1.2
     * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
     *             "ShortDashDotDot", "Dot", "Dash" ,"LongDash",
     *             "DashDot", "LongDashDot", "LongDashDotDot"]
     * @apioption  xAxis.minorGridLineDashStyle
     */

    /**
     * Specific tick interval in axis units for the minor ticks. On a linear
     * axis, if `"auto"`, the minor tick interval is calculated as a fifth
     * of the tickInterval. If `null` or `undefined`, minor ticks are not
     * shown.
     *
     * On logarithmic axes, the unit is the power of the value. For example,
     * setting the minorTickInterval to 1 puts one tick on each of 0.1, 1,
     * 10, 100 etc. Setting the minorTickInterval to 0.1 produces 9 ticks
     * between 1 and 10, 10 and 100 etc.
     *
     * If user settings dictate minor ticks to become too dense, they don't
     * make sense, and will be ignored to prevent performance problems.
     *
     * @sample {highcharts} highcharts/yaxis/minortickinterval-null/
     *         Null by default
     * @sample {highcharts} highcharts/yaxis/minortickinterval-5/
     *         5 units
     * @sample {highcharts} highcharts/yaxis/minortickinterval-log-auto/
     *         "auto"
     * @sample {highcharts} highcharts/yaxis/minortickinterval-log/
     *         0.1
     * @sample {highstock} stock/demo/basic-line/
     *         Null by default
     * @sample {highstock} stock/xaxis/minortickinterval-auto/
     *         "auto"
     *
     * @type      {number|string|null}
     * @apioption xAxis.minorTickInterval
     */

    /**
     * The pixel length of the minor tick marks.
     *
     * @sample {highcharts} highcharts/yaxis/minorticklength/
     *         10px on Y axis
     * @sample {highstock} stock/xaxis/minorticks/
     *         10px on Y axis
     */
    minorTickLength: 2,

    /**
     * The position of the minor tick marks relative to the axis line.
     *  Can be one of `inside` and `outside`.
     *
     * @sample {highcharts} highcharts/yaxis/minortickposition-outside/
     *         Outside by default
     * @sample {highcharts} highcharts/yaxis/minortickposition-inside/
     *         Inside
     * @sample {highstock} stock/xaxis/minorticks/
     *         Inside
     *
     * @validvalue ["inside", "outside"]
     */
    minorTickPosition: 'outside',

    /**
     * Enable or disable minor ticks. Unless
     * [minorTickInterval](#xAxis.minorTickInterval) is set, the tick
     * interval is calculated as a fifth of the `tickInterval`.
     *
     * On a logarithmic axis, minor ticks are laid out based on a best
     * guess, attempting to enter approximately 5 minor ticks between
     * each major tick.
     *
     * Prior to v6.0.0, ticks were unabled in auto layout by setting
     * `minorTickInterval` to `"auto"`.
     *
     * @productdesc {highcharts}
     * On axes using [categories](#xAxis.categories), minor ticks are not
     * supported.
     *
     * @sample {highcharts} highcharts/yaxis/minorticks-true/
     *         Enabled on linear Y axis
     *
     * @type      {boolean}
     * @default   false
     * @since     6.0.0
     * @apioption xAxis.minorTicks
     */

    /**
     * The pixel width of the minor tick mark.
     *
     * @sample {highcharts} highcharts/yaxis/minortickwidth/
     *         3px width
     * @sample {highstock} stock/xaxis/minorticks/
     *         1px width
     *
     * @type      {number}
     * @default   0
     * @apioption xAxis.minorTickWidth
     */

    /**
     * Padding of the min value relative to the length of the axis. A
     * padding of 0.05 will make a 100px axis 5px longer. This is useful
     * when you don't want the lowest data value to appear on the edge
     * of the plot area. When the axis' `min` option is set or a min extreme
     * is set using `axis.setExtremes()`, the minPadding will be ignored.
     *
     * @sample {highcharts} highcharts/yaxis/minpadding/
     *         Min padding of 0.2
     * @sample {highstock} stock/xaxis/minpadding-maxpadding/
     *         Greater min- and maxPadding
     * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
     *         Add some padding
     *
     * @default    {highcharts} 0.01
     * @default    {highstock|highmaps} 0
     * @since      1.2.0
     * @product    highcharts highstock
     */
    minPadding: 0.01,

    /**
     * The minimum range to display on this axis. The entire axis will not
     * be allowed to span over a smaller interval than this. For example,
     * for a datetime axis the main unit is milliseconds. If minRange is
     * set to 3600000, you can't zoom in more than to one hour.
     *
     * The default minRange for the x axis is five times the smallest
     * interval between any of the data points.
     *
     * On a logarithmic axis, the unit for the minimum range is the power.
     * So a minRange of 1 means that the axis can be zoomed to 10-100,
     * 100-1000, 1000-10000 etc.
     *
     * Note that the `minPadding`, `maxPadding`, `startOnTick` and
     * `endOnTick` settings also affect how the extremes of the axis
     * are computed.
     *
     * @sample {highcharts} highcharts/xaxis/minrange/
     *         Minimum range of 5
     * @sample {highstock} stock/xaxis/minrange/
     *         Max zoom of 6 months overrides user selections
     * @sample {highmaps} maps/axis/minrange/
     *         Minimum range of 1000
     *
     * @type      {number}
     * @apioption xAxis.minRange
     */

    /**
     * The minimum tick interval allowed in axis values. For example on
     * zooming in on an axis with daily data, this can be used to prevent
     * the axis from showing hours. Defaults to the closest distance between
     * two points on the axis.
     *
     * @type      {number}
     * @since     2.3.0
     * @apioption xAxis.minTickInterval
     */

    /**
     * The distance in pixels from the plot area to the axis line.
     * A positive offset moves the axis with it's line, labels and ticks
     * away from the plot area. This is typically used when two or more
     * axes are displayed on the same side of the plot. With multiple
     * axes the offset is dynamically adjusted to avoid collision, this
     * can be overridden by setting offset explicitly.
     *
     * @sample    {highcharts} highcharts/yaxis/offset/
     *            Y axis offset of 70
     * @sample    {highcharts} highcharts/yaxis/offset-centered/
     *            Axes positioned in the center of the plot
     * @sample    {highstock} stock/xaxis/offset/
     *            Y axis offset by 70 px
     *
     * @type      {number}
     * @default   0
     * @apioption xAxis.offset
     */

    /**
     * Whether to display the axis on the opposite side of the normal. The
     * normal is on the left side for vertical axes and bottom for
     * horizontal, so the opposite sides will be right and top respectively.
     * This is typically used with dual or multiple axes.
     *
     * @sample {highcharts} highcharts/yaxis/opposite/
     *         Secondary Y axis opposite
     * @sample {highstock} stock/xaxis/opposite/
     *         Y axis on left side
     *
     * @type      {boolean}
     * @default   false
     * @apioption xAxis.opposite
     */

    /**
     * In an ordinal axis, the points are equally spaced in the chart
     * regardless of the actual time or x distance between them. This means
     * that missing data periods (e.g. nights or weekends for a stock chart)
     * will not take up space in the chart.
     * Having `ordinal: false` will show any gaps created by the `gapSize`
     * setting proportionate to their duration.
     *
     * In stock charts the X axis is ordinal by default, unless
     * the boost module is used and at least one of the series' data length
     * exceeds the [boostThreshold](#series.line.boostThreshold).
     *
     * @sample {highstock} stock/xaxis/ordinal-true/
     *         True by default
     * @sample {highstock} stock/xaxis/ordinal-false/
     *         False
     *
     * @type      {boolean}
     * @default   true
     * @since     1.1
     * @product   highstock
     * @apioption xAxis.ordinal
     */

    /**
     * Additional range on the right side of the xAxis. Works similar to
     * `xAxis.maxPadding`, but value is set in milliseconds. Can be set for
     * both main `xAxis` and the navigator's `xAxis`.
     *
     * @sample {highstock} stock/xaxis/overscroll/
     *         One minute overscroll with live data
     *
     * @type      {number}
     * @default   0
     * @since     6.0.0
     * @product   highstock
     * @apioption xAxis.overscroll
     */

    /**
     * Refers to the index in the [panes](#panes) array. Used for circular
     * gauges and polar charts. When the option is not set then first pane
     * will be used.
     *
     * @sample highcharts/demo/gauge-vu-meter
     *         Two gauges with different center
     *
     * @type      {number}
     * @product   highcharts
     * @apioption xAxis.pane
     */

    /**
     * The zoomed range to display when only defining one or none of `min`
     * or `max`. For example, to show the latest month, a range of one month
     * can be set.
     *
     * @sample {highstock} stock/xaxis/range/
     *         Setting a zoomed range when the rangeSelector is disabled
     *
     * @type      {number}
     * @product   highstock
     * @apioption xAxis.range
     */

    /**
     * Whether to reverse the axis so that the highest number is closest
     * to the origin. If the chart is inverted, the x axis is reversed by
     * default.
     *
     * @sample {highcharts} highcharts/yaxis/reversed/
     *         Reversed Y axis
     * @sample {highstock} stock/xaxis/reversed/
     *         Reversed Y axis
     *
     * @type      {boolean}
     * @default   false
     * @apioption xAxis.reversed
     */
    // reversed: false,

    /**
     * This option determines how stacks should be ordered within a group.
     * For example reversed xAxis also reverses stacks, so first series
     * comes last in a group. To keep order like for non-reversed xAxis
     * enable this option.
     *
     * @sample {highcharts} highcharts/xaxis/reversedstacks/
     *         Reversed stacks comparison
     * @sample {highstock} highcharts/xaxis/reversedstacks/
     *         Reversed stacks comparison
     *
     * @type      {boolean}
     * @default   false
     * @since     6.1.1
     * @product   highcharts highstock
     * @apioption xAxis.reversedStacks
     */

    /**
     * An optional scrollbar to display on the X axis in response to
     * limiting the minimum and maximum of the axis values.
     *
     * In styled mode, all the presentational options for the scrollbar
     * are replaced by the classes `.highcharts-scrollbar-thumb`,
     * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
     * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
     *
     * @sample {highstock} stock/yaxis/heatmap-scrollbars/
     *         Heatmap with both scrollbars
     *
     * @type      {*}
     * @extends   scrollbar
     * @since     4.2.6
     * @product   highstock
     * @apioption xAxis.scrollbar
     */

    /**
     * Whether to show the axis line and title when the axis has no data.
     *
     * @sample {highcharts} highcharts/yaxis/showempty/
     *         When clicking the legend to hide series, one axis preserves
     *         line and title, the other doesn't
     * @sample {highstock} highcharts/yaxis/showempty/
     *         When clicking the legend to hide series, one axis preserves
     *         line and title, the other doesn't
     *
     * @type      {boolean}
     * @default   true
     * @since     1.1
     * @apioption xAxis.showEmpty
     */

    /**
     * Whether to show the first tick label.
     *
     * @sample {highcharts} highcharts/xaxis/showfirstlabel-false/
     *         Set to false on X axis
     * @sample {highstock} stock/xaxis/showfirstlabel/
     *         Labels below plot lines on Y axis
     *
     * @type      {boolean}
     * @default   true
     * @apioption xAxis.showFirstLabel
     */

    /**
     * Whether to show the last tick label. Defaults to `true` on cartesian
     * charts, and `false` on polar charts.
     *
     * @sample {highcharts} highcharts/xaxis/showlastlabel-true/
     *         Set to true on X axis
     * @sample {highstock} stock/xaxis/showfirstlabel/
     *         Labels below plot lines on Y axis
     *
     * @type      {boolean}
     * @default   true
     * @product   highcharts highstock
     * @apioption xAxis.showLastLabel
     */

    /**
     * A soft maximum for the axis. If the series data maximum is less than
     * this, the axis will stay at this maximum, but if the series data
     * maximum is higher, the axis will flex to show all data.
     *
     * @sample highcharts/yaxis/softmin-softmax/
     *         Soft min and max
     *
     * @type      {number}
     * @since     5.0.1
     * @product   highcharts highstock
     * @apioption xAxis.softMax
     */

    /**
     * A soft minimum for the axis. If the series data minimum is greater
     * than this, the axis will stay at this minimum, but if the series
     * data minimum is lower, the axis will flex to show all data.
     *
     * @sample highcharts/yaxis/softmin-softmax/
     *         Soft min and max
     *
     * @type      {number}
     * @since     5.0.1
     * @product   highcharts highstock
     * @apioption xAxis.softMin
     */

    /**
     * For datetime axes, this decides where to put the tick between weeks.
     *  0 = Sunday, 1 = Monday.
     *
     * @sample {highcharts} highcharts/xaxis/startofweek-monday/
     *         Monday by default
     * @sample {highcharts} highcharts/xaxis/startofweek-sunday/
     *         Sunday
     * @sample {highstock} stock/xaxis/startofweek-1
     *         Monday by default
     * @sample {highstock} stock/xaxis/startofweek-0
     *         Sunday
     *
     * @product highcharts highstock
     */
    startOfWeek: 1,

    /**
     * Whether to force the axis to start on a tick. Use this option with
     * the `minPadding` option to control the axis start.
     *
     * @productdesc {highstock}
     * In Highstock, `startOnTick` is always false when the navigator is
     * enabled, to prevent jumpy scrolling.
     *
     * @sample {highcharts} highcharts/xaxis/startontick-false/
     *         False by default
     * @sample {highcharts} highcharts/xaxis/startontick-true/
     *         True
     * @sample {highstock} stock/xaxis/endontick/
     *         False for Y axis
     *
     * @since 1.2.0
     */
    startOnTick: false,

    /**
     * The amount of ticks to draw on the axis. This opens up for aligning
     * the ticks of multiple charts or panes within a chart. This option
     * overrides the `tickPixelInterval` option.
     *
     * This option only has an effect on linear axes. Datetime, logarithmic
     * or category axes are not affected.
     *
     * @sample {highcharts} highcharts/yaxis/tickamount/
     *         8 ticks on Y axis
     * @sample {highstock} highcharts/yaxis/tickamount/
     *         8 ticks on Y axis
     *
     * @type      {number}
     * @since     4.1.0
     * @product   highcharts highstock
     * @apioption xAxis.tickAmount
     */

    /**
     * The interval of the tick marks in axis units. When `undefined`, the
     * tick interval is computed to approximately follow the
     * [tickPixelInterval](#xAxis.tickPixelInterval) on linear and datetime
     * axes. On categorized axes, a `undefined` tickInterval will default to
     * 1, one category. Note that datetime axes are based on milliseconds,
     * so for example an interval of one day is expressed as
     * `24 * 3600 * 1000`.
     *
     * On logarithmic axes, the tickInterval is based on powers, so a
     * tickInterval of 1 means one tick on each of 0.1, 1, 10, 100 etc. A
     * tickInterval of 2 means a tick of 0.1, 10, 1000 etc. A tickInterval
     * of 0.2 puts a tick on 0.1, 0.2, 0.4, 0.6, 0.8, 1, 2, 4, 6, 8, 10, 20,
     * 40 etc.
     *
     *
     * If the tickInterval is too dense for labels to be drawn, Highcharts
     * may remove ticks.
     *
     * If the chart has multiple axes, the [alignTicks](#chart.alignTicks)
     * option may interfere with the `tickInterval` setting.
     *
     * @see [tickPixelInterval](#xAxis.tickPixelInterval)
     * @see [tickPositions](#xAxis.tickPositions)
     * @see [tickPositioner](#xAxis.tickPositioner)
     *
     * @sample {highcharts} highcharts/xaxis/tickinterval-5/
     *         Tick interval of 5 on a linear axis
     * @sample {highstock} stock/xaxis/tickinterval/
     *         Tick interval of 0.01 on Y axis
     *
     * @type      {number}
     * @apioption xAxis.tickInterval
     */

    /**
     * The pixel length of the main tick marks.
     *
     * @sample {highcharts} highcharts/xaxis/ticklength/
     *         20 px tick length on the X axis
     * @sample {highstock} stock/xaxis/ticks/
     *         Formatted ticks on X axis
     */
    tickLength: 10,

    /**
     * If tickInterval is `null` this option sets the approximate pixel
     * interval of the tick marks. Not applicable to categorized axis.
     *
     * The tick interval is also influenced by the [minTickInterval](
     * #xAxis.minTickInterval) option, that, by default prevents ticks from
     * being denser than the data points.
     *
     * @see [tickInterval](#xAxis.tickInterval)
     * @see [tickPositioner](#xAxis.tickPositioner)
     * @see [tickPositions](#xAxis.tickPositions)
     *
     * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/
     *         50 px on X axis
     * @sample {highstock} stock/xaxis/tickpixelinterval/
     *         200 px on X axis
     */
    tickPixelInterval: 100,

    /**
     * For categorized axes only. If `on` the tick mark is placed in the
     * center of the category, if `between` the tick mark is placed between
     * categories. The default is `between` if the `tickInterval` is 1,
     *  else `on`.
     *
     * @sample {highcharts} highcharts/xaxis/tickmarkplacement-between/
     *         "between" by default
     * @sample {highcharts} highcharts/xaxis/tickmarkplacement-on/
     *         "on"
     *
     * @product    highcharts
     * @validvalue [null, "on", "between"]
     */
    tickmarkPlacement: 'between',

    /**
     * The position of the major tick marks relative to the axis line.
     * Can be one of `inside` and `outside`.
     *
     * @sample {highcharts} highcharts/xaxis/tickposition-outside/
     *         "outside" by default
     * @sample {highcharts} highcharts/xaxis/tickposition-inside/
     *         "inside"
     * @sample {highstock} stock/xaxis/ticks/
     *         Formatted ticks on X axis
     *
     * @validvalue ["inside", "outside"]
     */
    tickPosition: 'outside',

    /**
     * A callback function returning array defining where the ticks are
     * laid out on the axis. This overrides the default behaviour of
     * [tickPixelInterval](#xAxis.tickPixelInterval) and [tickInterval](
     * #xAxis.tickInterval). The automatic tick positions are accessible
     * through `this.tickPositions` and can be modified by the callback.
     *
     * @see [tickPositions](#xAxis.tickPositions)
     *
     * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
     *         Demo of tickPositions and tickPositioner
     * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
     *         Demo of tickPositions and tickPositioner
     *
     * @type      {Function}
     * @apioption xAxis.tickPositioner
     */

    /**
     * An array defining where the ticks are laid out on the axis. This
     * overrides the default behaviour of [tickPixelInterval](
     * #xAxis.tickPixelInterval) and [tickInterval](#xAxis.tickInterval).
     *
     * @see [tickPositioner](#xAxis.tickPositioner)
     *
     * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
     *         Demo of tickPositions and tickPositioner
     * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
     *         Demo of tickPositions and tickPositioner
     *
     * @type      {Array<number>}
     * @apioption xAxis.tickPositions
     */

    /**
     * The pixel width of the major tick marks.
     *
     * In styled mode, the stroke width is given in the `.highcharts-tick`
     * class.
     *
     * @sample {highcharts} highcharts/xaxis/tickwidth/
     *         10 px width
     * @sample {highcharts} highcharts/css/axis-grid/
     *         Styled mode
     * @sample {highstock} stock/xaxis/ticks/
     *         Formatted ticks on X axis
     * @sample {highstock} highcharts/css/axis-grid/
     *         Styled mode
     *
     * @type      {number}
     * @default   {highcharts} 1
     * @default   {highstock} 1
     * @default   {highmaps} 0
     * @apioption xAxis.tickWidth
     */

    /**
     * The axis title, showing next to the axis line.
     *
     * @productdesc {highmaps}
     * In Highmaps, the axis is hidden by default, but adding an axis title
     * is still possible. X axis and Y axis titles will appear at the bottom
     * and left by default.
     */
    title: {
      /**
       * Deprecated. Set the `text` to `null` to disable the title.
       *
       * @deprecated
       * @type      {string}
       * @default   middle
       * @product   highcharts
       * @apioption xAxis.title.enabled
       */

      /**
       * The pixel distance between the axis labels or line and the title.
       * Defaults to 0 for horizontal axes, 10 for vertical
       *
       * @sample {highcharts} highcharts/xaxis/title-margin/
       *         Y axis title margin of 60
       *
       * @type      {number}
       * @apioption xAxis.title.margin
       */

      /**
       * The distance of the axis title from the axis line. By default,
       * this distance is computed from the offset width of the labels,
       * the labels' distance from the axis and the title's margin.
       * However when the offset option is set, it overrides all this.
       *
       * @sample {highcharts} highcharts/yaxis/title-offset/
       *         Place the axis title on top of the axis
       * @sample {highstock} highcharts/yaxis/title-offset/
       *         Place the axis title on top of the Y axis
       *
       * @type      {number}
       * @since     2.2.0
       * @apioption xAxis.title.offset
       */

      /**
       * Whether to reserve space for the title when laying out the axis.
       *
       * @type      {boolean}
       * @default   true
       * @since     5.0.11
       * @product   highcharts highstock
       * @apioption xAxis.title.reserveSpace
       */

      /**
       * The rotation of the text in degrees. 0 is horizontal, 270 is
       * vertical reading from bottom to top.
       *
       * @sample {highcharts} highcharts/yaxis/title-offset/
       *         Horizontal
       *
       * @type      {number}
       * @default   0
       * @apioption xAxis.title.rotation
       */

      /**
       * The actual text of the axis title. It can contain basic HTML text
       * markup like <b>, <i> and spans with style.
       *
       * @sample {highcharts} highcharts/xaxis/title-text/
       *         Custom HTML
       * @sample {highstock} stock/xaxis/title-text/
       *         Titles for both axes
       *
       * @type      {string}
       * @apioption xAxis.title.text
       */

      /**
       * Alignment of the text, can be `"left"`, `"right"` or `"center"`.
       * Default alignment depends on the
       * [title.align](xAxis.title.align):
       *
       * Horizontal axes:
       * - for `align` = `"low"`, `textAlign` is set to `left`
       * - for `align` = `"middle"`, `textAlign` is set to `center`
       * - for `align` = `"high"`, `textAlign` is set to `right`
       *
       * Vertical axes:
       * - for `align` = `"low"` and `opposite` = `true`, `textAlign` is
       *   set to `right`
       * - for `align` = `"low"` and `opposite` = `false`, `textAlign` is
       *   set to `left`
       * - for `align` = `"middle"`, `textAlign` is set to `center`
       * - for `align` = `"high"` and `opposite` = `true` `textAlign` is
       *   set to `left`
       * - for `align` = `"high"` and `opposite` = `false` `textAlign` is
       *   set to `right`
       *
       * @type      {string}
       * @apioption xAxis.title.textAlign
       */

      /**
       * Whether to [use HTML](https://www.highcharts.com/docs/
       * chart-concepts/labels-and-string-formatting#html) to render the
       * axis title.
       *
       * @type      {boolean}
       * @default   false
       * @product   highcharts highstock
       * @apioption xAxis.title.useHTML
       */

      /**
       * Horizontal pixel offset of the title position.
       *
       * @type      {number}
       * @default   0
       * @since     4.1.6
       * @product   highcharts highstock
       * @apioption xAxis.title.x
       */

      /**
       * Vertical pixel offset of the title position.
       *
       * @type      {number}
       * @product   highcharts highstock
       * @apioption xAxis.title.y
       */

      /**
       * Alignment of the title relative to the axis values. Possible
       * values are "low", "middle" or "high".
       *
       * @sample {highcharts} highcharts/xaxis/title-align-low/
       *         "low"
       * @sample {highcharts} highcharts/xaxis/title-align-center/
       *         "middle" by default
       * @sample {highcharts} highcharts/xaxis/title-align-high/
       *         "high"
       * @sample {highcharts} highcharts/yaxis/title-offset/
       *         Place the Y axis title on top of the axis
       * @sample {highstock} stock/xaxis/title-align/
       *         Aligned to "high" value
       *
       * @validvalue ["low", "middle", "high"]
       */
      align: 'middle'
    },

    /**
     * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`
     * or `category`. In a datetime axis, the numbers are given in
     * milliseconds, and tick marks are placed on appropriate values like
     * full hours or days. In a category axis, the
     * [point names](#series.line.data.name) of the chart's series are used
     * for categories, if not a [categories](#xAxis.categories) array is
     * defined.
     *
     * @sample {highcharts} highcharts/xaxis/type-linear/
     *         Linear
     * @sample {highcharts} highcharts/yaxis/type-log/
     *         Logarithmic
     * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
     *         Logarithmic with minor grid lines
     * @sample {highcharts} highcharts/xaxis/type-log-both/
     *         Logarithmic on two axes
     * @sample {highcharts} highcharts/yaxis/type-log-negative/
     *         Logarithmic with extension to emulate negative values
     *
     * @product    highcharts
     * @validvalue ["linear", "logarithmic", "datetime", "category"]
     */
    type: 'linear'
    /**
     * Applies only when the axis `type` is `category`. When `uniqueNames`
     * is true, points are placed on the X axis according to their names.
     * If the same point name is repeated in the same or another series,
     * the point is placed on the same X position as other points of the
     * same name. When `uniqueNames` is false, the points are laid out in
     * increasing X positions regardless of their names, and the X axis
     * category will take the name of the last point in each position.
     *
     * @sample {highcharts} highcharts/xaxis/uniquenames-true/
     *         True by default
     * @sample {highcharts} highcharts/xaxis/uniquenames-false/
     *         False
     *
     * @type      {boolean}
     * @default   true
     * @since     4.2.7
     * @product   highcharts
     * @apioption xAxis.uniqueNames
     */

    /**
     * Datetime axis only. An array determining what time intervals the
     * ticks are allowed to fall on. Each array item is an array where the
     * first value is the time unit and the second value another array of
     * allowed multiples. Defaults to:
     *
     * <pre>units: [[
     *     'millisecond', // unit name
     *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
     * ], [
     *     'second',
     *     [1, 2, 5, 10, 15, 30]
     * ], [
     *     'minute',
     *     [1, 2, 5, 10, 15, 30]
     * ], [
     *     'hour',
     *     [1, 2, 3, 4, 6, 8, 12]
     * ], [
     *     'day',
     *     [1]
     * ], [
     *     'week',
     *     [1]
     * ], [
     *     'month',
     *     [1, 3, 6]
     * ], [
     *     'year',
     *     null
     * ]]</pre>
     *
     * @type      {Array<Array<string|Array<number>>>}
     * @product   highcharts highstock
     * @apioption xAxis.units
     */

    /**
     * Whether axis, including axis title, line, ticks and labels, should
     * be visible.
     *
     * @type      {boolean}
     * @default   true
     * @since     4.1.9
     * @product   highcharts highstock
     * @apioption xAxis.visible
     */

  },

  /**
   * The Y axis or value axis. Normally this is the vertical axis,
   * though if the chart is inverted this is the horizontal axis.
   * In case of multiple axes, the yAxis node is an array of
   * configuration objects.
   *
   * See [the Axis object](/class-reference/Highcharts.Axis) for programmatic
   * access to the axis.
   *
   * @extends      xAxis
   * @excluding    ordinal, overscroll
   * @optionparent yAxis
   */
  defaultYAxisOptions: {
    /**
     * In a polar chart, this is the angle of the Y axis in degrees, where
     * 0 is up and 90 is right. The angle determines the position of the
     * axis line and the labels, though the coordinate system is unaffected.
     *
     * @sample {highcharts} highcharts/yaxis/angle/
     *         Dual axis polar chart
     *
     * @type      {number}
     * @default   0
     * @since     4.2.7
     * @product   highcharts
     * @apioption yAxis.angle
     */

    /**
     * Polar charts only. Whether the grid lines should draw as a polygon
     * with straight lines between categories, or as circles. Can be either
     * `circle` or `polygon`.
     *
     * @sample {highcharts} highcharts/demo/polar-spider/
     *         Polygon grid lines
     * @sample {highcharts} highcharts/yaxis/gridlineinterpolation/
     *         Circle and polygon
     *
     * @type       {string}
     * @product    highcharts
     * @validvalue ["circle", "polygon"]
     * @apioption  yAxis.gridLineInterpolation
     */

    /**
     * The height of the Y axis. If it's a number, it is interpreted as
     * pixels.
     *
     * Since Highstock 2: If it's a percentage string, it is interpreted
     * as percentages of the total plot height.
     *
     * @see [yAxis.top](#yAxis.top)
     *
     * @sample {highstock} stock/demo/candlestick-and-volume/
     *         Percentage height panes
     *
     * @type      {number|string}
     * @product   highstock
     * @apioption yAxis.height
     */

    /**
     * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
     * to represent the maximum value of the Y axis.
     *
     * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
     *         Min and max colors
     *
     * @type      {Highcharts.ColorString}
     * @default   #003399
     * @since     4.0
     * @product   highcharts
     * @apioption yAxis.maxColor
     */

    /**
     * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
     * to represent the minimum value of the Y axis.
     *
     * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
     *         Min and max color
     *
     * @type      {Highcharts.ColorString}
     * @default   #e6ebf5
     * @since     4.0
     * @product   highcharts
     * @apioption yAxis.minColor
     */

    /**
     * Whether to reverse the axis so that the highest number is closest
     * to the origin.
     *
     * @sample {highcharts} highcharts/yaxis/reversed/
     *         Reversed Y axis
     * @sample {highstock} stock/xaxis/reversed/
     *         Reversed Y axis
     *
     * @type      {boolean}
     * @default   {highcharts} false
     * @default   {highstock} false
     * @default   {highmaps} true
     * @apioption yAxis.reversed
     */

    /**
     * If `true`, the first series in a stack will be drawn on top in a
     * positive, non-reversed Y axis. If `false`, the first series is in
     * the base of the stack.
     *
     * @sample {highcharts} highcharts/yaxis/reversedstacks-false/
     *         Non-reversed stacks
     * @sample {highstock} highcharts/yaxis/reversedstacks-false/
     *         Non-reversed stacks
     *
     * @type      {boolean}
     * @default   true
     * @since     3.0.10
     * @product   highcharts highstock
     * @apioption yAxis.reversedStacks
     */

    /**
     * Solid gauge series only. Color stops for the solid gauge. Use this
     * in cases where a linear gradient between a `minColor` and `maxColor`
     * is not sufficient. The stops is an array of tuples, where the first
     * item is a float between 0 and 1 assigning the relative position in
     * the gradient, and the second item is the color.
     *
     * For solid gauges, the Y axis also inherits the concept of [data classes](http://api.
     * highcharts.com/highmaps#colorAxis.dataClasses) from the Highmaps
     * color axis.
     *
     * @see [minColor](#yAxis.minColor)
     * @see [maxColor](#yAxis.maxColor)
     *
     * @sample {highcharts} highcharts/demo/gauge-solid/
     *         True by default
     *
     * @type      {Array<Array<number, Highcharts.ColorString>>}
     * @since     4.0
     * @product   highcharts
     * @apioption yAxis.stops
     */

    /**
     * The pixel width of the major tick marks.
     *
     * @sample {highcharts} highcharts/xaxis/tickwidth/ 10 px width
     * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
     *
     * @type      {number}
     * @default   0
     * @product   highcharts highstock
     * @apioption yAxis.tickWidth
     */

    /**
     * Angular gauges and solid gauges only. The label's pixel distance
     * from the perimeter of the plot area.
     *
     * @type      {number}
     * @default   -25
     * @product   highcharts
     * @apioption yAxis.labels.distance
     */

    /**
     * The y position offset of the label relative to the tick position
     * on the axis.
     *
     * @sample {highcharts} highcharts/xaxis/labels-x/
     *         Y axis labels placed on grid lines
     *
     * @type      {number}
     * @default   {highcharts} 3
     * @default   {highstock} -2
     * @default   {highmaps} 3
     * @apioption yAxis.labels.y
     */

    /**
     * @productdesc {highstock}
     * In Highstock, `endOnTick` is always false when the navigator is
     * enabled, to prevent jumpy scrolling.
     */
    endOnTick: true,

    /**
     * Padding of the max value relative to the length of the axis. A
     * padding of 0.05 will make a 100px axis 5px longer. This is useful
     * when you don't want the highest data value to appear on the edge
     * of the plot area. When the axis' `max` option is set or a max extreme
     * is set using `axis.setExtremes()`, the maxPadding will be ignored.
     *
     * @sample {highcharts} highcharts/yaxis/maxpadding-02/
     *         Max padding of 0.2
     * @sample {highstock} stock/xaxis/minpadding-maxpadding/
     *         Greater min- and maxPadding
     *
     * @since   1.2.0
     * @product highcharts highstock
     */
    maxPadding: 0.05,

    /**
     * Padding of the min value relative to the length of the axis. A
     * padding of 0.05 will make a 100px axis 5px longer. This is useful
     * when you don't want the lowest data value to appear on the edge
     * of the plot area. When the axis' `min` option is set or a max extreme
     * is set using `axis.setExtremes()`, the maxPadding will be ignored.
     *
     * @sample {highcharts} highcharts/yaxis/minpadding/
     *         Min padding of 0.2
     * @sample {highstock} stock/xaxis/minpadding-maxpadding/
     *         Greater min- and maxPadding
     *
     * @since   1.2.0
     * @product highcharts highstock
     */
    minPadding: 0.05,

    /**
     * @productdesc {highstock}
     * In Highstock 1.x, the Y axis was placed on the left side by default.
     *
     * @sample {highcharts} highcharts/yaxis/opposite/
     *         Secondary Y axis opposite
     * @sample {highstock} stock/xaxis/opposite/
     *         Y axis on left side
     *
     * @type      {boolean}
     * @default   {highstock} true
     * @default   {highcharts} false
     * @product   highstock highcharts
     * @apioption yAxis.opposite
     */

    /**
     * @see [tickInterval](#xAxis.tickInterval)
     * @see [tickPositioner](#xAxis.tickPositioner)
     * @see [tickPositions](#xAxis.tickPositions)
     */
    tickPixelInterval: 72,
    showLastLabel: true,

    /**
     * @extends    xAxis.labels
     */
    labels: {
      /**
       * What part of the string the given position is anchored to. Can
       * be one of `"left"`, `"center"` or `"right"`. The exact position
       * also depends on the `labels.x` setting.
       *
       * Angular gauges and solid gauges defaults to `center`.
       *
       * @sample {highcharts} highcharts/yaxis/labels-align-left/
       *         Left
       *
       * @type       {string}
       * @default    {highcharts|highmaps} right
       * @default    {highstock} left
       * @validvalue ["left", "center", "right"]
       * @apioption  yAxis.labels.align
       */

      /**
       * The x position offset of the label relative to the tick position
       * on the axis. Defaults to -15 for left axis, 15 for right axis.
       *
       * @sample {highcharts} highcharts/xaxis/labels-x/
       *         Y axis labels placed on grid lines
       */
      x: -8
    },

    /**
     * @productdesc {highmaps}
     * In Highmaps, the axis line is hidden by default, because the axis is
     * not visible by default.
     *
     * @type      {Highcharts.ColorString}
     * @apioption yAxis.lineColor
     */

    /**
     * @sample {highcharts} highcharts/yaxis/max-200/
     *         Y axis max of 200
     * @sample {highcharts} highcharts/yaxis/max-logarithmic/
     *         Y axis max on logarithmic axis
     * @sample {highstock} stock/yaxis/min-max/
     *         Fixed min and max on Y axis
     * @sample {highmaps} maps/axis/min-max/
     *         Pre-zoomed to a specific area
     *
     * @type      {number}
     * @apioption yAxis.max
     */

    /**
     * @sample {highcharts} highcharts/yaxis/min-startontick-false/
     *         -50 with startOnTick to false
     * @sample {highcharts} highcharts/yaxis/min-startontick-true/
     *         -50 with startOnTick true by default
     * @sample {highstock} stock/yaxis/min-max/
     *         Fixed min and max on Y axis
     * @sample {highmaps} maps/axis/min-max/
     *         Pre-zoomed to a specific area
     *
     * @type      {number}
     * @apioption yAxis.min
     */

    /**
     * An optional scrollbar to display on the Y axis in response to
     * limiting the minimum an maximum of the axis values.
     *
     * In styled mode, all the presentational options for the scrollbar
     * are replaced by the classes `.highcharts-scrollbar-thumb`,
     * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
     * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
     *
     * @sample {highstock} stock/yaxis/scrollbar/
     *         Scrollbar on the Y axis
     *
     * @extends   scrollbar
     * @excluding height
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar
     */

    /**
     * Enable the scrollbar on the Y axis.
     *
     * @sample {highstock} stock/yaxis/scrollbar/
     *         Enabled on Y axis
     *
     * @type      {boolean}
     * @default   false
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.enabled
     */

    /**
     * Pixel margin between the scrollbar and the axis elements.
     *
     * @type      {number}
     * @default   10
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.margin
     */

    /**
     * Whether to show the scrollbar when it is fully zoomed out at max
     * range. Setting it to `false` on the Y axis makes the scrollbar stay
     * hidden until the user zooms in, like common in browsers.
     *
     * @type      {boolean}
     * @default   true
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.showFull
     */

    /**
     * The width of a vertical scrollbar or height of a horizontal
     * scrollbar. Defaults to 20 on touch devices.
     *
     * @type      {number}
     * @default   14
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.size
     */

    /**
     * Z index of the scrollbar elements.
     *
     * @type      {number}
     * @default   3
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.zIndex
     */

    /**
     * A soft maximum for the axis. If the series data maximum is less
     * than this, the axis will stay at this maximum, but if the series
     * data maximum is higher, the axis will flex to show all data.
     *
     * **Note**: The [series.softThreshold](
     * #plotOptions.series.softThreshold) option takes precedence over this
     * option.
     *
     * @sample highcharts/yaxis/softmin-softmax/
     *         Soft min and max
     *
     * @type      {number}
     * @since     5.0.1
     * @product   highcharts highstock
     * @apioption yAxis.softMax
     */

    /**
     * A soft minimum for the axis. If the series data minimum is greater
     * than this, the axis will stay at this minimum, but if the series
     * data minimum is lower, the axis will flex to show all data.
     *
     * **Note**: The [series.softThreshold](
     * #plotOptions.series.softThreshold) option takes precedence over this
     * option.
     *
     * @sample highcharts/yaxis/softmin-softmax/
     *         Soft min and max
     *
     * @type      {number}
     * @since     5.0.1
     * @product   highcharts highstock
     * @apioption yAxis.softMin
     */

    /**
     * Defines the horizontal alignment of the stack total label. Can be one
     * of `"left"`, `"center"` or `"right"`. The default value is calculated
     * at runtime and depends on orientation and whether the stack is
     * positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-align-left/
     *         Aligned to the left
     * @sample {highcharts} highcharts/yaxis/stacklabels-align-center/
     *         Aligned in center
     * @sample {highcharts} highcharts/yaxis/stacklabels-align-right/
     *         Aligned to the right
     *
     * @type       {string}
     * @since      2.1.5
     * @product    highcharts
     * @validvalue ["left", "center", "right"]
     * @apioption  yAxis.stackLabels.align
     */

    /**
     * A [format string](http://docs.highcharts.com/#formatting) for the
     * data label. Available variables are the same as for `formatter`.
     *
     * @type      {string}
     * @default   {total}
     * @since     3.0.2
     * @product   highcharts highstock
     * @apioption yAxis.stackLabels.format
     */

    /**
     * Rotation of the labels in degrees.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-rotation/
     *         Labels rotated 45°
     *
     * @type      {number}
     * @default   0
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.rotation
     */

    /**
     * The text alignment for the label. While `align` determines where the
     * texts anchor point is placed with regards to the stack, `textAlign`
     * determines how the text is aligned against its anchor point. Possible
     * values are `"left"`, `"center"` and `"right"`. The default value is
     * calculated at runtime and depends on orientation and whether the
     * stack is positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-textalign-left/
     *         Label in center position but text-aligned left
     *
     * @type       {string}
     * @since      2.1.5
     * @product    highcharts
     * @validvalue ["left", "center", "right"]
     * @apioption  yAxis.stackLabels.textAlign
     */

    /**
     * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/
     * labels-and-string-formatting#html) to render the labels.
     *
     * @type      {boolean}
     * @default   false
     * @since     3.0
     * @product   highcharts highstock
     * @apioption yAxis.stackLabels.useHTML
     */

    /**
     * Defines the vertical alignment of the stack total label. Can be one
     * of `"top"`, `"middle"` or `"bottom"`. The default value is calculated
     * at runtime and depends on orientation and whether the stack is
     * positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-top/
     *         Vertically aligned top
     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-middle/
     *         Vertically aligned middle
     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-bottom/
     *         Vertically aligned bottom
     *
     * @type       {string}
     * @since      2.1.5
     * @product    highcharts
     * @validvalue ["top", "middle", "bottom"]
     * @apioption  yAxis.stackLabels.verticalAlign
     */

    /**
     * The x position offset of the label relative to the left of the
     * stacked bar. The default value is calculated at runtime and depends
     * on orientation and whether the stack is positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-x/
     *         Stack total labels with x offset
     *
     * @type      {number}
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.x
     */

    /**
     * The y position offset of the label relative to the tick position
     * on the axis. The default value is calculated at runtime and depends
     * on orientation and whether the stack is positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-y/
     *         Stack total labels with y offset
     *
     * @type      {number}
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.y
     */

    /**
     * Whether to force the axis to start on a tick. Use this option with
     * the `maxPadding` option to control the axis start.
     *
     * @sample  {highcharts} highcharts/xaxis/startontick-false/
     *          False by default
     * @sample  {highcharts} highcharts/xaxis/startontick-true/
     *          True
     * @sample  {highstock} stock/xaxis/endontick/
     *          False for Y axis
     *
     * @since   1.2.0
     * @product highcharts highstock
     */
    startOnTick: true,
    title: {
      /**
       * The pixel distance between the axis labels and the title.
       * Positive values are outside the axis line, negative are inside.
       *
       * @sample {highcharts} highcharts/xaxis/title-margin/
       *         Y axis title margin of 60
       *
       * @type      {number}
       * @default   40
       * @apioption yAxis.title.margin
       */

      /**
       * The rotation of the text in degrees. 0 is horizontal, 270 is
       * vertical reading from bottom to top.
       *
       * @sample {highcharts} highcharts/yaxis/title-offset/
       *         Horizontal
       */
      rotation: 270,

      /**
       * The actual text of the axis title. Horizontal texts can contain
       * HTML, but rotated texts are painted using vector techniques and
       * must be clean text. The Y axis title is disabled by setting the
       * `text` option to `undefined`.
       *
       * @sample  {highcharts} highcharts/xaxis/title-text/
       *          Custom HTML
       *
       * @default {highcharts} Values
       * @default {highstock} undefined
       * @product highcharts highstock
       */
      text: 'Values'
    },

    /**
     * The top position of the Y axis. If it's a number, it is interpreted
     * as pixel position relative to the chart.
     *
     * Since Highstock 2: If it's a percentage string, it is interpreted
     * as percentages of the plot height, offset from plot area top.
     *
     * @see [yAxis.height](#yAxis.height)
     *
     * @sample {highstock} stock/demo/candlestick-and-volume/
     *         Percentage height panes
     *
     * @type      {number|string}
     * @product   highstock
     * @apioption yAxis.top
     */

    /**
     * The stack labels show the total value for each bar in a stacked
     * column or bar chart. The label will be placed on top of positive
     * columns and below negative columns. In case of an inverted column
     * chart or a bar chart the label is placed to the right of positive
     * bars and to the left of negative bars.
     *
     * @product highcharts
     */
    stackLabels: {
      /**
       * Allow the stack labels to overlap.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-allowoverlap-false/
       *         Default false
       *
       * @since   5.0.13
       * @product highcharts
       */
      allowOverlap: false,

      /**
       * Enable or disable the stack total labels.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-enabled/
       *         Enabled stack total labels
       *
       * @since   2.1.5
       * @product highcharts
       */
      enabled: false,

      /**
       * Callback JavaScript function to format the label. The value is
       * given by `this.total`.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-formatter/
       *         Added units to stack total value
       *
       * @type    {Highcharts.FormatterCallbackFunction}
       * @since   2.1.5
       * @product highcharts
       */
      formatter: function () {
        return Highcharts.numberFormat(this.total, -1);
      }
    }
  },

  /**
   * The Z axis or depth axis for 3D plots.
   *
   * See [the Axis object](/class-reference/Highcharts.Axis) for programmatic
   * access to the axis.
   *
   * @sample {highcharts} highcharts/3d/scatter-zaxis-categories/
   *         Z-Axis with Categories
   * @sample {highcharts} highcharts/3d/scatter-zaxis-grid/
   *         Z-Axis with styling
   *
   * @extends   xAxis
   * @since     5.0.0
   * @product   highcharts
   * @excluding breaks, crosshair, lineColor, lineWidth, nameToX, showEmpty
   * @apioption zAxis
   */

  /**
   * These options extend the defaultOptions for left axes.
   *
   * @private
   * @name Highcharts.Axis#defaultLeftAxisOptions
   * @type {*}
   */
  defaultLeftAxisOptions: {
    labels: {
      x: -15
    },
    title: {
      rotation: 270
    }
  },

  /**
   * These options extend the defaultOptions for right axes.
   *
   * @private
   * @name Highcharts.Axis#defaultRightAxisOptions
   * @type {*}
   */
  defaultRightAxisOptions: {
    labels: {
      x: 15
    },
    title: {
      rotation: 90
    }
  },

  /**
   * These options extend the defaultOptions for bottom axes.
   *
   * @private
   * @name Highcharts.Axis#defaultBottomAxisOptions
   * @type {*}
   */
  defaultBottomAxisOptions: {
    labels: {
      autoRotation: [-45],
      x: 0 // overflow: undefined,
      // staggerLines: null

    },
    title: {
      rotation: 0
    }
  },

  /**
   * These options extend the defaultOptions for top axes.
   *
   * @private
   * @name Highcharts.Axis#defaultTopAxisOptions
   * @type {*}
   */
  defaultTopAxisOptions: {
    labels: {
      autoRotation: [-45],
      x: 0 // overflow: undefined
      // staggerLines: null

    },
    title: {
      rotation: 0
    }
  },

  /**
   * Overrideable function to initialize the axis.
   *
   * @see {@link Axis}
   *
   * @function Highcharts.Axis#init
   *
   * @param {Highcharts.Chart} chart
   *
   * @param {Highcharts.Options} userOptions
   *
   * @fires Highcharts.Axis#event:afterInit
   * @fires Highcharts.Axis#event:init
   */
  init: function (chart, userOptions) {
    var isXAxis = userOptions.isX,
        axis = this;
    /**
     * The Chart that the axis belongs to.
     *
     * @name Highcharts.Axis#chart
     * @type {Highcharts.Chart}
     */

    axis.chart = chart;
    /**
     * Whether the axis is horizontal.
     *
     * @name Highcharts.Axis#horiz
     * @type {boolean}
     */

    axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis; // Flag, isXAxis

    axis.isXAxis = isXAxis;
    /**
     * The collection where the axis belongs, for example `xAxis`, `yAxis`
     * or `colorAxis`. Corresponds to properties on Chart, for example
     * {@link Chart.xAxis}.
     *
     * @name Highcharts.Axis#coll
     * @type {string}
     */

    axis.coll = axis.coll || (isXAxis ? 'xAxis' : 'yAxis');
    fireEvent$1(this, 'init', {
      userOptions: userOptions
    });
    axis.opposite = userOptions.opposite; // needed in setOptions

    /**
     * The side on which the axis is rendered. 0 is top, 1 is right, 2 is
     * bottom and 3 is left.
     *
     * @name Highcharts.Axis#side
     * @type {number}
     */

    axis.side = userOptions.side || (axis.horiz ? axis.opposite ? 0 : 2 : // top : bottom
    axis.opposite ? 1 : 3); // right : left

    axis.setOptions(userOptions);
    var options = this.options,
        type = options.type,
        isDatetimeAxis = type === 'datetime';
    axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format
    // Flag, stagger lines or not

    axis.userOptions = userOptions;
    axis.minPixelPadding = 0;
    /**
     * Whether the axis is reversed. Based on the `axis.reversed`,
     * option, but inverted charts have reversed xAxis by default.
     *
     * @name Highcharts.Axis#reversed
     * @type {boolean}
     */

    axis.reversed = options.reversed;
    axis.visible = options.visible !== false;
    axis.zoomEnabled = options.zoomEnabled !== false; // Initial categories

    axis.hasNames = type === 'category' || options.categories === true;
    axis.categories = options.categories || axis.hasNames;

    if (!axis.names) {
      // Preserve on update (#3830)
      axis.names = [];
      axis.names.keys = {};
    } // Placeholder for plotlines and plotbands groups


    axis.plotLinesAndBandsGroups = {}; // Shorthand types

    axis.isLog = type === 'logarithmic';
    axis.isDatetimeAxis = isDatetimeAxis;
    axis.positiveValuesOnly = axis.isLog && !axis.allowNegativeLog; // Flag, if axis is linked to another axis

    axis.isLinked = defined$4(options.linkedTo); // Major ticks

    axis.ticks = {};
    axis.labelEdge = []; // Minor ticks

    axis.minorTicks = {}; // List of plotLines/Bands

    axis.plotLinesAndBands = []; // Alternate bands

    axis.alternateBands = {}; // Axis metrics

    axis.len = 0;
    axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
    axis.range = options.range;
    axis.offset = options.offset || 0; // Dictionary for stacks

    axis.stacks = {};
    axis.oldStacks = {};
    axis.stacksTouched = 0;
    /**
     * The maximum value of the axis. In a logarithmic axis, this is the
     * logarithm of the real value, and the real value can be obtained from
     * {@link Axis#getExtremes}.
     *
     * @name Highcharts.Axis#max
     * @type {number}
     */

    axis.max = null;
    /**
     * The minimum value of the axis. In a logarithmic axis, this is the
     * logarithm of the real value, and the real value can be obtained from
     * {@link Axis#getExtremes}.
     *
     * @name Highcharts.Axis#min
     * @type {number}
     */

    axis.min = null;
    /**
     * The processed crosshair options.
     *
     * @name Highcharts.Axis#crosshair
     * @type {false|Highcharts.AxisCrosshairOptions}
     */

    axis.crosshair = pick$4(options.crosshair, splat$1(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);
    var events = axis.options.events; // Register. Don't add it again on Axis.update().

    if (inArray$1(axis, chart.axes) === -1) {
      //
      if (isXAxis) {
        // #2713
        chart.axes.splice(chart.xAxis.length, 0, axis);
      } else {
        chart.axes.push(axis);
      }

      chart[axis.coll].push(axis);
    }
    /**
     * All series associated to the axis.
     *
     * @name Highcharts.Axis#series
     * @type {Array<Highcharts.Series>}
     */


    axis.series = axis.series || []; // populated by Series
    // Reversed axis

    if (chart.inverted && !axis.isZAxis && isXAxis && axis.reversed === undefined) {
      axis.reversed = true;
    } // register event listeners


    objectEach$1(events, function (event, eventType) {
      addEvent$1(axis, eventType, event);
    }); // extend logarithmic axis

    axis.lin2log = options.linearToLogConverter || axis.lin2log;

    if (axis.isLog) {
      axis.val2lin = axis.log2lin;
      axis.lin2val = axis.lin2log;
    }

    fireEvent$1(this, 'afterInit');
  },

  /**
   * Merge and set options.
   *
   * @private
   * @function Highcharts.Axis#setOptions
   *
   * @param {Highcharts.AxisOptions} userOptions
   *
   * @fires Highcharts.Axis#event:afterSetOptions
   */
  setOptions: function (userOptions) {
    this.options = merge$5(this.defaultOptions, this.coll === 'yAxis' && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], merge$5(defaultOptions[this.coll], // if set in setOptions (#1053)
    userOptions));
    fireEvent$1(this, 'afterSetOptions', {
      userOptions: userOptions
    });
  },

  /**
   * The default label formatter. The context is a special config object for
   * the label. In apps, use the {@link
   * https://api.highcharts.com/highcharts/xAxis.labels.formatter|
   * labels.formatter} instead except when a modification is needed.
   *
   * @private
   * @function Highcharts.Axis#defaultLabelFormatter
   *
   * @return {string}
   */
  defaultLabelFormatter: function () {
    var axis = this.axis,
        value = this.value,
        time = axis.chart.time,
        categories = axis.categories,
        dateTimeLabelFormat = this.dateTimeLabelFormat,
        lang = defaultOptions.lang,
        numericSymbols = lang.numericSymbols,
        numSymMagnitude = lang.numericSymbolMagnitude || 1000,
        i = numericSymbols && numericSymbols.length,
        multi,
        ret,
        formatOption = axis.options.labels.format,
        // make sure the same symbol is added for all labels on a linear
    // axis
    numericSymbolDetector = axis.isLog ? Math.abs(value) : axis.tickInterval;

    if (formatOption) {
      ret = format(formatOption, this, time);
    } else if (categories) {
      ret = value;
    } else if (dateTimeLabelFormat) {
      // datetime axis
      ret = time.dateFormat(dateTimeLabelFormat, value);
    } else if (i && numericSymbolDetector >= 1000) {
      // Decide whether we should add a numeric symbol like k (thousands)
      // or M (millions). If we are to enable this in tooltip or other
      // places as well, we can move this logic to the numberFormatter and
      // enable it by a parameter.
      while (i-- && ret === undefined) {
        multi = Math.pow(numSymMagnitude, i + 1);

        if ( // Only accept a numeric symbol when the distance is more
        // than a full unit. So for example if the symbol is k, we
        // don't accept numbers like 0.5k.
        numericSymbolDetector >= multi && // Accept one decimal before the symbol. Accepts 0.5k but
        // not 0.25k. How does this work with the previous?
        value * 10 % multi === 0 && numericSymbols[i] !== null && value !== 0) {
          // #5480
          ret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];
        }
      }
    }

    if (ret === undefined) {
      if (Math.abs(value) >= 10000) {
        // add thousands separators
        ret = Highcharts.numberFormat(value, -1);
      } else {
        // small numbers
        ret = Highcharts.numberFormat(value, -1, undefined, ''); // #2466
      }
    }

    return ret;
  },

  /**
   * Get the minimum and maximum for the series of each axis. The function
   * analyzes the axis series and updates `this.dataMin` and `this.dataMax`.
   *
   * @private
   * @function Highcharts.Axis#getSeriesExtremes
   *
   * @fires Highcharts.Axis#event:afterGetSeriesExtremes
   * @fires Highcharts.Axis#event:getSeriesExtremes
   */
  getSeriesExtremes: function () {
    var axis = this,
        chart = axis.chart;
    fireEvent$1(this, 'getSeriesExtremes', null, function () {
      axis.hasVisibleSeries = false; // Reset properties in case we're redrawing (#3353)

      axis.dataMin = axis.dataMax = axis.threshold = null;
      axis.softThreshold = !axis.isXAxis;

      if (axis.buildStacks) {
        axis.buildStacks();
      } // loop through this axis' series


      each$4(axis.series, function (series) {
        if (series.visible || !chart.options.chart.ignoreHiddenSeries) {
          var seriesOptions = series.options,
              xData,
              threshold = seriesOptions.threshold,
              seriesDataMin,
              seriesDataMax;
          axis.hasVisibleSeries = true; // Validate threshold in logarithmic axes

          if (axis.positiveValuesOnly && threshold <= 0) {
            threshold = null;
          } // Get dataMin and dataMax for X axes


          if (axis.isXAxis) {
            xData = series.xData;

            if (xData.length) {
              // If xData contains values which is not numbers,
              // then filter them out. To prevent performance hit,
              // we only do this after we have already found
              // seriesDataMin because in most cases all data is
              // valid. #5234.
              seriesDataMin = arrayMin(xData);
              seriesDataMax = arrayMax(xData);

              if (!isNumber$2(seriesDataMin) && !(seriesDataMin instanceof Date) // #5010
              ) {
                  xData = grep$1(xData, isNumber$2); // Do it again with valid data

                  seriesDataMin = arrayMin(xData);
                  seriesDataMax = arrayMax(xData);
                }

              if (xData.length) {
                axis.dataMin = Math.min(pick$4(axis.dataMin, xData[0], seriesDataMin), seriesDataMin);
                axis.dataMax = Math.max(pick$4(axis.dataMax, xData[0], seriesDataMax), seriesDataMax);
              }
            } // Get dataMin and dataMax for Y axes, as well as handle
            // stacking and processed data

          } else {
            // Get this particular series extremes
            series.getExtremes();
            seriesDataMax = series.dataMax;
            seriesDataMin = series.dataMin; // Get the dataMin and dataMax so far. If percentage is
            // used, the min and max are always 0 and 100. If
            // seriesDataMin and seriesDataMax is null, then series
            // doesn't have active y data, we continue with nulls

            if (defined$4(seriesDataMin) && defined$4(seriesDataMax)) {
              axis.dataMin = Math.min(pick$4(axis.dataMin, seriesDataMin), seriesDataMin);
              axis.dataMax = Math.max(pick$4(axis.dataMax, seriesDataMax), seriesDataMax);
            } // Adjust to threshold


            if (defined$4(threshold)) {
              axis.threshold = threshold;
            } // If any series has a hard threshold, it takes
            // precedence


            if (!seriesOptions.softThreshold || axis.positiveValuesOnly) {
              axis.softThreshold = false;
            }
          }
        }
      });
    });
    fireEvent$1(this, 'afterGetSeriesExtremes');
  },

  /**
   * Translate from axis value to pixel position on the chart, or back. Use
   * the `toPixels` and `toValue` functions in applications.
   *
   * @private
   * @function Highcharts.Axis#translate
   *
   * @param {number} val
   *
   * @param {boolean} [backwards]
   *
   * @param {boolean} [cvsCoord]
   *
   * @param {boolean} [old]
   *
   * @param {boolean} [handleLog]
   *
   * @param {number} [pointPlacement=0]
   *
   * @return {number|undefined}
   */
  translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {
    var axis = this.linkedParent || this,
        // #1417
    sign = 1,
        cvsOffset = 0,
        localA = old ? axis.oldTransA : axis.transA,
        localMin = old ? axis.oldMin : axis.min,
        returnValue,
        minPixelPadding = axis.minPixelPadding,
        doPostTranslate = (axis.isOrdinal || axis.isBroken || axis.isLog && handleLog) && axis.lin2val;

    if (!localA) {
      localA = axis.transA;
    } // In vertical axes, the canvas coordinates start from 0 at the top like
    // in SVG.


    if (cvsCoord) {
      sign *= -1; // canvas coordinates inverts the value

      cvsOffset = axis.len;
    } // Handle reversed axis


    if (axis.reversed) {
      sign *= -1;
      cvsOffset -= sign * (axis.sector || axis.len);
    } // From pixels to value


    if (backwards) {
      // reverse translation
      val = val * sign + cvsOffset;
      val -= minPixelPadding;
      returnValue = val / localA + localMin; // from chart pixel to value

      if (doPostTranslate) {
        // log and ordinal axes
        returnValue = axis.lin2val(returnValue);
      } // From value to pixels

    } else {
      if (doPostTranslate) {
        // log and ordinal axes
        val = axis.val2lin(val);
      }

      returnValue = isNumber$2(localMin) ? sign * (val - localMin) * localA + cvsOffset + sign * minPixelPadding + (isNumber$2(pointPlacement) ? localA * pointPlacement : 0) : undefined;
    }

    return returnValue;
  },

  /**
   * Translate a value in terms of axis units into pixels within the chart.
   *
   * @function Highcharts.Axis#toPixels
   *
   * @param {number} value
   *        A value in terms of axis units.
   *
   * @param {boolean} paneCoordinates
   *        Whether to return the pixel coordinate relative to the chart or
   *        just the axis/pane itself.
   *
   * @return {number}
   *         Pixel position of the value on the chart or axis.
   */
  toPixels: function (value, paneCoordinates) {
    return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
  },

  /**
   * Translate a pixel position along the axis to a value in terms of axis
   * units.
   *
   * @function Highcharts.Axis#toValue
   *
   * @param {number} pixel
   *        The pixel value coordinate.
   *
   * @param {boolean} paneCoordiantes
   *        Whether the input pixel is relative to the chart or just the
   *        axis/pane itself.
   *
   * @return {number}
   *         The axis value.
   */
  toValue: function (pixel, paneCoordinates) {
    return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
  },

  /**
   * Create the path for a plot line that goes from the given value on
   * this axis, across the plot to the opposite side. Also used internally for
   * grid lines and crosshairs.
   *
   * @function Highcharts.Axis#getPlotLinePath
   *
   * @param {number} value
   *        Axis value.
   *
   * @param {number} [lineWidth=1]
   *        Used for calculation crisp line coordinates.
   *
   * @param {boolean} [old=false]
   *        Use old coordinates (for resizing and rescaling).
   *
   * @param {boolean} [force=false]
   *        If `false`, the function will return null when it falls outside
   *        the axis bounds.
   *
   * @param {number} [translatedValue]
   *        If given, return the plot line path of a pixel position on the
   *        axis.
   *
   * @return {Array<string|number>}
   *         The SVG path definition for the plot line.
   */
  getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {
    var axis = this,
        chart = axis.chart,
        axisLeft = axis.left,
        axisTop = axis.top,
        x1,
        y1,
        x2,
        y2,
        cHeight = old && chart.oldChartHeight || chart.chartHeight,
        cWidth = old && chart.oldChartWidth || chart.chartWidth,
        skip,
        transB = axis.transB,

    /**
     * Check if x is between a and b. If not, either move to a/b
     * or skip, depending on the force parameter.
     */
    between = function (x, a, b) {
      if (x < a || x > b) {
        if (force) {
          x = Math.min(Math.max(a, x), b);
        } else {
          skip = true;
        }
      }

      return x;
    };

    translatedValue = pick$4(translatedValue, axis.translate(value, null, null, old)); // Keep the translated value within sane bounds, and avoid Infinity to
    // fail the isNumber test (#7709).

    translatedValue = Math.min(Math.max(-1e5, translatedValue), 1e5);
    x1 = x2 = Math.round(translatedValue + transB);
    y1 = y2 = Math.round(cHeight - translatedValue - transB);

    if (!isNumber$2(translatedValue)) {
      // no min or max
      skip = true;
      force = false; // #7175, don't force it when path is invalid
    } else if (axis.horiz) {
      y1 = axisTop;
      y2 = cHeight - axis.bottom;
      x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
    } else {
      x1 = axisLeft;
      x2 = cWidth - axis.right;
      y1 = y2 = between(y1, axisTop, axisTop + axis.height);
    }

    return skip && !force ? null : chart.renderer.crispLine(['M', x1, y1, 'L', x2, y2], lineWidth || 1);
  },

  /**
   * Internal function to et the tick positions of a linear axis to round
   * values like whole tens or every five.
   *
   * @function Highcharts.Axis#getLinearTickPositions
   *
   * @param {number} tickInterval
   *        The normalized tick interval.
   *
   * @param {number} min
   *        Axis minimum.
   *
   * @param {number} max
   *        Axis maximum.
   *
   * @return {Array<number>}
   *         An array of axis values where ticks should be placed.
   */
  getLinearTickPositions: function (tickInterval, min, max) {
    var pos,
        lastPos,
        roundedMin = correctFloat$1(Math.floor(min / tickInterval) * tickInterval),
        roundedMax = correctFloat$1(Math.ceil(max / tickInterval) * tickInterval),
        tickPositions = [],
        precision; // When the precision is higher than what we filter out in
    // correctFloat, skip it (#6183).

    if (correctFloat$1(roundedMin + tickInterval) === roundedMin) {
      precision = 20;
    } // For single points, add a tick regardless of the relative position
    // (#2662, #6274)


    if (this.single) {
      return [min];
    } // Populate the intermediate values


    pos = roundedMin;

    while (pos <= roundedMax) {
      // Place the tick on the rounded value
      tickPositions.push(pos); // Always add the raw tickInterval, not the corrected one.

      pos = correctFloat$1(pos + tickInterval, precision); // If the interval is not big enough in the current min - max range
      // to actually increase the loop variable, we need to break out to
      // prevent endless loop. Issue #619

      if (pos === lastPos) {
        break;
      } // Record the last value


      lastPos = pos;
    }

    return tickPositions;
  },

  /**
   * Resolve the new minorTicks/minorTickInterval options into the legacy
   * loosely typed minorTickInterval option.
   *
   * @function Highcharts.Axis#getMinorTickInterval
   *
   * @return {number|'auto'|null}
   */
  getMinorTickInterval: function () {
    var options = this.options;

    if (options.minorTicks === true) {
      return pick$4(options.minorTickInterval, 'auto');
    }

    if (options.minorTicks === false) {
      return null;
    }

    return options.minorTickInterval;
  },

  /**
   * Internal function to return the minor tick positions. For logarithmic
   * axes, the same logic as for major ticks is reused.
   *
   * @function Highcharts.Axis#getMinorTickPositions
   *
   * @return {Array<number>}
   *         An array of axis values where ticks should be placed.
   */
  getMinorTickPositions: function () {
    var axis = this,
        options = axis.options,
        tickPositions = axis.tickPositions,
        minorTickInterval = axis.minorTickInterval,
        minorTickPositions = [],
        pos,
        pointRangePadding = axis.pointRangePadding || 0,
        min = axis.min - pointRangePadding,
        // #1498
    max = axis.max + pointRangePadding,
        // #1498
    range = max - min; // If minor ticks get too dense, they are hard to read, and may cause
    // long running script. So we don't draw them.

    if (range && range / minorTickInterval < axis.len / 3) {
      // #3875
      if (axis.isLog) {
        // For each interval in the major ticks, compute the minor ticks
        // separately.
        each$4(this.paddedTicks, function (pos, i, paddedTicks) {
          if (i) {
            minorTickPositions.push.apply(minorTickPositions, axis.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));
          }
        });
      } else if (axis.isDatetimeAxis && this.getMinorTickInterval() === 'auto') {
        // #1314
        minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.normalizeTimeTickInterval(minorTickInterval), min, max, options.startOfWeek));
      } else {
        for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
          // Very, very, tight grid lines (#5771)
          if (pos === minorTickPositions[0]) {
            break;
          }

          minorTickPositions.push(pos);
        }
      }
    }

    if (minorTickPositions.length !== 0) {
      axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330
    }

    return minorTickPositions;
  },

  /**
   * Adjust the min and max for the minimum range. Keep in mind that the
   * series data is not yet processed, so we don't have information on data
   * cropping and grouping, or updated axis.pointRange or series.pointRange.
   * The data can't be processed until we have finally established min and
   * max.
   *
   * @private
   * @function Highcharts.Axis#adjustForMinRange
   */
  adjustForMinRange: function () {
    var axis = this,
        options = axis.options,
        min = axis.min,
        max = axis.max,
        zoomOffset,
        spaceAvailable,
        closestDataRange,
        i,
        distance,
        xData,
        loopLength,
        minArgs,
        maxArgs,
        minRange; // Set the automatic minimum range based on the closest point distance

    if (axis.isXAxis && axis.minRange === undefined && !axis.isLog) {
      if (defined$4(options.min) || defined$4(options.max)) {
        axis.minRange = null; // don't do this again
      } else {
        // Find the closest distance between raw data points, as opposed
        // to closestPointRange that applies to processed points
        // (cropped and grouped)
        each$4(axis.series, function (series) {
          xData = series.xData;
          loopLength = series.xIncrement ? 1 : xData.length - 1;

          for (i = loopLength; i > 0; i--) {
            distance = xData[i] - xData[i - 1];

            if (closestDataRange === undefined || distance < closestDataRange) {
              closestDataRange = distance;
            }
          }
        });
        axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);
      }
    } // if minRange is exceeded, adjust


    if (max - min < axis.minRange) {
      spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;
      minRange = axis.minRange;
      zoomOffset = (minRange - max + min) / 2; // if min and max options have been set, don't go beyond it

      minArgs = [min - zoomOffset, pick$4(options.min, min - zoomOffset)]; // If space is available, stay within the data range

      if (spaceAvailable) {
        minArgs[2] = axis.isLog ? axis.log2lin(axis.dataMin) : axis.dataMin;
      }

      min = arrayMax(minArgs);
      maxArgs = [min + minRange, pick$4(options.max, min + minRange)]; // If space is availabe, stay within the data range

      if (spaceAvailable) {
        maxArgs[2] = axis.isLog ? axis.log2lin(axis.dataMax) : axis.dataMax;
      }

      max = arrayMin(maxArgs); // now if the max is adjusted, adjust the min back

      if (max - min < minRange) {
        minArgs[0] = max - minRange;
        minArgs[1] = pick$4(options.min, max - minRange);
        min = arrayMax(minArgs);
      }
    } // Record modified extremes


    axis.min = min;
    axis.max = max;
  },

  /**
   * Find the closestPointRange across all series.
   *
   * @private
   * @function Highcharts.Axis#getClosest
   *
   * @return {number}
   */
  getClosest: function () {
    var ret;

    if (this.categories) {
      ret = 1;
    } else {
      each$4(this.series, function (series) {
        var seriesClosest = series.closestPointRange,
            visible = series.visible || !series.chart.options.chart.ignoreHiddenSeries;

        if (!series.noSharedTooltip && defined$4(seriesClosest) && visible) {
          ret = defined$4(ret) ? Math.min(ret, seriesClosest) : seriesClosest;
        }
      });
    }

    return ret;
  },

  /**
   * When a point name is given and no x, search for the name in the existing
   * categories, or if categories aren't provided, search names or create a
   * new category (#2522).
   *
   * @private
   * @function Highcharts.Axis#nameToX
   *
   * @param {Highcharts.Point} point
   *        The point to inspect.
   *
   * @return {number}
   *         The X value that the point is given.
   */
  nameToX: function (point) {
    var explicitCategories = isArray$1(this.categories),
        names = explicitCategories ? this.categories : this.names,
        nameX = point.options.x,
        x;
    point.series.requireSorting = false;

    if (!defined$4(nameX)) {
      nameX = this.options.uniqueNames === false ? point.series.autoIncrement() : explicitCategories ? inArray$1(point.name, names) : pick$4(names.keys[point.name], -1);
    }

    if (nameX === -1) {
      // Not found in currenct categories
      if (!explicitCategories) {
        x = names.length;
      }
    } else {
      x = nameX;
    } // Write the last point's name to the names array


    if (x !== undefined) {
      this.names[x] = point.name; // Backwards mapping is much faster than array searching (#7725)

      this.names.keys[point.name] = x;
    }

    return x;
  },

  /**
   * When changes have been done to series data, update the axis.names.
   *
   * @private
   * @function Highcharts.Axis#updateNames
   */
  updateNames: function () {
    var axis = this,
        names = this.names,
        i = names.length;

    if (i > 0) {
      each$4(Highcharts.keys(names.keys), function (key) {
        delete names.keys[key];
      });
      names.length = 0;
      this.minRange = this.userMinRange; // Reset

      each$4(this.series || [], function (series) {
        // Reset incrementer (#5928)
        series.xIncrement = null; // When adding a series, points are not yet generated

        if (!series.points || series.isDirtyData) {
          series.processData();
          series.generatePoints();
        }

        each$4(series.points, function (point, i) {
          var x;

          if (point.options) {
            x = axis.nameToX(point);

            if (x !== undefined && x !== point.x) {
              point.x = x;
              series.xData[i] = x;
            }
          }
        });
      });
    }
  },

  /**
   * Update translation information.
   *
   * @private
   * @function Highcharts.Axis#setAxisTranslation
   *
   * @param {boolean} saveOld
   *
   * @fires Highcharts.Axis#event:afterSetAxisTranslation
   */
  setAxisTranslation: function (saveOld) {
    var axis = this,
        range = axis.max - axis.min,
        pointRange = axis.axisPointRange || 0,
        closestPointRange,
        minPointOffset = 0,
        pointRangePadding = 0,
        linkedParent = axis.linkedParent,
        ordinalCorrection,
        hasCategories = !!axis.categories,
        transA = axis.transA,
        isXAxis = axis.isXAxis; // Adjust translation for padding. Y axis with categories need to go
    // through the same (#1784).

    if (isXAxis || hasCategories || pointRange) {
      // Get the closest points
      closestPointRange = axis.getClosest();

      if (linkedParent) {
        minPointOffset = linkedParent.minPointOffset;
        pointRangePadding = linkedParent.pointRangePadding;
      } else {
        each$4(axis.series, function (series) {
          var seriesPointRange = hasCategories ? 1 : isXAxis ? pick$4(series.options.pointRange, closestPointRange, 0) : axis.axisPointRange || 0,
              // #2806
          pointPlacement = series.options.pointPlacement;
          pointRange = Math.max(pointRange, seriesPointRange);

          if (!axis.single) {
            // minPointOffset is the value padding to the left of
            // the axis in order to make room for points with a
            // pointRange, typically columns. When the
            // pointPlacement option is 'between' or 'on', this
            // padding does not apply.
            minPointOffset = Math.max(minPointOffset, isString$2(pointPlacement) ? 0 : seriesPointRange / 2); // Determine the total padding needed to the length of
            // the axis to make room for the pointRange. If the
            // series' pointPlacement is 'on', no padding is added.

            pointRangePadding = Math.max(pointRangePadding, pointPlacement === 'on' ? 0 : seriesPointRange);
          }
        });
      } // Record minPointOffset and pointRangePadding


      ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853

      axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
      axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection; // pointRange means the width reserved for each point, like in a
      // column chart

      axis.pointRange = Math.min(pointRange, range); // closestPointRange means the closest distance between points. In
      // columns it is mostly equal to pointRange, but in lines pointRange
      // is 0 while closestPointRange is some other value

      if (isXAxis) {
        axis.closestPointRange = closestPointRange;
      }
    } // Secondary values


    if (saveOld) {
      axis.oldTransA = transA;
    }

    axis.translationSlope = axis.transA = transA = axis.options.staticScale || axis.len / (range + pointRangePadding || 1); // Translation addend

    axis.transB = axis.horiz ? axis.left : axis.bottom;
    axis.minPixelPadding = transA * minPointOffset;
    fireEvent$1(this, 'afterSetAxisTranslation');
  },

  /**
   * @private
   * @function Highcharts.Axis#minFromRange
   *
   * @return {number}
   */
  minFromRange: function () {
    return this.max - this.range;
  },

  /**
   * Set the tick positions to round values and optionally extend the extremes
   * to the nearest tick.
   *
   * @private
   * @function Highcharts.Axis#setTickInterval
   *
   * @param {boolean} secondPass
   *
   * @fires Highcharts.Axis#event:foundExtremes
   */
  setTickInterval: function (secondPass) {
    var axis = this,
        chart = axis.chart,
        options = axis.options,
        isLog = axis.isLog,
        isDatetimeAxis = axis.isDatetimeAxis,
        isXAxis = axis.isXAxis,
        isLinked = axis.isLinked,
        maxPadding = options.maxPadding,
        minPadding = options.minPadding,
        length,
        linkedParentExtremes,
        tickIntervalOption = options.tickInterval,
        minTickInterval,
        tickPixelIntervalOption = options.tickPixelInterval,
        categories = axis.categories,
        threshold = isNumber$2(axis.threshold) ? axis.threshold : null,
        softThreshold = axis.softThreshold,
        thresholdMin,
        thresholdMax,
        hardMin,
        hardMax;

    if (!isDatetimeAxis && !categories && !isLinked) {
      this.getTickAmount();
    } // Min or max set either by zooming/setExtremes or initial options


    hardMin = pick$4(axis.userMin, options.min);
    hardMax = pick$4(axis.userMax, options.max); // Linked axis gets the extremes from the parent axis

    if (isLinked) {
      axis.linkedParent = chart[axis.coll][options.linkedTo];
      linkedParentExtremes = axis.linkedParent.getExtremes();
      axis.min = pick$4(linkedParentExtremes.min, linkedParentExtremes.dataMin);
      axis.max = pick$4(linkedParentExtremes.max, linkedParentExtremes.dataMax);

      if (options.type !== axis.linkedParent.options.type) {
        Highcharts.error(11, 1); // Can't link axes of different type
      } // Initial min and max from the extreme data values

    } else {
      // Adjust to hard threshold
      if (!softThreshold && defined$4(threshold)) {
        if (axis.dataMin >= threshold) {
          thresholdMin = threshold;
          minPadding = 0;
        } else if (axis.dataMax <= threshold) {
          thresholdMax = threshold;
          maxPadding = 0;
        }
      }

      axis.min = pick$4(hardMin, thresholdMin, axis.dataMin);
      axis.max = pick$4(hardMax, thresholdMax, axis.dataMax);
    }

    if (isLog) {
      if (axis.positiveValuesOnly && !secondPass && Math.min(axis.min, pick$4(axis.dataMin, axis.min)) <= 0) {
        // #978
        Highcharts.error(10, 1); // Can't plot negative values on log axis
      } // The correctFloat cures #934, float errors on full tens. But it
      // was too aggressive for #4360 because of conversion back to lin,
      // therefore use precision 15.


      axis.min = correctFloat$1(axis.log2lin(axis.min), 15);
      axis.max = correctFloat$1(axis.log2lin(axis.max), 15);
    } // handle zoomed range


    if (axis.range && defined$4(axis.max)) {
      axis.userMin = axis.min = hardMin = Math.max(axis.dataMin, axis.minFromRange()); // #618, #6773

      axis.userMax = hardMax = axis.max;
      axis.range = null; // don't use it when running setExtremes
    } // Hook for Highstock Scroller. Consider combining with beforePadding.


    fireEvent$1(axis, 'foundExtremes'); // Hook for adjusting this.min and this.max. Used by bubble series.

    if (axis.beforePadding) {
      axis.beforePadding();
    } // adjust min and max for the minimum range


    axis.adjustForMinRange(); // Pad the values to get clear of the chart's edges. To avoid
    // tickInterval taking the padding into account, we do this after
    // computing tick interval (#1337).

    if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined$4(axis.min) && defined$4(axis.max)) {
      length = axis.max - axis.min;

      if (length) {
        if (!defined$4(hardMin) && minPadding) {
          axis.min -= length * minPadding;
        }

        if (!defined$4(hardMax) && maxPadding) {
          axis.max += length * maxPadding;
        }
      }
    } // Handle options for floor, ceiling, softMin and softMax (#6359)


    if (isNumber$2(options.softMin) && !isNumber$2(axis.userMin)) {
      axis.min = Math.min(axis.min, options.softMin);
    }

    if (isNumber$2(options.softMax) && !isNumber$2(axis.userMax)) {
      axis.max = Math.max(axis.max, options.softMax);
    }

    if (isNumber$2(options.floor)) {
      axis.min = Math.max(axis.min, options.floor);
    }

    if (isNumber$2(options.ceiling)) {
      axis.max = Math.min(axis.max, options.ceiling);
    } // When the threshold is soft, adjust the extreme value only if the data
    // extreme and the padded extreme land on either side of the threshold.
    // For example, a series of [0, 1, 2, 3] would make the yAxis add a tick
    // for -1 because of the default minPadding and startOnTick options.
    // This is prevented by the softThreshold option.


    if (softThreshold && defined$4(axis.dataMin)) {
      threshold = threshold || 0;

      if (!defined$4(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {
        axis.min = threshold;
      } else if (!defined$4(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {
        axis.max = threshold;
      }
    } // get tickInterval


    if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
      axis.tickInterval = 1;
    } else if (isLinked && !tickIntervalOption && tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
      axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
    } else {
      axis.tickInterval = pick$4(tickIntervalOption, this.tickAmount ? (axis.max - axis.min) / Math.max(this.tickAmount - 1, 1) : undefined, // For categoried axis, 1 is default, for linear axis use
      // tickPix
      categories ? 1 : // don't let it be more than the data range
      (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption));
    }
    /**
     * Now we're finished detecting min and max, crop and group series data.
     * This is in turn needed in order to find tick positions in
     * ordinal axes.
     */


    if (isXAxis && !secondPass) {
      each$4(axis.series, function (series) {
        series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
      });
    } // set the translation factor used in translate function


    axis.setAxisTranslation(true); // hook for ordinal axes and radial axes

    if (axis.beforeSetTickPositions) {
      axis.beforeSetTickPositions();
    } // hook for extensions, used in Highstock ordinal axes


    if (axis.postProcessTickInterval) {
      axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
    } // In column-like charts, don't cramp in more ticks than there are
    // points (#1943, #4184)


    if (axis.pointRange && !tickIntervalOption) {
      axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
    } // Before normalizing the tick interval, handle minimum tick interval.
    // This applies only if tickInterval is not defined.


    minTickInterval = pick$4(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);

    if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
      axis.tickInterval = minTickInterval;
    } // for linear axes, get magnitude and normalize the interval


    if (!isDatetimeAxis && !isLog && !tickIntervalOption) {
      axis.tickInterval = normalizeTickInterval(axis.tickInterval, null, getMagnitude(axis.tickInterval), // If the tick interval is between 0.5 and 5 and the axis max is
      // in the order of thousands, chances are we are dealing with
      // years. Don't allow decimals. #3363.
      pick$4(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)), !!this.tickAmount);
    } // Prevent ticks from getting so close that we can't draw the labels


    if (!this.tickAmount) {
      axis.tickInterval = axis.unsquish();
    }

    this.setTickPositions();
  },

  /**
   * Now we have computed the normalized tickInterval, get the tick positions
   *
   * @function Highcharts.Axis#setTickPositions
   *
   * @fires Highcharts.Axis#event:afterSetTickPositions
   */
  setTickPositions: function () {
    var options = this.options,
        tickPositions,
        tickPositionsOption = options.tickPositions,
        minorTickIntervalOption = this.getMinorTickInterval(),
        tickPositioner = options.tickPositioner,
        startOnTick = options.startOnTick,
        endOnTick = options.endOnTick; // Set the tickmarkOffset

    this.tickmarkOffset = this.categories && options.tickmarkPlacement === 'between' && this.tickInterval === 1 ? 0.5 : 0; // #3202
    // get minorTickInterval

    this.minorTickInterval = minorTickIntervalOption === 'auto' && this.tickInterval ? this.tickInterval / 5 : minorTickIntervalOption; // When there is only one point, or all points have the same value on
    // this axis, then min and max are equal and tickPositions.length is 0
    // or 1. In this case, add some padding in order to center the point,
    // but leave it with one tick. #1337.

    this.single = this.min === this.max && defined$4(this.min) && !this.tickAmount && ( // Data is on integer (#6563)
    parseInt(this.min, 10) === this.min || // Between integers and decimals are not allowed (#6274)
    options.allowDecimals !== false); // Find the tick positions. Work on a copy (#1565)

    this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice();

    if (!tickPositions) {
      // Too many ticks (#6405). Create a friendly warning and provide two
      // ticks so at least we can show the data series.
      if (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) {
        tickPositions = [this.min, this.max];
        Highcharts.error(19);
      } else if (this.isDatetimeAxis) {
        tickPositions = this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, this.ordinalPositions, this.closestPointRange, true);
      } else if (this.isLog) {
        tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);
      } else {
        tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
      } // Too dense ticks, keep only the first and last (#4477)


      if (tickPositions.length > this.len) {
        tickPositions = [tickPositions[0], tickPositions.pop()]; // Reduce doubled value (#7339)

        if (tickPositions[0] === tickPositions[1]) {
          tickPositions.length = 1;
        }
      }

      this.tickPositions = tickPositions; // Run the tick positioner callback, that allows modifying auto tick
      // positions.

      if (tickPositioner) {
        tickPositioner = tickPositioner.apply(this, [this.min, this.max]);

        if (tickPositioner) {
          this.tickPositions = tickPositions = tickPositioner;
        }
      }
    } // Reset min/max or remove extremes based on start/end on tick


    this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor

    this.trimTicks(tickPositions, startOnTick, endOnTick);

    if (!this.isLinked) {
      // Substract half a unit (#2619, #2846, #2515, #3390),
      // but not in case of multiple ticks (#6897)
      if (this.single && tickPositions.length < 2) {
        this.min -= 0.5;
        this.max += 0.5;
      }

      if (!tickPositionsOption && !tickPositioner) {
        this.adjustTickAmount();
      }
    }

    fireEvent$1(this, 'afterSetTickPositions');
  },

  /**
   * Handle startOnTick and endOnTick by either adapting to padding min/max or
   * rounded min/max. Also handle single data points.
   *
   * @private
   * @function Highcharts.Axis#trimTicks
   *
   * @param {Array<number>} tickPositions
   *
   * @param {boolean} startOnTicl
   *
   * @param {boolean} endOnTick
   */
  trimTicks: function (tickPositions, startOnTick, endOnTick) {
    var roundedMin = tickPositions[0],
        roundedMax = tickPositions[tickPositions.length - 1],
        minPointOffset = this.minPointOffset || 0;

    if (!this.isLinked) {
      if (startOnTick && roundedMin !== -Infinity) {
        // #6502
        this.min = roundedMin;
      } else {
        while (this.min - minPointOffset > tickPositions[0]) {
          tickPositions.shift();
        }
      }

      if (endOnTick) {
        this.max = roundedMax;
      } else {
        while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {
          tickPositions.pop();
        }
      } // If no tick are left, set one tick in the middle (#3195)


      if (tickPositions.length === 0 && defined$4(roundedMin) && !this.options.tickPositions) {
        tickPositions.push((roundedMax + roundedMin) / 2);
      }
    }
  },

  /**
   * Check if there are multiple axes in the same pane.
   *
   * @private
   * @function Highcharts.Axis#alignToOthers
   *
   * @return {boolean}
   *         True if there are other axes.
   */
  alignToOthers: function () {
    var others = {},
        // Whether there is another axis to pair with this one
    hasOther,
        options = this.options;

    if ( // Only if alignTicks is true
    this.chart.options.chart.alignTicks !== false && options.alignTicks !== false && // Disabled when startOnTick or endOnTick are false (#7604)
    options.startOnTick !== false && options.endOnTick !== false && // Don't try to align ticks on a log axis, they are not evenly
    // spaced (#6021)
    !this.isLog) {
      each$4(this.chart[this.coll], function (axis) {
        var otherOptions = axis.options,
            horiz = axis.horiz,
            key = [horiz ? otherOptions.left : otherOptions.top, otherOptions.width, otherOptions.height, otherOptions.pane].join(',');

        if (axis.series.length) {
          // #4442
          if (others[key]) {
            hasOther = true; // #4201
          } else {
            others[key] = 1;
          }
        }
      });
    }

    return hasOther;
  },

  /**
   * Find the max ticks of either the x and y axis collection, and record it
   * in `this.tickAmount`.
   *
   * @private
   * @function Highcharts.Axis#getTickAmount
   */
  getTickAmount: function () {
    var options = this.options,
        tickAmount = options.tickAmount,
        tickPixelInterval = options.tickPixelInterval;

    if (!defined$4(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial && !this.isLog && options.startOnTick && options.endOnTick) {
      tickAmount = 2;
    }

    if (!tickAmount && this.alignToOthers()) {
      // Add 1 because 4 tick intervals require 5 ticks (including first
      // and last)
      tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
    } // For tick amounts of 2 and 3, compute five ticks and remove the
    // intermediate ones. This prevents the axis from adding ticks that are
    // too far away from the data extremes.


    if (tickAmount < 4) {
      this.finalTickAmt = tickAmount;
      tickAmount = 5;
    }

    this.tickAmount = tickAmount;
  },

  /**
   * When using multiple axes, adjust the number of ticks to match the highest
   * number of ticks in that group.
   *
   * @private
   * @function Highcharts.Axis#adjustTickAmount
   */
  adjustTickAmount: function () {
    var tickInterval = this.tickInterval,
        tickPositions = this.tickPositions,
        tickAmount = this.tickAmount,
        finalTickAmt = this.finalTickAmt,
        currentTickAmount = tickPositions && tickPositions.length,
        threshold = pick$4(this.threshold, this.softThreshold ? 0 : null),
        i,
        len;

    if (this.hasData()) {
      if (currentTickAmount < tickAmount) {
        while (tickPositions.length < tickAmount) {
          // Extend evenly for both sides unless we're on the
          // threshold (#3965)
          if (tickPositions.length % 2 || this.min === threshold) {
            // to the end
            tickPositions.push(correctFloat$1(tickPositions[tickPositions.length - 1] + tickInterval));
          } else {
            // to the start
            tickPositions.unshift(correctFloat$1(tickPositions[0] - tickInterval));
          }
        }

        this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
        this.min = tickPositions[0];
        this.max = tickPositions[tickPositions.length - 1]; // We have too many ticks, run second pass to try to reduce ticks
      } else if (currentTickAmount > tickAmount) {
        this.tickInterval *= 2;
        this.setTickPositions();
      } // The finalTickAmt property is set in getTickAmount


      if (defined$4(finalTickAmt)) {
        i = len = tickPositions.length;

        while (i--) {
          if ( // Remove every other tick
          finalTickAmt === 3 && i % 2 === 1 || // Remove all but first and last
          finalTickAmt <= 2 && i > 0 && i < len - 1) {
            tickPositions.splice(i, 1);
          }
        }

        this.finalTickAmt = undefined;
      }
    }
  },

  /**
   * Set the scale based on data min and max, user set min and max or options.
   *
   * @private
   * @function Highcharts.Axis#setScale
   *
   * @fires Highcharts.Axis#event:afterSetScale
   */
  setScale: function () {
    var axis = this,
        isDirtyData,
        isDirtyAxisLength;
    axis.oldMin = axis.min;
    axis.oldMax = axis.max;
    axis.oldAxisLength = axis.len; // set the new axisLength

    axis.setAxisSize();
    isDirtyAxisLength = axis.len !== axis.oldAxisLength; // is there new data?

    each$4(axis.series, function (series) {
      if (series.isDirtyData || series.isDirty || // When x axis is dirty, we need new data extremes for y as well
      series.xAxis.isDirty) {
        isDirtyData = true;
      }
    }); // do we really need to go through all this?

    if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw || axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {
      if (axis.resetStacks) {
        axis.resetStacks();
      }

      axis.forceRedraw = false; // get data extremes if needed

      axis.getSeriesExtremes(); // get fixed positions based on tickInterval

      axis.setTickInterval(); // record old values to decide whether a rescale is necessary later
      // on (#540)

      axis.oldUserMin = axis.userMin;
      axis.oldUserMax = axis.userMax; // Mark as dirty if it is not already set to dirty and extremes have
      // changed. #595.

      if (!axis.isDirty) {
        axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
      }
    } else if (axis.cleanStacks) {
      axis.cleanStacks();
    }

    fireEvent$1(this, 'afterSetScale');
  },

  /**
   * Set the minimum and maximum of the axes after render time. If the
   * `startOnTick` and `endOnTick` options are true, the minimum and maximum
   * values are rounded off to the nearest tick. To prevent this, these
   * options can be set to false before calling setExtremes. Also, setExtremes
   * will not allow a range lower than the `minRange` option, which by default
   * is the range of five points.
   *
   * @sample highcharts/members/axis-setextremes/
   *         Set extremes from a button
   * @sample highcharts/members/axis-setextremes-datetime/
   *         Set extremes on a datetime axis
   * @sample highcharts/members/axis-setextremes-off-ticks/
   *         Set extremes off ticks
   * @sample stock/members/axis-setextremes/
   *         Set extremes in Highstock
   * @sample maps/members/axis-setextremes/
   *         Set extremes in Highmaps
   *
   * @function Highcharts.Axis#setExtremes
   *
   * @param {number} [newMin]
   *        The new minimum value.
   *
   * @param {number} [newMax]
   *        The new maximum value.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart or wait for an explicit call to
   *        {@link Highcharts.Chart#redraw}
   *
   * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]
   *        Enable or modify animations.
   *
   * @param {*} [eventArguments]
   *        Arguments to be accessed in event handler.
   *
   * @fires Highcharts.Axis#event:setExtremes
   */
  setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
    var axis = this,
        chart = axis.chart;
    redraw = pick$4(redraw, true); // defaults to true

    each$4(axis.series, function (serie) {
      delete serie.kdTree;
    }); // Extend the arguments with min and max

    eventArguments = extend$3(eventArguments, {
      min: newMin,
      max: newMax
    }); // Fire the event

    fireEvent$1(axis, 'setExtremes', eventArguments, function () {
      axis.userMin = newMin;
      axis.userMax = newMax;
      axis.eventArgs = eventArguments;

      if (redraw) {
        chart.redraw(animation);
      }
    });
  },

  /**
   * Overridable method for zooming chart. Pulled out in a separate method to
   * allow overriding in stock charts.
   *
   * @private
   * @function Highcharts.Axis#zoom
   *
   * @param {number} newMin
   *
   * @param {number} newMax
   *
   * @return {boolean}
   */
  zoom: function (newMin, newMax) {
    var dataMin = this.dataMin,
        dataMax = this.dataMax,
        options = this.options,
        min = Math.min(dataMin, pick$4(options.min, dataMin)),
        max = Math.max(dataMax, pick$4(options.max, dataMax));

    if (newMin !== this.min || newMax !== this.max) {
      // #5790
      // Prevent pinch zooming out of range. Check for defined is for
      // #1946. #1734.
      if (!this.allowZoomOutside) {
        // #6014, sometimes newMax will be smaller than min (or newMin
        // will be larger than max).
        if (defined$4(dataMin)) {
          if (newMin < min) {
            newMin = min;
          }

          if (newMin > max) {
            newMin = max;
          }
        }

        if (defined$4(dataMax)) {
          if (newMax < min) {
            newMax = min;
          }

          if (newMax > max) {
            newMax = max;
          }
        }
      } // In full view, displaying the reset zoom button is not required


      this.displayBtn = newMin !== undefined || newMax !== undefined; // Do it

      this.setExtremes(newMin, newMax, false, undefined, {
        trigger: 'zoom'
      });
    }

    return true;
  },

  /**
   * Update the axis metrics.
   *
   * @private
   * @function Highcharts.Axis#setAxisSize
   */
  setAxisSize: function () {
    var chart = this.chart,
        options = this.options,
        // [top, right, bottom, left]
    offsets = options.offsets || [0, 0, 0, 0],
        horiz = this.horiz,
        // Check for percentage based input values. Rounding fixes problems
    // with column overflow and plot line filtering (#4898, #4899)
    width = this.width = Math.round(Highcharts.relativeLength(pick$4(options.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth)),
        height = this.height = Math.round(Highcharts.relativeLength(pick$4(options.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight)),
        top = this.top = Math.round(Highcharts.relativeLength(pick$4(options.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop)),
        left = this.left = Math.round(Highcharts.relativeLength(pick$4(options.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft)); // Expose basic values to use in Series object and navigator

    this.bottom = chart.chartHeight - height - top;
    this.right = chart.chartWidth - width - left; // Direction agnostic properties

    this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905

    this.pos = horiz ? left : top; // distance from SVG origin
  },

  /**
   * Get the current extremes for the axis.
   *
   * @sample highcharts/members/axis-getextremes/
   *         Report extremes by click on a button
   * @sample maps/members/axis-getextremes/
   *         Get extremes in Highmaps
   *
   * @function Highcharts.Axis#getExtremes
   *
   * @returns {Highcharts.ExtremesObject}
   *          An object containing extremes information.
   */
  getExtremes: function () {
    var axis = this,
        isLog = axis.isLog;
    return {
      min: isLog ? correctFloat$1(axis.lin2log(axis.min)) : axis.min,
      max: isLog ? correctFloat$1(axis.lin2log(axis.max)) : axis.max,
      dataMin: axis.dataMin,
      dataMax: axis.dataMax,
      userMin: axis.userMin,
      userMax: axis.userMax
    };
  },

  /**
   * Get the zero plane either based on zero or on the min or max value.
   * Used in bar and area plots.
   *
   * @function Highcharts.Axis#getThreshold
   *
   * @param {number} threshold
   *        The threshold in axis values.
   *
   * @return {number}
   *         The translated threshold position in terms of pixels, and
   *         corrected to stay within the axis bounds.
   */
  getThreshold: function (threshold) {
    var axis = this,
        isLog = axis.isLog,
        realMin = isLog ? axis.lin2log(axis.min) : axis.min,
        realMax = isLog ? axis.lin2log(axis.max) : axis.max;

    if (threshold === null || threshold === -Infinity) {
      threshold = realMin;
    } else if (threshold === Infinity) {
      threshold = realMax;
    } else if (realMin > threshold) {
      threshold = realMin;
    } else if (realMax < threshold) {
      threshold = realMax;
    }

    return axis.translate(threshold, 0, 1, 0, 1);
  },

  /**
   * Compute auto alignment for the axis label based on which side the axis is
   * on and the given rotation for the label.
   *
   * @private
   * @function Highcharts.Axis#autoLabelAlign
   *
   * @param {number} rotation
   *        The rotation in degrees as set by either the `rotation` or
   *        `autoRotation` options.
   *
   * @return {string}
   *         Can be `center`, `left` or `right`.
   */
  autoLabelAlign: function (rotation) {
    var ret,
        angle = (pick$4(rotation, 0) - this.side * 90 + 720) % 360;

    if (angle > 15 && angle < 165) {
      ret = 'right';
    } else if (angle > 195 && angle < 345) {
      ret = 'left';
    } else {
      ret = 'center';
    }

    return ret;
  },

  /**
   * Get the tick length and width for the axis based on axis options.
   *
   * @private
   * @function Highcharts.Axis#tickSize
   *
   * @param {string} prefix
   *        'tick' or 'minorTick'
   *
   * @return {Array<number>}
   *         An array of tickLength and tickWidth
   */
  tickSize: function (prefix) {
    var options = this.options,
        tickLength = options[prefix + 'Length'],
        tickWidth = pick$4(options[prefix + 'Width'], prefix === 'tick' && this.isXAxis ? 1 : 0 // X axis default 1
    );

    if (tickWidth && tickLength) {
      // Negate the length
      if (options[prefix + 'Position'] === 'inside') {
        tickLength = -tickLength;
      }

      return [tickLength, tickWidth];
    }
  },

  /**
   * Return the size of the labels.
   *
   * @private
   * @function Highcharts.Axis#labelMetrics
   *
   * @return {Highcharts.FontMetricsObject}
   */
  labelMetrics: function () {
    var index = this.tickPositions && this.tickPositions[0] || 0;
    return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[index] && this.ticks[index].label);
  },

  /**
   * Prevent the ticks from getting so close we can't draw the labels. On a
   * horizontal axis, this is handled by rotating the labels, removing ticks
   * and adding ellipsis. On a vertical axis remove ticks and add ellipsis.
   *
   * @private
   * @function Highcharts.Axis#unsquish
   *
   * @return {number}
   */
  unsquish: function () {
    var labelOptions = this.options.labels,
        horiz = this.horiz,
        tickInterval = this.tickInterval,
        newTickInterval = tickInterval,
        slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),
        rotation,
        rotationOption = labelOptions.rotation,
        labelMetrics = this.labelMetrics(),
        step,
        bestScore = Number.MAX_VALUE,
        autoRotation,
        // Return the multiple of tickInterval that is needed to avoid
    // collision
    getStep = function (spaceNeeded) {
      var step = spaceNeeded / (slotSize || 1);
      step = step > 1 ? Math.ceil(step) : 1;
      return correctFloat$1(step * tickInterval);
    };

    if (horiz) {
      autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971
      defined$4(rotationOption) ? [rotationOption] : slotSize < pick$4(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation);

      if (autoRotation) {
        // Loop over the given autoRotation options, and determine
        // which gives the best score. The best score is that with
        // the lowest number of steps and a rotation closest
        // to horizontal.
        each$4(autoRotation, function (rot) {
          var score;

          if (rot === rotationOption || rot && rot >= -90 && rot <= 90) {
            // #3891
            step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad$2 * rot)));
            score = step + Math.abs(rot / 360);

            if (score < bestScore) {
              bestScore = score;
              rotation = rot;
              newTickInterval = step;
            }
          }
        });
      }
    } else if (!labelOptions.step) {
      // #4411
      newTickInterval = getStep(labelMetrics.h);
    }

    this.autoRotation = autoRotation;
    this.labelRotation = pick$4(rotation, rotationOption);
    return newTickInterval;
  },

  /**
   * Get the general slot width for labels/categories on this axis. This may
   * change between the pre-render (from Axis.getOffset) and the final tick
   * rendering and placement.
   *
   * @private
   * @function Highcharts.Axis#getSlotWidth
   *
   * @param {*} [tick]
   *        Optionally, calculate the slot width basing on tick label. It is
   *        used in highcharts-3d module, where the slots has different widths
   *        depending on perspective angles.
   *
   * @return {number}
   *         The pixel width allocated to each axis label.
   */
  getSlotWidth: function () {
    // #5086, #1580, #1931
    var chart = this.chart,
        horiz = this.horiz,
        labelOptions = this.options.labels,
        slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
        marginLeft = chart.margin[3];
    return horiz && (labelOptions.step || 0) < 2 && !labelOptions.rotation && // #4415
    (this.staggerLines || 1) * this.len / slotCount || !horiz && ( // #7028
    labelOptions.style && parseInt(labelOptions.style.width, 10) || marginLeft && marginLeft - chart.spacing[3] || chart.chartWidth * 0.33);
  },

  /**
   * Render the axis labels and determine whether ellipsis or rotation need
   * to be applied.
   *
   * @private
   * @function Highcharts.Axis#renderUnsquish
   */
  renderUnsquish: function () {
    var chart = this.chart,
        renderer = chart.renderer,
        tickPositions = this.tickPositions,
        ticks = this.ticks,
        labelOptions = this.options.labels,
        labelStyleOptions = labelOptions && labelOptions.style || {},
        horiz = this.horiz,
        slotWidth = this.getSlotWidth(),
        innerWidth = Math.max(1, Math.round(slotWidth - 2 * (labelOptions.padding || 5))),
        attr = {},
        labelMetrics = this.labelMetrics(),
        textOverflowOption = labelOptions.style && labelOptions.style.textOverflow,
        commonWidth,
        commonTextOverflow,
        maxLabelLength = 0,
        label,
        i,
        pos; // Set rotation option unless it is "auto", like in gauges

    if (!isString$2(labelOptions.rotation)) {
      attr.rotation = labelOptions.rotation || 0; // #4443
    } // Get the longest label length


    each$4(tickPositions, function (tick) {
      tick = ticks[tick];

      if (tick && tick.label && tick.label.textPxLength > maxLabelLength) {
        maxLabelLength = tick.label.textPxLength;
      }
    });
    this.maxLabelLength = maxLabelLength; // Handle auto rotation on horizontal axis

    if (this.autoRotation) {
      // Apply rotation only if the label is too wide for the slot, and
      // the label is wider than its height.
      if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {
        attr.rotation = this.labelRotation;
      } else {
        this.labelRotation = 0;
      } // Handle word-wrap or ellipsis on vertical axis

    } else if (slotWidth) {
      // For word-wrap or ellipsis
      commonWidth = innerWidth;

      if (!textOverflowOption) {
        commonTextOverflow = 'clip'; // On vertical axis, only allow word wrap if there is room
        // for more lines.

        i = tickPositions.length;

        while (!horiz && i--) {
          pos = tickPositions[i];
          label = ticks[pos].label;

          if (label) {
            // Reset ellipsis in order to get the correct
            // bounding box (#4070)
            if (label.styles && label.styles.textOverflow === 'ellipsis') {
              label.css({
                textOverflow: 'clip'
              }); // Set the correct width in order to read
              // the bounding box height (#4678, #5034)
            } else if (label.textPxLength > slotWidth) {
              label.css({
                width: slotWidth + 'px'
              });
            }

            if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
              label.specificTextOverflow = 'ellipsis';
            }
          }
        }
      }
    } // Add ellipsis if the label length is significantly longer than ideal


    if (attr.rotation) {
      commonWidth = maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : maxLabelLength;

      if (!textOverflowOption) {
        commonTextOverflow = 'ellipsis';
      }
    } // Set the explicit or automatic label alignment


    this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);

    if (this.labelAlign) {
      attr.align = this.labelAlign;
    } // Apply general and specific CSS


    each$4(tickPositions, function (pos) {
      var tick = ticks[pos],
          label = tick && tick.label,
          widthOption = labelStyleOptions.width,
          css = {};

      if (label) {
        // This needs to go before the CSS in old IE (#4502)
        label.attr(attr);

        if (commonWidth && !widthOption && // Setting width in this case messes with the bounding box
        // (#7975)
        labelStyleOptions.whiteSpace !== 'nowrap' && ( // Speed optimizing, #7656
        commonWidth < label.textPxLength || // Resetting CSS, #4928
        label.element.tagName === 'SPAN')) {
          css.width = commonWidth;

          if (!textOverflowOption) {
            css.textOverflow = label.specificTextOverflow || commonTextOverflow;
          }

          label.css(css); // Reset previously shortened label (#8210)
        } else if (label.styles && label.styles.width && !css.width && !widthOption) {
          label.css({
            width: null
          });
        }

        delete label.specificTextOverflow;
        tick.rotation = attr.rotation;
      }
    }); // Note: Why is this not part of getLabelPosition?

    this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
  },

  /**
   * Return true if the axis has associated data.
   *
   * @function Highcharts.Axis#hasData
   *
   * @return {boolean}
   *         True if the axis has associated visible series and those series
   *         have either valid data points or explicit `min` and `max`
   *         settings.
   */
  hasData: function () {
    return this.hasVisibleSeries || defined$4(this.min) && defined$4(this.max) && this.tickPositions && this.tickPositions.length > 0;
  },

  /**
   * Adds the title defined in axis.options.title.
   *
   * @function Highcharts.Axis#addTitle
   *
   * @param {boolean} display
   *        Whether or not to display the title.
   */
  addTitle: function (display) {
    var axis = this,
        renderer = axis.chart.renderer,
        horiz = axis.horiz,
        opposite = axis.opposite,
        options = axis.options,
        axisTitleOptions = options.title,
        textAlign;

    if (!axis.axisTitle) {
      textAlign = axisTitleOptions.textAlign;

      if (!textAlign) {
        textAlign = (horiz ? {
          low: 'left',
          middle: 'center',
          high: 'right'
        } : {
          low: opposite ? 'right' : 'left',
          middle: 'center',
          high: opposite ? 'left' : 'right'
        })[axisTitleOptions.align];
      }

      axis.axisTitle = renderer.text(axisTitleOptions.text, 0, 0, axisTitleOptions.useHTML).attr({
        zIndex: 7,
        rotation: axisTitleOptions.rotation || 0,
        align: textAlign
      }).addClass('highcharts-axis-title').add(axis.axisGroup);
      axis.axisTitle.isNew = true;
    } // Max width defaults to the length of the axis


    axis.axisTitle.css({
      width: axis.len
    }); // hide or show the title depending on whether showEmpty is set

    axis.axisTitle[display ? 'show' : 'hide'](true);
  },

  /**
   * Generates a tick for initial positioning.
   *
   * @private
   * @function Highcharts.Axis#generateTick
   *
   * @param {number} pos
   *        The tick position in axis values.
   *
   * @param {number} i
   *        The index of the tick in {@link Axis.tickPositions}.
   */
  generateTick: function (pos) {
    var ticks = this.ticks;

    if (!ticks[pos]) {
      ticks[pos] = new Tick(this, pos);
    } else {
      ticks[pos].addLabel(); // update labels depending on tick interval
    }
  },

  /**
   * Render the tick labels to a preliminary position to get their sizes.
   *
   * @private
   * @function Highcharts.Axis#getOffset
   *
   * @fires Highcharts.Axis#event:afterGetOffset
   */
  getOffset: function () {
    var axis = this,
        chart = axis.chart,
        renderer = chart.renderer,
        options = axis.options,
        tickPositions = axis.tickPositions,
        ticks = axis.ticks,
        horiz = axis.horiz,
        side = axis.side,
        invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side,
        hasData,
        showAxis,
        titleOffset = 0,
        titleOffsetOption,
        titleMargin = 0,
        axisTitleOptions = options.title,
        labelOptions = options.labels,
        labelOffset = 0,
        // reset
    labelOffsetPadded,
        axisOffset = chart.axisOffset,
        clipOffset = chart.clipOffset,
        clip,
        directionFactor = [-1, 1, 1, -1][side],
        className = options.className,
        axisParent = axis.axisParent,
        // Used in color axis
    lineHeightCorrection,
        tickSize = this.tickSize('tick'); // For reuse in Axis.render

    hasData = axis.hasData();
    axis.showAxis = showAxis = hasData || pick$4(options.showEmpty, true); // Set/reset staggerLines

    axis.staggerLines = axis.horiz && labelOptions.staggerLines; // Create the axisGroup and gridGroup elements on first iteration

    if (!axis.axisGroup) {
      axis.gridGroup = renderer.g('grid').attr({
        zIndex: options.gridZIndex || 1
      }).addClass('highcharts-' + this.coll.toLowerCase() + '-grid ' + (className || '')).add(axisParent);
      axis.axisGroup = renderer.g('axis').attr({
        zIndex: options.zIndex || 2
      }).addClass('highcharts-' + this.coll.toLowerCase() + ' ' + (className || '')).add(axisParent);
      axis.labelGroup = renderer.g('axis-labels').attr({
        zIndex: labelOptions.zIndex || 7
      }).addClass('highcharts-' + axis.coll.toLowerCase() + '-labels ' + (className || '')).add(axisParent);
    }

    if (hasData || axis.isLinked) {
      // Generate ticks
      each$4(tickPositions, function (pos, i) {
        // i is not used here, but may be used in overrides
        axis.generateTick(pos, i);
      });
      axis.renderUnsquish(); // Left side must be align: right and right side must
      // have align: left for labels

      axis.reserveSpaceDefault = side === 0 || side === 2 || {
        1: 'left',
        3: 'right'
      }[side] === axis.labelAlign;

      if (pick$4(labelOptions.reserveSpace, axis.labelAlign === 'center' ? true : null, axis.reserveSpaceDefault)) {
        each$4(tickPositions, function (pos) {
          // get the highest offset
          labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset);
        });
      }

      if (axis.staggerLines) {
        labelOffset *= axis.staggerLines;
      }

      axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
    } else {
      // doesn't have data
      objectEach$1(ticks, function (tick, n) {
        tick.destroy();
        delete ticks[n];
      });
    }

    if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
      axis.addTitle(showAxis);

      if (showAxis && axisTitleOptions.reserveSpace !== false) {
        axis.titleOffset = titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
        titleOffsetOption = axisTitleOptions.offset;
        titleMargin = defined$4(titleOffsetOption) ? 0 : pick$4(axisTitleOptions.margin, horiz ? 5 : 10);
      }
    } // Render the axis line


    axis.renderLine(); // handle automatic or user set offset

    axis.offset = directionFactor * pick$4(options.offset, axisOffset[side]);
    axis.tickRotCorr = axis.tickRotCorr || {
      x: 0,
      y: 0
    }; // polar

    if (side === 0) {
      lineHeightCorrection = -axis.labelMetrics().h;
    } else if (side === 2) {
      lineHeightCorrection = axis.tickRotCorr.y;
    } else {
      lineHeightCorrection = 0;
    } // Find the padded label offset


    labelOffsetPadded = Math.abs(labelOffset) + titleMargin;

    if (labelOffset) {
      labelOffsetPadded -= lineHeightCorrection;
      labelOffsetPadded += directionFactor * (horiz ? pick$4(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);
    }

    axis.axisTitleMargin = pick$4(titleOffsetOption, labelOffsetPadded);
    axisOffset[side] = Math.max(axisOffset[side], axis.axisTitleMargin + titleOffset + directionFactor * axis.offset, labelOffsetPadded, // #3027
    hasData && tickPositions.length && tickSize ? tickSize[0] + directionFactor * axis.offset : 0 // #4866
    ); // Decide the clipping needed to keep the graph inside
    // the plot area and axis lines

    clip = options.offset ? 0 : Math.floor(axis.axisLine.strokeWidth() / 2) * 2; // #4308, #4371

    clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);
    fireEvent$1(this, 'afterGetOffset');
  },

  /**
   * Internal function to get the path for the axis line. Extended for polar
   * charts.
   *
   * @function Highcharts.Axis#getLinePath
   *
   * @param {number} lineWidth
   *        The line width in pixels.
   *
   * @return {Highcharts.SVGPathArray}
   *         The SVG path definition in array form.
   */
  getLinePath: function (lineWidth) {
    var chart = this.chart,
        opposite = this.opposite,
        offset = this.offset,
        horiz = this.horiz,
        lineLeft = this.left + (opposite ? this.width : 0) + offset,
        lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;

    if (opposite) {
      lineWidth *= -1; // crispify the other way - #1480, #1687
    }

    return chart.renderer.crispLine(['M', horiz ? this.left : lineLeft, horiz ? lineTop : this.top, 'L', horiz ? chart.chartWidth - this.right : lineLeft, horiz ? lineTop : chart.chartHeight - this.bottom], lineWidth);
  },

  /**
   * Render the axis line. Called internally when rendering and redrawing the
   * axis.
   *
   * @function Highcharts.Axis#renderLine
   */
  renderLine: function () {
    if (!this.axisLine) {
      this.axisLine = this.chart.renderer.path().addClass('highcharts-axis-line').add(this.axisGroup);
    }
  },

  /**
   * Position the axis title.
   *
   * @private
   * @function Highcharts.Axis#getTitlePosition
   *
   * @return {Highcharts.AxisTitlePositionObject}
   *         X and Y positions for the title.
   */
  getTitlePosition: function () {
    // compute anchor points for each of the title align options
    var horiz = this.horiz,
        axisLeft = this.left,
        axisTop = this.top,
        axisLength = this.len,
        axisTitleOptions = this.options.title,
        margin = horiz ? axisLeft : axisTop,
        opposite = this.opposite,
        offset = this.offset,
        xOption = axisTitleOptions.x || 0,
        yOption = axisTitleOptions.y || 0,
        axisTitle = this.axisTitle,
        fontMetrics = this.chart.renderer.fontMetrics(axisTitleOptions.style && axisTitleOptions.style.fontSize, axisTitle),
        // The part of a multiline text that is below the baseline of the
    // first line. Subtract 1 to preserve pixel-perfectness from the
    // old behaviour (v5.0.12), where only one line was allowed.
    textHeightOvershoot = Math.max(axisTitle.getBBox(null, 0).height - fontMetrics.h - 1, 0),
        // the position in the length direction of the axis
    alongAxis = {
      low: margin + (horiz ? 0 : axisLength),
      middle: margin + axisLength / 2,
      high: margin + (horiz ? axisLength : 0)
    }[axisTitleOptions.align],
        // the position in the perpendicular direction of the axis
    offAxis = (horiz ? axisTop + this.height : axisLeft) + (horiz ? 1 : -1) * ( // horizontal axis reverses the margin
    opposite ? -1 : 1) * // so does opposite axes
    this.axisTitleMargin + [-textHeightOvershoot, // top
    textHeightOvershoot, // right
    fontMetrics.f, // bottom
    -textHeightOvershoot // left
    ][this.side];
    return {
      x: horiz ? alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset + xOption,
      y: horiz ? offAxis + yOption - (opposite ? this.height : 0) + offset : alongAxis + yOption
    };
  },

  /**
   * Render a minor tick into the given position. If a minor tick already
   * exists in this position, move it.
   *
   * @function Highcharts.Axis#renderMinorTick
   *
   * @param {number} pos
   *        The position in axis values.
   */
  renderMinorTick: function (pos) {
    var slideInTicks = this.chart.hasRendered && isNumber$2(this.oldMin),
        minorTicks = this.minorTicks;

    if (!minorTicks[pos]) {
      minorTicks[pos] = new Tick(this, pos, 'minor');
    } // Render new ticks in old position


    if (slideInTicks && minorTicks[pos].isNew) {
      minorTicks[pos].render(null, true);
    }

    minorTicks[pos].render(null, false, 1);
  },

  /**
   * Render a major tick into the given position. If a tick already exists
   * in this position, move it.
   *
   * @function Highcharts.Axis#renderTick
   *
   * @param {number} pos
   *        The position in axis values.
   *
   * @param {number} i
   *        The tick index.
   */
  renderTick: function (pos, i) {
    var isLinked = this.isLinked,
        ticks = this.ticks,
        slideInTicks = this.chart.hasRendered && isNumber$2(this.oldMin); // Linked axes need an extra check to find out if

    if (!isLinked || pos >= this.min && pos <= this.max) {
      if (!ticks[pos]) {
        ticks[pos] = new Tick(this, pos);
      } // render new ticks in old position


      if (slideInTicks && ticks[pos].isNew) {
        ticks[pos].render(i, true, 0.1);
      }

      ticks[pos].render(i);
    }
  },

  /**
   * Render the axis.
   *
   * @private
   * @function Highcharts.Axis#render
   *
   * @fires Highcharts.Axis#event:afterRender
   */
  render: function () {
    var axis = this,
        chart = axis.chart,
        renderer = chart.renderer,
        options = axis.options,
        isLog = axis.isLog,
        isLinked = axis.isLinked,
        tickPositions = axis.tickPositions,
        axisTitle = axis.axisTitle,
        ticks = axis.ticks,
        minorTicks = axis.minorTicks,
        alternateBands = axis.alternateBands,
        stackLabelOptions = options.stackLabels,
        alternateGridColor = options.alternateGridColor,
        tickmarkOffset = axis.tickmarkOffset,
        axisLine = axis.axisLine,
        showAxis = axis.showAxis,
        animation = animObject(renderer.globalAnimation),
        from,
        to; // Reset

    axis.labelEdge.length = 0;
    axis.overlap = false; // Mark all elements inActive before we go over and mark the active ones

    each$4([ticks, minorTicks, alternateBands], function (coll) {
      objectEach$1(coll, function (tick) {
        tick.isActive = false;
      });
    }); // If the series has data draw the ticks. Else only the line and title

    if (axis.hasData() || isLinked) {
      // minor ticks
      if (axis.minorTickInterval && !axis.categories) {
        each$4(axis.getMinorTickPositions(), function (pos) {
          axis.renderMinorTick(pos);
        });
      } // Major ticks. Pull out the first item and render it last so that
      // we can get the position of the neighbour label. #808.


      if (tickPositions.length) {
        // #1300
        each$4(tickPositions, function (pos, i) {
          axis.renderTick(pos, i);
        }); // In a categorized axis, the tick marks are displayed
        // between labels. So we need to add a tick mark and
        // grid line at the left edge of the X axis.

        if (tickmarkOffset && (axis.min === 0 || axis.single)) {
          if (!ticks[-1]) {
            ticks[-1] = new Tick(axis, -1, null, true);
          }

          ticks[-1].render(-1);
        }
      } // alternate grid color


      if (alternateGridColor) {
        each$4(tickPositions, function (pos, i) {
          to = tickPositions[i + 1] !== undefined ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;

          if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {
            // #2248, #4660
            if (!alternateBands[pos]) {
              alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);
            }

            from = pos + tickmarkOffset; // #949

            alternateBands[pos].options = {
              from: isLog ? axis.lin2log(from) : from,
              to: isLog ? axis.lin2log(to) : to,
              color: alternateGridColor
            };
            alternateBands[pos].render();
            alternateBands[pos].isActive = true;
          }
        });
      } // custom plot lines and bands


      if (!axis._addedPlotLB) {
        // only first time
        each$4((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
          axis.addPlotBandOrLine(plotLineOptions);
        });
        axis._addedPlotLB = true;
      }
    } // end if hasData
    // Remove inactive ticks


    each$4([ticks, minorTicks, alternateBands], function (coll) {
      var i,
          forDestruction = [],
          delay = animation.duration,
          destroyInactiveItems = function () {
        i = forDestruction.length;

        while (i--) {
          // When resizing rapidly, the same items
          // may be destroyed in different timeouts,
          // or the may be reactivated
          if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
            coll[forDestruction[i]].destroy();
            delete coll[forDestruction[i]];
          }
        }
      };

      objectEach$1(coll, function (tick, pos) {
        if (!tick.isActive) {
          // Render to zero opacity
          tick.render(pos, false, 0);
          tick.isActive = false;
          forDestruction.push(pos);
        }
      }); // When the objects are finished fading out, destroy them

      syncTimeout(destroyInactiveItems, coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay);
    }); // Set the axis line path

    if (axisLine) {
      axisLine[axisLine.isPlaced ? 'animate' : 'attr']({
        d: this.getLinePath(axisLine.strokeWidth())
      });
      axisLine.isPlaced = true; // Show or hide the line depending on options.showEmpty

      axisLine[showAxis ? 'show' : 'hide'](true);
    }

    if (axisTitle && showAxis) {
      var titleXy = axis.getTitlePosition();

      if (isNumber$2(titleXy.y)) {
        axisTitle[axisTitle.isNew ? 'attr' : 'animate'](titleXy);
        axisTitle.isNew = false;
      } else {
        axisTitle.attr('y', -9999);
        axisTitle.isNew = true;
      }
    } // Stacked totals:


    if (stackLabelOptions && stackLabelOptions.enabled) {
      axis.renderStackTotals();
    } // End stacked totals


    axis.isDirty = false;
    fireEvent$1(this, 'afterRender');
  },

  /**
   * Redraw the axis to reflect changes in the data or axis extremes. Called
   * internally from {@link Chart#redraw}.
   *
   * @private
   * @function Highcharts.Axis#redraw
   */
  redraw: function () {
    if (this.visible) {
      // render the axis
      this.render(); // move plot lines and bands

      each$4(this.plotLinesAndBands, function (plotLine) {
        plotLine.render();
      });
    } // mark associated series as dirty and ready for redraw


    each$4(this.series, function (series) {
      series.isDirty = true;
    });
  },
  // Properties to survive after destroy, needed for Axis.update (#4317,
  // #5773, #5881).
  keepProps: ['extKey', 'hcEvents', 'names', 'series', 'userMax', 'userMin'],

  /**
   * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint
   * to fully remove the axis.
   *
   * @private
   * @function Highcharts.Axis#destroy
   *
   * @param {boolean} keepEvents
   *        Whether to preserve events, used internally in Axis.update.
   */
  destroy: function (keepEvents) {
    var axis = this,
        stacks = axis.stacks,
        plotLinesAndBands = axis.plotLinesAndBands,
        plotGroup,
        i;
    fireEvent$1(this, 'destroy', {
      keepEvents: keepEvents
    }); // Remove the events

    if (!keepEvents) {
      removeEvent$1(axis);
    } // Destroy each stack total


    objectEach$1(stacks, function (stack, stackKey) {
      destroyObjectProperties$2(stack);
      stacks[stackKey] = null;
    }); // Destroy collections

    each$4([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {
      destroyObjectProperties$2(coll);
    });

    if (plotLinesAndBands) {
      i = plotLinesAndBands.length;

      while (i--) {
        // #1975
        plotLinesAndBands[i].destroy();
      }
    } // Destroy elements


    each$4(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'gridGroup', 'labelGroup', 'cross', 'scrollbar'], function (prop) {
      if (axis[prop]) {
        axis[prop] = axis[prop].destroy();
      }
    }); // Destroy each generated group for plotlines and plotbands

    for (plotGroup in axis.plotLinesAndBandsGroups) {
      axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();
    } // Delete all properties and fall back to the prototype.


    objectEach$1(axis, function (val, key) {
      if (inArray$1(key, axis.keepProps) === -1) {
        delete axis[key];
      }
    });
  },

  /**
   * Internal function to draw a crosshair.
   *
   * @function Highcharts.Axis#drawCrosshair
   *
   * @param {Highcharts.PointerEventObject} [e]
   *        The event arguments from the modified pointer event, extended with
   *        `chartX` and `chartY`
   *
   * @param {Highcharts.Point} [point]
   *        The Point object if the crosshair snaps to points.
   *
   * @fires Highcharts.Axis#event:afterDrawCrosshair
   * @fires Highcharts.Axis#event:drawCrosshair
   */
  drawCrosshair: function (e, point) {
    var path,
        options = this.crosshair,
        snap = pick$4(options.snap, true),
        pos,
        categorized,
        graphic = this.cross;
    fireEvent$1(this, 'drawCrosshair', {
      e: e,
      point: point
    }); // Use last available event when updating non-snapped crosshairs without
    // mouse interaction (#5287)

    if (!e) {
      e = this.cross && this.cross.e;
    }

    if ( // Disabled in options
    !this.crosshair || // Snap
    (defined$4(point) || !snap) === false) {
      this.hideCrosshair();
    } else {
      // Get the path
      if (!snap) {
        pos = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
      } else if (defined$4(point)) {
        // #3834
        pos = pick$4(point.crosshairPos, // 3D axis extension
        this.isXAxis ? point.plotX : this.len - point.plotY);
      }

      if (defined$4(pos)) {
        path = this.getPlotLinePath( // First argument, value, only used on radial
        point && (this.isXAxis ? point.x : pick$4(point.stackY, point.y)), null, null, null, pos // Translated position
        ) || null; // #3189
      }

      if (!defined$4(path)) {
        this.hideCrosshair();
        return;
      }

      categorized = this.categories && !this.isRadial; // Draw the cross

      if (!graphic) {
        this.cross = graphic = this.chart.renderer.path().addClass('highcharts-crosshair highcharts-crosshair-' + (categorized ? 'category ' : 'thin ') + options.className).attr({
          zIndex: pick$4(options.zIndex, 2)
        }).add();
      }

      graphic.show().attr({
        d: path
      });

      if (categorized && !options.width) {
        graphic.attr({
          'stroke-width': this.transA
        });
      }

      this.cross.e = e;
    }

    fireEvent$1(this, 'afterDrawCrosshair', {
      e: e,
      point: point
    });
  },

  /**
   * Hide the crosshair if visible.
   *
   * @function Highcharts.Axis#hideCrosshair
   */
  hideCrosshair: function () {
    if (this.cross) {
      this.cross.hide();
    }
  }
}); // end Axis

Highcharts.Axis = Axis;

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var Axis$1 = Highcharts.Axis,
    getMagnitude$1 = Highcharts.getMagnitude,
    normalizeTickInterval$1 = Highcharts.normalizeTickInterval,
    timeUnits$1 = Highcharts.timeUnits;
/**
 * Set the tick positions to a time unit that makes sense, for example
 * on the first of each month or on every Monday. Return an array
 * with the time positions. Used in datetime axes as well as for grouping
 * data on a datetime axis.
 *
 * @param {Object} normalizedInterval
 *        The interval in axis values (ms) and thecount
 * @param {Number} min The minimum in axis values
 * @param {Number} max The maximum in axis values
 * @param {Number} startOfWeek
 * @ignore
 */

Axis$1.prototype.getTimeTicks = function () {
  return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
};
/**
 * Get a normalized tick interval for dates. Returns a configuration object with
 * unit range (interval), count and name. Used to prepare data for getTimeTicks.
 * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
 * of segments in stock charts, the normalizing logic was extracted in order to
 * prevent it for running over again for each segment having the same interval.
 * #662, #697.
 *
 * @ignore
 */


Axis$1.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {
  var units = unitsOption || [['millisecond', // unit name
  [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
  ], ['second', [1, 2, 5, 10, 15, 30]], ['minute', [1, 2, 5, 10, 15, 30]], ['hour', [1, 2, 3, 4, 6, 8, 12]], ['day', [1, 2]], ['week', [1, 2]], ['month', [1, 2, 3, 4, 6]], ['year', null]],
      unit = units[units.length - 1],
      // default unit is years
  interval = timeUnits$1[unit[0]],
      multiples = unit[1],
      count,
      i; // loop through the units to find the one that best fits the tickInterval

  for (i = 0; i < units.length; i++) {
    unit = units[i];
    interval = timeUnits$1[unit[0]];
    multiples = unit[1];

    if (units[i + 1]) {
      // lessThan is in the middle between the highest multiple and the
      // next unit.
      var lessThan = (interval * multiples[multiples.length - 1] + timeUnits$1[units[i + 1][0]]) / 2; // break and keep the current unit

      if (tickInterval <= lessThan) {
        break;
      }
    }
  } // prevent 2.5 years intervals, though 25, 250 etc. are allowed


  if (interval === timeUnits$1.year && tickInterval < 5 * interval) {
    multiples = [1, 2, 5];
  } // get the count


  count = normalizeTickInterval$1(tickInterval / interval, multiples, unit[0] === 'year' ? Math.max(getMagnitude$1(tickInterval / interval), 1) : // #1913, #2360
  1);
  return {
    unitRange: interval,
    count: count,
    unitName: unit[0]
  };
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var Axis$2 = Highcharts.Axis,
    getMagnitude$2 = Highcharts.getMagnitude,
    map$1 = Highcharts.map,
    normalizeTickInterval$2 = Highcharts.normalizeTickInterval,
    pick$5 = Highcharts.pick;
/**
 * Methods defined on the Axis prototype
 */

/**
 * Set the tick positions of a logarithmic axis
 *
 * @ignore
 */

Axis$2.prototype.getLogTickPositions = function (interval, min, max, minor) {
  var axis = this,
      options = axis.options,
      axisLength = axis.len,
      // Since we use this method for both major and minor ticks,
  // use a local variable and return the result
  positions = []; // Reset

  if (!minor) {
    axis._minorAutoInterval = null;
  } // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.


  if (interval >= 0.5) {
    interval = Math.round(interval);
    positions = axis.getLinearTickPositions(interval, min, max); // Second case: We need intermediary ticks. For example
    // 1, 2, 4, 6, 8, 10, 20, 40 etc.
  } else if (interval >= 0.08) {
    var roundedMin = Math.floor(min),
        intermediate,
        i,
        j,
        len,
        pos,
        lastPos,
        break2;

    if (interval > 0.3) {
      intermediate = [1, 2, 4]; // 0.2 equals five minor ticks per 1, 10, 100 etc
    } else if (interval > 0.15) {
      intermediate = [1, 2, 4, 6, 8];
    } else {
      // 0.1 equals ten minor ticks per 1, 10, 100 etc
      intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    }

    for (i = roundedMin; i < max + 1 && !break2; i++) {
      len = intermediate.length;

      for (j = 0; j < len && !break2; j++) {
        pos = axis.log2lin(axis.lin2log(i) * intermediate[j]); // #1670, lastPos is #3113

        if (pos > min && (!minor || lastPos <= max) && lastPos !== undefined) {
          positions.push(lastPos);
        }

        if (lastPos > max) {
          break2 = true;
        }

        lastPos = pos;
      }
    } // Third case: We are so deep in between whole logarithmic values that
    // we might as well handle the tick positions like a linear axis. For
    // example 1.01, 1.02, 1.03, 1.04.

  } else {
    var realMin = axis.lin2log(min),
        realMax = axis.lin2log(max),
        tickIntervalOption = minor ? this.getMinorTickInterval() : options.tickInterval,
        filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
        tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
        totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
    interval = pick$5(filteredTickIntervalOption, axis._minorAutoInterval, (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1));
    interval = normalizeTickInterval$2(interval, null, getMagnitude$2(interval));
    positions = map$1(axis.getLinearTickPositions(interval, realMin, realMax), axis.log2lin);

    if (!minor) {
      axis._minorAutoInterval = interval / 5;
    }
  } // Set the axis-level tickInterval variable


  if (!minor) {
    axis.tickInterval = interval;
  }

  return positions;
};

Axis$2.prototype.log2lin = function (num) {
  return Math.log(num) / Math.LN10;
};

Axis$2.prototype.lin2log = function (num) {
  return Math.pow(10, num);
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var arrayMax$1 = Highcharts.arrayMax,
    arrayMin$1 = Highcharts.arrayMin,
    defined$5 = Highcharts.defined,
    destroyObjectProperties$3 = Highcharts.destroyObjectProperties,
    each$5 = Highcharts.each,
    erase$1 = Highcharts.erase,
    merge$6 = Highcharts.merge,
    pick$6 = Highcharts.pick;
/**
 * The object wrapper for plot lines and plot bands
 *
 * @class
 * @name Highcharts.PlotLineOrBand
 *
 * @param {Highcharts.Axis} axis
 *
 * @param {Highcharts.AxisPlotLinesOptions|Highcharts.AxisPlotBandsOptions} options
 */

Highcharts.PlotLineOrBand = function (axis, options) {
  this.axis = axis;

  if (options) {
    this.options = options;
    this.id = options.id;
  }
};

Highcharts.PlotLineOrBand.prototype = {
  /**
   * Render the plot line or plot band. If it is already existing,
   * move it.
   *
   * @private
   * @function Highcharts.PlotLineOrBand#render
   *
   * @return {Highcharts.PlotLineOrBand|undefined}
   */
  render: function () {
    var plotLine = this,
        axis = plotLine.axis,
        horiz = axis.horiz,
        options = plotLine.options,
        optionsLabel = options.label,
        label = plotLine.label,
        to = options.to,
        from = options.from,
        value = options.value,
        isBand = defined$5(from) && defined$5(to),
        isLine = defined$5(value),
        svgElem = plotLine.svgElem,
        isNew = !svgElem,
        path = [],
        color = options.color,
        zIndex = pick$6(options.zIndex, 0),
        events = options.events,
        attribs = {
      'class': 'highcharts-plot-' + (isBand ? 'band ' : 'line ') + (options.className || '')
    },
        groupAttribs = {},
        renderer = axis.chart.renderer,
        groupName = isBand ? 'bands' : 'lines',
        group; // logarithmic conversion

    if (axis.isLog) {
      from = axis.log2lin(from);
      to = axis.log2lin(to);
      value = axis.log2lin(value);
    } // Grouping and zIndex


    groupAttribs.zIndex = zIndex;
    groupName += '-' + zIndex;
    group = axis.plotLinesAndBandsGroups[groupName];

    if (!group) {
      axis.plotLinesAndBandsGroups[groupName] = group = renderer.g('plot-' + groupName).attr(groupAttribs).add();
    } // Create the path


    if (isNew) {
      /**
       * SVG element of the plot line or band.
       *
       * @name Highcharts.PlotLineOrBand#svgElement
       * @type {Highcharts.SVGElement}
       */
      plotLine.svgElem = svgElem = renderer.path().attr(attribs).add(group);
    } // Set the path or return


    if (isLine) {
      path = axis.getPlotLinePath(value, svgElem.strokeWidth());
    } else if (isBand) {
      // plot band
      path = axis.getPlotBandPath(from, to, options);
    } else {
      return;
    } // common for lines and bands


    if (isNew && path && path.length) {
      svgElem.attr({
        d: path
      }); // events

      if (events) {
        Highcharts.objectEach(events, function (event, eventType) {
          svgElem.on(eventType, function (e) {
            events[eventType].apply(plotLine, [e]);
          });
        });
      }
    } else if (svgElem) {
      if (path) {
        svgElem.show();
        svgElem.animate({
          d: path
        });
      } else {
        svgElem.hide();

        if (label) {
          plotLine.label = label = label.destroy();
        }
      }
    } // the plot band/line label


    if (optionsLabel && defined$5(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0 && !path.isFlat) {
      // apply defaults
      optionsLabel = merge$6({
        align: horiz && isBand && 'center',
        x: horiz ? !isBand && 4 : 10,
        verticalAlign: !horiz && isBand && 'middle',
        y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
        rotation: horiz && !isBand && 90
      }, optionsLabel);
      this.renderLabel(optionsLabel, path, isBand, zIndex);
    } else if (label) {
      // move out of sight
      label.hide();
    } // chainable


    return plotLine;
  },

  /**
   * Render and align label for plot line or band.
   *
   * @private
   * @function Highcharts.PlotLineOrBand#renderLabel
   *
   * @param {Highcharts.AxisPlotLinesLabelOptions|Highcharts.AxisPlotBandsLabelOptions} optionsLabel
   *
   * @param {Highcharts.SVGPathArray} path
   *
   * @param {boolean} [isBand]
   *
   * @param {number} [zIndex]
   */
  renderLabel: function (optionsLabel, path, isBand, zIndex) {
    var plotLine = this,
        label = plotLine.label,
        renderer = plotLine.axis.chart.renderer,
        attribs,
        xBounds,
        yBounds,
        x,
        y; // add the SVG element

    if (!label) {
      attribs = {
        align: optionsLabel.textAlign || optionsLabel.align,
        rotation: optionsLabel.rotation,
        'class': 'highcharts-plot-' + (isBand ? 'band' : 'line') + '-label ' + (optionsLabel.className || '')
      };
      attribs.zIndex = zIndex;
      /**
       * SVG element of the label.
       *
       * @name Highcharts.PlotLineOrBand#label
       * @type {Highcharts.SVGElement}
       */

      plotLine.label = label = renderer.text(optionsLabel.text, 0, 0, optionsLabel.useHTML).attr(attribs).add();
    } // get the bounding box and align the label
    // #3000 changed to better handle choice between plotband or plotline


    xBounds = path.xBounds || [path[1], path[4], isBand ? path[6] : path[1]];
    yBounds = path.yBounds || [path[2], path[5], isBand ? path[7] : path[2]];
    x = arrayMin$1(xBounds);
    y = arrayMin$1(yBounds);
    label.align(optionsLabel, false, {
      x: x,
      y: y,
      width: arrayMax$1(xBounds) - x,
      height: arrayMax$1(yBounds) - y
    });
    label.show();
  },

  /**
   * Remove the plot line or band.
   *
   * @function Highcharts.PlotLineOrBand#destroy
   */
  destroy: function () {
    // remove it from the lookup
    erase$1(this.axis.plotLinesAndBands, this);
    delete this.axis;
    destroyObjectProperties$3(this);
  }
}; // Object with members for extending the Axis prototype

Highcharts.extend(Axis.prototype,
/** @lends Highcharts.Axis.prototype */
{
  /**
   * An array of colored bands stretching across the plot area marking an
   * interval on the axis.
   *
   * In styled mode, the plot bands are styled by the `.highcharts-plot-band`
   * class in addition to the `className` option.
   *
   * @productdesc {highcharts}
   * In a gauge, a plot band on the Y axis (value axis) will stretch along the
   * perimeter of the gauge.
   *
   * @type      {Array<*>}
   * @product   highcharts highstock
   * @apioption xAxis.plotBands
   */

  /**
   * Border color for the plot band. Also requires `borderWidth` to be set.
   *
   * @type      {Highcharts.ColorString}
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.borderColor
   */

  /**
   * Border width for the plot band. Also requires `borderColor` to be set.
   *
   * @type      {number}
   * @default   0
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.borderWidth
   */

  /**
   * A custom class name, in addition to the default `highcharts-plot-band`,
   * to apply to each individual band.
   *
   * @type      {string}
   * @since     5.0.0
   * @apioption xAxis.plotBands.className
   */

  /**
   * The color of the plot band.
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-color/
   *         Color band
   * @sample {highstock} stock/xaxis/plotbands/
   *         Plot band on Y axis
   *
   * @type      {Highcharts.ColorString}
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.color
   */

  /**
   * An object defining mouse events for the plot band. Supported properties
   * are `click`, `mouseover`, `mouseout`, `mousemove`.
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-events/
   *         Mouse events demonstrated
   *
   * @since     1.2
   * @product   highcharts highstock
   * @context   PlotLineOrBand
   * @apioption xAxis.plotBands.events
   */

  /**
   * The start position of the plot band in axis units.
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-color/
   *         Datetime axis
   * @sample {highcharts} highcharts/xaxis/plotbands-from/
   *         Categorized axis
   * @sample {highstock} stock/xaxis/plotbands/
   *         Plot band on Y axis
   *
   * @type      {number}
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.from
   */

  /**
   * An id used for identifying the plot band in Axis.removePlotBand.
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-id/
   *         Remove plot band by id
   * @sample {highstock} highcharts/xaxis/plotbands-id/
   *         Remove plot band by id
   *
   * @type      {string}
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.id
   */

  /**
   * The end position of the plot band in axis units.
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-color/
   *         Datetime axis
   * @sample {highcharts} highcharts/xaxis/plotbands-from/
   *         Categorized axis
   * @sample {highstock} stock/xaxis/plotbands/
   *         Plot band on Y axis
   *
   * @type      {number}
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.to
   */

  /**
   * The z index of the plot band within the chart, relative to other
   * elements. Using the same z index as another element may give
   * unpredictable results, as the last rendered element will be on top.
   * Values from 0 to 20 make sense.
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-color/
   *         Behind plot lines by default
   * @sample {highcharts} highcharts/xaxis/plotbands-zindex/
   *         Above plot lines
   * @sample {highcharts} highcharts/xaxis/plotbands-zindex-above-series/
   *         Above plot lines and series
   *
   * @type      {number}
   * @since     1.2
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.zIndex
   */

  /**
   * Text labels for the plot bands
   *
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.label
   */

  /**
   * Horizontal alignment of the label. Can be one of "left", "center" or
   * "right".
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-label-align/
   *         Aligned to the right
   * @sample {highstock} stock/xaxis/plotbands-label/
   *         Plot band with labels
   *
   * @type      {string}
   * @default   center
   * @since     2.1
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.label.align
   */

  /**
   * Rotation of the text label in degrees .
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-label-rotation/
   *         Vertical text
   *
   * @type      {number}
   * @default   0
   * @since     2.1
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.label.rotation
   */

  /**
   * CSS styles for the text label.
   *
   * In styled mode, the labels are styled by the
   * `.highcharts-plot-band-label` class.
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-label-style/
   *         Blue and bold label
   *
   * @type      {Highcharts.CSSObject}
   * @since     2.1
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.label.style
   */

  /**
   * The string text itself. A subset of HTML is supported.
   *
   * @type      {string}
   * @since     2.1
   * @product   highcharts
   * @apioption xAxis.plotBands.label.text
   */

  /**
   * The text alignment for the label. While `align` determines where the
   * texts anchor point is placed within the plot band, `textAlign` determines
   * how the text is aligned against its anchor point. Possible values are
   * "left", "center" and "right". Defaults to the same as the `align` option.
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-label-rotation/
   *         Vertical text in center position but text-aligned left
   *
   * @type       {string}
   * @since      2.1
   * @product    highcharts highstock
   * @validvalue ["center", "left", "right"]
   * @apioption  xAxis.plotBands.label.textAlign
   */

  /**
   * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts
   * /labels-and-string-formatting#html) to render the labels.
   *
   * @type      {boolean}
   * @default   false
   * @since     3.0.3
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.label.useHTML
   */

  /**
   * Vertical alignment of the label relative to the plot band. Can be one of
   * "top", "middle" or "bottom".
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-label-verticalalign/
   *         Vertically centered label
   * @sample {highstock} stock/xaxis/plotbands-label/
   *         Plot band with labels
   *
   * @type       {string}
   * @default    top
   * @since      2.1
   * @product    highcharts highstock
   * @validvalue ["bottom", "middle",  "top"]
   * @apioption  xAxis.plotBands.label.verticalAlign
   */

  /**
   * Horizontal position relative the alignment. Default varies by
   * orientation.
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-label-align/
   *         Aligned 10px from the right edge
   * @sample {highstock} stock/xaxis/plotbands-label/
   *         Plot band with labels
   *
   * @type      {number}
   * @since     2.1
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.label.x
   */

  /**
   * Vertical position of the text baseline relative to the alignment. Default
   * varies by orientation.
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-label-y/
   *         Label on x axis
   * @sample {highstock} stock/xaxis/plotbands-label/
   *         Plot band with labels
   *
   * @type      {number}
   * @since     2.1
   * @product   highcharts highstock
   * @apioption xAxis.plotBands.label.y
   */

  /**
   * An array of lines stretching across the plot area, marking a specific
   * value on one of the axes.
   *
   * In styled mode, the plot lines are styled by the
   * `.highcharts-plot-line` class in addition to the `className` option.
   *
   * @type      {Array<*>}
   * @product   highcharts highstock
   * @apioption xAxis.plotLines
   */

  /**
   * A custom class name, in addition to the default `highcharts-plot-line`,
   * to apply to each individual line.
   *
   * @type      {string}
   * @since     5.0.0
   * @apioption xAxis.plotLines.className
   */

  /**
   * The color of the line.
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-color/
   *         A red line from X axis
   * @sample {highstock} stock/xaxis/plotlines/
   *         Plot line on Y axis
   *
   * @type      {Highcharts.ColorString}
   * @product   highcharts highstock
   * @apioption xAxis.plotLines.color
   */

  /**
   * The dashing or dot style for the plot line. For possible values see
   * [this overview](https://jsfiddle.net/gh/get/library/pure/highcharts
   * /highcharts/tree/master/samples/highcharts/plotoptions/series-
   * dashstyle-all/).
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-dashstyle/
   *         Dash and dot pattern
   * @sample {highstock} stock/xaxis/plotlines/
   *         Plot line on Y axis
   *
   * @type       {string}
   * @default    Solid
   * @since      1.2
   * @product    highcharts highstock
   * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
   *             "ShortDashDotDot", "Dot", "Dash" ,"LongDash", "DashDot",
   *             "LongDashDot", "LongDashDotDot"]
   * @apioption  xAxis.plotLines.dashStyle
   */

  /**
   * An object defining mouse events for the plot line. Supported
   * properties are `click`, `mouseover`, `mouseout`, `mousemove`.
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-events/
   *         Mouse events demonstrated
   *
   * @type      {*}
   * @since     1.2
   * @product   highcharts highstock
   * @context   PlotLineOrBand
   * @apioption xAxis.plotLines.events
   */

  /**
   * An id used for identifying the plot line in Axis.removePlotLine.
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-id/
   *         Remove plot line by id
   *
   * @type      {string}
   * @product   highcharts highstock
   * @apioption xAxis.plotLines.id
   */

  /**
   * The position of the line in axis units.
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-color/
   *         Between two categories on X axis
   * @sample {highstock} stock/xaxis/plotlines/
   *         Plot line on Y axis
   *
   * @type      {number}
   * @product   highcharts highstock
   * @apioption xAxis.plotLines.value
   */

  /**
   * The width or thickness of the plot line.
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-color/
   *         2px wide line from X axis
   * @sample {highstock} stock/xaxis/plotlines/
   *         Plot line on Y axis
   *
   * @type      {number}
   * @product   highcharts highstock
   * @apioption xAxis.plotLines.width
   */

  /**
   * The z index of the plot line within the chart.
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-zindex-behind/
   *         Behind plot lines by default
   * @sample {highcharts} highcharts/xaxis/plotlines-zindex-above/
   *         Above plot lines
   * @sample {highcharts} highcharts/xaxis/plotlines-zindex-above-all/
   *         Above plot lines and series
   *
   * @type      {number}
   * @since     1.2
   * @product   highcharts highstock
   * @apioption xAxis.plotLines.zIndex
   */

  /**
   * Text labels for the plot bands
   *
   * @product   highcharts highstock
   * @apioption xAxis.plotLines.label
   */

  /**
   * Horizontal alignment of the label. Can be one of "left", "center" or
   * "right".
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-label-align-right/
   *         Aligned to the right
   * @sample {highstock} stock/xaxis/plotlines/
   *         Plot line on Y axis
   *
   * @type       {string}
   * @default    left
   * @since      2.1
   * @product    highcharts highstock
   * @validvalue ["center", "left", "right"]
   * @apioption  xAxis.plotLines.label.align
   */

  /**
   * Rotation of the text label in degrees. Defaults to 0 for horizontal plot
   * lines and 90 for vertical lines.
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-label-verticalalign-middle/
   *         Slanted text
   *
   * @type      {number}
   * @since     2.1
   * @product   highcharts highstock
   * @apioption xAxis.plotLines.label.rotation
   */

  /**
   * CSS styles for the text label.
   *
   * In styled mode, the labels are styled by the
   * `.highcharts-plot-line-label` class.
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-label-style/
   *         Blue and bold label
   *
   * @type      {Highcharts.CSSObject}
   * @since     2.1
   * @product   highcharts highstock
   * @apioption xAxis.plotLines.label.style
   */

  /**
   * The text itself. A subset of HTML is supported.
   *
   * @type      {string}
   * @since     2.1
   * @product   highcharts
   * @apioption xAxis.plotLines.label.text
   */

  /**
   * The text alignment for the label. While `align` determines where the
   * texts anchor point is placed within the plot band, `textAlign` determines
   * how the text is aligned against its anchor point. Possible values are
   * "left", "center" and "right". Defaults to the same as the `align` option.
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-label-textalign/
   *         Text label in bottom position
   *
   * @type      {string}
   * @since     2.1
   * @product   highcharts highstock
   * @apioption xAxis.plotLines.label.textAlign
   */

  /**
   * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts
   * /labels-and-string-formatting#html) to render the labels.
   *
   * @type      {boolean}
   * @default   false
   * @since     3.0.3
   * @product   highcharts highstock
   * @apioption xAxis.plotLines.label.useHTML
   */

  /**
   * Vertical alignment of the label relative to the plot line. Can be
   * one of "top", "middle" or "bottom".
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-label-verticalalign-middle/
   *         Vertically centered label
   *
   * @type       {string}
   * @default    {highcharts} top
   * @default    {highstock} top
   * @since      2.1
   * @product    highcharts highstock
   * @validvalue ["top", "middle", "bottom"]
   * @apioption  xAxis.plotLines.label.verticalAlign
   */

  /**
   * Horizontal position relative the alignment. Default varies by
   * orientation.
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-label-align-right/
   *         Aligned 10px from the right edge
   * @sample {highstock} stock/xaxis/plotlines/
   *         Plot line on Y axis
   *
   * @type      {number}
   * @since     2.1
   * @product   highcharts highstock
   * @apioption xAxis.plotLines.label.x
   */

  /**
   * Vertical position of the text baseline relative to the alignment. Default
   * varies by orientation.
   *
   * @sample {highcharts} highcharts/xaxis/plotlines-label-y/
   *         Label below the plot line
   * @sample {highstock} stock/xaxis/plotlines/
   *         Plot line on Y axis
   *
   * @type      {number}
   * @since     2.1
   * @product   highcharts highstock
   * @apioption xAxis.plotLines.label.y
   */

  /**
   * An array of objects defining plot bands on the Y axis.
   *
   * @type      {Array<*>}
   * @extends   xAxis.plotBands
   * @product   highcharts highstock
   * @apioption yAxis.plotBands
   */

  /**
   * In a gauge chart, this option determines the inner radius of the
   * plot band that stretches along the perimeter. It can be given as
   * a percentage string, like `"100%"`, or as a pixel number, like `100`.
   * By default, the inner radius is controlled by the [thickness](
   * #yAxis.plotBands.thickness) option.
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-gauge
   *         Gauge plot band
   *
   * @type      {number|string}
   * @since     2.3
   * @product   highcharts
   * @apioption yAxis.plotBands.innerRadius
   */

  /**
   * In a gauge chart, this option determines the outer radius of the
   * plot band that stretches along the perimeter. It can be given as
   * a percentage string, like `"100%"`, or as a pixel number, like `100`.
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-gauge
   *         Gauge plot band
   *
   * @type      {number|string}
   * @default   100%
   * @since     2.3
   * @product   highcharts
   * @apioption yAxis.plotBands.outerRadius
   */

  /**
   * In a gauge chart, this option sets the width of the plot band
   * stretching along the perimeter. It can be given as a percentage
   * string, like `"10%"`, or as a pixel number, like `10`. The default
   * value 10 is the same as the default [tickLength](#yAxis.tickLength),
   * thus making the plot band act as a background for the tick markers.
   *
   * @sample {highcharts} highcharts/xaxis/plotbands-gauge
   *         Gauge plot band
   *
   * @type      {number|string}
   * @default   10
   * @since     2.3
   * @product   highcharts
   * @apioption yAxis.plotBands.thickness
   */

  /**
   * An array of objects representing plot lines on the X axis
   *
   * @type      {Array<*>}
   * @extends   xAxis.plotLines
   * @product   highcharts highstock
   * @apioption yAxis.plotLines
   */

  /**
   * Internal function to create the SVG path definition for a plot band.
   *
   * @function Highcharts.Axis#getPlotBandPath
   *
   * @param {number} from
   *        The axis value to start from.
   *
   * @param {number} to
   *        The axis value to end on.
   *
   * @return {Highcharts.SVGPathArray}
   *         The SVG path definition in array form.
   */
  getPlotBandPath: function (from, to) {
    var toPath = this.getPlotLinePath(to, null, null, true),
        path = this.getPlotLinePath(from, null, null, true),
        result = [],
        i,
        // #4964 check if chart is inverted or plotband is on yAxis
    horiz = this.horiz,
        plus = 1,
        isFlat,
        outside = from < this.min && to < this.min || from > this.max && to > this.max;

    if (path && toPath) {
      // Flat paths don't need labels (#3836)
      if (outside) {
        isFlat = path.toString() === toPath.toString();
        plus = 0;
      } // Go over each subpath - for panes in Highstock


      for (i = 0; i < path.length; i += 6) {
        // Add 1 pixel when coordinates are the same
        if (horiz && toPath[i + 1] === path[i + 1]) {
          toPath[i + 1] += plus;
          toPath[i + 4] += plus;
        } else if (!horiz && toPath[i + 2] === path[i + 2]) {
          toPath[i + 2] += plus;
          toPath[i + 5] += plus;
        }

        result.push('M', path[i + 1], path[i + 2], 'L', path[i + 4], path[i + 5], toPath[i + 4], toPath[i + 5], toPath[i + 1], toPath[i + 2], 'z');
        result.isFlat = isFlat;
      }
    } else {
      // outside the axis area
      path = null;
    }

    return result;
  },

  /**
   * Add a plot band after render time.
   *
   * @sample highcharts/members/axis-addplotband/
   *         Toggle the plot band from a button
   *
   * @function Highcharts.Axis#addPlotBand
   *
   * @param {Highcharts.AxisPlotBandsOptions} options
   *        A configuration object for the plot band, as defined in
   *        {@link  https://api.highcharts.com/highcharts/xAxis.plotBands|xAxis.plotBands}.
   *
   * @return {Highcharts.PlotLineOrBand|undefined}
   *         The added plot band.
   */
  addPlotBand: function (options) {
    return this.addPlotBandOrLine(options, 'plotBands');
  },

  /**
   * Add a plot line after render time.
   *
   * @sample highcharts/members/axis-addplotline/
   *         Toggle the plot line from a button
   *
   * @function Highcharts.Axis#addPlotLine
   *
   * @param {Highcharts.AxisPlotLinesOptions} options
   *        A configuration object for the plot line, as defined in
   *        {@link https://api.highcharts.com/highcharts/xAxis.plotLines|xAxis.plotLines}.
   *
   * @return {Highcharts.PlotLineOrBand|undefined}
   *         The added plot line.
   */
  addPlotLine: function (options) {
    return this.addPlotBandOrLine(options, 'plotLines');
  },

  /**
   * Add a plot band or plot line after render time. Called from addPlotBand
   * and addPlotLine internally.
   *
   * @private
   * @function Highcharts.Axis#addPlotBandOrLine
   *
   * @param {Highcharts.AxisPlotLinesOptions|Highcharts.AxisPlotBandsOptions} options
   *        The plotBand or plotLine configuration object.
   *
   * @param {"plotBands"|"plotLines"} [coll]
   *
   * @return {Highcharts.PlotLineOrBand|undefined}
   */
  addPlotBandOrLine: function (options, coll) {
    var obj = new Highcharts.PlotLineOrBand(this, options).render(),
        userOptions = this.userOptions;

    if (obj) {
      // #2189
      // Add it to the user options for exporting and Axis.update
      if (coll) {
        userOptions[coll] = userOptions[coll] || [];
        userOptions[coll].push(options);
      }

      this.plotLinesAndBands.push(obj);
    }

    return obj;
  },

  /**
   * Remove a plot band or plot line from the chart by id. Called internally
   * from `removePlotBand` and `removePlotLine`.
   *
   * @private
   * @function Highcharts.Axis#removePlotBandOrLine
   *
   * @param {string} id
   */
  removePlotBandOrLine: function (id) {
    var plotLinesAndBands = this.plotLinesAndBands,
        options = this.options,
        userOptions = this.userOptions,
        i = plotLinesAndBands.length;

    while (i--) {
      if (plotLinesAndBands[i].id === id) {
        plotLinesAndBands[i].destroy();
      }
    }

    each$5([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {
      i = arr.length;

      while (i--) {
        if (arr[i].id === id) {
          erase$1(arr, arr[i]);
        }
      }
    });
  },

  /**
   * Remove a plot band by its id.
   *
   * @sample highcharts/members/axis-removeplotband/
   *         Remove plot band by id
   * @sample highcharts/members/axis-addplotband/
   *         Toggle the plot band from a button
   *
   * @function Highcharts.Axis#removePlotBand
   *
   * @param {string} id
   *        The plot band's `id` as given in the original configuration
   *        object or in the `addPlotBand` option.
   */
  removePlotBand: function (id) {
    this.removePlotBandOrLine(id);
  },

  /**
   * Remove a plot line by its id.
   *
   * @sample highcharts/xaxis/plotlines-id/
   *         Remove plot line by id
   * @sample highcharts/members/axis-addplotline/
   *         Toggle the plot line from a button
   *
   * @function Highcharts.Axis#removePlotLine
   *
   * @param {string} id
   *        The plot line's `id` as given in the original configuration
   *        object or in the `addPlotLine` option.
   */
  removePlotLine: function (id) {
    this.removePlotBandOrLine(id);
  }
});

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var doc$3 = Highcharts.doc,
    each$6 = Highcharts.each,
    extend$4 = Highcharts.extend,
    format$1 = Highcharts.format,
    isNumber$3 = Highcharts.isNumber,
    map$2 = Highcharts.map,
    merge$7 = Highcharts.merge,
    pick$7 = Highcharts.pick,
    splat$2 = Highcharts.splat,
    syncTimeout$1 = Highcharts.syncTimeout,
    timeUnits$2 = Highcharts.timeUnits;
/**
 * Tooltip of a chart.
 *
 * @class
 * @name Highcharts.Tooltip
 *
 * @param {Highcharts.Chart} chart
 *        The chart instance.
 *
 * @param {Highcharts.TooltipOptions} options
 *        Tooltip options.
 */

Highcharts.Tooltip = function () {
  this.init.apply(this, arguments);
};

Highcharts.Tooltip.prototype = {
  /**
   * @private
   * @function Highcharts.Tooltip#init
   *
   * @param {Highcharts.Chart} chart
   *        The chart instance.
   *
   * @param {Highcharts.TooltipOptions} options
   *        Tooltip options.
   */
  init: function (chart, options) {
    /**
     * Chart of the tooltip.
     *
     * @readonly
     * @name Highcharts.Tooltip#chart
     * @type {Highcharts.Chart}
     */
    this.chart = chart;
    /**
     * Used tooltip options.
     *
     * @readonly
     * @name Highcharts.Tooltip#options
     * @type {Highcharts.TooltipOptions}
     */

    this.options = options;
    /**
     * List of crosshairs.
     *
     * @private
     * @readonly
     * @name Highcharts.Tooltip#crosshairs
     * @type {Array<*>}
     */

    this.crosshairs = [];
    /**
     * Current values of x and y when animating.
     *
     * @private
     * @readonly
     * @name Highcharts.Tooltip#now
     * @type {*}
     */

    this.now = {
      x: 0,
      y: 0
    };
    /**
     * Tooltips are initially hidden.
     *
     * @readonly
     * @name Highcharts.Tooltip#isHidden
     * @type {boolean}
     */

    this.isHidden = true;
    /**
     * True, if the tooltip is splitted into one label per series, with the
     * header close to the axis.
     *
     * @readonly
     * @name Highcharts.Tooltip#split
     * @type {boolean}
     */

    this.split = options.split && !chart.inverted;
    /**
     * When the tooltip is shared, the entire plot area will capture mouse
     * movement or touch events.
     *
     * @readonly
     * @name Highcharts.Tooltip#shared
     * @type {boolean}
     */

    this.shared = options.shared || this.split;
    /**
     * Whether to allow the tooltip to render outside the chart's SVG
     * element box. By default (false), the tooltip is rendered within the
     * chart's SVG element, which results in the tooltip being aligned
     * inside the chart area.
     *
     * @readonly
     * @name Highcharts.Tooltip#outside
     * @type {boolean}
     *
     * @todo
     * Split tooltip does not support outside in the first iteration. Should
     * not be too complicated to implement.
     */

    this.outside = options.outside && !this.split;
  },

  /**
   * Destroy the single tooltips in a split tooltip.
   * If the tooltip is active then it is not destroyed, unless forced to.
   *
   * @private
   * @function Highcharts.Tooltip#cleanSplit
   *
   * @param {boolean} force
   *        Force destroy all tooltips.
   */
  cleanSplit: function (force) {
    each$6(this.chart.series, function (series) {
      var tt = series && series.tt;

      if (tt) {
        if (!tt.isActive || force) {
          series.tt = tt.destroy();
        } else {
          tt.isActive = false;
        }
      }
    });
  },

  /**
   * In styled mode, apply the default filter for the tooltip drop-shadow. It
   * needs to have an id specific to the chart, otherwise there will be issues
   * when one tooltip adopts the filter of a different chart, specifically one
   * where the container is hidden.
   *
   * @private
   * @function Highcharts.Tooltip#applyFilter
   */
  applyFilter: function () {
    var chart = this.chart;
    chart.renderer.definition({
      tagName: 'filter',
      id: 'drop-shadow-' + chart.index,
      opacity: 0.5,
      children: [{
        tagName: 'feGaussianBlur',
        in: 'SourceAlpha',
        stdDeviation: 1
      }, {
        tagName: 'feOffset',
        dx: 1,
        dy: 1
      }, {
        tagName: 'feComponentTransfer',
        children: [{
          tagName: 'feFuncA',
          type: 'linear',
          slope: 0.3
        }]
      }, {
        tagName: 'feMerge',
        children: [{
          tagName: 'feMergeNode'
        }, {
          tagName: 'feMergeNode',
          in: 'SourceGraphic'
        }]
      }]
    });
    chart.renderer.definition({
      tagName: 'style',
      textContent: '.highcharts-tooltip-' + chart.index + '{' + 'filter:url(#drop-shadow-' + chart.index + ')' + '}'
    });
  },

  /**
   * Creates the Tooltip label element if it does not exist, then returns it.
   *
   * @function Highcharts.Tooltip#getLabel
   *
   * @return {Highcharts.SVGElement}
   */
  getLabel: function () {
    var renderer = this.chart.renderer,
        options = this.options,
        container;

    if (!this.label) {
      if (this.outside) {
        this.container = container = Highcharts.doc.createElement('div');
        container.className = 'highcharts-tooltip-container';
        Highcharts.css(container, {
          position: 'absolute',
          top: '1px',
          pointerEvents: options.style && options.style.pointerEvents
        });
        Highcharts.doc.body.appendChild(container);
        this.renderer = renderer = new Highcharts.Renderer(container, 0, 0);
      } // Create the label


      if (this.split) {
        this.label = renderer.g('tooltip');
      } else {
        this.label = renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip').attr({
          padding: options.padding,
          r: options.borderRadius
        });
      } // Apply the drop-shadow filter


      this.applyFilter();
      this.label.addClass('highcharts-tooltip-' + this.chart.index);

      if (this.outside) {
        this.label.attr({
          x: this.distance,
          y: this.distance
        });

        this.label.xSetter = function (value) {
          container.style.left = value + 'px';
        };

        this.label.ySetter = function (value) {
          container.style.top = value + 'px';
        };
      }

      this.label.attr({
        zIndex: 8
      }).add();
    }

    return this.label;
  },

  /**
   * Updates the tooltip with the provided tooltip options.
   *
   * @function Highcharts.Tooltip#update
   *
   * @param {Highcharts.TooltipOptions} options
   */
  update: function (options) {
    this.destroy(); // Update user options (#6218)

    merge$7(true, this.chart.options.tooltip.userOptions, options);
    this.init(this.chart, merge$7(true, this.options, options));
  },

  /**
   * Removes and destroys the tooltip and its elements.
   *
   * @function Highcharts.Tooltip#destroy
   */
  destroy: function () {
    // Destroy and clear local variables
    if (this.label) {
      this.label = this.label.destroy();
    }

    if (this.split && this.tt) {
      this.cleanSplit(this.chart, true);
      this.tt = this.tt.destroy();
    }

    if (this.renderer) {
      this.renderer = this.renderer.destroy();
      Highcharts.discardElement(this.container);
    }

    Highcharts.clearTimeout(this.hideTimer);
    Highcharts.clearTimeout(this.tooltipTimeout);
  },

  /**
   * Moves the tooltip with a soft animation to a new position.
   *
   * @function Highcharts.Tooltip#move
   *
   * @param {number} x
   *
   * @param {number} y
   *
   * @param {number} anchorX
   *
   * @param {number} anchorY
   */
  move: function (x, y, anchorX, anchorY) {
    var tooltip = this,
        now = tooltip.now,
        animate = tooltip.options.animation !== false && !tooltip.isHidden && ( // When we get close to the target position, abort animation and
    // land on the right place (#3056)
    Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),
        skipAnchor = tooltip.followPointer || tooltip.len > 1; // Get intermediate values for animation

    extend$4(now, {
      x: animate ? (2 * now.x + x) / 3 : x,
      y: animate ? (now.y + y) / 2 : y,
      anchorX: skipAnchor ? undefined : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
      anchorY: skipAnchor ? undefined : animate ? (now.anchorY + anchorY) / 2 : anchorY
    }); // Move to the intermediate value

    tooltip.getLabel().attr(now); // Run on next tick of the mouse tracker

    if (animate) {
      // Never allow two timeouts
      Highcharts.clearTimeout(this.tooltipTimeout); // Set the fixed interval ticking for the smooth tooltip

      this.tooltipTimeout = setTimeout(function () {
        // The interval function may still be running during destroy,
        // so check that the chart is really there before calling.
        if (tooltip) {
          tooltip.move(x, y, anchorX, anchorY);
        }
      }, 32);
    }
  },

  /**
   * Hides the tooltip with a fade out animation.
   *
   * @function Highcharts.Tooltip#hide
   *
   * @param {number} [delay]
   *        The fade out in milliseconds. If no value is provided the value
   *        of the tooltip.hideDelay option is used. A value of 0 disables
   *        the fade out animation.
   */
  hide: function (delay) {
    var tooltip = this; // disallow duplicate timers (#1728, #1766)

    Highcharts.clearTimeout(this.hideTimer);
    delay = pick$7(delay, this.options.hideDelay, 500);

    if (!this.isHidden) {
      this.hideTimer = syncTimeout$1(function () {
        tooltip.getLabel()[delay ? 'fadeOut' : 'hide']();
        tooltip.isHidden = true;
      }, delay);
    }
  },

  /**
   * Extendable method to get the anchor position of the tooltip
   * from a point or set of points
   *
   * @private
   * @function Highcharts.Tooltip#getAnchor
   *
   * @param {Array<Highchart.Points>} points
   *
   * @param {global.Event} [mouseEvent]
   */
  getAnchor: function (points, mouseEvent) {
    var ret,
        chart = this.chart,
        pointer = chart.pointer,
        inverted = chart.inverted,
        plotTop = chart.plotTop,
        plotLeft = chart.plotLeft,
        plotX = 0,
        plotY = 0,
        yAxis,
        xAxis;
    points = splat$2(points); // When tooltip follows mouse, relate the position to the mouse

    if (this.followPointer && mouseEvent) {
      if (mouseEvent.chartX === undefined) {
        mouseEvent = pointer.normalize(mouseEvent);
      }

      ret = [mouseEvent.chartX - chart.plotLeft, mouseEvent.chartY - plotTop]; // Pie uses a special tooltipPos
    } else if (points[0].tooltipPos) {
      ret = points[0].tooltipPos; // When shared, use the average position
    } else {
      each$6(points, function (point) {
        yAxis = point.series.yAxis;
        xAxis = point.series.xAxis;
        plotX += point.plotX + (!inverted && xAxis ? xAxis.left - plotLeft : 0);
        plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) + (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
      });
      plotX /= points.length;
      plotY /= points.length;
      ret = [inverted ? chart.plotWidth - plotY : plotX, this.shared && !inverted && points.length > 1 && mouseEvent ? // place shared tooltip next to the mouse (#424)
      mouseEvent.chartY - plotTop : inverted ? chart.plotHeight - plotX : plotY];
    }

    return map$2(ret, Math.round);
  },

  /**
   * Place the tooltip in a chart without spilling over
   * and not covering the point it self.
   *
   * @private
   * @function Highcharts.Tooltip#getPosition
   *
   * @param {number} boxWidth
   *
   * @param {number} boxHeight
   *
   * @param {Highcharts.Point} point
   *
   * @return {*}
   */
  getPosition: function (boxWidth, boxHeight, point) {
    var chart = this.chart,
        distance = this.distance,
        ret = {},
        // Don't use h if chart isn't inverted (#7242)
    h = chart.inverted && point.h || 0,
        // #4117
    swapped,
        outside = this.outside,
        outerWidth = outside ? // substract distance to prevent scrollbars
    doc$3.documentElement.clientWidth - 2 * distance : chart.chartWidth,
        outerHeight = outside ? Math.max(doc$3.body.scrollHeight, doc$3.documentElement.scrollHeight, doc$3.body.offsetHeight, doc$3.documentElement.offsetHeight, doc$3.documentElement.clientHeight) : chart.chartHeight,
        chartPosition = chart.pointer.chartPosition,
        first = ['y', outerHeight, boxHeight, (outside ? chartPosition.top - distance : 0) + point.plotY + chart.plotTop, outside ? 0 : chart.plotTop, outside ? outerHeight : chart.plotTop + chart.plotHeight],
        second = ['x', outerWidth, boxWidth, (outside ? chartPosition.left - distance : 0) + point.plotX + chart.plotLeft, outside ? 0 : chart.plotLeft, outside ? outerWidth : chart.plotLeft + chart.plotWidth],
        // The far side is right or bottom
    preferFarSide = !this.followPointer && pick$7(point.ttBelow, !chart.inverted === !!point.negative),
        // #4984

    /*
     * Handle the preferred dimension. When the preferred dimension is
     * tooltip on top or bottom of the point, it will look for space
     * there.
     *
     * @private
     */
    firstDimension = function (dim, outerSize, innerSize, point, min, max) {
      var roomLeft = innerSize < point - distance,
          roomRight = point + distance + innerSize < outerSize,
          alignedLeft = point - distance - innerSize,
          alignedRight = point + distance;

      if (preferFarSide && roomRight) {
        ret[dim] = alignedRight;
      } else if (!preferFarSide && roomLeft) {
        ret[dim] = alignedLeft;
      } else if (roomLeft) {
        ret[dim] = Math.min(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);
      } else if (roomRight) {
        ret[dim] = Math.max(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);
      } else {
        return false;
      }
    },

    /*
     * Handle the secondary dimension. If the preferred dimension is
     * tooltip on top or bottom of the point, the second dimension is to
     * align the tooltip above the point, trying to align center but
     * allowing left or right align within the chart box.
     *
     * @private
     */
    secondDimension = function (dim, outerSize, innerSize, point) {
      var retVal; // Too close to the edge, return false and swap dimensions

      if (point < distance || point > outerSize - distance) {
        retVal = false; // Align left/top
      } else if (point < innerSize / 2) {
        ret[dim] = 1; // Align right/bottom
      } else if (point > outerSize - innerSize / 2) {
        ret[dim] = outerSize - innerSize - 2; // Align center
      } else {
        ret[dim] = point - innerSize / 2;
      }

      return retVal;
    },

    /*
     * Swap the dimensions
     */
    swap = function (count) {
      var temp = first;
      first = second;
      second = temp;
      swapped = count;
    },
        run = function () {
      if (firstDimension.apply(0, first) !== false) {
        if (secondDimension.apply(0, second) === false && !swapped) {
          swap(true);
          run();
        }
      } else if (!swapped) {
        swap(true);
        run();
      } else {
        ret.x = ret.y = 0;
      }
    }; // Under these conditions, prefer the tooltip on the side of the point


    if (chart.inverted || this.len > 1) {
      swap();
    }

    run();
    return ret;
  },

  /**
   * In case no user defined formatter is given, this will be used. Note that
   * the context here is an object holding point, series, x, y etc.
   *
   * @private
   * @function Highcharts.Tooltip#defaultFormatter
   *
   * @param {Highcharts.Tooltip} tooltip
   *
   * @return {Array<string>}
   */
  defaultFormatter: function (tooltip) {
    var items = this.points || splat$2(this),
        s; // Build the header

    s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; // build the values

    s = s.concat(tooltip.bodyFormatter(items)); // footer

    s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));
    return s;
  },

  /**
   * Refresh the tooltip's text and position.
   *
   * @function Highcharts.Tooltip#refresh
   *
   * @param {Highcharts.Point|Array<Highcharts.Point>} pointOrPoints
   *        Either a point or an array of points.
   *
   * @param {global.Event} [mouseEvent]
   *        Mouse event, that is responsible for the refresh and should be
   *        used for the tooltip update.
   */
  refresh: function (pointOrPoints, mouseEvent) {
    var tooltip = this,
        label,
        options = tooltip.options,
        x,
        y,
        point = pointOrPoints,
        anchor,
        textConfig = {},
        text,
        pointConfig = [],
        formatter = options.formatter || tooltip.defaultFormatter,
        shared = tooltip.shared,
        currentSeries;

    if (!options.enabled) {
      return;
    }

    Highcharts.clearTimeout(this.hideTimer); // get the reference point coordinates (pie charts use tooltipPos)

    tooltip.followPointer = splat$2(point)[0].series.tooltipOptions.followPointer;
    anchor = tooltip.getAnchor(point, mouseEvent);
    x = anchor[0];
    y = anchor[1]; // shared tooltip, array is sent over

    if (shared && !(point.series && point.series.noSharedTooltip)) {
      each$6(point, function (item) {
        item.setState('hover');
        pointConfig.push(item.getLabelConfig());
      });
      textConfig = {
        x: point[0].category,
        y: point[0].y
      };
      textConfig.points = pointConfig;
      point = point[0]; // single point tooltip
    } else {
      textConfig = point.getLabelConfig();
    }

    this.len = pointConfig.length; // #6128

    text = formatter.call(textConfig, tooltip); // register the current series

    currentSeries = point.series;
    this.distance = pick$7(currentSeries.tooltipOptions.distance, 16); // update the inner HTML

    if (text === false) {
      this.hide();
    } else {
      label = tooltip.getLabel(); // show it

      if (tooltip.isHidden) {
        label.attr({
          opacity: 1
        }).show();
      } // update text


      if (tooltip.split) {
        this.renderSplit(text, splat$2(pointOrPoints));
      } else {
        // Prevent the tooltip from flowing over the chart box (#6659)
        label.css({
          width: this.chart.spacingBox.width
        });
        label.attr({
          text: text && text.join ? text.join('') : text
        }); // Set the stroke color of the box to reflect the point

        label.removeClass(/highcharts-color-[\d]+/g).addClass('highcharts-color-' + pick$7(point.colorIndex, currentSeries.colorIndex));
        tooltip.updatePosition({
          plotX: x,
          plotY: y,
          negative: point.negative,
          ttBelow: point.ttBelow,
          h: anchor[2] || 0
        });
      }

      this.isHidden = false;
    }
  },

  /**
   * Render the split tooltip. Loops over each point's text and adds
   * a label next to the point, then uses the distribute function to
   * find best non-overlapping positions.
   *
   * @private
   * @function Highcharts.Tooltip#renderSplit
   *
   * @param {Array<Highcharts.Label>} labels
   *
   * @param {Array<Highcharts.Point>} points
   */
  renderSplit: function (labels, points) {
    var tooltip = this,
        boxes = [],
        chart = this.chart,
        ren = chart.renderer,
        rightAligned = true,
        options = this.options,
        headerHeight = 0,
        headerTop,
        tooltipLabel = this.getLabel(),
        distributionBoxTop = chart.plotTop; // Graceful degradation for legacy formatters

    if (Highcharts.isString(labels)) {
      labels = [false, labels];
    } // Create the individual labels for header and points, ignore footer


    each$6(labels.slice(0, points.length + 1), function (str, i) {
      if (str !== false) {
        var point = points[i - 1] || // Item 0 is the header. Instead of this, we could also
        // use the crosshair label
        {
          isHeader: true,
          plotX: points[0].plotX
        },
            owner = point.series || tooltip,
            tt = owner.tt,
            series = point.series || {},
            colorClass = 'highcharts-color-' + pick$7(point.colorIndex, series.colorIndex, 'none'),
            target,
            x,
            bBox,
            boxWidth; // Store the tooltip referance on the series

        if (!tt) {
          owner.tt = tt = ren.label(null, null, null, 'callout', null, null, options.useHTML).addClass('highcharts-tooltip-box ' + colorClass + (point.isHeader ? ' highcharts-tooltip-header' : '')).attr({
            'padding': options.padding,
            'r': options.borderRadius
          }).add(tooltipLabel);
        }

        tt.isActive = true;
        tt.attr({
          text: str
        }); // Get X position now, so we can move all to the other side in
        // case of overflow

        bBox = tt.getBBox();
        boxWidth = bBox.width + tt.strokeWidth();

        if (point.isHeader) {
          headerHeight = bBox.height;

          if (chart.xAxis[0].opposite) {
            headerTop = true;
            distributionBoxTop -= headerHeight;
          }

          x = Math.max(0, // No left overflow
          Math.min(point.plotX + chart.plotLeft - boxWidth / 2, // No right overflow (#5794)
          chart.chartWidth + ( // Scrollable plot area
          chart.scrollablePixels ? chart.scrollablePixels - chart.marginRight : 0) - boxWidth));
        } else {
          x = point.plotX + chart.plotLeft - pick$7(options.distance, 16) - boxWidth;
        } // If overflow left, we don't use this x in the next loop


        if (x < 0) {
          rightAligned = false;
        } // Prepare for distribution


        target = (point.series && point.series.yAxis && point.series.yAxis.pos) + (point.plotY || 0);
        target -= distributionBoxTop;

        if (point.isHeader) {
          target = headerTop ? -headerHeight : chart.plotHeight + headerHeight;
        }

        boxes.push({
          target: target,
          rank: point.isHeader ? 1 : 0,
          size: owner.tt.getBBox().height + 1,
          point: point,
          x: x,
          tt: tt
        });
      }
    }); // Clean previous run (for missing points)

    this.cleanSplit(); // Distribute and put in place

    Highcharts.distribute(boxes, chart.plotHeight + headerHeight);
    each$6(boxes, function (box) {
      var point = box.point,
          series = point.series; // Put the label in place

      box.tt.attr({
        visibility: box.pos === undefined ? 'hidden' : 'inherit',
        x: rightAligned || point.isHeader ? box.x : point.plotX + chart.plotLeft + pick$7(options.distance, 16),
        y: box.pos + distributionBoxTop,
        anchorX: point.isHeader ? point.plotX + chart.plotLeft : point.plotX + series.xAxis.pos,
        anchorY: point.isHeader ? chart.plotTop + chart.plotHeight / 2 : point.plotY + series.yAxis.pos
      });
    });
  },

  /**
   * Find the new position and perform the move
   *
   * @private
   * @function Highcharts.Tooltip#updatePosition
   *
   * @param {Highcharts.Point} point
   */
  updatePosition: function (point) {
    var chart = this.chart,
        label = this.getLabel(),
        pos = (this.options.positioner || this.getPosition).call(this, label.width, label.height, point),
        anchorX = point.plotX + chart.plotLeft,
        anchorY = point.plotY + chart.plotTop,
        pad; // Set the renderer size dynamically to prevent document size to change

    if (this.outside) {
      pad = (this.options.borderWidth || 0) + 2 * this.distance;
      this.renderer.setSize(label.width + pad, label.height + pad, false);
      anchorX += chart.pointer.chartPosition.left - pos.x;
      anchorY += chart.pointer.chartPosition.top - pos.y;
    } // do the move


    this.move(Math.round(pos.x), Math.round(pos.y || 0), // can be undefined (#3977)
    anchorX, anchorY);
  },

  /**
   * Get the optimal date format for a point, based on a range.
   *
   * @private
   * @function Highcharts.Tooltip#getDateFormat
   *
   * @param {number} range
   *        The time range
   *
   * @param {number|Date} date
   *        The date of the point in question
   *
   * @param {number} startOfWeek
   *        An integer representing the first day of the week, where 0 is
   *        Sunday.
   *
   * @param {Highcharts.Dictionary<string>} dateTimeLabelFormats
   *        A map of time units to formats.
   *
   * @return {string}
   *         The optimal date format for a point.
   */
  getDateFormat: function (range, date, startOfWeek, dateTimeLabelFormats) {
    var time = this.chart.time,
        dateStr = time.dateFormat('%m-%d %H:%M:%S.%L', date),
        format,
        n,
        blank = '01-01 00:00:00.000',
        strpos = {
      millisecond: 15,
      second: 12,
      minute: 9,
      hour: 6,
      day: 3
    },
        lastN = 'millisecond'; // for sub-millisecond data, #4223

    for (n in timeUnits$2) {
      // If the range is exactly one week and we're looking at a
      // Sunday/Monday, go for the week format
      if (range === timeUnits$2.week && +time.dateFormat('%w', date) === startOfWeek && dateStr.substr(6) === blank.substr(6)) {
        n = 'week';
        break;
      } // The first format that is too great for the range


      if (timeUnits$2[n] > range) {
        n = lastN;
        break;
      } // If the point is placed every day at 23:59, we need to show
      // the minutes as well. #2637.


      if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
        break;
      } // Weeks are outside the hierarchy, only apply them on
      // Mondays/Sundays like in the first condition


      if (n !== 'week') {
        lastN = n;
      }
    }

    if (n) {
      format = dateTimeLabelFormats[n];
    }

    return format;
  },

  /**
   * Get the best X date format based on the closest point range on the axis.
   *
   * @private
   * @function Highcharts.Tooltip#getXDateFormat
   *
   * @param {Highcharts.Point} point
   *
   * @param {Highcharts.TooltipOptions} options
   *
   * @param {Highcharts.Axis} xAxis
   *
   * @return {string}
   */
  getXDateFormat: function (point, options, xAxis) {
    var xDateFormat,
        dateTimeLabelFormats = options.dateTimeLabelFormats,
        closestPointRange = xAxis && xAxis.closestPointRange;

    if (closestPointRange) {
      xDateFormat = this.getDateFormat(closestPointRange, point.x, xAxis.options.startOfWeek, dateTimeLabelFormats);
    } else {
      xDateFormat = dateTimeLabelFormats.day;
    }

    return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
  },

  /**
   * Format the footer/header of the tooltip
   * #3397: abstraction to enable formatting of footer and header
   *
   * @private
   * @function Highcharts.Tooltip#tooltipFooterHeaderFormatter
   *
   * @param {*} labelConfig
   *
   * @param {boolean} isFooter
   *
   * @return {string}
   */
  tooltipFooterHeaderFormatter: function (labelConfig, isFooter) {
    var footOrHead = isFooter ? 'footer' : 'header',
        series = labelConfig.series,
        tooltipOptions = series.tooltipOptions,
        xDateFormat = tooltipOptions.xDateFormat,
        xAxis = series.xAxis,
        isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber$3(labelConfig.key),
        formatString = tooltipOptions[footOrHead + 'Format']; // Guess the best date format based on the closest point distance (#568,
    // #3418)

    if (isDateTime && !xDateFormat) {
      xDateFormat = this.getXDateFormat(labelConfig, tooltipOptions, xAxis);
    } // Insert the footer date format if any


    if (isDateTime && xDateFormat) {
      each$6(labelConfig.point && labelConfig.point.tooltipDateKeys || ['key'], function (key) {
        formatString = formatString.replace('{point.' + key + '}', '{point.' + key + ':' + xDateFormat + '}');
      });
    }

    return format$1(formatString, {
      point: labelConfig,
      series: series
    }, this.chart.time);
  },

  /**
   * Build the body (lines) of the tooltip by iterating over the items and
   * returning one entry for each item, abstracting this functionality allows
   * to easily overwrite and extend it.
   *
   * @private
   * @function Highcharts.Tooltip#bodyFormatter
   *
   * @param {Array<Highcharts.Point>} items
   *
   * @return {string}
   */
  bodyFormatter: function (items) {
    return map$2(items, function (item) {
      var tooltipOptions = item.series.tooltipOptions;
      return (tooltipOptions[(item.point.formatPrefix || 'point') + 'Formatter'] || item.point.tooltipFormatter).call(item.point, tooltipOptions[(item.point.formatPrefix || 'point') + 'Format']);
    });
  }
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var H$1 = Highcharts,
    addEvent$2 = H$1.addEvent,
    attr$2 = H$1.attr,
    charts$2 = H$1.charts,
    color$3 = H$1.color,
    css$2 = H$1.css,
    defined$6 = H$1.defined,
    each$7 = H$1.each,
    extend$5 = H$1.extend,
    find = H$1.find,
    fireEvent$2 = H$1.fireEvent,
    isNumber$4 = H$1.isNumber,
    isObject$2 = H$1.isObject,
    offset = H$1.offset,
    pick$8 = H$1.pick,
    splat$3 = H$1.splat,
    Tooltip = H$1.Tooltip;
/**
 * The mouse and touch tracker object. Each {@link Chart} item has one
 * assosiated Pointer item that can be accessed from the  {@link Chart.pointer}
 * property.
 *
 * @class
 * @name Highcharts.Pointer
 *
 * @param {Highcharts.Chart} chart
 *        The Chart instance.
 *
 * @param {Highcharts.Options} options
 *        The root options object. The pointer uses options from the chart and
 *        tooltip structures.
 */

Highcharts.Pointer = function (chart, options) {
  this.init(chart, options);
};

Highcharts.Pointer.prototype = {
  /**
   * Initialize the Pointer.
   *
   * @private
   * @function Highcharts.Pointer#init
   *
   * @param {Highcharts.Chart} chart
   *        The Chart instance.
   *
   * @param {Highcharts.Options} options
   *        The root options object. The pointer uses options from the chart
   *        and tooltip structures.
   */
  init: function (chart, options) {
    // Store references
    this.options = options;
    this.chart = chart; // Do we need to handle click on a touch device?

    this.runChartClick = options.chart.events && !!options.chart.events.click;
    this.pinchDown = [];
    this.lastValidTouch = {};

    if (Tooltip) {
      /**
       * Tooltip object for points of series.
       *
       * @name Highcharts.Chart#tooltip
       * @type {Highcharts.Tooltip}
       */
      chart.tooltip = new Tooltip(chart, options.tooltip);
      this.followTouchMove = pick$8(options.tooltip.followTouchMove, true);
    }

    this.setDOMEvents();
  },

  /**
   * Resolve the zoomType option, this is reset on all touch start and mouse
   * down events.
   *
   * @private
   * @function Highcharts.Pointer#zoomOption
   *
   * @param {global.Event} e
   *        Event object.
   */
  zoomOption: function (e) {
    var chart = this.chart,
        options = chart.options.chart,
        zoomType = options.zoomType || '',
        inverted = chart.inverted,
        zoomX,
        zoomY; // Look for the pinchType option

    if (/touch/.test(e.type)) {
      zoomType = pick$8(options.pinchType, zoomType);
    }

    this.zoomX = zoomX = /x/.test(zoomType);
    this.zoomY = zoomY = /y/.test(zoomType);
    this.zoomHor = zoomX && !inverted || zoomY && inverted;
    this.zoomVert = zoomY && !inverted || zoomX && inverted;
    this.hasZoom = zoomX || zoomY;
  },

  /**
   * Takes a browser event object and extends it with custom Highcharts
   * properties `chartX` and `chartY` in order to work on the internal
   * coordinate system.
   *
   * @function Highcharts.Pointer#normalize
   *
   * @param {global.Event} e
   *        Event object in standard browsers.
   *
   * @return {Highcharts.PointerEventObject}
   *         A browser event with extended properties `chartX` and `chartY`.
   */
  normalize: function (e, chartPosition) {
    var ePos; // iOS (#2757)

    ePos = e.touches ? e.touches.length ? e.touches.item(0) : e.changedTouches[0] : e; // Get mouse position

    if (!chartPosition) {
      this.chartPosition = chartPosition = offset(this.chart.container);
    }

    return extend$5(e, {
      chartX: Math.round(ePos.pageX - chartPosition.left),
      chartY: Math.round(ePos.pageY - chartPosition.top)
    });
  },

  /**
   * Get the click position in terms of axis values.
   *
   * @function Highcharts.Pointer#getCoordinates
   *
   * @param {Highcharts.PointerEventObject} e
   *        Pointer event, extended with `chartX` and `chartY` properties.
   *
   * @return {Highcharts.PointerAxisCoordinatesObject}
   */
  getCoordinates: function (e) {
    var coordinates = {
      xAxis: [],
      yAxis: []
    };
    each$7(this.chart.axes, function (axis) {
      coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
        axis: axis,
        value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
      });
    });
    return coordinates;
  },

  /**
   * Finds the closest point to a set of coordinates, using the k-d-tree
   * algorithm.
   *
   * @function Highcharts.Pointer#findNearestKDPoints
   *
   * @param {Array<Highcharts.Series>} series
   *        All the series to search in.
   *
   * @param {boolean} shared
   *        Whether it is a shared tooltip or not.
   *
   * @param {Highcharts.PointerCoordinatesObject} coordinates
   *        Chart coordinates of the pointer.
   *
   * @return {Point|undefined}
   *         The point closest to given coordinates.
   */
  findNearestKDPoint: function (series, shared, coordinates) {
    var closest,
        sort = function (p1, p2) {
      var isCloserX = p1.distX - p2.distX,
          isCloser = p1.dist - p2.dist,
          isAbove = (p2.series.group && p2.series.group.zIndex) - (p1.series.group && p1.series.group.zIndex),
          result; // We have two points which are not in the same place on xAxis
      // and shared tooltip:

      if (isCloserX !== 0 && shared) {
        // #5721
        result = isCloserX; // Points are not exactly in the same place on x/yAxis:
      } else if (isCloser !== 0) {
        result = isCloser; // The same xAxis and yAxis position, sort by z-index:
      } else if (isAbove !== 0) {
        result = isAbove; // The same zIndex, sort by array index:
      } else {
        result = p1.series.index > p2.series.index ? -1 : 1;
      }

      return result;
    };

    each$7(series, function (s) {
      var noSharedTooltip = s.noSharedTooltip && shared,
          compareX = !noSharedTooltip && s.options.findNearestPointBy.indexOf('y') < 0,
          point = s.searchPoint(coordinates, compareX);

      if ( // Check that we actually found a point on the series.
      isObject$2(point, true) && ( // Use the new point if it is closer.
      !isObject$2(closest, true) || sort(closest, point) > 0)) {
        closest = point;
      }
    });
    return closest;
  },

  /**
   * @private
   * @function Highcharts.Pointer#getPointFromEvent
   *
   * @param {global.Event} e
   *
   * @return {Highcharts.Point|undefined}
   */
  getPointFromEvent: function (e) {
    var target = e.target,
        point;

    while (target && !point) {
      point = target.point;
      target = target.parentNode;
    }

    return point;
  },

  /**
   * @private
   * @function Highcharts.Pointer#getChartCoordinatesFromPoint
   *
   * @param {Highcharts.Point} point
   *
   * @param {boolean} inverted
   *
   * @return {Highcharts.PointerCoordinatesObject}
   */
  getChartCoordinatesFromPoint: function (point, inverted) {
    var series = point.series,
        xAxis = series.xAxis,
        yAxis = series.yAxis,
        plotX = pick$8(point.clientX, point.plotX),
        shapeArgs = point.shapeArgs;

    if (xAxis && yAxis) {
      return inverted ? {
        chartX: xAxis.len + xAxis.pos - plotX,
        chartY: yAxis.len + yAxis.pos - point.plotY
      } : {
        chartX: plotX + xAxis.pos,
        chartY: point.plotY + yAxis.pos
      };
    } else if (shapeArgs && shapeArgs.x && shapeArgs.y) {
      // E.g. pies do not have axes
      return {
        chartX: shapeArgs.x,
        chartY: shapeArgs.y
      };
    }
  },

  /**
   * Calculates what is the current hovered point/points and series.
   *
   * @private
   * @function Highcharts.Pointer#getHoverData
   *
   * @param {Highcharts.Point|undefined} existingHoverPoint
   *        The point currrently beeing hovered.
   *
   * @param {Highcharts.Series|undefined} existingHoverSeries
   *        The series currently beeing hovered.
   *
   * @param {Array<Highcharts.Series>} series
   *        All the series in the chart.
   *
   * @param {boolean} isDirectTouch
   *        Is the pointer directly hovering the point.
   *
   * @param {boolean} shared
   *        Whether it is a shared tooltip or not.
   *
   * @param {Highcharts.PointerCoordinatesObject} coordinates
   *        Chart coordinates of the pointer.
   *
   * @return {*}
   *         Object containing resulting hover data: hoverPoint, hoverSeries,
   *         and hoverPoints.
   */
  getHoverData: function (existingHoverPoint, existingHoverSeries, series, isDirectTouch, shared, coordinates, params) {
    var hoverPoint,
        hoverPoints = [],
        hoverSeries = existingHoverSeries,
        isBoosting = params && params.isBoosting,
        useExisting = !!(isDirectTouch && existingHoverPoint),
        notSticky = hoverSeries && !hoverSeries.stickyTracking,
        filter = function (s) {
      return s.visible && !(!shared && s.directTouch) && // #3821
      pick$8(s.options.enableMouseTracking, true);
    },
        // Which series to look in for the hover point
    searchSeries = notSticky ? // Only search on hovered series if it has stickyTracking false
    [hoverSeries] : // Filter what series to look in.
    H$1.grep(series, function (s) {
      return filter(s) && s.stickyTracking;
    }); // Use existing hovered point or find the one closest to coordinates.


    hoverPoint = useExisting ? existingHoverPoint : this.findNearestKDPoint(searchSeries, shared, coordinates); // Assign hover series

    hoverSeries = hoverPoint && hoverPoint.series; // If we have a hoverPoint, assign hoverPoints.

    if (hoverPoint) {
      // When tooltip is shared, it displays more than one point
      if (shared && !hoverSeries.noSharedTooltip) {
        searchSeries = H$1.grep(series, function (s) {
          return filter(s) && !s.noSharedTooltip;
        }); // Get all points with the same x value as the hoverPoint

        each$7(searchSeries, function (s) {
          var point = find(s.points, function (p) {
            return p.x === hoverPoint.x && !p.isNull;
          });

          if (isObject$2(point)) {
            /*
            * Boost returns a minimal point. Convert it to a usable
            * point for tooltip and states.
            */
            if (isBoosting) {
              point = s.getPoint(point);
            }

            hoverPoints.push(point);
          }
        });
      } else {
        hoverPoints.push(hoverPoint);
      }
    }

    return {
      hoverPoint: hoverPoint,
      hoverSeries: hoverSeries,
      hoverPoints: hoverPoints
    };
  },

  /**
   * With line type charts with a single tracker, get the point closest to the
   * mouse. Run Point.onMouseOver and display tooltip for the point or points.
   *
   * @private
   * @function Highcharts.Pointer#runPointActions
   *
   * @param {global.Event} e
   *
   * @param {Highcharts.Point} p
   *
   * @fires Highcharts.Point#event:mouseOut
   * @fires Highcharts.Point#event:mouseOver
   */
  runPointActions: function (e, p) {
    var pointer = this,
        chart = pointer.chart,
        series = chart.series,
        tooltip = chart.tooltip && chart.tooltip.options.enabled ? chart.tooltip : undefined,
        shared = tooltip ? tooltip.shared : false,
        hoverPoint = p || chart.hoverPoint,
        hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries,
        // onMouseOver or already hovering a series with directTouch
    isDirectTouch = e.type !== 'touchmove' && (!!p || hoverSeries && hoverSeries.directTouch && pointer.isDirectTouch),
        hoverData = this.getHoverData(hoverPoint, hoverSeries, series, isDirectTouch, shared, e, {
      isBoosting: chart.isBoosting
    }),
        useSharedTooltip,
        followPointer,
        anchor,
        points; // Update variables from hoverData.

    hoverPoint = hoverData.hoverPoint;
    points = hoverData.hoverPoints;
    hoverSeries = hoverData.hoverSeries;
    followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
    useSharedTooltip = shared && hoverSeries && !hoverSeries.noSharedTooltip; // Refresh tooltip for kdpoint if new hover point or tooltip was hidden
    // #3926, #4200

    if (hoverPoint && ( // !(hoverSeries && hoverSeries.directTouch) &&
    hoverPoint !== chart.hoverPoint || tooltip && tooltip.isHidden)) {
      each$7(chart.hoverPoints || [], function (p) {
        if (H$1.inArray(p, points) === -1) {
          p.setState();
        }
      }); // Do mouseover on all points (#3919, #3985, #4410, #5622)

      each$7(points || [], function (p) {
        p.setState('hover');
      }); // set normal state to previous series

      if (chart.hoverSeries !== hoverSeries) {
        hoverSeries.onMouseOver();
      } // If tracking is on series in stead of on each point,
      // fire mouseOver on hover point. // #4448


      if (chart.hoverPoint) {
        chart.hoverPoint.firePointEvent('mouseOut');
      } // Hover point may have been destroyed in the event handlers (#7127)


      if (!hoverPoint.series) {
        return;
      }

      hoverPoint.firePointEvent('mouseOver');
      chart.hoverPoints = points;
      chart.hoverPoint = hoverPoint; // Draw tooltip if necessary

      if (tooltip) {
        tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);
      } // Update positions (regardless of kdpoint or hoverPoint)

    } else if (followPointer && tooltip && !tooltip.isHidden) {
      anchor = tooltip.getAnchor([{}], e);
      tooltip.updatePosition({
        plotX: anchor[0],
        plotY: anchor[1]
      });
    } // Start the event listener to pick up the tooltip and crosshairs


    if (!pointer.unDocMouseMove) {
      pointer.unDocMouseMove = addEvent$2(chart.container.ownerDocument, 'mousemove', function (e) {
        var chart = charts$2[H$1.hoverChartIndex];

        if (chart) {
          chart.pointer.onDocumentMouseMove(e);
        }
      });
    } // Issues related to crosshair #4927, #5269 #5066, #5658


    each$7(chart.axes, function drawAxisCrosshair(axis) {
      var snap = pick$8(axis.crosshair.snap, true),
          point = !snap ? undefined : H$1.find(points, function (p) {
        return p.series[axis.coll] === axis;
      }); // Axis has snapping crosshairs, and one of the hover points belongs
      // to axis. Always call drawCrosshair when it is not snap.

      if (point || !snap) {
        axis.drawCrosshair(e, point); // Axis has snapping crosshairs, but no hover point belongs to axis
      } else {
        axis.hideCrosshair();
      }
    });
  },

  /**
   * Reset the tracking by hiding the tooltip, the hover series state and the
   * hover point
   *
   * @function Highcharts.Pointer#reset
   *
   * @param {boolean} allowMove
   *        Instead of destroying the tooltip altogether, allow moving it if
   *        possible.
   *
   * @param {number} delay
   */
  reset: function (allowMove, delay) {
    var pointer = this,
        chart = pointer.chart,
        hoverSeries = chart.hoverSeries,
        hoverPoint = chart.hoverPoint,
        hoverPoints = chart.hoverPoints,
        tooltip = chart.tooltip,
        tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint; // Check if the points have moved outside the plot area (#1003, #4736,
    // #5101)

    if (allowMove && tooltipPoints) {
      each$7(splat$3(tooltipPoints), function (point) {
        if (point.series.isCartesian && point.plotX === undefined) {
          allowMove = false;
        }
      });
    } // Just move the tooltip, #349


    if (allowMove) {
      if (tooltip && tooltipPoints) {
        tooltip.refresh(tooltipPoints);

        if (tooltip.shared && hoverPoints) {
          // #8284
          each$7(hoverPoints, function (point) {
            point.setState(point.state, true);

            if (point.series.xAxis.crosshair) {
              point.series.xAxis.drawCrosshair(null, point);
            }

            if (point.series.yAxis.crosshair) {
              point.series.yAxis.drawCrosshair(null, point);
            }
          });
        } else if (hoverPoint) {
          // #2500
          hoverPoint.setState(hoverPoint.state, true);
          each$7(chart.axes, function (axis) {
            if (axis.crosshair) {
              axis.drawCrosshair(null, hoverPoint);
            }
          });
        }
      } // Full reset

    } else {
      if (hoverPoint) {
        hoverPoint.onMouseOut();
      }

      if (hoverPoints) {
        each$7(hoverPoints, function (point) {
          point.setState();
        });
      }

      if (hoverSeries) {
        hoverSeries.onMouseOut();
      }

      if (tooltip) {
        tooltip.hide(delay);
      }

      if (pointer.unDocMouseMove) {
        pointer.unDocMouseMove = pointer.unDocMouseMove();
      } // Remove crosshairs


      each$7(chart.axes, function (axis) {
        axis.hideCrosshair();
      });
      pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;
    }
  },

  /**
   * Scale series groups to a certain scale and translation.
   *
   * @private
   * @function Highcharts.Pointer#scaleGroups
   *
   * @param {Highcharts.SeriesPlotBoxObject} attribs
   *
   * @param {boolean} clip
   */
  scaleGroups: function (attribs, clip) {
    var chart = this.chart,
        seriesAttribs; // Scale each series

    each$7(chart.series, function (series) {
      seriesAttribs = attribs || series.getPlotBox(); // #1701

      if (series.xAxis && series.xAxis.zoomEnabled && series.group) {
        series.group.attr(seriesAttribs);

        if (series.markerGroup) {
          series.markerGroup.attr(seriesAttribs);
          series.markerGroup.clip(clip ? chart.clipRect : null);
        }

        if (series.dataLabelsGroup) {
          series.dataLabelsGroup.attr(seriesAttribs);
        }
      }
    }); // Clip

    chart.clipRect.attr(clip || chart.clipBox);
  },

  /**
   * Start a drag operation.
   *
   * @private
   * @function Highcharts.Pointer#dragStart
   *
   * @param {Highcharts.PointerEventObject} e
   */
  dragStart: function (e) {
    var chart = this.chart; // Record the start position

    chart.mouseIsDown = e.type;
    chart.cancelClick = false;
    chart.mouseDownX = this.mouseDownX = e.chartX;
    chart.mouseDownY = this.mouseDownY = e.chartY;
  },

  /**
   * Perform a drag operation in response to a mousemove event while the mouse
   * is down.
   *
   * @private
   * @function Highcharts.Pointer#drag
   *
   * @param {Highcharts.PointerEventObject} e
   */
  drag: function (e) {
    var chart = this.chart,
        chartOptions = chart.options.chart,
        chartX = e.chartX,
        chartY = e.chartY,
        zoomHor = this.zoomHor,
        zoomVert = this.zoomVert,
        plotLeft = chart.plotLeft,
        plotTop = chart.plotTop,
        plotWidth = chart.plotWidth,
        plotHeight = chart.plotHeight,
        clickedInside,
        size,
        selectionMarker = this.selectionMarker,
        mouseDownX = this.mouseDownX,
        mouseDownY = this.mouseDownY,
        panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key']; // If the device supports both touch and mouse (like IE11), and we are
    // touch-dragging inside the plot area, don't handle the mouse event.
    // #4339.

    if (selectionMarker && selectionMarker.touch) {
      return;
    } // If the mouse is outside the plot area, adjust to cooordinates
    // inside to prevent the selection marker from going outside


    if (chartX < plotLeft) {
      chartX = plotLeft;
    } else if (chartX > plotLeft + plotWidth) {
      chartX = plotLeft + plotWidth;
    }

    if (chartY < plotTop) {
      chartY = plotTop;
    } else if (chartY > plotTop + plotHeight) {
      chartY = plotTop + plotHeight;
    } // determine if the mouse has moved more than 10px


    this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) + Math.pow(mouseDownY - chartY, 2));

    if (this.hasDragged > 10) {
      clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop); // make a selection

      if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
        if (!selectionMarker) {
          this.selectionMarker = selectionMarker = chart.renderer.rect(plotLeft, plotTop, zoomHor ? 1 : plotWidth, zoomVert ? 1 : plotHeight, 0).attr({
            'class': 'highcharts-selection-marker',
            'zIndex': 7
          }).add();
        }
      } // adjust the width of the selection marker


      if (selectionMarker && zoomHor) {
        size = chartX - mouseDownX;
        selectionMarker.attr({
          width: Math.abs(size),
          x: (size > 0 ? 0 : size) + mouseDownX
        });
      } // adjust the height of the selection marker


      if (selectionMarker && zoomVert) {
        size = chartY - mouseDownY;
        selectionMarker.attr({
          height: Math.abs(size),
          y: (size > 0 ? 0 : size) + mouseDownY
        });
      } // panning


      if (clickedInside && !selectionMarker && chartOptions.panning) {
        chart.pan(e, chartOptions.panning);
      }
    }
  },

  /**
   * On mouse up or touch end across the entire document, drop the selection.
   *
   * @private
   * @function Highcharts.Pointer#drop
   *
   * @param {global.Event} e
   */
  drop: function (e) {
    var pointer = this,
        chart = this.chart,
        hasPinched = this.hasPinched;

    if (this.selectionMarker) {
      var selectionData = {
        originalEvent: e,
        // #4890
        xAxis: [],
        yAxis: []
      },
          selectionBox = this.selectionMarker,
          selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
          selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
          selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
          selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
          runZoom; // a selection has been made

      if (this.hasDragged || hasPinched) {
        // record each axis' min and max
        each$7(chart.axes, function (axis) {
          if (axis.zoomEnabled && defined$6(axis.min) && (hasPinched || pointer[{
            xAxis: 'zoomX',
            yAxis: 'zoomY'
          }[axis.coll]])) {
            // #859, #3569
            var horiz = axis.horiz,
                minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0,
                // #1207, #3075
            selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
                selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);
            selectionData[axis.coll].push({
              axis: axis,
              // Min/max for reversed axes
              min: Math.min(selectionMin, selectionMax),
              max: Math.max(selectionMin, selectionMax)
            });
            runZoom = true;
          }
        });

        if (runZoom) {
          fireEvent$2(chart, 'selection', selectionData, function (args) {
            chart.zoom(extend$5(args, hasPinched ? {
              animation: false
            } : null));
          });
        }
      }

      if (isNumber$4(chart.index)) {
        this.selectionMarker = this.selectionMarker.destroy();
      } // Reset scaling preview


      if (hasPinched) {
        this.scaleGroups();
      }
    } // Reset all. Check isNumber because it may be destroyed on mouse up
    // (#877)


    if (chart && isNumber$4(chart.index)) {
      css$2(chart.container, {
        cursor: chart._cursor
      });
      chart.cancelClick = this.hasDragged > 10; // #370

      chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
      this.pinchDown = [];
    }
  },

  /**
   * @private
   * @function Highcharts.Pointer#onContainerMouseDown
   *
   * @param {global.Event} e
   */
  onContainerMouseDown: function (e) {
    // Normalize before the 'if' for the legacy IE (#7850)
    e = this.normalize(e);

    if (e.button !== 2) {
      this.zoomOption(e); // issue #295, dragging not always working in Firefox

      if (e.preventDefault) {
        e.preventDefault();
      }

      this.dragStart(e);
    }
  },

  /**
   * @private
   * @function Highcharts.Pointer#onDocumentMouseUp
   *
   * @param {global.Event} e
   */
  onDocumentMouseUp: function (e) {
    if (charts$2[H$1.hoverChartIndex]) {
      charts$2[H$1.hoverChartIndex].pointer.drop(e);
    }
  },

  /**
   * Special handler for mouse move that will hide the tooltip when the mouse
   * leaves the plotarea. Issue #149 workaround. The mouseleave event does not
   * always fire.
   *
   * @private
   * @function Highcharts.Pointer#onDocumentMouseMove
   *
   * @param {Highcharts.PointerEventObject} e
   */
  onDocumentMouseMove: function (e) {
    var chart = this.chart,
        chartPosition = this.chartPosition;
    e = this.normalize(e, chartPosition); // If we're outside, hide the tooltip

    if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') && !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
      this.reset();
    }
  },

  /**
   * When mouse leaves the container, hide the tooltip.
   *
   * @private
   * @function Highcharts.Pointer#onContainerMouseLeave
   *
   * @param {global.Event} e
   */
  onContainerMouseLeave: function (e) {
    var chart = charts$2[H$1.hoverChartIndex]; // #4886, MS Touch end fires mouseleave but with no related target

    if (chart && (e.relatedTarget || e.toElement)) {
      chart.pointer.reset(); // Also reset the chart position, used in #149 fix

      chart.pointer.chartPosition = null;
    }
  },

  /**
   * The mousemove, touchmove and touchstart event handler
   *
   * @private
   * @function Highcharts.Pointer#onContainerMouseMove
   *
   * @param {Highcharts.PointerEventObject} e
   */
  onContainerMouseMove: function (e) {
    var chart = this.chart;

    if (!defined$6(H$1.hoverChartIndex) || !charts$2[H$1.hoverChartIndex] || !charts$2[H$1.hoverChartIndex].mouseIsDown) {
      H$1.hoverChartIndex = chart.index;
    }

    e = this.normalize(e);
    e.returnValue = false; // #2251, #3224

    if (chart.mouseIsDown === 'mousedown') {
      this.drag(e);
    } // Show the tooltip and run mouse over events (#977)


    if ((this.inClass(e.target, 'highcharts-tracker') || chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
      this.runPointActions(e);
    }
  },

  /**
   * Utility to detect whether an element has, or has a parent with, a
   * specificclass name. Used on detection of tracker objects and on deciding
   * whether hovering the tooltip should cause the active series to mouse out.
   *
   * @function Highcharts.Pointer#inClass
   *
   * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element
   *        The element to investigate.
   *
   * @param {string} className
   *        The class name to look for.
   *
   * @return {boolean}
   *         True if either the element or one of its parents has the given
   *         class name.
   */
  inClass: function (element, className) {
    var elemClassName;

    while (element) {
      elemClassName = attr$2(element, 'class');

      if (elemClassName) {
        if (elemClassName.indexOf(className) !== -1) {
          return true;
        }

        if (elemClassName.indexOf('highcharts-container') !== -1) {
          return false;
        }
      }

      element = element.parentNode;
    }
  },

  /**
   * @private
   * @function Highcharts.Pointer#onTrackerMouseOut
   *
   * @param {global.Event} e
   */
  onTrackerMouseOut: function (e) {
    var series = this.chart.hoverSeries,
        relatedTarget = e.relatedTarget || e.toElement;
    this.isDirectTouch = false;

    if (series && relatedTarget && !series.stickyTracking && !this.inClass(relatedTarget, 'highcharts-tooltip') && (!this.inClass(relatedTarget, 'highcharts-series-' + series.index) || // #2499, #4465
    !this.inClass(relatedTarget, 'highcharts-tracker') // #5553
    )) {
      series.onMouseOut();
    }
  },

  /**
   * @private
   * @function Highcharts.Pointer#onContainerClick
   *
   * @param {Highcharts.PointerEventObject} e
   */
  onContainerClick: function (e) {
    var chart = this.chart,
        hoverPoint = chart.hoverPoint,
        plotLeft = chart.plotLeft,
        plotTop = chart.plotTop;
    e = this.normalize(e);

    if (!chart.cancelClick) {
      // On tracker click, fire the series and point events. #783, #1583
      if (hoverPoint && this.inClass(e.target, 'highcharts-tracker')) {
        // the series click event
        fireEvent$2(hoverPoint.series, 'click', extend$5(e, {
          point: hoverPoint
        })); // the point click event

        if (chart.hoverPoint) {
          // it may be destroyed (#1844)
          hoverPoint.firePointEvent('click', e);
        } // When clicking outside a tracker, fire a chart event

      } else {
        extend$5(e, this.getCoordinates(e)); // fire a click event in the chart

        if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
          fireEvent$2(chart, 'click', e);
        }
      }
    }
  },

  /**
   * Set the JS DOM events on the container and document. This method should
   * contain a one-to-one assignment between methods and their handlers. Any
   * advanced logic should be moved to the handler reflecting the event's
   * name.
   *
   * @private
   * @function Highcharts.Pointer#setDOMEvents
   */
  setDOMEvents: function () {
    var pointer = this,
        container = pointer.chart.container,
        ownerDoc = container.ownerDocument;

    container.onmousedown = function (e) {
      pointer.onContainerMouseDown(e);
    };

    container.onmousemove = function (e) {
      pointer.onContainerMouseMove(e);
    };

    container.onclick = function (e) {
      pointer.onContainerClick(e);
    };

    this.unbindContainerMouseLeave = addEvent$2(container, 'mouseleave', pointer.onContainerMouseLeave);

    if (!H$1.unbindDocumentMouseUp) {
      H$1.unbindDocumentMouseUp = addEvent$2(ownerDoc, 'mouseup', pointer.onDocumentMouseUp);
    }

    if (H$1.hasTouch) {
      container.ontouchstart = function (e) {
        pointer.onContainerTouchStart(e);
      };

      container.ontouchmove = function (e) {
        pointer.onContainerTouchMove(e);
      };

      if (!H$1.unbindDocumentTouchEnd) {
        H$1.unbindDocumentTouchEnd = addEvent$2(ownerDoc, 'touchend', pointer.onDocumentTouchEnd);
      }
    }
  },

  /**
   * Destroys the Pointer object and disconnects DOM events.
   *
   * @function Highcharts.Pointer#destroy
   */
  destroy: function () {
    var pointer = this;

    if (pointer.unDocMouseMove) {
      pointer.unDocMouseMove();
    }

    this.unbindContainerMouseLeave();

    if (!H$1.chartCount) {
      if (H$1.unbindDocumentMouseUp) {
        H$1.unbindDocumentMouseUp = H$1.unbindDocumentMouseUp();
      }

      if (H$1.unbindDocumentTouchEnd) {
        H$1.unbindDocumentTouchEnd = H$1.unbindDocumentTouchEnd();
      }
    } // memory and CPU leak


    clearInterval(pointer.tooltipTimeout);
    H$1.objectEach(pointer, function (val, prop) {
      pointer[prop] = null;
    });
  }
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var charts$3 = Highcharts.charts,
    each$8 = Highcharts.each,
    extend$6 = Highcharts.extend,
    map$3 = Highcharts.map,
    noop$1 = Highcharts.noop,
    pick$9 = Highcharts.pick,
    Pointer = Highcharts.Pointer; // Support for touch devices

extend$6(Pointer.prototype,
/** @lends Pointer.prototype */
{
  /**
   * Run translation operations
   *
   * @private
   * @function Highcharts.Pointer#pinchTranslate
   *
   * @param {Array<*>} pinchDown
   *
   * @param {Array<*>} touches
   *
   * @param {*} transform
   *
   * @param {*} selectionMarker
   *
   * @param {*} clip
   *
   * @param {*} lastValidTouch
   */
  pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
    if (this.zoomHor) {
      this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
    }

    if (this.zoomVert) {
      this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
    }
  },

  /**
   * Run translation operations for each direction (horizontal and vertical)
   * independently.
   *
   * @private
   * @function Highcharts.Pointer#pinchTranslateDirection
   *
   * @param {boolean} horiz
   *
   * @param {Array<*>} pinchDown
   *
   * @param {Array<*>} touches
   *
   * @param {*} transform
   *
   * @param {*} selectionMarker
   *
   * @param {*} clip
   *
   * @param {*} lastValidTouch
   *
   * @param {number|undefined} [forcedScale=1]
   */
  pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
    var chart = this.chart,
        xy = horiz ? 'x' : 'y',
        XY = horiz ? 'X' : 'Y',
        sChartXY = 'chart' + XY,
        wh = horiz ? 'width' : 'height',
        plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
        selectionWH,
        selectionXY,
        clipXY,
        scale = forcedScale || 1,
        inverted = chart.inverted,
        bounds = chart.bounds[horiz ? 'h' : 'v'],
        singleTouch = pinchDown.length === 1,
        touch0Start = pinchDown[0][sChartXY],
        touch0Now = touches[0][sChartXY],
        touch1Start = !singleTouch && pinchDown[1][sChartXY],
        touch1Now = !singleTouch && touches[1][sChartXY],
        outOfBounds,
        transformScale,
        scaleKey,
        setScale = function () {
      // Don't zoom if fingers are too close on this axis
      if (!singleTouch && Math.abs(touch0Start - touch1Start) > 20) {
        scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start);
      }

      clipXY = (plotLeftTop - touch0Now) / scale + touch0Start;
      selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
    }; // Set the scale, first pass


    setScale(); // The clip position (x or y) is altered if out of bounds, the selection
    // position is not

    selectionXY = clipXY; // Out of bounds

    if (selectionXY < bounds.min) {
      selectionXY = bounds.min;
      outOfBounds = true;
    } else if (selectionXY + selectionWH > bounds.max) {
      selectionXY = bounds.max - selectionWH;
      outOfBounds = true;
    } // Is the chart dragged off its bounds, determined by dataMin and
    // dataMax?


    if (outOfBounds) {
      // Modify the touchNow position in order to create an elastic drag
      // movement. This indicates to the user that the chart is responsive
      // but can't be dragged further.
      touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);

      if (!singleTouch) {
        touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
      } // Set the scale, second pass to adapt to the modified touchNow
      // positions


      setScale();
    } else {
      lastValidTouch[xy] = [touch0Now, touch1Now];
    } // Set geometry for clipping, selection and transformation


    if (!inverted) {
      clip[xy] = clipXY - plotLeftTop;
      clip[wh] = selectionWH;
    }

    scaleKey = inverted ? horiz ? 'scaleY' : 'scaleX' : 'scale' + XY;
    transformScale = inverted ? 1 / scale : scale;
    selectionMarker[wh] = selectionWH;
    selectionMarker[xy] = selectionXY;
    transform[scaleKey] = scale;
    transform['translate' + XY] = transformScale * plotLeftTop + (touch0Now - transformScale * touch0Start);
  },

  /**
   * Handle touch events with two touches
   *
   * @private
   * @function Highcharts.Pointer#pinch
   *
   * @param {Highcharts.PointerEvent} e
   */
  pinch: function (e) {
    var self = this,
        chart = self.chart,
        pinchDown = self.pinchDown,
        touches = e.touches,
        touchesLength = touches.length,
        lastValidTouch = self.lastValidTouch,
        hasZoom = self.hasZoom,
        selectionMarker = self.selectionMarker,
        transform = {},
        fireClickEvent = touchesLength === 1 && (self.inClass(e.target, 'highcharts-tracker') && chart.runTrackerClick || self.runChartClick),
        clip = {}; // Don't initiate panning until the user has pinched. This prevents us
    // from blocking page scrolling as users scroll down a long page
    // (#4210).

    if (touchesLength > 1) {
      self.initiated = true;
    } // On touch devices, only proceed to trigger click if a handler is
    // defined


    if (hasZoom && self.initiated && !fireClickEvent) {
      e.preventDefault();
    } // Normalize each touch


    map$3(touches, function (e) {
      return self.normalize(e);
    }); // Register the touch start position

    if (e.type === 'touchstart') {
      each$8(touches, function (e, i) {
        pinchDown[i] = {
          chartX: e.chartX,
          chartY: e.chartY
        };
      });
      lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
      lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY]; // Identify the data bounds in pixels

      each$8(chart.axes, function (axis) {
        if (axis.zoomEnabled) {
          var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
              minPixelPadding = axis.minPixelPadding,
              min = axis.toPixels(pick$9(axis.options.min, axis.dataMin)),
              max = axis.toPixels(pick$9(axis.options.max, axis.dataMax)),
              absMin = Math.min(min, max),
              absMax = Math.max(min, max); // Store the bounds for use in the touchmove handler

          bounds.min = Math.min(axis.pos, absMin - minPixelPadding);
          bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);
        }
      });
      self.res = true; // reset on next move
      // Optionally move the tooltip on touchmove
    } else if (self.followTouchMove && touchesLength === 1) {
      this.runPointActions(self.normalize(e)); // Event type is touchmove, handle panning and pinching
    } else if (pinchDown.length) {
      // can be 0 when releasing, if touchend
      // fires first
      // Set the marker
      if (!selectionMarker) {
        self.selectionMarker = selectionMarker = extend$6({
          destroy: noop$1,
          touch: true
        }, chart.plotBox);
      }

      self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
      self.hasPinched = hasZoom; // Scale and translate the groups to provide visual feedback during
      // pinching

      self.scaleGroups(transform, clip);

      if (self.res) {
        self.res = false;
        this.reset(false, 0);
      }
    }
  },

  /**
   * General touch handler shared by touchstart and touchmove.
   *
   * @private
   * @function Highcharts.Pointer#touch
   *
   * @param {Highcharts.PointerEvent} e
   *
   * @param {boolean} start
   */
  touch: function (e, start) {
    var chart = this.chart,
        hasMoved,
        pinchDown,
        isInside;

    if (chart.index !== Highcharts.hoverChartIndex) {
      this.onContainerMouseLeave({
        relatedTarget: true
      });
    }

    Highcharts.hoverChartIndex = chart.index;

    if (e.touches.length === 1) {
      e = this.normalize(e);
      isInside = chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop);

      if (isInside && !chart.openMenu) {
        // Run mouse events and display tooltip etc
        if (start) {
          this.runPointActions(e);
        } // Android fires touchmove events after the touchstart even if
        // the finger hasn't moved, or moved only a pixel or two. In iOS
        // however, the touchmove doesn't fire unless the finger moves
        // more than ~4px. So we emulate this behaviour in Android by
        // checking how much it moved, and cancelling on small
        // distances. #3450.


        if (e.type === 'touchmove') {
          pinchDown = this.pinchDown;
          hasMoved = pinchDown[0] ? Math.sqrt( // #5266
          Math.pow(pinchDown[0].chartX - e.chartX, 2) + Math.pow(pinchDown[0].chartY - e.chartY, 2)) >= 4 : false;
        }

        if (pick$9(hasMoved, true)) {
          this.pinch(e);
        }
      } else if (start) {
        // Hide the tooltip on touching outside the plot area (#1203)
        this.reset();
      }
    } else if (e.touches.length === 2) {
      this.pinch(e);
    }
  },

  /**
   * @private
   * @function Highcharts.Pointer#onContainerTouchStart
   *
   * @param {Highcharts.PointerEvent} e
   */
  onContainerTouchStart: function (e) {
    this.zoomOption(e);
    this.touch(e, true);
  },

  /**
   * @private
   * @function Highcharts.Pointer#onContainerTouchMove
   *
   * @param {Highcharts.PointerEvent} e
   */
  onContainerTouchMove: function (e) {
    this.touch(e);
  },

  /**
   * @private
   * @function Highcharts.Pointer#onDocumentTouchEnd
   *
   * @param {Highcharts.PointerEvent} e
   */
  onDocumentTouchEnd: function (e) {
    if (charts$3[Highcharts.hoverChartIndex]) {
      charts$3[Highcharts.hoverChartIndex].pointer.drop(e);
    }
  }
});

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$3 = Highcharts.addEvent,
    charts$4 = Highcharts.charts,
    css$3 = Highcharts.css,
    doc$4 = Highcharts.doc,
    extend$7 = Highcharts.extend,
    hasTouch$1 = Highcharts.hasTouch,
    noop$2 = Highcharts.noop,
    Pointer$1 = Highcharts.Pointer,
    removeEvent$2 = Highcharts.removeEvent,
    win$5 = Highcharts.win,
    wrap$3 = Highcharts.wrap;

if (!hasTouch$1 && (win$5.PointerEvent || win$5.MSPointerEvent)) {
  // The touches object keeps track of the points being touched at all times
  var touches = {},
      hasPointerEvent = !!win$5.PointerEvent,
      getWebkitTouches = function () {
    var fake = [];

    fake.item = function (i) {
      return this[i];
    };

    Highcharts.objectEach(touches, function (touch) {
      fake.push({
        pageX: touch.pageX,
        pageY: touch.pageY,
        target: touch.target
      });
    });
    return fake;
  },
      translateMSPointer = function (e, method, wktype, func) {
    var p;

    if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts$4[Highcharts.hoverChartIndex]) {
      func(e);
      p = charts$4[Highcharts.hoverChartIndex].pointer;
      p[method]({
        type: wktype,
        target: e.currentTarget,
        preventDefault: noop$2,
        touches: getWebkitTouches()
      });
    }
  }; // Extend the Pointer prototype with methods for each event handler and more


  extend$7(Pointer$1.prototype,
  /** @lends Pointer.prototype */
  {
    /**
     * @private
     * @function Highcharts.Pointer#onContainerPointerDown
     *
     * @param {Highcharts.PointerEventObject} e
     */
    onContainerPointerDown: function (e) {
      translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {
        touches[e.pointerId] = {
          pageX: e.pageX,
          pageY: e.pageY,
          target: e.currentTarget
        };
      });
    },

    /**
     * @private
     * @function Highcharts.Pointer#onContainerPointerMove
     *
     * @param {Highcharts.PointerEventObject} e
     */
    onContainerPointerMove: function (e) {
      translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {
        touches[e.pointerId] = {
          pageX: e.pageX,
          pageY: e.pageY
        };

        if (!touches[e.pointerId].target) {
          touches[e.pointerId].target = e.currentTarget;
        }
      });
    },

    /**
     * @private
     * @function Highcharts.Pointer#onDocumentPointerUp
     *
     * @param {Highcharts.PointerEventObject} e
     */
    onDocumentPointerUp: function (e) {
      translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function (e) {
        delete touches[e.pointerId];
      });
    },

    /**
     * Add or remove the MS Pointer specific events
     *
     * @private
     * @function Highcharts.Pointer#batchMSEvents
     *
     * @param {Function} fn
     */
    batchMSEvents: function (fn) {
      fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
      fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
      fn(doc$4, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
    }
  }); // Disable default IE actions for pinch and such on chart element

  wrap$3(Pointer$1.prototype, 'init', function (proceed, chart, options) {
    proceed.call(this, chart, options);

    if (this.hasZoom) {
      // #4014
      css$3(chart.container, {
        '-ms-touch-action': 'none',
        'touch-action': 'none'
      });
    }
  }); // Add IE specific touch events to chart

  wrap$3(Pointer$1.prototype, 'setDOMEvents', function (proceed) {
    proceed.apply(this);

    if (this.hasZoom || this.followTouchMove) {
      this.batchMSEvents(addEvent$3);
    }
  }); // Destroy MS events also

  wrap$3(Pointer$1.prototype, 'destroy', function (proceed) {
    this.batchMSEvents(removeEvent$2);
    proceed.call(this);
  });
}

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var H$2 = Highcharts,
    addEvent$4 = H$2.addEvent,
    css$4 = H$2.css,
    discardElement = H$2.discardElement,
    defined$7 = H$2.defined,
    each$9 = H$2.each,
    fireEvent$3 = H$2.fireEvent,
    isFirefox$3 = H$2.isFirefox,
    marginNames = H$2.marginNames,
    merge$8 = H$2.merge,
    pick$a = H$2.pick,
    setAnimation = H$2.setAnimation,
    stableSort = H$2.stableSort,
    win$6 = H$2.win,
    wrap$4 = H$2.wrap;
/**
 * The overview of the chart's series. The legend object is instanciated
 * internally in the chart constructor, and is available from the `chart.legend`
 * property. Each chart has only one legend.
 *
 * @class
 * @name Highcharts.Legend
 *
 * @param {Highcharts.Chart} chart
 *        The chart instance.
 *
 * @param {Highcharts.LegendOptions} options
 *        Legend options.
 */

Highcharts.Legend = function (chart, options) {
  this.init(chart, options);
};

Highcharts.Legend.prototype = {
  /**
   * Initialize the legend.
   *
   * @private
   * @function Highcharts.Legend#init
   *
   * @param {Highcharts.Chart} chart
   *        The chart instance.
   *
   * @param {Highcharts.LegendOptions} options
   *        Legend options.
   */
  init: function (chart, options) {
    /**
     * Chart of this legend.
     *
     * @readonly
     * @name Highcharts.Legend#chart
     * @type {Highcharts.Chart}
     */
    this.chart = chart;
    this.setOptions(options);

    if (options.enabled) {
      // Render it
      this.render(); // move checkboxes

      addEvent$4(this.chart, 'endResize', function () {
        this.legend.positionCheckboxes();
      });

      if (this.proximate) {
        this.unchartrender = addEvent$4(this.chart, 'render', function () {
          this.legend.proximatePositions();
          this.legend.positionItems();
        });
      } else if (this.unchartrender) {
        this.unchartrender();
      }
    }
  },

  /**
   * @private
   * @function Highcharts.Legend#setOptions
   *
   * @param {Highcharts.LegendOptions} options
   */
  setOptions: function (options) {
    var padding = pick$a(options.padding, 8);
    /**
     * Legend options.
     *
     * @readonly
     * @name Highcharts.Legend#options
     * @type {Highcharts.LegendOptions}
     */

    this.options = options;
    this.itemMarginTop = options.itemMarginTop || 0;
    this.padding = padding;
    this.initialItemY = padding - 5; // 5 is pixels above the text

    this.symbolWidth = pick$a(options.symbolWidth, 16);
    this.pages = [];
    this.proximate = options.layout === 'proximate' && !this.chart.inverted;
  },

  /**
   * Update the legend with new options. Equivalent to running `chart.update`
   * with a legend configuration option.
   *
   * @sample highcharts/legend/legend-update/
   *         Legend update
   *
   * @function Highcharts.Legend#update
   *
   * @param {Highcharts.LegendOptions} options
   *        Legend options.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart.
   *
   * @todo
   * Make events official: Fires the event `afterUpdate`.
   */
  update: function (options, redraw) {
    var chart = this.chart;
    this.setOptions(merge$8(true, this.options, options));
    this.destroy();
    chart.isDirtyLegend = chart.isDirtyBox = true;

    if (pick$a(redraw, true)) {
      chart.redraw();
    }

    fireEvent$3(this, 'afterUpdate');
  },

  /**
   * Set the colors for the legend item.
   *
   * @private
   * @function Highcharts.Legend#colorizeItem
   *
   * @param {Highcharts.Point|Highcharts.Series} item
   *        A Series or Point instance
   *
   * @param {boolean} [visible=false]
   *        Dimmed or colored
   *
   * @todo
   * Make events official: Fires the event `afterColorizeItem`.
   */
  colorizeItem: function (item, visible) {
    item.legendGroup[visible ? 'removeClass' : 'addClass']('highcharts-legend-item-hidden');
    fireEvent$3(this, 'afterColorizeItem', {
      item: item,
      visible: visible
    });
  },

  /**
   * @private
   * @function Highcharts.Legend#positionItems
   */
  positionItems: function () {
    // Now that the legend width and height are established, put the items
    // in the final position
    each$9(this.allItems, this.positionItem, this);

    if (!this.chart.isResizing) {
      this.positionCheckboxes();
    }
  },

  /**
   * Position the legend item.
   *
   * @private
   * @function Highcharts.Legend#positionItem
   *
   * @param {Highcharts.Point|Highcharts.Series} item
   *        The item to position
   */
  positionItem: function (item) {
    var legend = this,
        options = legend.options,
        symbolPadding = options.symbolPadding,
        ltr = !options.rtl,
        legendItemPos = item._legendItemPos,
        itemX = legendItemPos[0],
        itemY = legendItemPos[1],
        checkbox = item.checkbox,
        legendGroup = item.legendGroup;

    if (legendGroup && legendGroup.element) {
      legendGroup[defined$7(legendGroup.translateY) ? 'animate' : 'attr']({
        translateX: ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
        translateY: itemY
      });
    }

    if (checkbox) {
      checkbox.x = itemX;
      checkbox.y = itemY;
    }
  },

  /**
   * Destroy a single legend item, used internally on removing series items.
   *
   * @private
   * @function Highcharts.Legend#destroyItem
   *
   * @param {Highcharts.Point|Highcharts.Series} item
   *        The item to remove
   */
  destroyItem: function (item) {
    var checkbox = item.checkbox; // destroy SVG elements

    each$9(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {
      if (item[key]) {
        item[key] = item[key].destroy();
      }
    });

    if (checkbox) {
      discardElement(item.checkbox);
    }
  },

  /**
   * Destroy the legend. Used internally. To reflow objects, `chart.redraw`
   * must be called after destruction.
   *
   * @private
   * @function Highcharts.Legend#destroy
   */
  destroy: function () {
    function destroyItems(key) {
      if (this[key]) {
        this[key] = this[key].destroy();
      }
    } // Destroy items


    each$9(this.getAllItems(), function (item) {
      each$9(['legendItem', 'legendGroup'], destroyItems, item);
    }); // Destroy legend elements

    each$9(['clipRect', 'up', 'down', 'pager', 'nav', 'box', 'title', 'group'], destroyItems, this);
    this.display = null; // Reset in .render on update.
  },

  /**
   * Position the checkboxes after the width is determined.
   *
   * @private
   * @function Highcharts.Legend#positionCheckboxes
   */
  positionCheckboxes: function () {
    var alignAttr = this.group && this.group.alignAttr,
        translateY,
        clipHeight = this.clipHeight || this.legendHeight,
        titleHeight = this.titleHeight;

    if (alignAttr) {
      translateY = alignAttr.translateY;
      each$9(this.allItems, function (item) {
        var checkbox = item.checkbox,
            top;

        if (checkbox) {
          top = translateY + titleHeight + checkbox.y + (this.scrollOffset || 0) + 3;
          css$4(checkbox, {
            left: alignAttr.translateX + item.checkboxOffset + checkbox.x - 20 + 'px',
            top: top + 'px',
            display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : 'none'
          });
        }
      }, this);
    }
  },

  /**
   * Render the legend title on top of the legend.
   *
   * @private
   * @function Highcharts.Legend#renderTitle
   */
  renderTitle: function () {
    var options = this.options,
        padding = this.padding,
        titleOptions = options.title,
        titleHeight = 0,
        bBox;

    if (titleOptions.text) {
      if (!this.title) {
        /**
         * SVG element of the legend title.
         *
         * @readonly
         * @name Highcharts.Legend#title
         * @type {Highcharts.SVGElement}
         */
        this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, options.useHTML, null, 'legend-title').attr({
          zIndex: 1
        }).add(this.group);
      }

      bBox = this.title.getBBox();
      titleHeight = bBox.height;
      this.offsetWidth = bBox.width; // #1717

      this.contentGroup.attr({
        translateY: titleHeight
      });
    }

    this.titleHeight = titleHeight;
  },

  /**
   * Set the legend item text.
   *
   * @function Highcharts.Legend#setText
   *
   * @param {Highcharts.Point|Highcharts.Series} item
   *        The item for which to update the text in the legend.
   */
  setText: function (item) {
    var options = this.options;
    item.legendItem.attr({
      text: options.labelFormat ? H$2.format(options.labelFormat, item, this.chart.time) : options.labelFormatter.call(item)
    });
  },

  /**
   * Render a single specific legend item. Called internally from the `render`
   * function.
   *
   * @private
   * @function Highcharts.Legend#renderItem
   *
   * @param {Highcharts.Point|Highcharts.Series} item
   *        The item to render.
   */
  renderItem: function (item) {
    var legend = this,
        chart = legend.chart,
        renderer = chart.renderer,
        options = legend.options,
        horizontal = options.layout === 'horizontal',
        symbolWidth = legend.symbolWidth,
        symbolPadding = options.symbolPadding,
        itemDistance = horizontal ? pick$a(options.itemDistance, 20) : 0,
        ltr = !options.rtl,
        bBox,
        li = item.legendItem,
        isSeries = !item.series,
        series = !isSeries && item.series.drawLegendSymbol ? item.series : item,
        seriesOptions = series.options,
        showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,
        // full width minus text width
    itemExtraWidth = symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0),
        useHTML = options.useHTML,
        fontSize = 12,
        itemClassName = item.options.className;

    if (!li) {
      // generate it once, later move it
      // Generate the group box, a group to hold the symbol and text. Text
      // is to be appended in Legend class.
      item.legendGroup = renderer.g('legend-item').addClass('highcharts-' + series.type + '-series ' + 'highcharts-color-' + item.colorIndex + (itemClassName ? ' ' + itemClassName : '') + (isSeries ? ' highcharts-series-' + item.index : '')).attr({
        zIndex: 1
      }).add(legend.scrollGroup); // Generate the list item text and add it to the group

      item.legendItem = li = renderer.text('', ltr ? symbolWidth + symbolPadding : -symbolPadding, legend.baseline || 0, useHTML).attr({
        align: ltr ? 'left' : 'right',
        zIndex: 2
      }).add(item.legendGroup); // Get the baseline for the first item - the font size is equal for
      // all

      if (!legend.baseline) {
        legend.fontMetrics = renderer.fontMetrics(fontSize, li);
        legend.baseline = legend.fontMetrics.f + 3 + legend.itemMarginTop;
        li.attr('y', legend.baseline);
      } // Draw the legend symbol inside the group box


      legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;
      series.drawLegendSymbol(legend, item);

      if (legend.setItemEvents) {
        legend.setItemEvents(item, li, useHTML);
      } // add the HTML checkbox on top


      if (showCheckbox) {
        legend.createCheckboxForItem(item);
      }
    } // Colorize the items


    legend.colorizeItem(item, item.visible); // Take care of max width and text overflow (#6659)

    li.css({
      width: (options.itemWidth || options.width || chart.spacingBox.width) - itemExtraWidth
    }); // Always update the text

    legend.setText(item); // calculate the positions for the next line

    bBox = li.getBBox();
    item.itemWidth = item.checkboxOffset = options.itemWidth || item.legendItemWidth || bBox.width + itemExtraWidth;
    legend.maxItemWidth = Math.max(legend.maxItemWidth, item.itemWidth);
    legend.totalItemWidth += item.itemWidth;
    legend.itemHeight = item.itemHeight = Math.round(item.legendItemHeight || bBox.height || legend.symbolHeight);
  },

  /**
   * Get the position of the item in the layout. We now know the
   * maxItemWidth from the previous loop.
   *
   * @private
   * @function Highcharts.Legend#layoutItem
   *
   * @param {Highcharts.Point|Highcharts.Series} item
   */
  layoutItem: function (item) {
    var options = this.options,
        padding = this.padding,
        horizontal = options.layout === 'horizontal',
        itemHeight = item.itemHeight,
        itemMarginBottom = options.itemMarginBottom || 0,
        itemMarginTop = this.itemMarginTop,
        itemDistance = horizontal ? pick$a(options.itemDistance, 20) : 0,
        widthOption = options.width,
        maxLegendWidth = widthOption || this.chart.spacingBox.width - 2 * padding - options.x,
        itemWidth = options.alignColumns && this.totalItemWidth > maxLegendWidth ? this.maxItemWidth : item.itemWidth; // If the item exceeds the width, start a new line

    if (horizontal && this.itemX - padding + itemWidth > maxLegendWidth) {
      this.itemX = padding;
      this.itemY += itemMarginTop + this.lastLineHeight + itemMarginBottom;
      this.lastLineHeight = 0; // reset for next line (#915, #3976)
    } // Set the edge positions


    this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;
    this.lastLineHeight = Math.max( // #915
    itemHeight, this.lastLineHeight); // cache the position of the newly generated or reordered items

    item._legendItemPos = [this.itemX, this.itemY]; // advance

    if (horizontal) {
      this.itemX += itemWidth;
    } else {
      this.itemY += itemMarginTop + itemHeight + itemMarginBottom;
      this.lastLineHeight = itemHeight;
    } // the width of the widest item


    this.offsetWidth = widthOption || Math.max((horizontal ? this.itemX - padding - (item.checkbox ? // decrease by itemDistance only when no checkbox #4853
    0 : itemDistance) : itemWidth) + padding, this.offsetWidth);
  },

  /**
   * Get all items, which is one item per series for most series and one
   * item per point for pie series and its derivatives.
   *
   * @private
   * @function Highcharts.Legend#getAllItems
   *
   * @return {Array<Highcharts.Point|Highcharts.Series>}
   *         The current items in the legend.
   *
   * @fires Highcharts.Legend#event:afterGetAllItems
   *
   * @todo
   * Make events official: Fires the event `afterGetAllItems`.
   */
  getAllItems: function () {
    var allItems = [];
    each$9(this.chart.series, function (series) {
      var seriesOptions = series && series.options; // Handle showInLegend. If the series is linked to another series,
      // defaults to false.

      if (series && pick$a(seriesOptions.showInLegend, !defined$7(seriesOptions.linkedTo) ? undefined : false, true)) {
        // Use points or series for the legend item depending on
        // legendType
        allItems = allItems.concat(series.legendItems || (seriesOptions.legendType === 'point' ? series.data : series));
      }
    });
    fireEvent$3(this, 'afterGetAllItems', {
      allItems: allItems
    });
    return allItems;
  },

  /**
   * Get a short, three letter string reflecting the alignment and layout.
   *
   * @private
   * @function Highcharts.Legend#getAlignment
   *
   * @return {string}
   *         The alignment, empty string if floating
   */
  getAlignment: function () {
    var options = this.options; // Use the first letter of each alignment option in order to detect
    // the side. (#4189 - use charAt(x) notation instead of [x] for IE7)

    if (this.proximate) {
      return options.align.charAt(0) + 'tv';
    }

    return options.floating ? '' : options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0);
  },

  /**
   * Adjust the chart margins by reserving space for the legend on only one
   * side of the chart. If the position is set to a corner, top or bottom is
   * reserved for horizontal legends and left or right for vertical ones.
   *
   * @private
   * @function Highcharts.Legend#adjustMargins
   *
   * @param {Array<number>} margin
   *
   * @param {number} spacing
   */
  adjustMargins: function (margin, spacing) {
    var chart = this.chart,
        options = this.options,
        alignment = this.getAlignment();

    if (alignment) {
      each$9([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function (alignments, side) {
        if (alignments.test(alignment) && !defined$7(margin[side])) {
          // Now we have detected on which side of the chart we should
          // reserve space for the legend
          chart[marginNames[side]] = Math.max(chart[marginNames[side]], chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + [1, -1, -1, 1][side] * options[side % 2 ? 'x' : 'y'] + pick$a(options.margin, 12) + spacing[side] + (side === 0 && chart.options.title.margin !== undefined ? chart.titleOffset + chart.options.title.margin : 0) // #7428, #7894
          );
        }
      });
    }
  },

  /**
   * @private
   * @function Highcharts.Legend#proximatePositions
   */
  proximatePositions: function () {
    var chart = this.chart,
        boxes = [],
        alignLeft = this.options.align === 'left';
    each$9(this.allItems, function (item) {
      var lastPoint,
          height,
          useFirstPoint = alignLeft;

      if (item.xAxis && item.points) {
        if (item.xAxis.options.reversed) {
          useFirstPoint = !useFirstPoint;
        }

        lastPoint = H$2.find(useFirstPoint ? item.points : item.points.slice(0).reverse(), function (item) {
          return H$2.isNumber(item.plotY);
        });
        height = item.legendGroup.getBBox().height;
        boxes.push({
          target: item.visible ? (lastPoint ? lastPoint.plotY : item.xAxis.height) - 0.3 * height : chart.plotHeight,
          size: height,
          item: item
        });
      }
    }, this);
    H$2.distribute(boxes, chart.plotHeight);
    each$9(boxes, function (box) {
      box.item._legendItemPos[1] = chart.plotTop - chart.spacing[0] + box.pos;
    });
  },

  /**
   * Render the legend. This method can be called both before and after
   * `chart.render`. If called after, it will only rearrange items instead
   * of creating new ones. Called internally on initial render and after
   * redraws.
   *
   * @private
   * @function Highcharts.Legend#render
   */
  render: function () {
    var legend = this,
        chart = legend.chart,
        renderer = chart.renderer,
        legendGroup = legend.group,
        allItems,
        display,
        legendWidth,
        legendHeight,
        box = legend.box,
        options = legend.options,
        padding = legend.padding,
        alignTo;
    legend.itemX = padding;
    legend.itemY = legend.initialItemY;
    legend.offsetWidth = 0;
    legend.lastItemY = 0;

    if (!legendGroup) {
      /**
       * SVG group of the legend.
       *
       * @readonly
       * @name Highcharts.Legend#group
       * @type {Highcharts.SVGElement}
       */
      legend.group = legendGroup = renderer.g('legend').attr({
        zIndex: 7
      }).add();
      legend.contentGroup = renderer.g().attr({
        zIndex: 1
      }) // above background
      .add(legendGroup);
      legend.scrollGroup = renderer.g().add(legend.contentGroup);
    }

    legend.renderTitle(); // add each series or point

    allItems = legend.getAllItems(); // sort by legendIndex

    stableSort(allItems, function (a, b) {
      return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
    }); // reversed legend

    if (options.reversed) {
      allItems.reverse();
    }
    /**
     * All items for the legend, which is an array of series for most series
     * and an array of points for pie series and its derivatives.
     *
     * @readonly
     * @name Highcharts.Legend#allItems
     * @type {Array<Highcharts.Point|Highcharts.Series>}
     */


    legend.allItems = allItems;
    legend.display = display = !!allItems.length; // Render the items. First we run a loop to set the text and properties
    // and read all the bounding boxes. The next loop computes the item
    // positions based on the bounding boxes.

    legend.lastLineHeight = 0;
    legend.maxItemWidth = 0;
    legend.totalItemWidth = 0;
    legend.itemHeight = 0;
    each$9(allItems, legend.renderItem, legend);
    each$9(allItems, legend.layoutItem, legend); // Get the box

    legendWidth = (options.width || legend.offsetWidth) + padding;
    legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
    legendHeight = legend.handleOverflow(legendHeight);
    legendHeight += padding; // Draw the border and/or background

    if (!box) {
      /**
       * SVG element of the legend box.
       *
       * @readonly
       * @name Highcharts.Legend#box
       * @type {Highcharts.SVGElement}
       */
      legend.box = box = renderer.rect().addClass('highcharts-legend-box').attr({
        r: options.borderRadius
      }).add(legendGroup);
      box.isNew = true;
    }

    if (legendWidth > 0 && legendHeight > 0) {
      box[box.isNew ? 'attr' : 'animate'](box.crisp.call({}, {
        // #7260
        x: 0,
        y: 0,
        width: legendWidth,
        height: legendHeight
      }, box.strokeWidth()));
      box.isNew = false;
    } // hide the border if no items


    box[display ? 'show' : 'hide'](); // Open for responsiveness

    if (legendGroup.getStyle('display') === 'none') {
      legendWidth = legendHeight = 0;
    }

    legend.legendWidth = legendWidth;
    legend.legendHeight = legendHeight;

    if (display) {
      // If aligning to the top and the layout is horizontal, adjust for
      // the title (#7428)
      alignTo = chart.spacingBox;

      if (/(lth|ct|rth)/.test(legend.getAlignment())) {
        alignTo = merge$8(alignTo, {
          y: alignTo.y + chart.titleOffset + chart.options.title.margin
        });
      }

      legendGroup.align(merge$8(options, {
        width: legendWidth,
        height: legendHeight,
        verticalAlign: this.proximate ? 'top' : options.verticalAlign
      }), true, alignTo);
    }

    if (!this.proximate) {
      this.positionItems();
    }
  },

  /**
   * Set up the overflow handling by adding navigation with up and down arrows
   * below the legend.
   *
   * @private
   * @function Highcharts.Legend#handleOverflow
   *
   * @param {number} legendHeight
   *
   * @return {number}
   */
  handleOverflow: function (legendHeight) {
    var legend = this,
        chart = this.chart,
        renderer = chart.renderer,
        options = this.options,
        optionsY = options.y,
        alignTop = options.verticalAlign === 'top',
        padding = this.padding,
        spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - padding,
        maxHeight = options.maxHeight,
        clipHeight,
        clipRect = this.clipRect,
        navOptions = options.navigation,
        animation = pick$a(navOptions.animation, true),
        arrowSize = navOptions.arrowSize || 12,
        nav = this.nav,
        pages = this.pages,
        lastY,
        allItems = this.allItems,
        clipToHeight = function (height) {
      if (typeof height === 'number') {
        clipRect.attr({
          height: height
        });
      } else if (clipRect) {
        // Reset (#5912)
        legend.clipRect = clipRect.destroy();
        legend.contentGroup.clip();
      } // useHTML


      if (legend.contentGroup.div) {
        legend.contentGroup.div.style.clip = height ? 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)' : 'auto';
      }
    }; // Adjust the height


    if (options.layout === 'horizontal' && options.verticalAlign !== 'middle' && !options.floating) {
      spaceHeight /= 2;
    }

    if (maxHeight) {
      spaceHeight = Math.min(spaceHeight, maxHeight);
    } // Reset the legend height and adjust the clipping rectangle


    pages.length = 0;

    if (legendHeight > spaceHeight && navOptions.enabled !== false) {
      this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);
      this.currentPage = pick$a(this.currentPage, 1);
      this.fullHeight = legendHeight; // Fill pages with Y positions so that the top of each a legend item
      // defines the scroll top for each page (#2098)

      each$9(allItems, function (item, i) {
        var y = item._legendItemPos[1],
            h = Math.round(item.legendItem.getBBox().height),
            len = pages.length;

        if (!len || y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1]) {
          pages.push(lastY || y);
          len++;
        } // Keep track of which page each item is on


        item.pageIx = len - 1;

        if (lastY) {
          allItems[i - 1].pageIx = len - 1;
        }

        if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {
          pages.push(y);
          item.pageIx = len;
        }

        if (y !== lastY) {
          lastY = y;
        }
      }); // Only apply clipping if needed. Clipping causes blurred legend in
      // PDF export (#1787)

      if (!clipRect) {
        clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);
        legend.contentGroup.clip(clipRect);
      }

      clipToHeight(clipHeight); // Add navigation elements

      if (!nav) {
        this.nav = nav = renderer.g().attr({
          zIndex: 1
        }).add(this.group);
        this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize).on('click', function () {
          legend.scroll(-1, animation);
        }).add(nav);
        this.pager = renderer.text('', 15, 10).addClass('highcharts-legend-navigation').add(nav);
        this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize).on('click', function () {
          legend.scroll(1, animation);
        }).add(nav);
      } // Set initial position


      legend.scroll(0);
      legendHeight = spaceHeight; // Reset
    } else if (nav) {
      clipToHeight();
      this.nav = nav.destroy(); // #6322

      this.scrollGroup.attr({
        translateY: 1
      });
      this.clipHeight = 0; // #1379
    }

    return legendHeight;
  },

  /**
   * Scroll the legend by a number of pages.
   *
   * @private
   * @function Highcharts.Legend#scroll
   *
   * @param {number} scrollBy
   *        The number of pages to scroll.
   *
   * @param {Highcharts.AnimationOptionsObject} animation
   *        Whether and how to apply animation.
   */
  scroll: function (scrollBy, animation) {
    var pages = this.pages,
        pageCount = pages.length,
        currentPage = this.currentPage + scrollBy,
        clipHeight = this.clipHeight,
        navOptions = this.options.navigation,
        pager = this.pager,
        padding = this.padding; // When resizing while looking at the last page

    if (currentPage > pageCount) {
      currentPage = pageCount;
    }

    if (currentPage > 0) {
      if (animation !== undefined) {
        setAnimation(animation, this.chart);
      }

      this.nav.attr({
        translateX: padding,
        translateY: clipHeight + this.padding + 7 + this.titleHeight,
        visibility: 'visible'
      });
      this.up.attr({
        'class': currentPage === 1 ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'
      });
      pager.attr({
        text: currentPage + '/' + pageCount
      });
      this.down.attr({
        'x': 18 + this.pager.getBBox().width,
        // adjust to text width
        'class': currentPage === pageCount ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'
      });
      this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;
      this.scrollGroup.animate({
        translateY: this.scrollOffset
      });
      this.currentPage = currentPage;
      this.positionCheckboxes();
    }
  }
};
/**
 * Legend symbol mixin.
 *
 * @private
 * @mixin Highcharts.LegendSymbolMixin
 */

H$2.LegendSymbolMixin = {
  /**
   * Get the series' symbol in the legend
   *
   * @private
   * @function Highcharts.LegendSymbolMixin.drawRectangle
   *
   * @param {Highcharts.Legend} legend
   *        The legend object
   *
   * @param {Highcharts.Point|Highcharts.Series} item
   *        The series (this) or point
   */
  drawRectangle: function (legend, item) {
    var options = legend.options,
        symbolHeight = legend.symbolHeight,
        square = options.squareSymbol,
        symbolWidth = square ? symbolHeight : legend.symbolWidth;
    item.legendSymbol = this.chart.renderer.rect(square ? (legend.symbolWidth - symbolHeight) / 2 : 0, legend.baseline - symbolHeight + 1, // #3988
    symbolWidth, symbolHeight, pick$a(legend.options.symbolRadius, symbolHeight / 2)).addClass('highcharts-point').attr({
      zIndex: 3
    }).add(item.legendGroup);
  },

  /**
   * Get the series' symbol in the legend. This method should be overridable
   * to create custom symbols through
   * Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
   *
   * @private
   * @function Highcharts.LegendSymbolMixin.drawLineMarker
   *
   * @param {Highcharts.Legend} legend
   *        The legend object.
   */
  drawLineMarker: function (legend) {
    var options = this.options,
        markerOptions = options.marker,
        radius,
        legendSymbol,
        symbolWidth = legend.symbolWidth,
        symbolHeight = legend.symbolHeight,
        generalRadius = symbolHeight / 2,
        renderer = this.chart.renderer,
        legendItemGroup = this.legendGroup,
        verticalCenter = legend.baseline - Math.round(legend.fontMetrics.b * 0.3),
        attr = {}; // Draw the line

    this.legendLine = renderer.path(['M', 0, verticalCenter, 'L', symbolWidth, verticalCenter]).addClass('highcharts-graph').attr(attr).add(legendItemGroup); // Draw the marker

    if (markerOptions && markerOptions.enabled !== false && symbolWidth) {
      // Do not allow the marker to be larger than the symbolHeight
      radius = Math.min(pick$a(markerOptions.radius, generalRadius), generalRadius); // Restrict symbol markers size

      if (this.symbol.indexOf('url') === 0) {
        markerOptions = merge$8(markerOptions, {
          width: symbolHeight,
          height: symbolHeight
        });
        radius = 0;
      }

      this.legendSymbol = legendSymbol = renderer.symbol(this.symbol, symbolWidth / 2 - radius, verticalCenter - radius, 2 * radius, 2 * radius, markerOptions).addClass('highcharts-point').add(legendItemGroup);
      legendSymbol.isMarker = true;
    }
  }
}; // Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
// and for #2580, a similar drawing flaw in Firefox 26.
// Explore if there's a general cause for this. The problem may be related
// to nested group elements, as the legend item texts are within 4 group
// elements.

if (/Trident\/7\.0/.test(win$6.navigator.userAgent) || isFirefox$3) {
  wrap$4(Highcharts.Legend.prototype, 'positionItem', function (proceed, item) {
    var legend = this,
        // If chart destroyed in sync, this is undefined (#2030)
    runPositionItem = function () {
      if (item._legendItemPos) {
        proceed.call(legend, item);
      }
    }; // Do it now, for export and to get checkbox placement


    runPositionItem(); // Do it after to work around the core issue

    setTimeout(runPositionItem);
  });
}

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$5 = Highcharts.addEvent,
    animate$2 = Highcharts.animate,
    animObject$1 = Highcharts.animObject,
    attr$3 = Highcharts.attr,
    doc$5 = Highcharts.doc,
    Axis$3 = Highcharts.Axis,
    // @todo add as requirement
createElement$2 = Highcharts.createElement,
    defaultOptions$1 = Highcharts.defaultOptions,
    discardElement$1 = Highcharts.discardElement,
    charts$5 = Highcharts.charts,
    css$5 = Highcharts.css,
    defined$8 = Highcharts.defined,
    each$a = Highcharts.each,
    extend$8 = Highcharts.extend,
    find$1 = Highcharts.find,
    fireEvent$4 = Highcharts.fireEvent,
    grep$2 = Highcharts.grep,
    isNumber$5 = Highcharts.isNumber,
    isObject$3 = Highcharts.isObject,
    isString$3 = Highcharts.isString,
    Legend = Highcharts.Legend,
    // @todo add as requirement
marginNames$1 = Highcharts.marginNames,
    merge$9 = Highcharts.merge,
    objectEach$2 = Highcharts.objectEach,
    Pointer$2 = Highcharts.Pointer,
    // @todo add as requirement
pick$b = Highcharts.pick,
    pInt$3 = Highcharts.pInt,
    removeEvent$3 = Highcharts.removeEvent,
    seriesTypes = Highcharts.seriesTypes,
    splat$4 = Highcharts.splat,
    syncTimeout$2 = Highcharts.syncTimeout,
    win$7 = Highcharts.win;
/**
 * The Chart class. The recommended constructor is {@link Highcharts#chart}.
 *
 * @example
 * var chart = Highcharts.chart('container', {
 *        title: {
 *               text: 'My chart'
 *        },
 *        series: [{
 *            data: [1, 3, 2, 4]
 *        }]
 * })
 *
 * @class
 * @name Highcharts.Chart
 *
 * @param {Highcharts.Options} options
 *        The chart options structure.
 *
 * @param {Highcharts.ChartCallbackFunction|undefined} [callback]
 *        Function to run when the chart has loaded and and all external images
 *        are loaded. Defining a
 *        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}
 *        handler is equivalent.
 */

/**
* @class
* @name Highcharts.Chart
*
* @param {string|Highcharts.HTMLDOMElement} renderTo
*        The DOM element to render to, or its id.
*
* @param {Highcharts.Options} options
*        The chart options structure.
*
* @param {Highcharts.ChartCallbackFunction|undefined} [callback]
*        Function to run when the chart has loaded and and all external images
*        are loaded. Defining a
*        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}
*        handler is equivalent.
*/

var Chart = Highcharts.Chart = function () {
  this.getArgs.apply(this, arguments);
};
/**
 * Factory function for basic charts.
 *
 * @example
 * // Render a chart in to div#container
 * var chart = Highcharts.chart('container', {
 *     title: {
 *         text: 'My chart'
 *     },
 *     series: [{
 *         data: [1, 3, 2, 4]
 *     }]
 * });
 *
 * @function Highcharts.chart
 *
 * @param {Highcharts.Options} options
 *        The chart options structure.
 *
 * @param {Highcharts.ChartCallbackFunction|undefined} [callback]
 *        Function to run when the chart has loaded and and all external images
 *        are loaded. Defining a
 *        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}
 *        handler is equivalent.
 *
 * @return {Highcharts.Chart}
 *         Returns the Chart object.
 */

/**
* @function Highcharts.chart
*
* @param {string|Highcharts.HTMLDOMElement} renderTo
*        The DOM element to render to, or its id.
*
* @param {Highcharts.Options} options
*        The chart options structure.
*
* @param {Highcharts.ChartCallbackFunction|undefined} [callback]
*        Function to run when the chart has loaded and and all external images
*        are loaded. Defining a
*        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}
*        handler is equivalent.
*
* @return {Highcharts.Chart}
*         Returns the Chart object.
*/


Highcharts.chart = function (a, b, c) {
  return new Chart(a, b, c);
};

extend$8(Chart.prototype,
/** @lends Highcharts.Chart.prototype */
{
  // Hook for adding callbacks in modules
  callbacks: [],

  /**
   * Handle the arguments passed to the constructor.
   *
   * @private
   * @function Highcharts.Chart#getArgs
   *
   * @param {...Array<*>} arguments
   *        All arguments for the constructor.
   *
   * @return {Array<*>}
   *         Passed arguments without renderTo.
   *
   * @fires Highcharts.Chart#event:init
   * @fires Highcharts.Chart#event:afterInit
   */
  getArgs: function () {
    var args = [].slice.call(arguments); // Remove the optional first argument, renderTo, and
    // set it on this.

    if (isString$3(args[0]) || args[0].nodeName) {
      this.renderTo = args.shift();
    }

    this.init(args[0], args[1]);
  },

  /**
   * Overridable function that initializes the chart. The constructor's
   * arguments are passed on directly.
   *
   * @function Highcharts.Chart#init
   *
   * @param {Highcharts.Options} userOptions
   *        Custom options.
   *
   * @param {Function|undefined} [callback]
   *        Function to run when the chart has loaded and and all external
   *        images are loaded.
   *
   * @fires Highcharts.Chart#event:init
   * @fires Highcharts.Chart#event:afterInit
   */
  init: function (userOptions, callback) {
    // Handle regular options
    var options,
        type,
        // skip merging data points to increase performance
    seriesOptions = userOptions.series,
        userPlotOptions = userOptions.plotOptions || {}; // Fire the event with a default function

    fireEvent$4(this, 'init', {
      args: arguments
    }, function () {
      userOptions.series = null;
      options = merge$9(defaultOptions$1, userOptions); // do the merge
      // Override (by copy of user options) or clear tooltip options
      // in chart.options.plotOptions (#6218)

      for (type in options.plotOptions) {
        options.plotOptions[type].tooltip = userPlotOptions[type] && merge$9(userPlotOptions[type].tooltip) // override by copy
        || undefined; // or clear
      } // User options have higher priority than default options
      // (#6218). In case of exporting: path is changed


      options.tooltip.userOptions = userOptions.chart && userOptions.chart.forExport && userOptions.tooltip.userOptions || userOptions.tooltip; // set back the series data

      options.series = userOptions.series = seriesOptions;
      this.userOptions = userOptions;
      var optionsChart = options.chart;
      var chartEvents = optionsChart.events;
      this.margin = [];
      this.spacing = []; // Pixel data bounds for touch zoom

      this.bounds = {
        h: {},
        v: {}
      }; // An array of functions that returns labels that should be
      // considered for anti-collision

      this.labelCollectors = [];
      this.callback = callback;
      this.isResizing = 0;
      /**
       * The options structure for the chart. It contains members for
       * the sub elements like series, legend, tooltip etc.
       *
       * @name Highcharts.Chart#options
       * @type {Highcharts.Options}
       */

      this.options = options;
      /**
       * All the axes in the chart.
       *
       * @see  Highcharts.Chart.xAxis
       * @see  Highcharts.Chart.yAxis
       *
       * @name Highcharts.Chart#axes
       * @type {Array<Highcharts.Axis>}
       */

      this.axes = [];
      /**
       * All the current series in the chart.
       *
       * @name Highcharts.Chart#series
       * @type {Array<Highcharts.Series>}
       */

      this.series = [];
      /**
       * The `Time` object associated with the chart. Since v6.0.5,
       * time settings can be applied individually for each chart. If
       * no individual settings apply, the `Time` object is shared by
       * all instances.
       *
       * @name Highcharts.Chart#time
       * @type {Highcharts.Time}
       */

      this.time = userOptions.time && Highcharts.keys(userOptions.time).length ? new Highcharts.Time(userOptions.time) : Highcharts.time;
      this.hasCartesianSeries = optionsChart.showAxes;
      var chart = this; // Add the chart to the global lookup

      chart.index = charts$5.length;
      charts$5.push(chart);
      Highcharts.chartCount++; // Chart event handlers

      if (chartEvents) {
        objectEach$2(chartEvents, function (event, eventType) {
          addEvent$5(chart, eventType, event);
        });
      }
      /**
       * A collection of the X axes in the chart.
       *
       * @name Highcharts.Chart#xAxis
       * @type {Array<Highcharts.Axis>}
       */


      chart.xAxis = [];
      /**
       * A collection of the Y axes in the chart.
       *
       * @name Highcharts.Chart#yAxis
       * @type {Array<Highcharts.Axis>}
       *
       * @todo
       * Make events official: Fire the event `afterInit`.
       */

      chart.yAxis = [];
      chart.pointCount = chart.colorCounter = chart.symbolCounter = 0; // Fire after init but before first render, before axes and series
      // have been initialized.

      fireEvent$4(chart, 'afterInit');
      chart.firstRender();
    });
  },

  /**
   * Internal function to unitialize an individual series.
   *
   * @private
   * @function Highcharts.Chart#initSeries
   *
   * @param {Highcharts.ChartOptions} options
   *
   * @return {Highcharts.Series}
   */
  initSeries: function (options) {
    var chart = this,
        optionsChart = chart.options.chart,
        type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
        series,
        Constr = seriesTypes[type]; // No such series type

    if (!Constr) {
      Highcharts.error(17, true);
    }

    series = new Constr();
    series.init(this, options);
    return series;
  },

  /**
   * Order all series above a given index. When series are added and ordered
   * by configuration, only the last series is handled (#248, #1123, #2456,
   * #6112). This function is called on series initialization and destroy.
   *
   * @private
   * @function Highcharts.Series#orderSeries
   *
   * @param {number} fromIndex
   *        If this is given, only the series above this index are handled.
   */
  orderSeries: function (fromIndex) {
    var series = this.series,
        i = fromIndex || 0;

    for (; i < series.length; i++) {
      if (series[i]) {
        series[i].index = i;
        series[i].name = series[i].getName();
      }
    }
  },

  /**
   * Check whether a given point is within the plot area.
   *
   * @function Highcharts.Chart#isInsidePlot
   *
   * @param {number} plotX
   *        Pixel x relative to the plot area.
   *
   * @param {number} plotY
   *        Pixel y relative to the plot area.
   *
   * @param {boolean} inverted
   *        Whether the chart is inverted.
   *
   * @return {boolean}
   *         Returns true if the given point is inside the plot area.
   */
  isInsidePlot: function (plotX, plotY, inverted) {
    var x = inverted ? plotY : plotX,
        y = inverted ? plotX : plotY;
    return x >= 0 && x <= this.plotWidth && y >= 0 && y <= this.plotHeight;
  },

  /**
   * Redraw the chart after changes have been done to the data, axis extremes
   * chart size or chart elements. All methods for updating axes, series or
   * points have a parameter for redrawing the chart. This is `true` by
   * default. But in many cases you want to do more than one operation on the
   * chart before redrawing, for example add a number of points. In those
   * cases it is a waste of resources to redraw the chart for each new point
   * added. So you add the points and call `chart.redraw()` after.
   *
   * @function Highcharts.Chart#redraw
   *
   * @param {boolean|Highcharts.AnimationOptionsObject|undefined} [animation]
   *        If or how to apply animation to the redraw.
   *
   * @fires Highcharts.Chart#event:afterSetExtremes
   * @fires Highcharts.Chart#event:beforeRedraw
   * @fires Highcharts.Chart#event:predraw
   * @fires Highcharts.Chart#event:redraw
   * @fires Highcharts.Chart#event:render
   * @fires Highcharts.Chart#event:updatedData
   */
  redraw: function (animation) {
    fireEvent$4(this, 'beforeRedraw');
    var chart = this,
        axes = chart.axes,
        series = chart.series,
        pointer = chart.pointer,
        legend = chart.legend,
        legendUserOptions = chart.userOptions.legend,
        redrawLegend = chart.isDirtyLegend,
        hasStackedSeries,
        hasDirtyStacks,
        hasCartesianSeries = chart.hasCartesianSeries,
        isDirtyBox = chart.isDirtyBox,
        i,
        serie,
        renderer = chart.renderer,
        isHiddenChart = renderer.isHidden(),
        afterRedraw = []; // Handle responsive rules, not only on resize (#6130)

    if (chart.setResponsive) {
      chart.setResponsive(false);
    }

    Highcharts.setAnimation(animation, chart);

    if (isHiddenChart) {
      chart.temporaryDisplay();
    } // Adjust title layout (reflow multiline text)


    chart.layOutTitles(); // link stacked series

    i = series.length;

    while (i--) {
      serie = series[i];

      if (serie.options.stacking) {
        hasStackedSeries = true;

        if (serie.isDirty) {
          hasDirtyStacks = true;
          break;
        }
      }
    }

    if (hasDirtyStacks) {
      // mark others as dirty
      i = series.length;

      while (i--) {
        serie = series[i];

        if (serie.options.stacking) {
          serie.isDirty = true;
        }
      }
    } // Handle updated data in the series


    each$a(series, function (serie) {
      if (serie.isDirty) {
        if (serie.options.legendType === 'point') {
          if (serie.updateTotals) {
            serie.updateTotals();
          }

          redrawLegend = true;
        } else if (legendUserOptions && (legendUserOptions.labelFormatter || legendUserOptions.labelFormat)) {
          redrawLegend = true; // #2165
        }
      }

      if (serie.isDirtyData) {
        fireEvent$4(serie, 'updatedData');
      }
    }); // handle added or removed series

    if (redrawLegend && legend && legend.options.enabled) {
      // draw legend graphics
      legend.render();
      chart.isDirtyLegend = false;
    } // reset stacks


    if (hasStackedSeries) {
      chart.getStacks();
    }

    if (hasCartesianSeries) {
      // set axes scales
      each$a(axes, function (axis) {
        axis.updateNames();
        axis.setScale();
      });
    }

    chart.getMargins(); // #3098

    if (hasCartesianSeries) {
      // If one axis is dirty, all axes must be redrawn (#792, #2169)
      each$a(axes, function (axis) {
        if (axis.isDirty) {
          isDirtyBox = true;
        }
      }); // redraw axes

      each$a(axes, function (axis) {
        // Fire 'afterSetExtremes' only if extremes are set
        var key = axis.min + ',' + axis.max;

        if (axis.extKey !== key) {
          // #821, #4452
          axis.extKey = key; // prevent a recursive call to chart.redraw() (#1119)

          afterRedraw.push(function () {
            fireEvent$4(axis, 'afterSetExtremes', extend$8(axis.eventArgs, axis.getExtremes())); // #747, #751

            delete axis.eventArgs;
          });
        }

        if (isDirtyBox || hasStackedSeries) {
          axis.redraw();
        }
      });
    } // the plot areas size has changed


    if (isDirtyBox) {
      chart.drawChartBox();
    } // Fire an event before redrawing series, used by the boost module to
    // clear previous series renderings.


    fireEvent$4(chart, 'predraw'); // redraw affected series

    each$a(series, function (serie) {
      if ((isDirtyBox || serie.isDirty) && serie.visible) {
        serie.redraw();
      } // Set it here, otherwise we will have unlimited 'updatedData' calls
      // for a hidden series after setData(). Fixes #6012


      serie.isDirtyData = false;
    }); // move tooltip or reset

    if (pointer) {
      pointer.reset(true);
    } // redraw if canvas


    renderer.draw(); // Fire the events

    fireEvent$4(chart, 'redraw');
    fireEvent$4(chart, 'render');

    if (isHiddenChart) {
      chart.temporaryDisplay(true);
    } // Fire callbacks that are put on hold until after the redraw


    each$a(afterRedraw, function (callback) {
      callback.call();
    });
  },

  /**
   * Get an axis, series or point object by `id` as given in the configuration
   * options. Returns `undefined` if no item is found.
   *
   * @sample highcharts/plotoptions/series-id/
   *         Get series by id
   *
   * @function Highcharts.Chart#get
   *
   * @param {string} id
   *        The id as given in the configuration options.
   *
   * @return {Highcharts.Axis|Highcharts.Series|Highcharts.Point|undefined}
   *         The retrieved item.
   */
  get: function (id) {
    var ret,
        series = this.series,
        i;

    function itemById(item) {
      return item.id === id || item.options && item.options.id === id;
    }

    ret = // Search axes
    find$1(this.axes, itemById) || // Search series
    find$1(this.series, itemById); // Search points

    for (i = 0; !ret && i < series.length; i++) {
      ret = find$1(series[i].points || [], itemById);
    }

    return ret;
  },

  /**
   * Create the Axis instances based on the config options.
   *
   * @private
   * @function Highcharts.Chart#getAxes
   *
   * @fires Highcharts.Chart#event:afterGetAxes
   * @fires Highcharts.Chart#event:getAxes
   */
  getAxes: function () {
    var chart = this,
        options = this.options,
        xAxisOptions = options.xAxis = splat$4(options.xAxis || {}),
        yAxisOptions = options.yAxis = splat$4(options.yAxis || {}),
        optionsArray;
    fireEvent$4(this, 'getAxes'); // make sure the options are arrays and add some members

    each$a(xAxisOptions, function (axis, i) {
      axis.index = i;
      axis.isX = true;
    });
    each$a(yAxisOptions, function (axis, i) {
      axis.index = i;
    }); // concatenate all axis options into one array

    optionsArray = xAxisOptions.concat(yAxisOptions);
    each$a(optionsArray, function (axisOptions) {
      new Axis$3(chart, axisOptions); // eslint-disable-line no-new
    });
    fireEvent$4(this, 'afterGetAxes');
  },

  /**
   * Returns an array of all currently selected points in the chart. Points
   * can be selected by clicking or programmatically by the
   * {@link Highcharts.Point#select}
   * function.
   *
   * @sample highcharts/plotoptions/series-allowpointselect-line/
   *         Get selected points
   *
   * @function Highcharts.Chart#getSelectedPoints
   *
   * @return {Array<Highcharts.Point>}
   *         The currently selected points.
   */
  getSelectedPoints: function () {
    var points = [];
    each$a(this.series, function (serie) {
      // series.data - for points outside of viewed range (#6445)
      points = points.concat(grep$2(serie.data || [], function (point) {
        return point.selected;
      }));
    });
    return points;
  },

  /**
   * Returns an array of all currently selected series in the chart. Series
   * can be selected either programmatically by the
   * {@link Highcharts.Series#select}
   * function or by checking the checkbox next to the legend item if
   * {@link https://api.highcharts.com/highcharts/plotOptions.series.showCheckbox| series.showCheckBox}
   * is true.
   *
   * @sample highcharts/members/chart-getselectedseries/
   *         Get selected series
   *
   * @function Highcharts.Chart#getSelectedSeries
   *
   * @return {Array<Highcharts.Series>}
   *         The currently selected series.
   */
  getSelectedSeries: function () {
    return grep$2(this.series, function (serie) {
      return serie.selected;
    });
  },

  /**
   * Set a new title or subtitle for the chart.
   *
   * @sample highcharts/members/chart-settitle/
   *         Set title text and styles
   *
   * @function Highcharts.Chart#setTitle
   *
   * @param {Highcharts.TitleOptions} titleOptions
   *        New title options. The title text itself is set by the
   *        `titleOptions.text` property.
   *
   * @param {Highcharts.SubtitleOptions} subtitleOptions
   *        New subtitle options. The subtitle text itself is set by the
   *        `subtitleOptions.text` property.
   *
   * @param {boolean} redraw
   *        Whether to redraw the chart or wait for a later call to
   *        `chart.redraw()`.
   */
  setTitle: function (titleOptions, subtitleOptions, redraw) {
    var chart = this,
        options = chart.options,
        chartTitleOptions,
        chartSubtitleOptions;
    chartTitleOptions = options.title = merge$9(options.title, titleOptions);
    chartSubtitleOptions = options.subtitle = merge$9(options.subtitle, subtitleOptions); // add title and subtitle

    /**
     * The chart title. The title has an `update` method that allows
     * modifying the options directly or indirectly via
     * `chart.update`.
     *
     * @sample highcharts/members/title-update/
     *         Updating titles
     *
     * @name Highcharts.Chart#title
     * @type {Highcharts.TitleObject}
     */

    /**
     * The chart subtitle. The subtitle has an `update` method that
     * allows modifying the options directly or indirectly via
     * `chart.update`.
     *
     * @name Highcharts.Chart#subtitle
     * @type {Highcharts.SubtitleObject}
     */

    each$a([['title', titleOptions, chartTitleOptions], ['subtitle', subtitleOptions, chartSubtitleOptions]], function (arr, i) {
      var name = arr[0],
          title = chart[name],
          titleOptions = arr[1],
          chartTitleOptions = arr[2];

      if (title && titleOptions) {
        chart[name] = title = title.destroy(); // remove old
      }

      if (chartTitleOptions && !title) {
        chart[name] = chart.renderer.text(chartTitleOptions.text, 0, 0, chartTitleOptions.useHTML).attr({
          align: chartTitleOptions.align,
          'class': 'highcharts-' + name,
          zIndex: chartTitleOptions.zIndex || 4
        }).add(); // Update methods, shortcut to Chart.setTitle

        chart[name].update = function (o) {
          chart.setTitle(!i && o, i && o);
        };
      }
    });
    chart.layOutTitles(redraw);
  },

  /**
   * Internal function to lay out the chart titles and cache the full offset
   * height for use in `getMargins`. The result is stored in
   * `this.titleOffset`.
   *
   * @private
   * @function Highcharts.Chart#layOutTitles
   *
   * @param {boolean|undefined} [redraw=true]
   */
  layOutTitles: function (redraw) {
    var titleOffset = 0,
        requiresDirtyBox,
        renderer = this.renderer,
        spacingBox = this.spacingBox; // Lay out the title and the subtitle respectively

    each$a(['title', 'subtitle'], function (key) {
      var title = this[key],
          titleOptions = this.options[key],
          offset = key === 'title' ? -3 : // Floating subtitle (#6574)
      titleOptions.verticalAlign ? 0 : titleOffset + 2,
          titleSize;

      if (title) {
        titleSize = renderer.fontMetrics(titleSize, title).b;
        title.css({
          width: (titleOptions.width || spacingBox.width + titleOptions.widthAdjust) + 'px'
        }).align(extend$8({
          y: offset + titleSize
        }, titleOptions), false, 'spacingBox');

        if (!titleOptions.floating && !titleOptions.verticalAlign) {
          titleOffset = Math.ceil(titleOffset + // Skip the cache for HTML (#3481)
          title.getBBox(titleOptions.useHTML).height);
        }
      }
    }, this);
    requiresDirtyBox = this.titleOffset !== titleOffset;
    this.titleOffset = titleOffset; // used in getMargins

    if (!this.isDirtyBox && requiresDirtyBox) {
      this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox; // Redraw if necessary (#2719, #2744)

      if (this.hasRendered && pick$b(redraw, true) && this.isDirtyBox) {
        this.redraw();
      }
    }
  },

  /**
   * Internal function to get the chart width and height according to options
   * and container size. Sets
   * {@link Chart.chartWidth} and
   * {@link Chart.chartHeight}.
   *
   * @function Highcharts.Chart#getChartSize
   *
   * @return {void}
   */
  getChartSize: function () {
    var chart = this,
        optionsChart = chart.options.chart,
        widthOption = optionsChart.width,
        heightOption = optionsChart.height,
        renderTo = chart.renderTo; // Get inner width and height

    if (!defined$8(widthOption)) {
      chart.containerWidth = Highcharts.getStyle(renderTo, 'width');
    }

    if (!defined$8(heightOption)) {
      chart.containerHeight = Highcharts.getStyle(renderTo, 'height');
    }
    /**
     * The current pixel width of the chart.
     *
     * @name Highcharts.Chart#chartWidth
     * @type {number}
     */


    chart.chartWidth = Math.max( // #1393
    0, widthOption || chart.containerWidth || 600 // #1460
    );
    /**
     * The current pixel height of the chart.
     *
     * @name Highcharts.Chart#chartHeight
     * @type {number}
     */

    chart.chartHeight = Math.max(0, Highcharts.relativeLength(heightOption, chart.chartWidth) || (chart.containerHeight > 1 ? chart.containerHeight : 400));
  },

  /**
   * If the renderTo element has no offsetWidth, most likely one or more of
   * its parents are hidden. Loop up the DOM tree to temporarily display the
   * parents, then save the original display properties, and when the true
   * size is retrieved, reset them. Used on first render and on redraws.
   *
   * @private
   * @function Highcharts.Chart#temporaryDisplay
   *
   * @param {boolean} revert
   *        Revert to the saved original styles.
   */
  temporaryDisplay: function (revert) {
    var node = this.renderTo,
        tempStyle;

    if (!revert) {
      while (node && node.style) {
        // When rendering to a detached node, it needs to be temporarily
        // attached in order to read styling and bounding boxes (#5783,
        // #7024).
        if (!doc$5.body.contains(node) && !node.parentNode) {
          node.hcOrigDetached = true;
          doc$5.body.appendChild(node);
        }

        if (Highcharts.getStyle(node, 'display', false) === 'none' || node.hcOricDetached) {
          node.hcOrigStyle = {
            display: node.style.display,
            height: node.style.height,
            overflow: node.style.overflow
          };
          tempStyle = {
            display: 'block',
            overflow: 'hidden'
          };

          if (node !== this.renderTo) {
            tempStyle.height = 0;
          }

          Highcharts.css(node, tempStyle); // If it still doesn't have an offset width after setting
          // display to block, it probably has an !important priority
          // #2631, 6803

          if (!node.offsetWidth) {
            node.style.setProperty('display', 'block', 'important');
          }
        }

        node = node.parentNode;

        if (node === doc$5.body) {
          break;
        }
      }
    } else {
      while (node && node.style) {
        if (node.hcOrigStyle) {
          Highcharts.css(node, node.hcOrigStyle);
          delete node.hcOrigStyle;
        }

        if (node.hcOrigDetached) {
          doc$5.body.removeChild(node);
          node.hcOrigDetached = false;
        }

        node = node.parentNode;
      }
    }
  },

  /**
   * Set the {@link Chart.container|chart container's} class name, in
   * addition to `highcharts-container`.
   *
   * @function Highcharts.Chart#setClassName
   *
   * @param {string} className
   */
  setClassName: function (className) {
    this.container.className = 'highcharts-container ' + (className || '');
  },

  /**
   * Get the containing element, determine the size and create the inner
   * container div to hold the chart.
   *
   * @private
   * @function Highcharts.Chart#afterGetContainer
   *
   * @fires Highcharts.Chart#event:afterGetContainer
   */
  getContainer: function () {
    var chart = this,
        container,
        options = chart.options,
        optionsChart = options.chart,
        chartWidth,
        chartHeight,
        renderTo = chart.renderTo,
        indexAttrName = 'data-highcharts-chart',
        oldChartIndex,
        Ren,
        containerId = Highcharts.uniqueKey(),
        containerStyle,
        key;

    if (!renderTo) {
      chart.renderTo = renderTo = optionsChart.renderTo;
    }

    if (isString$3(renderTo)) {
      chart.renderTo = renderTo = doc$5.getElementById(renderTo);
    } // Display an error if the renderTo is wrong


    if (!renderTo) {
      Highcharts.error(13, true);
    } // If the container already holds a chart, destroy it. The check for
    // hasRendered is there because web pages that are saved to disk from
    // the browser, will preserve the data-highcharts-chart attribute and
    // the SVG contents, but not an interactive chart. So in this case,
    // charts[oldChartIndex] will point to the wrong chart if any (#2609).


    oldChartIndex = pInt$3(attr$3(renderTo, indexAttrName));

    if (isNumber$5(oldChartIndex) && charts$5[oldChartIndex] && charts$5[oldChartIndex].hasRendered) {
      charts$5[oldChartIndex].destroy();
    } // Make a reference to the chart from the div


    attr$3(renderTo, indexAttrName, chart.index); // remove previous chart

    renderTo.innerHTML = ''; // If the container doesn't have an offsetWidth, it has or is a child of
    // a node that has display:none. We need to temporarily move it out to a
    // visible state to determine the size, else the legend and tooltips
    // won't render properly. The skipClone option is used in sparklines as
    // a micro optimization, saving about 1-2 ms each chart.

    if (!optionsChart.skipClone && !renderTo.offsetWidth) {
      chart.temporaryDisplay();
    } // get the width and height


    chart.getChartSize();
    chartWidth = chart.chartWidth;
    chartHeight = chart.chartHeight; // Create the inner container

    /**
     * The containing HTML element of the chart. The container is
     * dynamically inserted into the element given as the `renderTo`
     * parameter in the {@link Highcharts#chart} constructor.
     *
     * @name Highcharts.Chart#container
     * @type {Highcharts.HTMLDOMElement}
     */

    container = createElement$2('div', {
      id: containerId
    }, containerStyle, renderTo);
    chart.container = container; // cache the cursor (#1650)

    chart._cursor = container.style.cursor; // Initialize the renderer

    Ren = Highcharts[optionsChart.renderer] || Highcharts.Renderer;
    /**
     * The renderer instance of the chart. Each chart instance has only one
     * associated renderer.
     *
     * @name Highcharts.Chart#renderer
     * @type {Highcharts.SVGRenderer}
     */

    chart.renderer = new Ren(container, chartWidth, chartHeight, null, optionsChart.forExport, options.exporting && options.exporting.allowHTML);
    chart.setClassName(optionsChart.className); // Initialize definitions

    for (key in options.defs) {
      this.renderer.definition(options.defs[key]);
    } // Add a reference to the charts index


    chart.renderer.chartIndex = chart.index;
    fireEvent$4(this, 'afterGetContainer');
  },

  /**
   * Calculate margins by rendering axis labels in a preliminary position.
   * Title, subtitle and legend have already been rendered at this stage, but
   * will be moved into their final positions.
   *
   * @private
   * @function Highcharts.Chart#getMargins
   *
   * @param  {boolean} skipAxes
   *
   * @fires Highcharts.Chart#event:getMargins
   */
  getMargins: function (skipAxes) {
    var chart = this,
        spacing = chart.spacing,
        margin = chart.margin,
        titleOffset = chart.titleOffset;
    chart.resetMargins(); // Adjust for title and subtitle

    if (titleOffset && !defined$8(margin[0])) {
      chart.plotTop = Math.max(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);
    } // Adjust for legend


    if (chart.legend && chart.legend.display) {
      chart.legend.adjustMargins(margin, spacing);
    }

    fireEvent$4(this, 'getMargins');

    if (!skipAxes) {
      this.getAxisMargins();
    }
  },

  /**
   * @private
   * @function Highcharts.Chart#getAxisMargins
   */
  getAxisMargins: function () {
    var chart = this,
        // [top, right, bottom, left]
    axisOffset = chart.axisOffset = [0, 0, 0, 0],
        margin = chart.margin; // pre-render axes to get labels offset width

    if (chart.hasCartesianSeries) {
      each$a(chart.axes, function (axis) {
        if (axis.visible) {
          axis.getOffset();
        }
      });
    } // Add the axis offsets


    each$a(marginNames$1, function (m, side) {
      if (!defined$8(margin[side])) {
        chart[m] += axisOffset[side];
      }
    });
    chart.setChartSize();
  },

  /**
   * Reflows the chart to its container. By default, the chart reflows
   * automatically to its container following a `window.resize` event, as per
   * the {@link https://api.highcharts/highcharts/chart.reflow|chart.reflow}
   * option. However, there are no reliable events for div resize, so if the
   * container is resized without a window resize event, this must be called
   * explicitly.
   *
   * @sample highcharts/members/chart-reflow/
   *         Resize div and reflow
   * @sample highcharts/chart/events-container/
   *         Pop up and reflow
   *
   * @function Highcharts.Chart#reflow
   *
   * @param  {global.Event} e
   *         Event arguments. Used primarily when the function is called
   *         internally as a response to window resize.
   */
  reflow: function (e) {
    var chart = this,
        optionsChart = chart.options.chart,
        renderTo = chart.renderTo,
        hasUserSize = defined$8(optionsChart.width) && defined$8(optionsChart.height),
        width = optionsChart.width || Highcharts.getStyle(renderTo, 'width'),
        height = optionsChart.height || Highcharts.getStyle(renderTo, 'height'),
        target = e ? e.target : win$7; // Width and height checks for display:none. Target is doc in IE8 and
    // Opera, win in Firefox, Chrome and IE9.

    if (!hasUserSize && !chart.isPrinting && width && height && (target === win$7 || target === doc$5)) {
      if (width !== chart.containerWidth || height !== chart.containerHeight) {
        Highcharts.clearTimeout(chart.reflowTimeout); // When called from window.resize, e is set, else it's called
        // directly (#2224)

        chart.reflowTimeout = syncTimeout$2(function () {
          // Set size, it may have been destroyed in the meantime
          // (#1257)
          if (chart.container) {
            chart.setSize(undefined, undefined, false);
          }
        }, e ? 100 : 0);
      }

      chart.containerWidth = width;
      chart.containerHeight = height;
    }
  },

  /**
   * Toggle the event handlers necessary for auto resizing, depending on the
   * `chart.reflow` option.
   *
   * @private
   * @function Highcharts.Chart#setReflow
   *
   * @param  {boolean} reflow
   */
  setReflow: function (reflow) {
    var chart = this;

    if (reflow !== false && !this.unbindReflow) {
      this.unbindReflow = addEvent$5(win$7, 'resize', function (e) {
        chart.reflow(e);
      });
      addEvent$5(this, 'destroy', this.unbindReflow);
    } else if (reflow === false && this.unbindReflow) {
      // Unbind and unset
      this.unbindReflow = this.unbindReflow();
    } // The following will add listeners to re-fit the chart before and after
    // printing (#2284). However it only works in WebKit. Should have worked
    // in Firefox, but not supported in IE.

    /*
    if (win.matchMedia) {
        win.matchMedia('print').addListener(function reflow() {
            chart.reflow();
        });
    }
    //*/

  },

  /**
   * Resize the chart to a given width and height. In order to set the width
   * only, the height argument may be skipped. To set the height only, pass
   * `undefined` for the width.
   *
   * @sample highcharts/members/chart-setsize-button/
   *         Test resizing from buttons
   * @sample highcharts/members/chart-setsize-jquery-resizable/
   *         Add a jQuery UI resizable
   * @sample stock/members/chart-setsize/
   *         Highstock with UI resizable
   *
   * @function Highcharts.Chart#setSize
   *
   * @param  {number|null|undefined} [width]
   *         The new pixel width of the chart. Since v4.2.6, the argument can
   *         be `undefined` in order to preserve the current value (when
   *         setting height only), or `null` to adapt to the width of the
   *         containing element.
   *
   * @param  {number|null|undefined} [height]
   *         The new pixel height of the chart. Since v4.2.6, the argument can
   *         be `undefined` in order to preserve the current value, or `null`
   *         in order to adapt to the height of the containing element.
   *
   * @param  {Highcharts.AnimationOptionsObject|undefined} [animation=true]
   *         Whether and how to apply animation.
   *
   * @fires Highcharts.Chart#event:endResize
   * @fires Highcharts.Chart#event:resize
   */
  setSize: function (width, height, animation) {
    var chart = this,
        renderer = chart.renderer,
        globalAnimation; // Handle the isResizing counter

    chart.isResizing += 1; // set the animation for the current process

    Highcharts.setAnimation(animation, chart);
    chart.oldChartHeight = chart.chartHeight;
    chart.oldChartWidth = chart.chartWidth;

    if (width !== undefined) {
      chart.options.chart.width = width;
    }

    if (height !== undefined) {
      chart.options.chart.height = height;
    }

    chart.getChartSize(); // Resize the container with the global animation applied if enabled
    // (#2503)

    chart.setChartSize(true);
    renderer.setSize(chart.chartWidth, chart.chartHeight, animation); // handle axes

    each$a(chart.axes, function (axis) {
      axis.isDirty = true;
      axis.setScale();
    });
    chart.isDirtyLegend = true; // force legend redraw

    chart.isDirtyBox = true; // force redraw of plot and chart border

    chart.layOutTitles(); // #2857

    chart.getMargins();
    chart.redraw(animation);
    chart.oldChartHeight = null;
    fireEvent$4(chart, 'resize'); // Fire endResize and set isResizing back. If animation is disabled,
    // fire without delay

    syncTimeout$2(function () {
      if (chart) {
        fireEvent$4(chart, 'endResize', null, function () {
          chart.isResizing -= 1;
        });
      }
    }, animObject$1(globalAnimation).duration);
  },

  /**
   * Set the public chart properties. This is done before and after the
   * pre-render to determine margin sizes.
   *
   * @private
   * @function Highcharts.Chart#setChartSize
   *
   * @param  {boolean} skipAxes
   *
   * @fires Highcharts.Chart#event:afterSetChartSize
   */
  setChartSize: function (skipAxes) {
    var chart = this,
        inverted = chart.inverted,
        renderer = chart.renderer,
        chartWidth = chart.chartWidth,
        chartHeight = chart.chartHeight,
        optionsChart = chart.options.chart,
        spacing = chart.spacing,
        clipOffset = chart.clipOffset,
        clipX,
        clipY,
        plotLeft,
        plotTop,
        plotWidth,
        plotHeight,
        plotBorderWidth;
    /**
     * The current left position of the plot area in pixels.
     *
     * @name Highcharts.Chart#plotLeft
     * @type {number}
     */

    chart.plotLeft = plotLeft = Math.round(chart.plotLeft);
    /**
     * The current top position of the plot area in pixels.
     *
     * @name Highcharts.Chart#plotTop
     * @type {number}
     */

    chart.plotTop = plotTop = Math.round(chart.plotTop);
    /**
     * The current width of the plot area in pixels.
     *
     * @name Highcharts.Chart#plotWidth
     * @type {number}
     */

    chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));
    /**
     * The current height of the plot area in pixels.
     *
     * @name Highcharts.Chart#plotHeight
     * @type {number}
     */

    chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));
    chart.plotSizeX = inverted ? plotHeight : plotWidth;
    chart.plotSizeY = inverted ? plotWidth : plotHeight;
    chart.plotBorderWidth = optionsChart.plotBorderWidth || 0; // Set boxes used for alignment

    chart.spacingBox = renderer.spacingBox = {
      x: spacing[3],
      y: spacing[0],
      width: chartWidth - spacing[3] - spacing[1],
      height: chartHeight - spacing[0] - spacing[2]
    };
    chart.plotBox = renderer.plotBox = {
      x: plotLeft,
      y: plotTop,
      width: plotWidth,
      height: plotHeight
    };
    plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2);
    clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2);
    clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);
    chart.clipBox = {
      x: clipX,
      y: clipY,
      width: Math.floor(chart.plotSizeX - Math.max(plotBorderWidth, clipOffset[1]) / 2 - clipX),
      height: Math.max(0, Math.floor(chart.plotSizeY - Math.max(plotBorderWidth, clipOffset[2]) / 2 - clipY))
    };

    if (!skipAxes) {
      each$a(chart.axes, function (axis) {
        axis.setAxisSize();
        axis.setAxisTranslation();
      });
    }

    fireEvent$4(chart, 'afterSetChartSize', {
      skipAxes: skipAxes
    });
  },

  /**
   * Initial margins before auto size margins are applied.
   *
   * @private
   * @function Highcharts.Chart#resetMargins
   */
  resetMargins: function () {
    var chart = this,
        chartOptions = chart.options.chart; // Create margin and spacing array

    each$a(['margin', 'spacing'], function splashArrays(target) {
      var value = chartOptions[target],
          values = isObject$3(value) ? value : [value, value, value, value];
      each$a(['Top', 'Right', 'Bottom', 'Left'], function (sideName, side) {
        chart[target][side] = pick$b(chartOptions[target + sideName], values[side]);
      });
    }); // Set margin names like chart.plotTop, chart.plotLeft,
    // chart.marginRight, chart.marginBottom.

    each$a(marginNames$1, function (m, side) {
      chart[m] = pick$b(chart.margin[side], chart.spacing[side]);
    });
    chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left

    chart.clipOffset = [0, 0, 0, 0];
  },

  /**
   * Internal function to draw or redraw the borders and backgrounds for chart
   * and plot area.
   *
   * @private
   * @function Highcharts.Chart#drawChartBox
   *
   * @fires Highcharts.Chart#event:afterDrawChartBox
   */
  drawChartBox: function () {
    var chart = this,
        optionsChart = chart.options.chart,
        renderer = chart.renderer,
        chartWidth = chart.chartWidth,
        chartHeight = chart.chartHeight,
        chartBackground = chart.chartBackground,
        plotBackground = chart.plotBackground,
        plotBorder = chart.plotBorder,
        chartBorderWidth,
        mgn,
        plotLeft = chart.plotLeft,
        plotTop = chart.plotTop,
        plotWidth = chart.plotWidth,
        plotHeight = chart.plotHeight,
        plotBox = chart.plotBox,
        clipRect = chart.clipRect,
        clipBox = chart.clipBox,
        verb = 'animate'; // Chart area

    if (!chartBackground) {
      chart.chartBackground = chartBackground = renderer.rect().addClass('highcharts-background').add();
      verb = 'attr';
    }

    chartBorderWidth = mgn = chartBackground.strokeWidth();
    chartBackground[verb]({
      x: mgn / 2,
      y: mgn / 2,
      width: chartWidth - mgn - chartBorderWidth % 2,
      height: chartHeight - mgn - chartBorderWidth % 2,
      r: optionsChart.borderRadius
    }); // Plot background

    verb = 'animate';

    if (!plotBackground) {
      verb = 'attr';
      chart.plotBackground = plotBackground = renderer.rect().addClass('highcharts-plot-background').add();
    }

    plotBackground[verb](plotBox); // Plot clip

    if (!clipRect) {
      chart.clipRect = renderer.clipRect(clipBox);
    } else {
      clipRect.animate({
        width: clipBox.width,
        height: clipBox.height
      });
    } // Plot area border


    verb = 'animate';

    if (!plotBorder) {
      verb = 'attr';
      chart.plotBorder = plotBorder = renderer.rect().addClass('highcharts-plot-border').attr({
        zIndex: 1 // Above the grid

      }).add();
    }

    plotBorder[verb](plotBorder.crisp({
      x: plotLeft,
      y: plotTop,
      width: plotWidth,
      height: plotHeight
    }, -plotBorder.strokeWidth())); // #3282 plotBorder should be negative;
    // reset

    chart.isDirtyBox = false;
    fireEvent$4(this, 'afterDrawChartBox');
  },

  /**
   * Detect whether a certain chart property is needed based on inspecting its
   * options and series. This mainly applies to the chart.inverted property,
   * and in extensions to the chart.angular and chart.polar properties.
   *
   * @private
   * @function Highcharts.Chart#propFromSeries
   */
  propFromSeries: function () {
    var chart = this,
        optionsChart = chart.options.chart,
        klass,
        seriesOptions = chart.options.series,
        i,
        value;
    each$a(['inverted', 'angular', 'polar'], function (key) {
      // The default series type's class
      klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType]; // Get the value from available chart-wide properties

      value = optionsChart[key] || // It is set in the options
      klass && klass.prototype[key]; // The default series class
      // requires it
      // 4. Check if any the chart's series require it

      i = seriesOptions && seriesOptions.length;

      while (!value && i--) {
        klass = seriesTypes[seriesOptions[i].type];

        if (klass && klass.prototype[key]) {
          value = true;
        }
      } // Set the chart property


      chart[key] = value;
    });
  },

  /**
   * Internal function to link two or more series together, based on the
   * `linkedTo` option. This is done from `Chart.render`, and after
   * `Chart.addSeries` and `Series.remove`.
   *
   * @private
   * @function Highcharts.Chart#linkSeries
   *
   * @fires Highcharts.Chart#event:afterLinkSeries
   */
  linkSeries: function () {
    var chart = this,
        chartSeries = chart.series; // Reset links

    each$a(chartSeries, function (series) {
      series.linkedSeries.length = 0;
    }); // Apply new links

    each$a(chartSeries, function (series) {
      var linkedTo = series.options.linkedTo;

      if (isString$3(linkedTo)) {
        if (linkedTo === ':previous') {
          linkedTo = chart.series[series.index - 1];
        } else {
          linkedTo = chart.get(linkedTo);
        } // #3341 avoid mutual linking


        if (linkedTo && linkedTo.linkedParent !== series) {
          linkedTo.linkedSeries.push(series);
          series.linkedParent = linkedTo;
          series.visible = pick$b(series.options.visible, linkedTo.options.visible, series.visible); // #3879
        }
      }
    });
    fireEvent$4(this, 'afterLinkSeries');
  },

  /**
   * Render series for the chart.
   *
   * @private
   * @function Highcharts.Chart#renderSeries
   */
  renderSeries: function () {
    each$a(this.series, function (serie) {
      serie.translate();
      serie.render();
    });
  },

  /**
   * Render labels for the chart.
   *
   * @private
   * @function Highcharts.Chart#renderLabels
   */
  renderLabels: function () {
    var chart = this,
        labels = chart.options.labels;

    if (labels.items) {
      each$a(labels.items, function (label) {
        var style = extend$8(labels.style, label.style),
            x = pInt$3(style.left) + chart.plotLeft,
            y = pInt$3(style.top) + chart.plotTop + 12; // delete to prevent rewriting in IE

        delete style.left;
        delete style.top;
        chart.renderer.text(label.html, x, y).attr({
          zIndex: 2
        }).css(style).add();
      });
    }
  },

  /**
   * Render all graphics for the chart. Runs internally on initialization.
   *
   * @private
   * @function Highcharts.Chart#render
   */
  render: function () {
    var chart = this,
        axes = chart.axes,
        renderer = chart.renderer,
        options = chart.options,
        tempWidth,
        tempHeight,
        redoHorizontal,
        redoVertical; // Title

    chart.setTitle();
    /**
     * The overview of the chart's series.
     *
     * @name Highcharts.Chart#legend
     * @type {Highcharts.Legend}
     */

    chart.legend = new Legend(chart, options.legend); // Get stacks

    if (chart.getStacks) {
      chart.getStacks();
    } // Get chart margins


    chart.getMargins(true);
    chart.setChartSize(); // Record preliminary dimensions for later comparison

    tempWidth = chart.plotWidth; // 21 is the most common correction for X axis labels
    // use Math.max to prevent negative plotHeight

    tempHeight = chart.plotHeight = Math.max(chart.plotHeight - 21, 0); // Get margins by pre-rendering axes

    each$a(axes, function (axis) {
      axis.setScale();
    });
    chart.getAxisMargins(); // If the plot area size has changed significantly, calculate tick
    // positions again

    redoHorizontal = tempWidth / chart.plotWidth > 1.1; // Height is more sensitive, use lower threshold

    redoVertical = tempHeight / chart.plotHeight > 1.05;

    if (redoHorizontal || redoVertical) {
      each$a(axes, function (axis) {
        if (axis.horiz && redoHorizontal || !axis.horiz && redoVertical) {
          // update to reflect the new margins
          axis.setTickInterval(true);
        }
      });
      chart.getMargins(); // second pass to check for new labels
    } // Draw the borders and backgrounds


    chart.drawChartBox(); // Axes

    if (chart.hasCartesianSeries) {
      each$a(axes, function (axis) {
        if (axis.visible) {
          axis.render();
        }
      });
    } // The series


    if (!chart.seriesGroup) {
      chart.seriesGroup = renderer.g('series-group').attr({
        zIndex: 3
      }).add();
    }

    chart.renderSeries(); // Labels

    chart.renderLabels(); // Credits

    chart.addCredits(); // Handle responsiveness

    if (chart.setResponsive) {
      chart.setResponsive();
    } // Set flag


    chart.hasRendered = true;
  },

  /**
   * Set a new credits label for the chart.
   *
   * @sample highcharts/credits/credits-update/
   *         Add and update credits
   *
   * @function Highcharts.Chart#addCredits
   *
   * @param  {Highcharts.CreditsOptions} options
   *         A configuration object for the new credits.
   */
  addCredits: function (credits) {
    var chart = this;
    credits = merge$9(true, this.options.credits, credits);

    if (credits.enabled && !this.credits) {
      /**
       * The chart's credits label. The label has an `update` method that
       * allows setting new options as per the
       * {@link https://api.highcharts.com/highcharts/credits|credits options set}.
       *
       * @name Highcharts.Chart#credits
       * @type {Highcharts.SVGElement}
       */
      this.credits = this.renderer.text(credits.text + (this.mapCredits || ''), 0, 0).addClass('highcharts-credits').on('click', function () {
        if (credits.href) {
          win$7.location.href = credits.href;
        }
      }).attr({
        align: credits.position.align,
        zIndex: 8
      }).add().align(credits.position); // Dynamically update

      this.credits.update = function (options) {
        chart.credits = chart.credits.destroy();
        chart.addCredits(options);
      };
    }
  },

  /**
   * Remove the chart and purge memory. This method is called internally
   * before adding a second chart into the same container, as well as on
   * window unload to prevent leaks.
   *
   * @sample highcharts/members/chart-destroy/
   *         Destroy the chart from a button
   * @sample stock/members/chart-destroy/
   *         Destroy with Highstock
   *
   * @function Highcharts.Chart#destroy
   *
   * @fires Highcharts.Chart#event:destroy
   */
  destroy: function () {
    var chart = this,
        axes = chart.axes,
        series = chart.series,
        container = chart.container,
        i,
        parentNode = container && container.parentNode; // fire the chart.destoy event

    fireEvent$4(chart, 'destroy'); // Delete the chart from charts lookup array

    if (chart.renderer.forExport) {
      Highcharts.erase(charts$5, chart); // #6569
    } else {
      charts$5[chart.index] = undefined;
    }

    Highcharts.chartCount--;
    chart.renderTo.removeAttribute('data-highcharts-chart'); // remove events

    removeEvent$3(chart); // ==== Destroy collections:
    // Destroy axes

    i = axes.length;

    while (i--) {
      axes[i] = axes[i].destroy();
    } // Destroy scroller & scroller series before destroying base series


    if (this.scroller && this.scroller.destroy) {
      this.scroller.destroy();
    } // Destroy each series


    i = series.length;

    while (i--) {
      series[i] = series[i].destroy();
    } // ==== Destroy chart properties:


    each$a(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {
      var prop = chart[name];

      if (prop && prop.destroy) {
        chart[name] = prop.destroy();
      }
    }); // Remove container and all SVG, check container as it can break in IE
    // when destroyed before finished loading

    if (container) {
      container.innerHTML = '';
      removeEvent$3(container);

      if (parentNode) {
        discardElement$1(container);
      }
    } // clean it all up


    objectEach$2(chart, function (val, key) {
      delete chart[key];
    });
  },

  /**
   * Prepare for first rendering after all data are loaded.
   *
   * @private
   * @function Highcharts.Chart#firstRender
   *
   * @fires Highcharts.Chart#event:beforeRender
   */
  firstRender: function () {
    var chart = this,
        options = chart.options; // Hook for oldIE to check whether the chart is ready to render

    if (chart.isReadyToRender && !chart.isReadyToRender()) {
      return;
    } // Create the container


    chart.getContainer();
    chart.resetMargins();
    chart.setChartSize(); // Set the common chart properties (mainly invert) from the given series

    chart.propFromSeries(); // get axes

    chart.getAxes(); // Initialize the series

    each$a(options.series || [], function (serieOptions) {
      chart.initSeries(serieOptions);
    });
    chart.linkSeries(); // Run an event after axes and series are initialized, but before
    // render. At this stage, the series data is indexed and cached in the
    // xData and yData arrays, so we can access those before rendering. Used
    // in Highstock.

    fireEvent$4(chart, 'beforeRender'); // depends on inverted and on margins being set

    if (Pointer$2) {
      /**
       * The Pointer that keeps track of mouse and touch interaction.
       *
       * @memberof Highcharts.Chart
       * @name pointer
       * @type {Highcharts.Pointer}
       * @instance
       */
      chart.pointer = new Pointer$2(chart, options);
    }

    chart.render(); // Fire the load event if there are no external images

    if (!chart.renderer.imgCount && chart.onload) {
      chart.onload();
    } // If the chart was rendered outside the top container, put it back in
    // (#3679)


    chart.temporaryDisplay(true);
  },

  /**
   * Internal function that runs on chart load, async if any images are loaded
   * in the chart. Runs the callbacks and triggers the `load` and `render`
   * events.
   *
   * @private
   * @function Highcharts.Chart#onload
   *
   * @fires Highcharts.Chart#event:load
   * @fires Highcharts.Chart#event:render
   */
  onload: function () {
    // Run callbacks
    each$a([this.callback].concat(this.callbacks), function (fn) {
      // Chart destroyed in its own callback (#3600)
      if (fn && this.index !== undefined) {
        fn.apply(this, [this]);
      }
    }, this);
    fireEvent$4(this, 'load');
    fireEvent$4(this, 'render'); // Set up auto resize, check for not destroyed (#6068)

    if (defined$8(this.index)) {
      this.setReflow(this.options.chart.reflow);
    } // Don't run again


    this.onload = null;
  }
}); // end Chart

/**
 * (c) 2010-2018 Torstein Honsi
 *
 * License: www.highcharts.com/license
 *
 * Highcharts feature to make the Y axis stay fixed when scrolling the chart
 * horizontally on mobile devices. Supports left and right side axes.
 */
var addEvent$6 = Highcharts.addEvent,
    Chart$1 = Highcharts.Chart,
    each$b = Highcharts.each;
/**
 * Options for a scrollable plot area. This feature provides a minimum width for
 * the plot area of the chart. If the width gets smaller than this, typically
 * on mobile devices, a native browser scrollbar is presented below the chart.
 * This scrollbar provides smooth scrolling for the contents of the plot area,
 * whereas the title, legend and axes are fixed.
 *
 * @type    {Object}
 * @sample  {highcharts} highcharts/chart/scrollable-plotarea
 *          Scrollable plot area
 * @since   6.1.0
 * @product highcharts
 * @apioption chart.scrollablePlotArea
 */

/**
 * The minimum width for the plot area. If it gets smaller than this, the plot
 * area will become scrollable.
 *
 * @type    {Number}
 * @apioption chart.scrollablePlotArea.minWidth
 */

/**
 * The initial scrolling position of the scrollable plot area. Ranges from 0 to
 * 1, where 0 aligns the plot area to the left and 1 aligns it to the right.
 * Typically we would use 1 if the chart has right aligned Y axes.
 *
 * @type    {Number}
 * @apioption chart.scrollablePlotArea.scrollPositionX
 */

addEvent$6(Chart$1, 'afterSetChartSize', function (e) {
  var scrollablePlotArea = this.options.chart.scrollablePlotArea,
      scrollableMinWidth = scrollablePlotArea && scrollablePlotArea.minWidth,
      scrollablePixels;

  if (scrollableMinWidth && !this.renderer.forExport) {
    // The amount of pixels to scroll, the difference between chart
    // width and scrollable width
    this.scrollablePixels = scrollablePixels = Math.max(0, scrollableMinWidth - this.chartWidth);

    if (scrollablePixels) {
      this.plotWidth += scrollablePixels;
      this.clipBox.width += scrollablePixels;

      if (!e.skipAxes) {
        each$b(this.axes, function (axis) {
          if (axis.side === 1) {
            // Get the plot lines right in getPlotLinePath,
            // temporarily set it to the adjusted plot width.
            axis.getPlotLinePath = function () {
              var right = this.right,
                  path;
              this.right = right - axis.chart.scrollablePixels;
              path = Highcharts.Axis.prototype.getPlotLinePath.apply(this, arguments);
              this.right = right;
              return path;
            };
          } else {
            // Apply the corrected plotWidth
            axis.setAxisSize();
            axis.setAxisTranslation();
          }
        });
      }
    }
  }
});
addEvent$6(Chart$1, 'render', function () {
  if (this.scrollablePixels) {
    if (this.setUpScrolling) {
      this.setUpScrolling();
    }

    this.applyFixed();
  } else if (this.fixedDiv) {
    // Has been in scrollable mode
    this.applyFixed();
  }
});

Chart$1.prototype.setUpScrolling = function () {
  // Add the necessary divs to provide scrolling
  this.scrollingContainer = Highcharts.createElement('div', {
    'className': 'highcharts-scrolling'
  }, {
    overflowX: 'auto',
    WebkitOverflowScrolling: 'touch'
  }, this.renderTo);
  this.innerContainer = Highcharts.createElement('div', {
    'className': 'highcharts-inner-container'
  }, null, this.scrollingContainer); // Now move the container inside

  this.innerContainer.appendChild(this.container); // Don't run again

  this.setUpScrolling = null;
};

Chart$1.prototype.applyFixed = function () {
  var container = this.container,
      fixedRenderer,
      scrollableWidth,
      firstTime = !this.fixedDiv; // First render

  if (firstTime) {
    this.fixedDiv = Highcharts.createElement('div', {
      className: 'highcharts-fixed'
    }, {
      position: 'absolute',
      overflow: 'hidden',
      pointerEvents: 'none',
      zIndex: 2
    }, null, true);
    this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild);
    this.fixedRenderer = fixedRenderer = new Highcharts.Renderer(this.fixedDiv, 0, 0); // Mask

    this.scrollableMask = fixedRenderer.path().attr({
      fill: Highcharts.color(this.options.chart.backgroundColor || '#fff').setOpacity(0.85).get(),
      zIndex: -1
    }).addClass('highcharts-scrollable-mask').add(); // These elements are moved over to the fixed renderer and stay fixed
    // when the user scrolls the chart.

    Highcharts.each([this.inverted ? '.highcharts-xaxis' : '.highcharts-yaxis', this.inverted ? '.highcharts-xaxis-labels' : '.highcharts-yaxis-labels', '.highcharts-contextbutton', '.highcharts-credits', '.highcharts-legend', '.highcharts-subtitle', '.highcharts-title', '.highcharts-legend-checkbox'], function (className) {
      Highcharts.each(container.querySelectorAll(className), function (elem) {
        (elem.namespaceURI === fixedRenderer.SVG_NS ? fixedRenderer.box : fixedRenderer.box.parentNode).appendChild(elem);
        elem.style.pointerEvents = 'auto';
      });
    });
  } // Set the size of the fixed renderer to the visible width


  this.fixedRenderer.setSize(this.chartWidth, this.chartHeight); // Increase the size of the scrollable renderer and background

  scrollableWidth = this.chartWidth + this.scrollablePixels;
  Highcharts.stop(this.container);
  this.container.style.width = scrollableWidth + 'px';
  this.renderer.boxWrapper.attr({
    width: scrollableWidth,
    height: this.chartHeight,
    viewBox: [0, 0, scrollableWidth, this.chartHeight].join(' ')
  });
  this.chartBackground.attr({
    width: scrollableWidth
  }); // Set scroll position

  if (firstTime) {
    var options = this.options.chart.scrollablePlotArea;

    if (options.scrollPositionX) {
      this.scrollingContainer.scrollLeft = this.scrollablePixels * options.scrollPositionX;
    }
  } // Mask behind the left and right side


  var axisOffset = this.axisOffset,
      maskTop = this.plotTop - axisOffset[0] - 1,
      maskBottom = this.plotTop + this.plotHeight + axisOffset[2],
      maskPlotRight = this.plotLeft + this.plotWidth - this.scrollablePixels;
  this.scrollableMask.attr({
    d: this.scrollablePixels ? [// Left side
    'M', 0, maskTop, 'L', this.plotLeft - 1, maskTop, 'L', this.plotLeft - 1, maskBottom, 'L', 0, maskBottom, 'Z', // Right side
    'M', maskPlotRight, maskTop, 'L', this.chartWidth, maskTop, 'L', this.chartWidth, maskBottom, 'L', maskPlotRight, maskBottom, 'Z'] : ['M', 0, 0]
  });
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var Point,
    H$3 = Highcharts,
    each$c = H$3.each,
    extend$9 = H$3.extend,
    erase$2 = H$3.erase,
    fireEvent$5 = H$3.fireEvent,
    format$2 = H$3.format,
    isArray$2 = H$3.isArray,
    isNumber$6 = H$3.isNumber,
    pick$c = H$3.pick,
    removeEvent$4 = H$3.removeEvent;
/**
 * The Point object. The point objects are generated from the `series.data`
 * configuration objects or raw numbers. They can be accessed from the
 * `Series.points` array. Other ways to instantiate points are through {@link
 * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.
 *
 * @class
 * @name Highcharts.Point
 */

Highcharts.Point = Point = function () {};

Highcharts.Point.prototype = {
  /**
   * Initialize the point. Called internally based on the `series.data`
   * option.
   *
   * @function Highcharts.Point#init
   *
   * @param {Highcharts.Series} series
   *        The series object containing this point.
   *
   * @param {number|Array<number>|*} options
   *        The data in either number, array or object format.
   *
   * @param {number} x
   *        Optionally, the X value of the point.
   *
   * @return {Highcharts.Point}
   *         The Point instance.
   *
   * @fires Highcharts.Point#event:afterInit
   */
  init: function (series, options, x) {
    var point = this,
        colorCount = series.chart.options.chart.colorCount,
        colorIndex;
    /**
     * The series object associated with the point.
     *
     * @name Highcharts.Point#series
     * @type {Highcharts.Series}
     */

    point.series = series;
    point.applyOptions(options, x);

    if (series.options.colorByPoint) {
      colorIndex = series.colorCounter;
      series.colorCounter++; // loop back to zero

      if (series.colorCounter === colorCount) {
        series.colorCounter = 0;
      }
    } else {
      colorIndex = series.colorIndex;
    }
    /**
     * The point's current color index, used in styled mode instead of
     * `color`. The color index is inserted in class names used for styling.
     *
     * @name Highcharts.Point#colorIndex
     * @type {number}
     */


    point.colorIndex = pick$c(point.colorIndex, colorIndex);
    series.chart.pointCount++;
    fireEvent$5(point, 'afterInit');
    return point;
  },

  /**
   * Apply the options containing the x and y data and possible some extra
   * properties. Called on point init or from point.update.
   *
   * @private
   * @function Highcharts.Point#applyOptions
   *
   * @param {*} options
   *        The point options as defined in series.data.
   *
   * @param {number} x
   *        Optionally, the x value.
   *
   * @return {Highcharts.Point}
   *         The Point instance.
   */
  applyOptions: function (options, x) {
    var point = this,
        series = point.series,
        pointValKey = series.options.pointValKey || series.pointValKey;
    options = Point.prototype.optionsToObject.call(this, options); // copy options directly to point

    extend$9(point, options);
    /**
     * The point's options as applied in the initial configuration, or
     * extended through `Point.update`.
     *
     * @name Highcharts.Point#options
     * @type {*}
     */

    point.options = point.options ? extend$9(point.options, options) : options; // Since options are copied into the Point instance, some accidental
    // options must be shielded (#5681)

    if (options.group) {
      delete point.group;
    }
    /**
     * The y value of the point.
     *
     * @name Highcharts.Point#y
     * @type {number|undefined}
     */
    // For higher dimension series types. For instance, for ranges, point.y
    // is mapped to point.low.


    if (pointValKey) {
      point.y = point[pointValKey];
    }

    point.isNull = pick$c(point.isValid && !point.isValid(), point.x === null || !isNumber$6(point.y, true)); // #3571, check for NaN
    // The point is initially selected by options (#5777)

    if (point.selected) {
      point.state = 'select';
    }
    /**
     * The x value of the point.
     *
     * @name Highcharts.Point#x
     * @type {number}
     */
    // If no x is set by now, get auto incremented value. All points must
    // have an x value, however the y value can be null to create a gap in
    // the series


    if ('name' in point && x === undefined && series.xAxis && series.xAxis.hasNames) {
      point.x = series.xAxis.nameToX(point);
    }

    if (point.x === undefined && series) {
      if (x === undefined) {
        point.x = series.autoIncrement(point);
      } else {
        point.x = x;
      }
    }

    return point;
  },

  /**
   * Set a value in an object, on the property defined by key. The key
   * supports nested properties using dot notation. The function modifies the
   * input object and does not make a copy.
   *
   * @function Highcharts.Point#setNestedProperty
   *
   * @param {*} object
   *        The object to set the value on.
   *
   * @param {*} value
   *        The value to set.
   *
   * @param {string} key
   *        Key to the property to set.
   *
   * @return {*}
   *         The modified object.
   */
  setNestedProperty: function (object, value, key) {
    var nestedKeys = key.split('.');
    H$3.reduce(nestedKeys, function (result, key, i, arr) {
      var isLastKey = arr.length - 1 === i;
      result[key] = isLastKey ? value : H$3.isObject(result[key], true) ? result[key] : {};
      return result[key];
    }, object);
    return object;
  },

  /**
   * Transform number or array configs into objects. Used internally to unify
   * the different configuration formats for points. For example, a simple
   * number `10` in a line series will be transformed to `{ y: 10 }`, and an
   * array config like `[1, 10]` in a scatter series will be transformed to
   * `{ x: 1, y: 10 }`.
   *
   * @function Highcharts.Point#optionsToObject
   *
   * @param {number|Array<number>|*} options
   *        The input option.
   *
   * @return {*}
   *         Transformed options.
   */
  optionsToObject: function (options) {
    var ret = {},
        series = this.series,
        keys = series.options.keys,
        pointArrayMap = keys || series.pointArrayMap || ['y'],
        valueCount = pointArrayMap.length,
        firstItemType,
        i = 0,
        j = 0;

    if (isNumber$6(options) || options === null) {
      ret[pointArrayMap[0]] = options;
    } else if (isArray$2(options)) {
      // with leading x value
      if (!keys && options.length > valueCount) {
        firstItemType = typeof options[0];

        if (firstItemType === 'string') {
          ret.name = options[0];
        } else if (firstItemType === 'number') {
          ret.x = options[0];
        }

        i++;
      }

      while (j < valueCount) {
        // Skip undefined positions for keys
        if (!keys || options[i] !== undefined) {
          if (pointArrayMap[j].indexOf('.') > 0) {
            // Handle nested keys, e.g. ['color.pattern.image']
            // Avoid function call unless necessary.
            H$3.Point.prototype.setNestedProperty(ret, options[i], pointArrayMap[j]);
          } else {
            ret[pointArrayMap[j]] = options[i];
          }
        }

        i++;
        j++;
      }
    } else if (typeof options === 'object') {
      ret = options; // This is the fastest way to detect if there are individual point
      // dataLabels that need to be considered in drawDataLabels. These
      // can only occur in object configs.

      if (options.dataLabels) {
        series._hasPointLabels = true;
      } // Same approach as above for markers


      if (options.marker) {
        series._hasPointMarkers = true;
      }
    }

    return ret;
  },

  /**
   * Get the CSS class names for individual points. Used internally where the
   * returned value is set on every point.
   *
   * @function Highcharts.Point#getClassName
   *
   * @return {string}
   *         The class names.
   */
  getClassName: function () {
    return 'highcharts-point' + (this.selected ? ' highcharts-point-select' : '') + (this.negative ? ' highcharts-negative' : '') + (this.isNull ? ' highcharts-null-point' : '') + (this.colorIndex !== undefined ? ' highcharts-color-' + this.colorIndex : '') + (this.options.className ? ' ' + this.options.className : '') + (this.zone && this.zone.className ? ' ' + this.zone.className.replace('highcharts-negative', '') : '');
  },

  /**
   * In a series with `zones`, return the zone that the point belongs to.
   *
   * @function Highcharts.Point#getZone
   *
   * @return {Highcharts.PlotSeriesZonesOptions}
   *         The zone item.
   */
  getZone: function () {
    var series = this.series,
        zones = series.zones,
        zoneAxis = series.zoneAxis || 'y',
        i = 0,
        zone;
    zone = zones[i];

    while (this[zoneAxis] >= zone.value) {
      zone = zones[++i];
    } // For resetting or reusing the point (#8100)


    if (!this.nonZonedColor) {
      this.nonZonedColor = this.color;
    }

    if (zone && zone.color && !this.options.color) {
      this.color = zone.color;
    } else {
      this.color = this.nonZonedColor;
    }

    return zone;
  },

  /**
   * Destroy a point to clear memory. Its reference still stays in
   * `series.data`.
   *
   * @private
   * @function Highcharts.Point#destroy
   */
  destroy: function () {
    var point = this,
        series = point.series,
        chart = series.chart,
        hoverPoints = chart.hoverPoints,
        prop;
    chart.pointCount--;

    if (hoverPoints) {
      point.setState();
      erase$2(hoverPoints, point);

      if (!hoverPoints.length) {
        chart.hoverPoints = null;
      }
    }

    if (point === chart.hoverPoint) {
      point.onMouseOut();
    } // Remove all events


    if (point.graphic || point.dataLabel) {
      removeEvent$4(point);
      point.destroyElements();
    }

    if (point.legendItem) {
      // pies have legend items
      chart.legend.destroyItem(point);
    }

    for (prop in point) {
      point[prop] = null;
    }
  },

  /**
   * Destroy SVG elements associated with the point.
   *
   * @private
   * @function Highcharts.Point#destroyElements
   */
  destroyElements: function () {
    var point = this,
        props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],
        prop,
        i = 6;

    while (i--) {
      prop = props[i];

      if (point[prop]) {
        point[prop] = point[prop].destroy();
      }
    }
  },

  /**
   * Return the configuration hash needed for the data label and tooltip
   * formatters.
   *
   * @function Highcharts.Point#getLabelConfig
   *
   * @return {Highcharts.PointLabelObject}
   *         Abstract object used in formatters and formats.
   */
  getLabelConfig: function () {
    return {
      x: this.category,
      y: this.y,
      color: this.color,
      colorIndex: this.colorIndex,
      key: this.name || this.category,
      series: this.series,
      point: this,
      percentage: this.percentage,
      total: this.total || this.stackTotal
    };
  },

  /**
   * Extendable method for formatting each point's tooltip line.
   *
   * @function Highcharts.Point#tooltipFormatter
   *
   * @param {string} pointFormat
   *        The point format.
   *
   * @return {string}
   *         A string to be concatenated in to the common tooltip text.
   */
  tooltipFormatter: function (pointFormat) {
    // Insert options for valueDecimals, valuePrefix, and valueSuffix
    var series = this.series,
        seriesTooltipOptions = series.tooltipOptions,
        valueDecimals = pick$c(seriesTooltipOptions.valueDecimals, ''),
        valuePrefix = seriesTooltipOptions.valuePrefix || '',
        valueSuffix = seriesTooltipOptions.valueSuffix || ''; // Loop over the point array map and replace unformatted values with
    // sprintf formatting markup

    each$c(series.pointArrayMap || ['y'], function (key) {
      key = '{point.' + key; // without the closing bracket

      if (valuePrefix || valueSuffix) {
        pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), valuePrefix + key + '}' + valueSuffix);
      }

      pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), key + ':,.' + valueDecimals + 'f}');
    });
    return format$2(pointFormat, {
      point: this,
      series: this.series
    }, series.chart.time);
  },

  /**
   * Fire an event on the Point object.
   *
   * @private
   * @function Highcharts.Point#firePointEvent
   *
   * @param {string} eventType
   *        Type of the event.
   *
   * @param {*} eventArgs
   *        Additional event arguments.
   *
   * @param {Function} defaultFunction
   *        Default event handler.
   *
   * @fires Highcharts.Point#event:*
   */
  firePointEvent: function (eventType, eventArgs, defaultFunction) {
    var point = this,
        series = this.series,
        seriesOptions = series.options; // load event handlers on demand to save time on mouseover/out

    if (seriesOptions.point.events[eventType] || point.options && point.options.events && point.options.events[eventType]) {
      this.importEvents();
    } // add default handler if in selection mode


    if (eventType === 'click' && seriesOptions.allowPointSelect) {
      defaultFunction = function (event) {
        // Control key is for Windows, meta (= Cmd key) for Mac, Shift
        // for Opera.
        if (point.select) {
          // #2911
          point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
        }
      };
    }

    fireEvent$5(this, eventType, eventArgs, defaultFunction);
  },

  /**
   * For certain series types, like pie charts, where individual points can
   * be shown or hidden.
   *
   * @name Highcharts.Point#visible
   * @type {boolean}
   */
  visible: true
};
/**
 * For categorized axes this property holds the category name for the
 * point. For other axes it holds the X value.
 *
 * @name Highcharts.Point#category
 * @type {number|string}
 */

/**
 * The name of the point. The name can be given as the first position of the
 * point configuration array, or as a `name` property in the configuration:
 *
 * @example
 * // Array config
 * data: [
 *     ['John', 1],
 *     ['Jane', 2]
 * ]
 *
 * // Object config
 * data: [{
 *        name: 'John',
 *        y: 1
 * }, {
 *     name: 'Jane',
 *     y: 2
 * }]
 *
 * @name Highcharts.Point#name
 * @type {string}
 */

/**
 * The percentage for points in a stacked series or pies.
 *
 * @name Highcharts.Point#percentage
 * @type {number}
 */

/**
 * The total of values in either a stack for stacked series, or a pie in a pie
 * series.
 *
 * @name Highcharts.Point#total
 * @type {number}
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$7 = Highcharts.addEvent,
    animObject$2 = Highcharts.animObject,
    arrayMax$2 = Highcharts.arrayMax,
    arrayMin$2 = Highcharts.arrayMin,
    correctFloat$2 = Highcharts.correctFloat,
    defaultOptions$2 = Highcharts.defaultOptions,
    defaultPlotOptions = Highcharts.defaultPlotOptions,
    defined$9 = Highcharts.defined,
    each$d = Highcharts.each,
    erase$3 = Highcharts.erase,
    extend$a = Highcharts.extend,
    fireEvent$6 = Highcharts.fireEvent,
    grep$3 = Highcharts.grep,
    isArray$3 = Highcharts.isArray,
    isNumber$7 = Highcharts.isNumber,
    isString$4 = Highcharts.isString,
    LegendSymbolMixin = Highcharts.LegendSymbolMixin,
    // @todo add as a requirement
merge$a = Highcharts.merge,
    objectEach$3 = Highcharts.objectEach,
    pick$d = Highcharts.pick,
    Point$1 = Highcharts.Point,
    // @todo  add as a requirement
removeEvent$5 = Highcharts.removeEvent,
    splat$5 = Highcharts.splat,
    SVGElement$2 = Highcharts.SVGElement,
    syncTimeout$3 = Highcharts.syncTimeout,
    win$8 = Highcharts.win;
/**
 * This is the base series prototype that all other series types inherit from.
 * A new series is initialized either through the
 * {@link https://api.highcharts.com/highcharts/series|series}
 * option structure, or after the chart is initialized, through
 * {@link Highcharts.Chart#addSeries}.
 *
 * The object can be accessed in a number of ways. All series and point event
 * handlers give a reference to the `series` object. The chart object has a
 * {@link Highcharts.Chart.series|series} property that is a collection of all
 * the chart's series. The point objects and axis objects also have the same
 * reference.
 *
 * Another way to reference the series programmatically is by `id`. Add an id
 * in the series configuration options, and get the series object by
 * {@link Highcharts.Chart#get}.
 *
 * Configuration options for the series are given in three levels. Options for
 * all series in a chart are given in the
 * {@link https://api.highcharts.com/highcharts/plotOptions.series|
 * plotOptions.series} object. Then options for all series of a specific type
 * are given in the plotOptions of that type, for example `plotOptions.line`.
 * Next, options for one single series are given in the series array, or as
 * arguements to `chart.addSeries`.
 *
 * The data in the series is stored in various arrays.
 *
 * - First, `series.options.data` contains all the original config options for
 *   each point whether added by options or methods like `series.addPoint`.
 *
 * - Next, `series.data` contains those values converted to points, but in case
 *   the series data length exceeds the `cropThreshold`, or if the data is
 *   grouped, `series.data` doesn't contain all the points. It only contains the
 *   points that have been created on demand.
 *
 * - Then there's `series.points` that contains all currently visible point
 *   objects. In case of cropping, the cropped-away points are not part of this
 *   array. The `series.points` array starts at `series.cropStart` compared to
 *   `series.data` and `series.options.data`. If however the series data is
 *   grouped, these can't be correlated one to one.
 *
 * - `series.xData` and `series.processedXData` contain clean x values,
 *   equivalent to `series.data` and `series.points`.
 *
 * - `series.yData` and `series.processedYData` contain clean y values,
 *   equivalent to `series.data` and `series.points`.
 *
 * @class
 * @name Highcharts.Series
 *
 * @param {Highcharts.Chart} chart
 *        The chart instance.
 *
 * @param {Highcharts.PlotSeriesOptions} options
 *        The series options.
 */

/**
* The line series is the base type and is therefor the series base prototype.
*
* @private
* @class
* @name Highcharts.seriesTypes.line
*
* @augments Highcharts.Series
*/

Highcharts.Series = Highcharts.seriesType('line', null
/**
 * General options for all series types.
 *
 * @optionparent plotOptions.series
 */
, {
  // base series options

  /**
   * For some series, there is a limit that shuts down initial animation
   * by default when the total number of points in the chart is too high.
   * For example, for a column chart and its derivatives, animation doesn't
   * run if there is more than 250 points totally. To disable this cap, set
   * `animationLimit` to `Infinity`.
   *
   * @type      {number}
   * @apioption plotOptions.series.animationLimit
   */

  /**
   * Allow this series' points to be selected by clicking on the graphic
   * (columns, point markers, pie slices, map areas etc).
   *
   * @see {@link Highcharts.Chart#getSelectedPoints}.
   *
   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/
   *         Line
   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-column/
   *         Column
   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/
   *         Pie
   * @sample {highmaps} maps/plotoptions/series-allowpointselect/
   *         Map area
   * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
   *         Map bubble
   *
   * @since 1.2.0
   */
  allowPointSelect: false,

  /**
   * If true, a checkbox is displayed next to the legend item to allow
   * selecting the series. The state of the checkbox is determined by
   * the `selected` option.
   *
   * @productdesc {highmaps}
   * Note that if a `colorAxis` is defined, the color axis is represented in
   * the legend, not the series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/
   *         Show select box
   *
   * @since 1.2.0
   */
  showCheckbox: false,

  /**
   * Enable or disable the initial animation when a series is displayed.
   * The animation can also be set as a configuration object. Please
   * note that this option only applies to the initial animation of the
   * series itself. For other animations, see [chart.animation](
   * #chart.animation) and the animation parameter under the API methods. The
   * following properties are supported:
   *
   * <dl>
   *
   * <dt>duration</dt>
   *
   * <dd>The duration of the animation in milliseconds.</dd>
   *
   * <dt>easing</dt>
   *
   * <dd>Can be a string reference to an easing function set on the `Math`
   * object or a function. See the _Custom easing function_ demo below.</dd>
   *
   * </dl>
   *
   * Due to poor performance, animation is disabled in old IE browsers
   * for several chart types.
   *
   * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/
   *         Animation disabled
   * @sample {highcharts} highcharts/plotoptions/series-animation-slower/
   *         Slower animation
   * @sample {highcharts} highcharts/plotoptions/series-animation-easing/
   *         Custom easing function
   * @sample {highstock} stock/plotoptions/animation-slower/
   *         Slower animation
   * @sample {highstock} stock/plotoptions/animation-easing/
   *         Custom easing function
   * @sample {highmaps} maps/plotoptions/series-animation-true/
   *         Animation enabled on map series
   * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/
   *         Disabled on mapbubble series
   *
   * @type    {boolean|Highcharts.AnimationOptionsObject}
   * @default {highcharts} true
   * @default {highstock} true
   * @default {highmaps} false
   */
  animation: {
    /**
     * @type      {number}
     * @default   1000
     * @apioption plotOptions.series.animation.duration
     */
    duration: 1000
  },

  /**
   * An additional class name to apply to the series' graphical elements. This
   * option does not replace default class names of the graphical element.
   *
   * @type      {string}
   * @since     5.0.0
   * @apioption plotOptions.series.className
   */

  /**
   * Disable this option to allow series rendering in the whole plotting
   * area.
   *
   * **Note:** Clipping should be always enabled when
   * [chart.zoomType](#chart.zoomType) is set
   *
   * @sample {highcharts} highcharts/plotoptions/series-clip/
   *         Disabled clipping
   *
   * @default   true
   * @type      {boolean}
   * @since     3.0.0
   * @apioption plotOptions.series.clip
   */

  /**
   * The main color of the series. In line type series it applies to the
   * line and the point markers unless otherwise specified. In bar type
   * series it applies to the bars unless a color is specified per point.
   * The default value is pulled from the `options.colors` array.
   *
   * In styled mode, the color can be defined by the
   * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series
   * color can be set with the `.highcharts-series`, `.highcharts-color-{n}`,
   * `.highcharts-{type}-series` or `.highcharts-series-{n}` class, or
   * individual classes given by the `className` option.
   *
   * @productdesc {highmaps}
   * In maps, the series color is rarely used, as most choropleth maps use the
   * color to denote the value of each point. The series color can however be
   * used in a map with multiple series holding categorized data.
   *
   * @sample {highcharts} highcharts/plotoptions/series-color-general/
   *         General plot option
   * @sample {highcharts} highcharts/plotoptions/series-color-specific/
   *         One specific series
   * @sample {highcharts} highcharts/plotoptions/series-color-area/
   *         Area color
   * @sample {highcharts} highcharts/series/infographic/
   *         Pattern fill
   * @sample {highmaps} maps/demo/category-map/
   *         Category map by multiple series
   *
   * @type      {Highcharts.ColorString}
   * @apioption plotOptions.series.color
   */

  /**
   * Styled mode only. A specific color index to use for the series, so its
   * graphic representations are given the class name `highcharts-color-{n}`.
   *
   * @type      {number}
   * @since     5.0.0
   * @apioption plotOptions.series.colorIndex
   */

  /**
   * Whether to connect a graph line across null points, or render a gap
   * between the two points on either side of the null.
   *
   * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/
   *         False by default
   * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/
   *         True
   *
   * @type      {boolean}
   * @default   false
   * @product   highcharts highstock
   * @apioption plotOptions.series.connectNulls
   */

  /**
   * You can set the cursor to "pointer" if you have click events attached
   * to the series, to signal to the user that the points and lines can
   * be clicked.
   *
   * In styled mode, the series cursor can be set with the same classes
   * as listed under [series.color](#plotOptions.series.color).
   *
   * @sample {highcharts} highcharts/plotoptions/series-cursor-line/
   *         On line graph
   * @sample {highcharts} highcharts/plotoptions/series-cursor-column/
   *         On columns
   * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/
   *         On scatter markers
   * @sample {highstock} stock/plotoptions/cursor/
   *         Pointer on a line graph
   * @sample {highmaps} maps/plotoptions/series-allowpointselect/
   *         Map area
   * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
   *         Map bubble
   *
   * @type       {string}
   * @validvalue ["crosshair","default","help","none","pointer"]
   * @apioption  plotOptions.series.cursor
   */

  /**
   * A name for the dash style to use for the graph, or for some series types
   * the outline of each shape.
   *
   * In styled mode, the [stroke dash-array](https://jsfiddle.net/gh/get/
   * library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/
   * series-dashstyle/) can be set with the same classes as listed under
   * [series.color](#plotOptions.series.color).
   *
   * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
   *         Possible values demonstrated
   * @sample {highcharts} highcharts/plotoptions/series-dashstyle/
   *         Chart suitable for printing in black and white
   * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/
   *         Possible values demonstrated
   * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/
   *         Possible values demonstrated
   * @sample {highmaps} maps/plotoptions/series-dashstyle/
   *         Dotted borders on a map
   *
   * @type       {string}
   * @default    Solid
   * @since      2.1
   * @validvalue ["Dash","DashDot","Dot","LongDash","LongDashDot",
   *             "LongDashDotDot","ShortDash","ShortDashDot",
   *             "ShortDashDotDot","ShortDot","Solid"]
   * @apioption  plotOptions.series.dashStyle
   */

  /**
   * Requires the Accessibility module.
   *
   * A description of the series to add to the screen reader information
   * about the series.
   *
   * @type      {string}
   * @since     5.0.0
   * @apioption plotOptions.series.description
   */

  /**
   * Enable or disable the mouse tracking for a specific series. This
   * includes point tooltips and click events on graphs and points. For
   * large datasets it improves performance.
   *
   * @sample {highcharts} highcharts/plotoptions/series-enablemousetracking-false/
   *         No mouse tracking
   * @sample {highmaps} maps/plotoptions/series-enablemousetracking-false/
   *         No mouse tracking
   *
   * @type      {boolean}
   * @default   true
   * @apioption plotOptions.series.enableMouseTracking
   */

  /**
   * By default, series are exposed to screen readers as regions. By enabling
   * this option, the series element itself will be exposed in the same
   * way as the data points. This is useful if the series is not used
   * as a grouping entity in the chart, but you still want to attach a
   * description to the series.
   *
   * Requires the Accessibility module.
   *
   * @sample highcharts/accessibility/art-grants/
   *         Accessible data visualization
   *
   * @type      {boolean}
   * @since     5.0.12
   * @apioption plotOptions.series.exposeElementToA11y
   */

  /**
   * Whether to use the Y extremes of the total chart width or only the
   * zoomed area when zooming in on parts of the X axis. By default, the
   * Y axis adjusts to the min and max of the visible data. Cartesian
   * series only.
   *
   * @type      {boolean}
   * @default   false
   * @since     4.1.6
   * @product   highcharts highstock
   * @apioption plotOptions.series.getExtremesFromAll
   */

  /**
   * An array specifying which option maps to which key in the data point
   * array. This makes it convenient to work with unstructured data arrays
   * from different sources.
   *
   * @see [series.data](#series.line.data)
   *
   * @sample {highcharts|highstock} highcharts/series/data-keys/
   *         An extended data array with keys
   * @sample {highcharts|highstock} highcharts/series/data-nested-keys/
   *         Nested keys used to access object properties
   *
   * @type      {Array<string>}
   * @since     4.1.6
   * @apioption plotOptions.series.keys
   */

  /**
   * The line cap used for line ends and line joins on the graph.
   *
   * @type       {string}
   * @product    highcharts highstock
   * @validvalue ["round", "square"]
   * @apioption  plotOptions.series.linecap
   */

  /**
   * The [id](#series.id) of another series to link to. Additionally,
   * the value can be ":previous" to link to the previous series. When
   * two series are linked, only the first one appears in the legend.
   * Toggling the visibility of this also toggles the linked series.
   *
   * @sample {highcharts|highstock} highcharts/demo/arearange-line/
   *         Linked series
   *
   * @type      {string}
   * @since     3.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.linkedTo
   */

  /**
   * Options for the corresponding navigator series if `showInNavigator`
   * is `true` for this series. Available options are the same as any
   * series, documented at [plotOptions](#plotOptions.series) and
   * [series](#series).
   *
   * These options are merged with options in [navigator.series](
   * #navigator.series), and will take precedence if the same option is
   * defined both places.
   *
   * @see [navigator.series](#navigator.series)
   *
   * @type      {*}
   * @since     5.0.0
   * @product   highstock
   * @apioption plotOptions.series.navigatorOptions
   */

  /**
   * The color for the parts of the graph or points that are below the
   * [threshold](#plotOptions.series.threshold).
   *
   * @see In styled mode, a negative color is applied by setting this option
   *      to `true` combined with the `.highcharts-negative` class name.
   *
   * @sample {highcharts} highcharts/plotoptions/series-negative-color/
   *         Spline, area and column
   * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/
   *         Arearange
   * @sample {highcharts} highcharts/css/series-negative-color/
   *         Styled mode
   * @sample {highstock} highcharts/plotoptions/series-negative-color/
   *         Spline, area and column
   * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/
   *         Arearange
   * @sample {highmaps} highcharts/plotoptions/series-negative-color/
   *         Spline, area and column
   * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/
   *         Arearange
   *
   * @type      {Highcharts.ColorString}
   * @since     3.0
   * @apioption plotOptions.series.negativeColor
   */

  /**
   * Same as [accessibility.pointDescriptionFormatter](
   * #accessibility.pointDescriptionFormatter), but for an individual series.
   * Overrides the chart wide configuration.
   *
   * @type      {Function}
   * @since     5.0.12
   * @apioption plotOptions.series.pointDescriptionFormatter
   */

  /**
   * If no x values are given for the points in a series, `pointInterval`
   * defines the interval of the x values. For example, if a series contains
   * one value every decade starting from year 0, set `pointInterval` to
   * `10`. In true `datetime` axes, the `pointInterval` is set in
   * milliseconds.
   *
   * It can be also be combined with `pointIntervalUnit` to draw irregular
   * time intervals.
   *
   * Please note that this options applies to the _series data_, not the
   * interval of the axis ticks, which is independent.
   *
   * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
   *         Datetime X axis
   * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
   *         Using pointStart and pointInterval
   *
   * @type      {number}
   * @default   1
   * @product   highcharts highstock
   * @apioption plotOptions.series.pointInterval
   */

  /**
   * On datetime series, this allows for setting the
   * [pointInterval](#plotOptions.series.pointInterval) to irregular time
   * units, `day`, `month` and `year`. A day is usually the same as 24 hours,
   * but `pointIntervalUnit` also takes the DST crossover into consideration
   * when dealing with local time. Combine this option with `pointInterval`
   * to draw weeks, quarters, 6 months, 10 years etc.
   *
   * Please note that this options applies to the _series data_, not the
   * interval of the axis ticks, which is independent.
   *
   * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/
   *         One point a month
   * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/
   *         One point a month
   *
   * @type       {string}
   * @since      4.1.0
   * @product    highcharts highstock
   * @validvalue ["day", "month", "year"]
   * @apioption  plotOptions.series.pointIntervalUnit
   */

  /**
   * Possible values: `"on"`, `"between"`, `number`.
   *
   * In a column chart, when pointPlacement is `"on"`, the point will
   * not create any padding of the X axis. In a polar column chart this
   * means that the first column points directly north. If the pointPlacement
   * is `"between"`, the columns will be laid out between ticks. This
   * is useful for example for visualising an amount between two points
   * in time or in a certain sector of a polar chart.
   *
   * Since Highcharts 3.0.2, the point placement can also be numeric,
   * where 0 is on the axis value, -0.5 is between this value and the
   * previous, and 0.5 is between this value and the next. Unlike the
   * textual options, numeric point placement options won't affect axis
   * padding.
   *
   * Note that pointPlacement needs a [pointRange](
   * #plotOptions.series.pointRange) to work. For column series this is
   * computed, but for line-type series it needs to be set.
   *
   * Defaults to `undefined` in cartesian charts, `"between"` in polar charts.
   *
   * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)
   *
   * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-between/
   *         Between in a column chart
   * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-numeric/
   *         Numeric placement for custom layout
   *
   * @type      {string|number}
   * @since     2.3.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.pointPlacement
   */

  /**
   * If no x values are given for the points in a series, pointStart defines
   * on what value to start. For example, if a series contains one yearly
   * value starting from 1945, set pointStart to 1945.
   *
   * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/
   *         Linear
   * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
   *         Datetime
   * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
   *         Using pointStart and pointInterval
   *
   * @type      {number}
   * @default   0
   * @product   highcharts highstock
   * @apioption plotOptions.series.pointStart
   */

  /**
   * Whether to select the series initially. If `showCheckbox` is true,
   * the checkbox next to the series name in the legend will be checked for a
   * selected series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-selected/
   *         One out of two series selected
   *
   * @type      {boolean}
   * @default   false
   * @since     1.2.0
   * @apioption plotOptions.series.selected
   */

  /**
   * Whether to apply a drop shadow to the graph line. Since 2.3 the shadow
   * can be an object configuration containing `color`, `offsetX`, `offsetY`,
   * `opacity` and `width`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-shadow/
   *         Shadow enabled
   *
   * @type      {boolean|Highcharts.ShadowOptionsObject}
   * @default   false
   * @apioption plotOptions.series.shadow
   */

  /**
   * Whether to display this particular series or series type in the legend.
   * The default value is `true` for standalone series, `false` for linked
   * series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
   *         One series in the legend, one hidden
   *
   * @type      {boolean}
   * @default   true
   * @apioption plotOptions.series.showInLegend
   */

  /**
   * Whether or not to show the series in the navigator. Takes precedence
   * over [navigator.baseSeries](#navigator.baseSeries) if defined.
   *
   * @type      {boolean}
   * @since     5.0.0
   * @product   highstock
   * @apioption plotOptions.series.showInNavigator
   */

  /**
   * If set to `true`, the accessibility module will skip past the points
   * in this series for keyboard navigation.
   *
   * @type      {boolean}
   * @since     5.0.12
   * @apioption plotOptions.series.skipKeyboardNavigation
   */

  /**
   * Whether to stack the values of each series on top of each other. Possible
   * values are `undefined` to disable, `"normal"` to stack by value or
   * `"percent"`. When stacking is enabled, data must be sorted in ascending
   * X order. A special stacking option is with the streamgraph series type,
   * where the stacking option is set to `"stream"`.
   *
   * @see [yAxis.reversedStacks](#yAxis.reversedStacks)
   *
   * @sample {highcharts} highcharts/plotoptions/series-stacking-line/
   *         Line
   * @sample {highcharts} highcharts/plotoptions/series-stacking-column/
   *         Column
   * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/
   *         Bar
   * @sample {highcharts} highcharts/plotoptions/series-stacking-area/
   *         Area
   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/
   *         Line
   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-column/
   *         Column
   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/
   *         Bar
   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/
   *         Area
   * @sample {highstock} stock/plotoptions/stacking/
   *         Area
   *
   * @type       {string}
   * @product    highcharts highstock
   * @validvalue ["normal", "percent"]
   * @apioption  plotOptions.series.stacking
   */

  /**
   * Whether to apply steps to the line. Possible values are `left`, `center`
   * and `right`.
   *
   * @sample {highcharts} highcharts/plotoptions/line-step/
   *         Different step line options
   * @sample {highcharts} highcharts/plotoptions/area-step/
   *         Stepped, stacked area
   * @sample {highstock} stock/plotoptions/line-step/
   *         Step line
   *
   * @type       {string}
   * @since      1.2.5
   * @product    highcharts highstock
   * @validvalue ["left", "center", "right"]
   * @apioption  plotOptions.series.step
   */

  /**
   * The threshold, also called zero level or base level. For line type
   * series this is only used in conjunction with
   * [negativeColor](#plotOptions.series.negativeColor).
   *
   * @see [softThreshold](#plotOptions.series.softThreshold).
   *
   * @type      {number}
   * @default   0
   * @since     3.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.threshold
   */

  /**
   * Set the initial visibility of the series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-visible/
   *         Two series, one hidden and one visible
   * @sample {highstock} stock/plotoptions/series-visibility/
   *         Hidden series
   *
   * @type      {boolean}
   * @default   true
   * @apioption plotOptions.series.visible
   */

  /**
   * Defines the Axis on which the zones are applied.
   *
   * @see [zones](#plotOptions.series.zones)
   *
   * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/
   *         Zones on the X-Axis
   * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/
   *         Zones on the X-Axis
   *
   * @type      {string}
   * @default   y
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zoneAxis
   */

  /**
   * General event handlers for the series items. These event hooks can also
   * be attached to the series at run time using the `Highcharts.addEvent`
   * function.
   */
  events: {},

  /**
   * Fires after the series has finished its initial animation, or in
   * case animation is disabled, immediately as the series is displayed.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-afteranimate/
   *         Show label after animate
   * @sample {highstock} highcharts/plotoptions/series-events-afteranimate/
   *         Show label after animate
   *
   * @type      {Function}
   * @since     4.0
   * @product   highcharts highstock
   * @context   Series
   * @apioption plotOptions.series.events.afterAnimate
   */

  /**
   * Fires when the checkbox next to the series' name in the legend is
   * clicked. One parameter, `event`, is passed to the function. The state
   * of the checkbox is found by `event.checked`. The checked item is
   * found by `event.item`. Return `false` to prevent the default action
   * which is to toggle the select state of the series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
   *         Alert checkbox status
   *
   * @type      {Function}
   * @since     1.2.0
   * @context   Series
   * @apioption plotOptions.series.events.checkboxClick
   */

  /**
   * Fires when the series is clicked. One parameter, `event`, is passed to
   * the function, containing common event information. Additionally,
   * `event.point` holds a pointer to the nearest point on the graph.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-click/
   *         Alert click info
   * @sample {highstock} stock/plotoptions/series-events-click/
   *         Alert click info
   * @sample {highmaps} maps/plotoptions/series-events-click/
   *         Display click info in subtitle
   *
   * @type      {Function}
   * @context   Series
   * @apioption plotOptions.series.events.click
   */

  /**
   * Fires when the series is hidden after chart generation time, either
   * by clicking the legend item or by calling `.hide()`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-hide/
   *         Alert when the series is hidden by clicking the legend item
   *
   * @type      {Function}
   * @since     1.2.0
   * @context   Series
   * @apioption plotOptions.series.events.hide
   */

  /**
   * Fires when the legend item belonging to the series is clicked. One
   * parameter, `event`, is passed to the function. The default action
   * is to toggle the visibility of the series. This can be prevented
   * by returning `false` or calling `event.preventDefault()`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-legenditemclick/
   *         Confirm hiding and showing
   *
   * @type      {Function}
   * @context   Series
   * @apioption plotOptions.series.events.legendItemClick
   */

  /**
   * Fires when the mouse leaves the graph. One parameter, `event`, is
   * passed to the function, containing common event information. If the
   * [stickyTracking](#plotOptions.series) option is true, `mouseOut`
   * doesn't happen before the mouse enters another graph or leaves the
   * plot area.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
   *         With sticky tracking by default
   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
   *         Without sticky tracking
   *
   * @type      {Function}
   * @context   Series
   * @apioption plotOptions.series.events.mouseOut
   */

  /**
   * Fires when the mouse enters the graph. One parameter, `event`, is
   * passed to the function, containing common event information.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
   *         With sticky tracking by default
   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
   *         Without sticky tracking
   *
   * @type      {Function}
   * @context   Series
   * @apioption plotOptions.series.events.mouseOver
   */

  /**
   * Fires when the series is shown after chart generation time, either
   * by clicking the legend item or by calling `.show()`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-show/
   *         Alert when the series is shown by clicking the legend item.
   *
   * @type      {Function}
   * @since     1.2.0
   * @context   Series
   * @apioption plotOptions.series.events.show
   */

  /**
   * Options for the point markers of line-like series. Properties like
   * `fillColor`, `lineColor` and `lineWidth` define the visual appearance
   * of the markers. Other series types, like column series, don't have
   * markers, but have visual options on the series level instead.
   *
   * In styled mode, the markers can be styled with the `.highcharts-point`,
   * `.highcharts-point-hover` and `.highcharts-point-select`
   * class names.
   */
  marker: {
    /**
     * Enable or disable the point marker. If `undefined`, the markers are
     * hidden when the data is dense, and shown for more widespread data
     * points.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-enabled/
     *         Disabled markers
     * @sample {highcharts} highcharts/plotoptions/series-marker-enabled-false/
     *         Disabled in normal state but enabled on hover
     * @sample {highstock} stock/plotoptions/series-marker/
     *         Enabled markers
     *
     * @type      {boolean}
     * @default   {highcharts} undefined
     * @default   {highstock} false
     * @apioption plotOptions.series.marker.enabled
     */

    /**
     * Image markers only. Set the image width explicitly. When using this
     * option, a `width` must also be set.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
     *         Fixed width and height
     * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
     *         Fixed width and height
     *
     * @type      {number}
     * @since     4.0.4
     * @apioption plotOptions.series.marker.height
     */

    /**
     * A predefined shape or symbol for the marker. When undefined, the
     * symbol is pulled from options.symbols. Other possible values are
     * "circle", "square", "diamond", "triangle" and "triangle-down".
     *
     * Additionally, the URL to a graphic can be given on this form:
     * "url(graphic.png)". Note that for the image to be applied to exported
     * charts, its URL needs to be accessible by the export server.
     *
     * Custom callbacks for symbol path generation can also be added to
     * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
     * used by its method name, as shown in the demo.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
     *         Predefined, graphic and custom markers
     * @sample {highstock} highcharts/plotoptions/series-marker-symbol/
     *         Predefined, graphic and custom markers
     *
     * @type      {string}
     * @apioption plotOptions.series.marker.symbol
     */

    /**
     * The threshold for how dense the point markers should be before they
     * are hidden, given that `enabled` is not defined. The number indicates
     * the horizontal distance between the two closest points in the series,
     * as multiples of the `marker.radius`. In other words, the default
     * value of 2 means points are hidden if overlapping horizontally.
     *
     * @sample highcharts/plotoptions/series-marker-enabledthreshold
     *         A higher threshold
     *
     * @since 6.0.5
     */
    enabledThreshold: 2,

    /**
     * The radius of the point marker.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-radius/
     *         Bigger markers
     */
    radius: 4,

    /**
     * Image markers only. Set the image width explicitly. When using this
     * option, a `height` must also be set.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
     *         Fixed width and height
     * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
     *         Fixed width and height
     *
     * @type      {number}
     * @since     4.0.4
     * @apioption plotOptions.series.marker.width
     */

    /**
     * States for a single point marker.
     */
    states: {
      /**
       * The normal state of a single point marker. Currently only used
       * for setting animation when returning to normal state from hover.
       */
      normal: {
        /**
         * Animation when returning to normal state after hovering.
         *
         * @type {boolean|Highcharts.AnimationOptionsObject}
         */
        animation: true
      },

      /**
       * The hover state for a single point marker.
       */
      hover: {
        /**
         * Animation when hovering over the marker.
         *
         * @type {boolean|Highcharts.AnimationOptionsObject}
         */
        animation: {
          duration: 50
        },

        /**
         * Enable or disable the point marker.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-enabled/
         *         Disabled hover state
         */
        enabled: true,

        /**
         * The fill color of the marker in hover state. When
         * `undefined`, the series' or point's fillColor for normal
         * state is used.
         *
         * @type      {Highcharts.ColorString}
         * @apioption plotOptions.series.marker.states.hover.fillColor
         */

        /**
         * The color of the point marker's outline. When `undefined`,
         * the series' or point's lineColor for normal state is used.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linecolor/
         *         White fill color, black line color
         *
         * @type      {Highcharts.ColorString}
         * @apioption plotOptions.series.marker.states.hover.lineColor
         */

        /**
         * The width of the point marker's outline. When `undefined`,
         * the series' or point's lineWidth for normal state is used.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linewidth/
         *         3px line width
         *
         * @type      {number}
         * @apioption plotOptions.series.marker.states.hover.lineWidth
         */

        /**
         * The radius of the point marker. In hover state, it defaults
         * to the normal state's radius + 2 as per the [radiusPlus](
         * #plotOptions.series.marker.states.hover.radiusPlus)
         * option.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-radius/
         *         10px radius
         *
         * @type      {number}
         * @apioption plotOptions.series.marker.states.hover.radius
         */

        /**
         * The number of pixels to increase the radius of the hovered
         * point.
         *
         * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
         *         5 pixels greater radius on hover
         * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
         *         5 pixels greater radius on hover
         *
         * @since 4.0.3
         */
        radiusPlus: 2
      }
    }
  },

  /**
   * Properties for each single point.
   */
  point: {
    /**
     * Fires when a point is clicked. One parameter, `event`, is passed
     * to the function, containing common event information.
     *
     * If the `series.allowPointSelect` option is true, the default
     * action for the point's click event is to toggle the point's
     * select state. Returning `false` cancels this action.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-click/
     *         Click marker to alert values
     * @sample {highcharts} highcharts/plotoptions/series-point-events-click-column/
     *         Click column
     * @sample {highcharts} highcharts/plotoptions/series-point-events-click-url/
     *         Go to URL
     * @sample {highmaps} maps/plotoptions/series-point-events-click/
     *         Click marker to display values
     * @sample {highmaps} maps/plotoptions/series-point-events-click-url/
     *         Go to URL
     *
     * @type      {Function}
     * @context   Point
     * @apioption plotOptions.series.point.events.click
     */

    /**
     * Fires when the mouse leaves the area close to the point. One
     * parameter, `event`, is passed to the function, containing common
     * event information.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
     *         Show values in the chart's corner on mouse over
     *
     * @type      {Function}
     * @context   Point
     * @apioption plotOptions.series.point.events.mouseOut
     */

    /**
     * Fires when the mouse enters the area close to the point. One
     * parameter, `event`, is passed to the function, containing common
     * event information.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
     *         Show values in the chart's corner on mouse over
     *
     * @type      {Function}
     * @context   Point
     * @apioption plotOptions.series.point.events.mouseOver
     */

    /**
     * Fires when the point is removed using the `.remove()` method. One
     * parameter, `event`, is passed to the function. Returning `false`
     * cancels the operation.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-remove/
     *         Remove point and confirm
     *
     * @type      {Function}
     * @since     1.2.0
     * @context   Point
     * @apioption plotOptions.series.point.events.remove
     */

    /**
     * Fires when the point is selected either programmatically or
     * following a click on the point. One parameter, `event`, is passed
     * to the function. Returning `false` cancels the operation.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-select/
     *         Report the last selected point
     * @sample {highmaps} maps/plotoptions/series-allowpointselect/
     *         Report select and unselect
     *
     * @type      {Function}
     * @since     1.2.0
     * @context   Point
     * @apioption plotOptions.series.point.events.select
     */

    /**
     * Fires when the point is unselected either programmatically or
     * following a click on the point. One parameter, `event`, is passed
     * to the function.
     *  Returning `false` cancels the operation.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-unselect/
     *         Report the last unselected point
     * @sample {highmaps} maps/plotoptions/series-allowpointselect/
     *         Report select and unselect
     *
     * @type      {Function}
     * @since     1.2.0
     * @context   Point
     * @apioption plotOptions.series.point.events.unselect
     */

    /**
     * Fires when the point is updated programmatically through the
     * `.update()` method. One parameter, `event`, is passed to the
     * function. The new point options can be accessed through
     * `event.options`. Returning `false` cancels the operation.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-update/
     *         Confirm point updating
     *
     * @type      {Function}
     * @since     1.2.0
     * @context   Point
     * @apioption plotOptions.series.point.events.update
     */

    /**
     * Events for each single point.
     */
    events: {}
  },

  /**
   * Options for the series data labels, appearing next to each data point.
   *
   * In styled mode, the data labels can be styled with the
   * `.highcharts-data-label-box` and `.highcharts-data-label` class names
   * ([see example](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-datalabels)).
   */
  dataLabels: {
    /**
     * The alignment of the data label compared to the point. If `right`,
     * the right side of the label should be touching the point. For
     * points with an extent, like columns, the alignments also dictates
     * how to align it inside the box, as given with the
     * [inside](#plotOptions.column.dataLabels.inside) option. Can be one of
     * `left`, `center` or `right`.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-align-left/
     *         Left aligned
     *
     * @validvalue ["left", "center", "right"]
     */
    align: 'center',

    /**
     * Whether to allow data labels to overlap. To make the labels less
     * sensitive for overlapping, the [dataLabels.padding](
     * #plotOptions.series.dataLabels.padding) can be set to 0.
     *
     * @sample highcharts/plotoptions/series-datalabels-allowoverlap-false/
     *         Don't allow overlap
     *
     * @type      {boolean}
     * @default   false
     * @since     4.1.0
     * @apioption plotOptions.series.dataLabels.allowOverlap
     */

    /**
     * The border radius in pixels for the data label.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     * @sample {highstock} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     * @sample {highmaps} maps/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @type      {number}
     * @default   0
     * @since     2.2.1
     * @apioption plotOptions.series.dataLabels.borderRadius
     */

    /**
     * The border width in pixels for the data label.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     * @sample {highstock} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @type      {number}
     * @default   0
     * @since     2.2.1
     * @apioption plotOptions.series.dataLabels.borderWidth
     */

    /**
     * A class name for the data label. Particularly in styled mode, this
     * can be used to give each series' or point's data label unique
     * styling. In addition to this option, a default color class name is
     * added so that we can give the labels a
     * [contrast text shadow](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/data-label-contrast/).
     *
     * @sample {highcharts} highcharts/css/series-datalabels/
     *         Styling by CSS
     * @sample {highstock} highcharts/css/series-datalabels/
     *         Styling by CSS
     * @sample {highmaps} highcharts/css/series-datalabels/
     *         Styling by CSS
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption plotOptions.series.dataLabels.className
     */

    /**
     * The text color for the data labels. Defaults to `undefined`. For
     * certain series types, like column or map, the data labels can be
     * drawn inside the points. In this case the data label will be drawn
     * with maximum contrast by default. Additionally, it will be given a
     * `text-outline` style with the opposite color, to further increase the
     * contrast. This can be overridden by setting the `text-outline` style
     * to `none` in the `dataLabels.style` option.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/
     *         Red data labels
     * @sample {highmaps} maps/demo/color-axis/
     *         White data labels
     *
     * @type      {Highcharts.ColorString}
     * @apioption plotOptions.series.dataLabels.color
     */

    /**
     * Whether to hide data labels that are outside the plot area. By
     * default, the data label is moved inside the plot area according to
     * the [overflow](#plotOptions.series.dataLabels.overflow) option.
     *
     * @type      {boolean}
     * @default   true
     * @since     2.3.3
     * @apioption plotOptions.series.dataLabels.crop
     */

    /**
     * Whether to defer displaying the data labels until the initial series
     * animation has finished.
     *
     * @type      {boolean}
     * @default   true
     * @since     4.0
     * @product   highcharts highstock
     * @apioption plotOptions.series.dataLabels.defer
     */

    /**
     * Enable or disable the data labels.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/
     *         Data labels enabled
     * @sample {highmaps} maps/demo/color-axis/
     *         Data labels enabled
     *
     * @type      {boolean}
     * @default   false
     * @apioption plotOptions.series.dataLabels.enabled
     */

    /**
     * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
     * for the data label. Available variables are the same as for
     * `formatter`.
     *
     * @sample {highcharts|highstock} highcharts/plotoptions/series-datalabels-format/
     *         Add a unit
     * @sample {highmaps} maps/plotoptions/series-datalabels-format/
     *         Formatted value in the data label
     *
     * @type      {string}
     * @default   {highcharts} {y}
     * @default   {highstock} {y}
     * @default   {highmaps} {point.value}
     * @since     3.0
     * @apioption plotOptions.series.dataLabels.format
     */

    /**
     * Callback JavaScript function to format the data label. Note that if a
     * `format` is defined, the format takes precedence and the formatter is
     * ignored. Available data are:
     *
     * <table>
     *
     * <tbody>
     *
     * <tr>
     *
     * <td>`this.percentage`</td>
     *
     * <td>Stacked series and pies only. The point's percentage of the
     * total.</td>
     *
     * </tr>
     *
     * <tr>
     *
     * <td>`this.point`</td>
     *
     * <td>The point object. The point name, if defined, is available
     * through `this.point.name`.</td>
     *
     * </tr>
     *
     * <tr>
     *
     * <td>`this.series`:</td>
     *
     * <td>The series object. The series name is available through
     * `this.series.name`.</td>
     *
     * </tr>
     *
     * <tr>
     *
     * <td>`this.total`</td>
     *
     * <td>Stacked series only. The total value at this point's x value.
     * </td>
     *
     * </tr>
     *
     * <tr>
     *
     * <td>`this.x`:</td>
     *
     * <td>The x value.</td>
     *
     * </tr>
     *
     * <tr>
     *
     * <td>`this.y`:</td>
     *
     * <td>The y value.</td>
     *
     * </tr>
     *
     * </tbody>
     *
     * </table>
     *
     * @sample {highmaps} maps/plotoptions/series-datalabels-format/
     *         Formatted value
     *
     * @type    {Highcharts.FormatterCallbackFunction}
     * @default function () { return this.y; }
     */
    formatter: function () {
      return this.y === null ? '' : Highcharts.numberFormat(this.y, -1);
    },

    /**
     * For points with an extent, like columns or map areas, whether to
     * align the data label inside the box or to the actual value point.
     * Defaults to `false` in most cases, `true` in stacked columns.
     *
     * @type      {boolean}
     * @since     3.0
     * @apioption plotOptions.series.dataLabels.inside
     */

    /**
     * How to handle data labels that flow outside the plot area. The
     * default is `"justify"`, which aligns them inside the plot area. For
     * columns and bars, this means it will be moved inside the bar. To
     * display data labels outside the plot area, set `crop` to `false` and
     * `overflow` to `"allow"`.
     *
     * @type       {string}
     * @default    justify
     * @since      3.0.6
     * @validvalue ["allow", "justify"]
     * @apioption  plotOptions.series.dataLabels.overflow
     */

    /**
     * Text rotation in degrees. Note that due to a more complex structure,
     * backgrounds, borders and padding will be lost on a rotated data
     * label.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
     *         Vertical labels
     *
     * @type      {number}
     * @default   0
     * @apioption plotOptions.series.dataLabels.rotation
     */

    /**
     * Whether to
     * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the labels.
     *
     * @type      {boolean}
     * @default   false
     * @apioption plotOptions.series.dataLabels.useHTML
     */

    /**
     * The vertical alignment of a data label. Can be one of `top`, `middle`
     * or `bottom`. The default value depends on the data, for instance
     * in a column chart, the label is above positive values and below
     * negative values.
     *
     * @since      2.3.3
     * @validvalue ["top", "middle", "bottom"]
     */
    verticalAlign: 'bottom',
    // above singular point

    /**
     * The x position offset of the label relative to the point in pixels.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
     *         Vertical and positioned
     */
    x: 0,

    /**
     * The y position offset of the label relative to the point in pixels.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
     *         Vertical and positioned
     */
    y: 0,

    /**
     * When either the `borderWidth` or the `backgroundColor` is set,
     * this is the padding within the box.
     *
     * @sample {highcharts|highstock} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     * @sample {highmaps} maps/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @default {highcharts} 5
     * @default {highstock} 5
     * @default {highmaps} 0
     * @since   2.2.1
     */
    padding: 5
  },

  /**
   * When the series contains less points than the crop threshold, all
   * points are drawn, even if the points fall outside the visible plot
   * area at the current zoom. The advantage of drawing all points (including
   * markers and columns), is that animation is performed on updates.
   * On the other hand, when the series contains more points than the
   * crop threshold, the series data is cropped to only contain points
   * that fall within the plot area. The advantage of cropping away invisible
   * points is to increase performance on large series.
   *
   * @since   2.2
   * @product highcharts highstock
   */
  cropThreshold: 300,

  /**
   * The width of each point on the x axis. For example in a column chart
   * with one value each day, the pointRange would be 1 day (= 24 * 3600
   * * 1000 milliseconds). This is normally computed automatically, but
   * this option can be used to override the automatic value.
   *
   * @product highstock
   */
  pointRange: 0,

  /**
   * When this is true, the series will not cause the Y axis to cross
   * the zero plane (or [threshold](#plotOptions.series.threshold) option)
   * unless the data actually crosses the plane.
   *
   * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
   * 3 will make the Y axis show negative values according to the `minPadding`
   * option. If `softThreshold` is `true`, the Y axis starts at 0.
   *
   * @since   4.1.9
   * @product highcharts highstock
   */
  softThreshold: true,

  /**
   * A wrapper object for all the series options in specific states.
   */
  states: {
    /**
     * The normal state of a series, or for point items in column, pie and
     * similar series. Currently only used for setting animation when
     * returning to normal state from hover.
     */
    normal: {
      /**
       * Animation when returning to normal state after hovering.
       *
       * @type {boolean|Highcharts.AnimationOptionsObject}
       */
      animation: true
    },

    /**
     * Options for the hovered series. These settings override the normal
     * state options when a series is moused over or touched.
     */
    hover: {
      /**
       * Enable separate styles for the hovered series to visualize that
       * the user hovers either the series itself or the legend. .
       *
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled/
       *         Line
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-column/
       *         Column
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-pie/
       *         Pie
       *
       * @type      {boolean}
       * @default   true
       * @since     1.2
       * @apioption plotOptions.series.states.hover.enabled
       */

      /**
       * Animation setting for hovering the graph in line-type series.
       *
       * @type    {boolean|Highcharts.AnimationOptionsObject}
       * @since   5.0.8
       * @product highcharts
       */
      animation: {
        /**
         * The duration of the hover animation in milliseconds. By
         * default the hover state animates quickly in, and slowly back
         * to normal.
         */
        duration: 50
      },

      /**
       * Pixel width of the graph line. By default this property is
       * undefined, and the `lineWidthPlus` property dictates how much
       * to increase the linewidth from normal state.
       *
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidth/
       *         5px line on hover
       *
       * @type      {number}
       * @product   highcharts highstock
       * @apioption plotOptions.series.states.hover.lineWidth
       */

      /**
       * The additional line width for the graph of a hovered series.
       *
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
       *         5 pixels wider
       * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
       *         5 pixels wider
       *
       * @since   4.0.3
       * @product highcharts highstock
       */
      lineWidthPlus: 1,

      /**
       * In Highcharts 1.0, the appearance of all markers belonging to the
       * hovered series. For settings on the hover state of the individual
       * point, see
       * [marker.states.hover](#plotOptions.series.marker.states.hover).
       *
       * @deprecated
       *
       * @extends plotOptions.series.marker
       * @product highcharts highstock
       */
      marker: {// lineWidth: base + 1,
        // radius: base + 1
      },

      /**
       * Options for the halo appearing around the hovered point in line-
       * type series as well as outside the hovered slice in pie charts.
       * By default the halo is filled by the current point or series
       * color with an opacity of 0.25\. The halo can be disabled by
       * setting the `halo` option to `false`.
       *
       * In styled mode, the halo is styled with the `.highcharts-halo`
       * class, with colors inherited from `.highcharts-color-{n}`.
       *
       * @sample {highcharts} highcharts/plotoptions/halo/
       *         Halo options
       * @sample {highstock} highcharts/plotoptions/halo/
       *         Halo options
       *
       * @since   4.0
       * @product highcharts highstock
       */
      halo: {
        /**
         * A collection of SVG attributes to override the appearance of
         * the halo, for example `fill`, `stroke` and `stroke-width`.
         *
         * @type      {Highcharts.SVGAttributes}
         * @since     4.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.states.hover.halo.attributes
         */

        /**
         * The pixel size of the halo. For point markers this is the
         * radius of the halo. For pie slices it is the width of the
         * halo outside the slice. For bubbles it defaults to 5 and is
         * the width of the halo outside the bubble.
         *
         * @since   4.0
         * @product highcharts highstock
         */
        size: 10
      }
    },

    /**
     * Specific options for point in selected states, after being selected
     * by [allowPointSelect](#plotOptions.series.allowPointSelect) or
     * programmatically.
     *
     * @sample {highmaps} maps/plotoptions/series-allowpointselect/
     *         Allow point select demo
     *
     * @extends   plotOptions.series.states.hover
     * @excluding brightness
     * @product   highmaps
     */
    select: {// marker: {}
    }
  },

  /**
   * Sticky tracking of mouse events. When true, the `mouseOut` event
   * on a series isn't triggered until the mouse moves over another series,
   * or out of the plot area. When false, the `mouseOut` event on a
   * series is triggered when the mouse leaves the area around the series'
   * graph or markers. This also implies the tooltip when not shared. When
   * `stickyTracking` is false and `tooltip.shared` is false, the tooltip will
   * be hidden when moving the mouse between series. Defaults to true for line
   * and area type series, but to false for columns, pies etc.
   *
   * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/
   *         True by default
   * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/
   *         False
   *
   * @default {highcharts} true
   * @default {highstock} true
   * @default {highmaps} false
   * @since   2.0
   */
  stickyTracking: true,

  /**
   * A configuration object for the tooltip rendering of each single series.
   * Properties are inherited from [tooltip](#tooltip), but only the
   * following properties can be defined on a series level.
   *
   * @since     2.3
   * @extends   tooltip
   * @excluding animation,backgroundColor,borderColor,borderRadius,
   *            borderWidth,crosshairs,enabled,formatter,positioner,shadow,
   *            shared,shape,snap,style,useHTML
   * @apioption plotOptions.series.tooltip
   */

  /**
   * When a series contains a data array that is longer than this, only
   * one dimensional arrays of numbers, or two dimensional arrays with
   * x and y values are allowed. Also, only the first point is tested,
   * and the rest are assumed to be the same format. This saves expensive
   * data checking and indexing in long series. Set it to `0` disable.
   *
   * @since   2.2
   * @product highcharts highstock
   */
  turboThreshold: 1000,

  /**
   * An array defining zones within a series. Zones can be applied to
   * the X axis, Y axis or Z axis for bubbles, according to the `zoneAxis`
   * option. The zone definitions have to be in ascending order regarding to
   * the value.
   *
   * In styled mode, the color zones are styled with the
   * `.highcharts-zone-{n}` class, or custom classed from the `className`
   * option
   * ([view live demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/color-zones/)).
   *
   * @see [zoneAxis](#plotOptions.series.zoneAxis)
   *
   * @sample {highcharts} highcharts/series/color-zones-simple/
   *         Color zones
   * @sample {highstock} highcharts/series/color-zones-simple/
   *         Color zones
   *
   * @type      {Array<*>}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones
   */

  /**
   * Styled mode only. A custom class name for the zone.
   *
   * @sample highcharts/css/color-zones/
   *         Zones styled by class name
   *
   * @type      {string}
   * @since     5.0.0
   * @apioption plotOptions.series.zones.className
   */

  /**
   * Defines the color of the series.
   *
   * @see [series color](#plotOptions.series.color)
   *
   * @type      {Highcharts.ColorString}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones.color
   */

  /**
   * A name for the dash style to use for the graph.
   *
   * @see [series.dashStyle](#plotOptions.series.dashStyle)
   *
   * @sample {highcharts|highstock} highcharts/series/color-zones-dashstyle-dot/
   *         Dashed line indicates prognosis
   *
   * @type      {string}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones.dashStyle
   */

  /**
   * Defines the fill color for the series (in area type series)
   *
   * @see [fillColor](#plotOptions.area.fillColor)
   *
   * @type      {Highcharts.ColorString}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones.fillColor
   */

  /**
   * The value up to where the zone extends, if undefined the zones stretches
   * to the last value in the series.
   *
   * @type      {number}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones.value
   */

  /**
   * Determines whether the series should look for the nearest point
   * in both dimensions or just the x-dimension when hovering the series.
   * Defaults to `'xy'` for scatter series and `'x'` for most other
   * series. If the data has duplicate x-values, it is recommended to
   * set this to `'xy'` to allow hovering over all points.
   *
   * Applies only to series types using nearest neighbor search (not
   * direct hover) for tooltip.
   *
   * @sample {highcharts} highcharts/series/findnearestpointby/
   *         Different hover behaviors
   * @sample {highstock} highcharts/series/findnearestpointby/
   *         Different hover behaviors
   * @sample {highmaps} highcharts/series/findnearestpointby/
   *         Different hover behaviors
   *
   * @since      5.0.10
   * @validvalue ["x", "xy"]
   */
  findNearestPointBy: 'x'
},
/** @lends Highcharts.Series.prototype */
{
  /**
   * Series options for specific data and the data itself. In TypeScript you
   * have to cast the series options to specific series types, to get all
   * possible options for a series.
   *
   * @example
   * // TypeScript example
   * Highcharts.chart('container', {
   *     series: [{
   *         color: '#06C',
   *         data: [[0, 1], [2, 3]]
   *     } as Highcharts.SeriesLineOptions ]
   * });
   *
   *
   * @type      {Array<*>}
   * @apioption series
   */

  /**
   * An id for the series. This can be used after render time to get a pointer
   * to the series object through `chart.get()`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-id/
   *         Get series by id
   *
   * @type      {string}
   * @since     1.2.0
   * @apioption series.id
   */

  /**
   * The index of the series in the chart, affecting the internal index in the
   * `chart.series` array, the visible Z index as well as the order in the
   * legend.
   *
   * @type      {number}
   * @since     2.3.0
   * @apioption series.index
   */

  /**
   * The sequential index of the series in the legend.
   *
   * @see [legend.reversed](#legend.reversed),
   *      [yAxis.reversedStacks](#yAxis.reversedStacks)
   *
   * @sample {highcharts|highstock} highcharts/series/legendindex/
   *         Legend in opposite order
   *
   * @type      {number}
   * @apioption series.legendIndex
   */

  /**
   * The name of the series as shown in the legend, tooltip etc.
   *
   * @sample {highcharts} highcharts/series/name/
   *         Series name
   * @sample {highmaps} maps/demo/category-map/
   *         Series name
   *
   * @type      {string}
   * @apioption series.name
   */

  /**
   * This option allows grouping series in a stacked chart. The stack option
   * can be a string or anything else, as long as the grouped series' stack
   * options match each other after conversion into a string.
   *
   * @sample {highcharts} highcharts/series/stack/
   *         Stacked and grouped columns
   *
   * @type      {string|*}
   * @since     2.1
   * @product   highcharts highstock
   * @apioption series.stack
   */

  /**
   * The type of series, for example `line` or `column`. By default, the
   * series type is inherited from [chart.type](#chart.type), so unless the
   * chart is a combination of series types, there is no need to set it on the
   * series level.
   *
   * @sample {highcharts} highcharts/series/type/
   *         Line and column in the same chart
   * @sample {highmaps} maps/demo/mapline-mappoint/
   *         Multiple types in the same map
   *
   * @type      {string}
   * @apioption series.type
   */

  /**
   * When using dual or multiple x axes, this number defines which xAxis the
   * particular series is connected to. It refers to either the
   * {@link #xAxis.id|axis id}
   * or the index of the axis in the xAxis array, with 0 being the first.
   *
   * @type      {number|string}
   * @default   0
   * @product   highcharts highstock
   * @apioption series.xAxis
   */

  /**
   * When using dual or multiple y axes, this number defines which yAxis the
   * particular series is connected to. It refers to either the
   * {@link #yAxis.id|axis id}
   * or the index of the axis in the yAxis array, with 0 being the first.
   *
   * @sample {highcharts} highcharts/series/yaxis/
   *         Apply the column series to the secondary Y axis
   *
   * @type      {number|string}
   * @default   0
   * @product   highcharts highstock
   * @apioption series.yAxis
   */

  /**
   * Define the visual z index of the series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-zindex-default/
   *         With no z index, the series defined last are on top
   * @sample {highcharts} highcharts/plotoptions/series-zindex/
   *         With a z index, the series with the highest z index is on top
   * @sample {highstock} highcharts/plotoptions/series-zindex-default/
   *         With no z index, the series defined last are on top
   * @sample {highstock} highcharts/plotoptions/series-zindex/
   *         With a z index, the series with the highest z index is on top
   *
   * @type      {number}
   * @product   highcharts highstock
   * @apioption series.zIndex
   */
  isCartesian: true,
  pointClass: Point$1,
  sorted: true,
  // requires the data to be sorted
  requireSorting: true,
  directTouch: false,
  axisTypes: ['xAxis', 'yAxis'],
  colorCounter: 0,
  // each point's x and y values are stored in this.xData and this.yData
  parallelArrays: ['x', 'y'],
  coll: 'series',
  init: function (chart, options) {
    var series = this,
        events,
        chartSeries = chart.series,
        lastSeries;
    /**
     * Read only. The chart that the series belongs to.
     *
     * @name Highcharts.Series#chart
     * @type {Highcharts.Chart}
     */

    series.chart = chart;
    /**
     * Read only. The series' type, like "line", "area", "column" etc. The
     * type in the series options anc can be altered using {@link
     * Series#update}.
     *
     * @name Highcharts.Series#type
     * @type {string}
     */

    /**
     * Read only. The series' current options. To update, use {@link
     * Series#update}.
     *
     * @name Highcharts.Series#options
     * @type {Highcharts.PlotSeriesOptions}
     */

    series.options = options = series.setOptions(options);
    series.linkedSeries = []; // bind the axes

    series.bindAxes(); // set some variables

    extend$a(series, {
      /**
       * The series name as given in the options. Defaults to
       * "Series {n}".
       *
       * @name Highcharts.Series#name
       * @type {string}
       */
      name: options.name,
      state: '',

      /**
       * Read only. The series' visibility state as set by {@link
       * Series#show}, {@link Series#hide}, or in the initial
       * configuration.
       *
       * @name Highcharts.Series#visible
       * @type {boolean}
       */
      visible: options.visible !== false,
      // true by default

      /**
       * Read only. The series' selected state as set by {@link
       * Highcharts.Series#select}.
       *
       * @name Highcharts.Series#selected
       * @type {boolean}
       */
      selected: options.selected === true // false by default

    }); // register event listeners

    events = options.events;
    objectEach$3(events, function (event, eventType) {
      addEvent$7(series, eventType, event);
    });

    if (events && events.click || options.point && options.point.events && options.point.events.click || options.allowPointSelect) {
      chart.runTrackerClick = true;
    }

    series.getColor();
    series.getSymbol(); // Set the data

    each$d(series.parallelArrays, function (key) {
      series[key + 'Data'] = [];
    });
    series.setData(options.data, false); // Mark cartesian

    if (series.isCartesian) {
      chart.hasCartesianSeries = true;
    } // Get the index and register the series in the chart. The index is one
    // more than the current latest series index (#5960).


    if (chartSeries.length) {
      lastSeries = chartSeries[chartSeries.length - 1];
    }

    series._i = pick$d(lastSeries && lastSeries._i, -1) + 1; // Insert the series and re-order all series above the insertion point.

    chart.orderSeries(this.insert(chartSeries));
    fireEvent$6(this, 'afterInit');
  },

  /**
   * Insert the series in a collection with other series, either the chart
   * series or yAxis series, in the correct order according to the index
   * option. Used internally when adding series.
   *
   * @private
   * @function Highcharts.Series#insert
   *
   * @param {Array<Highcharts.Series>} collection
   *        A collection of series, like `chart.series` or `xAxis.series`.
   *
   * @return {number}
   *         The index of the series in the collection.
   */
  insert: function (collection) {
    var indexOption = this.options.index,
        i; // Insert by index option

    if (isNumber$7(indexOption)) {
      i = collection.length;

      while (i--) {
        // Loop down until the interted element has higher index
        if (indexOption >= pick$d(collection[i].options.index, collection[i]._i)) {
          collection.splice(i + 1, 0, this);
          break;
        }
      }

      if (i === -1) {
        collection.unshift(this);
      }

      i = i + 1; // Or just push it to the end
    } else {
      collection.push(this);
    }

    return pick$d(i, collection.length - 1);
  },

  /**
   * Set the xAxis and yAxis properties of cartesian series, and register the
   * series in the `axis.series` array.
   *
   * @private
   * @function Highcharts.Series#bindAxes
   *
   * @exception 18
   */
  bindAxes: function () {
    var series = this,
        seriesOptions = series.options,
        chart = series.chart,
        axisOptions; // repeat for xAxis and yAxis

    each$d(series.axisTypes || [], function (AXIS) {
      // loop through the chart's axis objects
      each$d(chart[AXIS], function (axis) {
        axisOptions = axis.options; // apply if the series xAxis or yAxis option mathches the number
        // of the axis, or if undefined, use the first axis

        if (seriesOptions[AXIS] === axisOptions.index || seriesOptions[AXIS] !== undefined && seriesOptions[AXIS] === axisOptions.id || seriesOptions[AXIS] === undefined && axisOptions.index === 0) {
          // register this series in the axis.series lookup
          series.insert(axis.series); // set this series.xAxis or series.yAxis reference

          /**
           * Read only. The unique xAxis object associated with the
           * series.
           *
           * @name Highcharts.Series#xAxis
           * @type {Highcharts.Axis}
           */

          /**
           * Read only. The unique yAxis object associated with the
           * series.
           *
           * @name Highcharts.Series#yAxis
           * @type {Highcharts.Axis}
           */

          series[AXIS] = axis; // mark dirty for redraw

          axis.isDirty = true;
        }
      }); // The series needs an X and an Y axis

      if (!series[AXIS] && series.optionalAxis !== AXIS) {
        Highcharts.error(18, true);
      }
    });
  },

  /**
   * For simple series types like line and column, the data values are held in
   * arrays like xData and yData for quick lookup to find extremes and more.
   * For multidimensional series like bubble and map, this can be extended
   * with arrays like zData and valueData by adding to the
   * `series.parallelArrays` array.
   *
   * @private
   * @function Highcharts.Series#updateParallelArrays
   *
   * @param {Highcharts.Point} point
   *
   * @param {number|string} i
   */
  updateParallelArrays: function (point, i) {
    var series = point.series,
        args = arguments,
        fn = isNumber$7(i) ? // Insert the value in the given position
    function (key) {
      var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];
      series[key + 'Data'][i] = val;
    } : // Apply the method specified in i with the following arguments
    // as arguments
    function (key) {
      Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));
    };
    each$d(series.parallelArrays, fn);
  },

  /**
   * Return an auto incremented x value based on the pointStart and
   * pointInterval options. This is only used if an x value is not given for
   * the point that calls autoIncrement.
   *
   * @private
   * @function Highcharts.Series#autoIncrement
   *
   * @return {number}
   */
  autoIncrement: function () {
    var options = this.options,
        xIncrement = this.xIncrement,
        date,
        pointInterval,
        pointIntervalUnit = options.pointIntervalUnit,
        time = this.chart.time;
    xIncrement = pick$d(xIncrement, options.pointStart, 0);
    this.pointInterval = pointInterval = pick$d(this.pointInterval, options.pointInterval, 1); // Added code for pointInterval strings

    if (pointIntervalUnit) {
      date = new time.Date(xIncrement);

      if (pointIntervalUnit === 'day') {
        time.set('Date', date, time.get('Date', date) + pointInterval);
      } else if (pointIntervalUnit === 'month') {
        time.set('Month', date, time.get('Month', date) + pointInterval);
      } else if (pointIntervalUnit === 'year') {
        time.set('FullYear', date, time.get('FullYear', date) + pointInterval);
      }

      pointInterval = date.getTime() - xIncrement;
    }

    this.xIncrement = xIncrement + pointInterval;
    return xIncrement;
  },

  /**
   * Set the series options by merging from the options tree. Called
   * internally on initiating and updating series. This function will not
   * redraw the series. For API usage, use {@link Series#update}.
   *
   * @function Highcharts.Series#setOptions
   *
   * @param {Highcharts.PlotSeriesOptions} itemOptions
   *        The series options.
   *
   * @return {Highcharts.PlotSeriesOptions}
   *
   * @fires Highcharts.Series#event:afterSetOptions
   */
  setOptions: function (itemOptions) {
    var chart = this.chart,
        chartOptions = chart.options,
        plotOptions = chartOptions.plotOptions,
        userOptions = chart.userOptions || {},
        userPlotOptions = userOptions.plotOptions || {},
        typeOptions = plotOptions[this.type],
        options,
        zones;
    this.userOptions = itemOptions; // General series options take precedence over type options because
    // otherwise, default type options like column.animation would be
    // overwritten by the general option. But issues have been raised here
    // (#3881), and the solution may be to distinguish between default
    // option and userOptions like in the tooltip below.

    options = merge$a(typeOptions, plotOptions.series, itemOptions); // The tooltip options are merged between global and series specific
    // options. Importance order asscendingly:
    // globals: (1)tooltip, (2)plotOptions.series, (3)plotOptions[this.type]
    // init userOptions with possible later updates: 4-6 like 1-3 and
    // (7)this series options

    this.tooltipOptions = merge$a(defaultOptions$2.tooltip, // 1
    defaultOptions$2.plotOptions.series && defaultOptions$2.plotOptions.series.tooltip, // 2
    defaultOptions$2.plotOptions[this.type].tooltip, // 3
    chartOptions.tooltip.userOptions, // 4
    plotOptions.series && plotOptions.series.tooltip, // 5
    plotOptions[this.type].tooltip, // 6
    itemOptions.tooltip // 7
    ); // When shared tooltip, stickyTracking is true by default,
    // unless user says otherwise.

    this.stickyTracking = pick$d(itemOptions.stickyTracking, userPlotOptions[this.type] && userPlotOptions[this.type].stickyTracking, userPlotOptions.series && userPlotOptions.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : options.stickyTracking); // Delete marker object if not allowed (#1125)

    if (typeOptions.marker === null) {
      delete options.marker;
    } // Handle color zones


    this.zoneAxis = options.zoneAxis;
    zones = this.zones = (options.zones || []).slice();

    if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
      zones.push({
        value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,
        className: 'highcharts-negative'
      });
    }

    if (zones.length) {
      // Push one extra zone for the rest
      if (defined$9(zones[zones.length - 1].value)) {
        zones.push({});
      }
    }

    fireEvent$6(this, 'afterSetOptions', {
      options: options
    });
    return options;
  },

  /**
   * Return series name in "Series {Number}" format or the one defined by a
   * user. This method can be simply overridden as series name format can
   * vary (e.g. technical indicators).
   *
   * @function Highcharts.Series#getName
   *
   * @return {string}
   *         The series name.
   */
  getName: function () {
    return this.name || 'Series ' + (this.index + 1);
  },

  /**
   * @private
   * @function Highcharts.Series#getCyclic
   *
   * @param {string} prop
   *
   * @param {*} value
   *
   * @param {*} [defaults]
   */
  getCyclic: function (prop, value, defaults) {
    var i,
        chart = this.chart,
        userOptions = this.userOptions,
        indexName = prop + 'Index',
        counterName = prop + 'Counter',
        len = defaults ? defaults.length : pick$d(chart.options.chart[prop + 'Count'], chart[prop + 'Count']),
        setting;

    if (!value) {
      // Pick up either the colorIndex option, or the _colorIndex after
      // Series.update()
      setting = pick$d(userOptions[indexName], userOptions['_' + indexName]);

      if (defined$9(setting)) {
        // after Series.update()
        i = setting;
      } else {
        // #6138
        if (!chart.series.length) {
          chart[counterName] = 0;
        }

        userOptions['_' + indexName] = i = chart[counterName] % len;
        chart[counterName] += 1;
      }

      if (defaults) {
        value = defaults[i];
      }
    } // Set the colorIndex


    if (i !== undefined) {
      this[indexName] = i;
    }

    this[prop] = value;
  },

  /**
   * Get the series' color based on either the options or pulled from global
   * options.
   *
   * @function Highcharts.Series#getColor
   */
  getColor: function () {
    this.getCyclic('color');
  },

  /**
   * Get the series' symbol based on either the options or pulled from global
   * options.
   *
   * @function Highcharts.Series#getSymbol
   */
  getSymbol: function () {
    var seriesMarkerOption = this.options.marker;
    this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);
  },

  /**
   * @private
   * @borrows LegendSymbolMixin.drawLineMarker as Highcharts.Series#drawLegendSymbol
   */
  drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

  /**
   * Internal function called from setData. If the point count is the same as
   * is was, or if there are overlapping X values, just run Point.update which
   * is cheaper, allows animation, and keeps references to points. This also
   * allows adding or removing points if the X-es don't match.
   *
   * @private
   * @function Highcharts.Series#updateData
   *
   * @param {Array<*>} data
   *
   * @return {boolean}
   */
  updateData: function (data) {
    var options = this.options,
        oldData = this.points,
        pointsToAdd = [],
        hasUpdatedByKey,
        i,
        point,
        lastIndex,
        requireSorting = this.requireSorting; // Iterate the new data

    each$d(data, function (pointOptions) {
      var x, pointIndex; // Get the x of the new data point

      x = Highcharts.defined(pointOptions) && this.pointClass.prototype.optionsToObject.call({
        series: this
      }, pointOptions).x;

      if (isNumber$7(x)) {
        // Search for the same X in the existing data set
        pointIndex = Highcharts.inArray(x, this.xData, lastIndex); // Matching X not found
        // or used already due to ununique x values (#8995),
        // add point (but later)

        if (pointIndex === -1 || oldData[pointIndex].touched) {
          pointsToAdd.push(pointOptions); // Matching X found, update
        } else if (pointOptions !== options.data[pointIndex]) {
          oldData[pointIndex].update(pointOptions, false, null, false); // Mark it touched, below we will remove all points that
          // are not touched.

          oldData[pointIndex].touched = true; // Speed optimize by only searching after last known index.
          // Performs ~20% bettor on large data sets.

          if (requireSorting) {
            lastIndex = pointIndex + 1;
          } // Point exists, no changes, don't remove it

        } else if (oldData[pointIndex]) {
          oldData[pointIndex].touched = true;
        }

        hasUpdatedByKey = true;
      }
    }, this); // Remove points that don't exist in the updated data set

    if (hasUpdatedByKey) {
      i = oldData.length;

      while (i--) {
        point = oldData[i];

        if (!point.touched) {
          point.remove(false);
        }

        point.touched = false;
      } // If we did not find keys (x-values), and the length is the same,
      // update one-to-one

    } else if (data.length === oldData.length) {
      each$d(data, function (point, i) {
        // .update doesn't exist on a linked, hidden series (#3709)
        if (oldData[i].update && point !== options.data[i]) {
          oldData[i].update(point, false, null, false);
        }
      }); // Did not succeed in updating data
    } else {
      return false;
    } // Add new points


    each$d(pointsToAdd, function (point) {
      this.addPoint(point, false);
    }, this);
    return true;
  },

  /**
   * Apply a new set of data to the series and optionally redraw it. The new
   * data array is passed by reference (except in case of `updatePoints`), and
   * may later be mutated when updating the chart data.
   *
   * Note the difference in behaviour when setting the same amount of points,
   * or a different amount of points, as handled by the `updatePoints`
   * parameter.
   *
   * @sample highcharts/members/series-setdata/
   *         Set new data from a button
   * @sample highcharts/members/series-setdata-pie/
   *         Set data in a pie
   * @sample stock/members/series-setdata/
   *         Set new data in Highstock
   * @sample maps/members/series-setdata/
   *         Set new data in Highmaps
   *
   * @function Highcharts.Series#setData
   *
   * @param {Array<*>} data
   *        Takes an array of data in the same format as described under
   *        `series.{type}.data` for the given series type, for example a
   *        line series would take data in the form described under
   *        [series.line.data](https://api.highcharts.com/highcharts/series.line.data).
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after the series is altered. If doing
   *        more operations on the chart, it is a good idea to set redraw to
   *        false and call {@link Chart#redraw} after.
   *
   * @param {Highcharts.AnimationOptionsObject} [animation]
   *        When the updated data is the same length as the existing data,
   *        points will be updated by default, and animation visualizes how
   *        the points are changed. Set false to disable animation, or a
   *        configuration object to set duration or easing.
   *
   * @param {boolean} [updatePoints=true]
   *        When the updated data is the same length as the existing data, or
   *        points can be matched by X values, points will be updated instead
   *        of replaced. This allows updating with animation and performs
   *        better. In this case, the original array is not passed by
   *        reference. Set `false` to prevent.
   */
  setData: function (data, redraw, animation, updatePoints) {
    var series = this,
        oldData = series.points,
        oldDataLength = oldData && oldData.length || 0,
        dataLength,
        options = series.options,
        chart = series.chart,
        firstPoint = null,
        xAxis = series.xAxis,
        i,
        turboThreshold = options.turboThreshold,
        pt,
        xData = this.xData,
        yData = this.yData,
        pointArrayMap = series.pointArrayMap,
        valueCount = pointArrayMap && pointArrayMap.length,
        updatedData;
    data = data || [];
    dataLength = data.length;
    redraw = pick$d(redraw, true); // If the point count is the same as is was, just run Point.update which
    // is cheaper, allows animation, and keeps references to points.

    if (updatePoints !== false && dataLength && oldDataLength && !series.cropped && !series.hasGroupedData && series.visible && // Soft updating has no benefit in boost, and causes JS error
    // (#8355)
    !series.isSeriesBoosting) {
      updatedData = this.updateData(data);
    }

    if (!updatedData) {
      // Reset properties
      series.xIncrement = null;
      series.colorCounter = 0; // for series with colorByPoint (#1547)
      // Update parallel arrays

      each$d(this.parallelArrays, function (key) {
        series[key + 'Data'].length = 0;
      }); // In turbo mode, only one- or twodimensional arrays of numbers are
      // allowed. The first value is tested, and we assume that all the
      // rest are defined the same way. Although the 'for' loops are
      // similar, they are repeated inside each if-else conditional for
      // max performance.

      if (turboThreshold && dataLength > turboThreshold) {
        // find the first non-null point
        i = 0;

        while (firstPoint === null && i < dataLength) {
          firstPoint = data[i];
          i++;
        }

        if (isNumber$7(firstPoint)) {
          // assume all points are numbers
          for (i = 0; i < dataLength; i++) {
            xData[i] = this.autoIncrement();
            yData[i] = data[i];
          } // Assume all points are arrays when first point is

        } else if (isArray$3(firstPoint)) {
          if (valueCount) {
            // [x, low, high] or [x, o, h, l, c]
            for (i = 0; i < dataLength; i++) {
              pt = data[i];
              xData[i] = pt[0];
              yData[i] = pt.slice(1, valueCount + 1);
            }
          } else {
            // [x, y]
            for (i = 0; i < dataLength; i++) {
              pt = data[i];
              xData[i] = pt[0];
              yData[i] = pt[1];
            }
          }
        } else {
          // Highcharts expects configs to be numbers or arrays in
          // turbo mode
          Highcharts.error(12);
        }
      } else {
        for (i = 0; i < dataLength; i++) {
          if (data[i] !== undefined) {
            // stray commas in oldIE
            pt = {
              series: series
            };
            series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
            series.updateParallelArrays(pt, i);
          }
        }
      } // Forgetting to cast strings to numbers is a common caveat when
      // handling CSV or JSON


      if (yData && isString$4(yData[0])) {
        Highcharts.error(14, true);
      }

      series.data = [];
      series.options.data = series.userOptions.data = data; // destroy old points

      i = oldDataLength;

      while (i--) {
        if (oldData[i] && oldData[i].destroy) {
          oldData[i].destroy();
        }
      } // reset minRange (#878)


      if (xAxis) {
        xAxis.minRange = xAxis.userMinRange;
      } // redraw


      series.isDirty = chart.isDirtyBox = true;
      series.isDirtyData = !!oldData;
      animation = false;
    } // Typically for pie series, points need to be processed and generated
    // prior to rendering the legend


    if (options.legendType === 'point') {
      this.processData();
      this.generatePoints();
    }

    if (redraw) {
      chart.redraw(animation);
    }
  },

  /**
   * Internal function to process the data by cropping away unused data points
   * if the series is longer than the crop threshold. This saves computing
   * time for large series. In Highstock, this function is extended to
   * provide data grouping.
   *
   * @private
   * @function Highcharts.Series#processData
   *
   * @param {boolean} force
   *        Force data grouping.
   *
   * @return {boolean|undefined}
   */
  processData: function (force) {
    var series = this,
        processedXData = series.xData,
        // copied during slice operation
    processedYData = series.yData,
        dataLength = processedXData.length,
        croppedData,
        cropStart = 0,
        cropped,
        distance,
        closestPointRange,
        xAxis = series.xAxis,
        i,
        // loop variable
    options = series.options,
        cropThreshold = options.cropThreshold,
        getExtremesFromAll = series.getExtremesFromAll || options.getExtremesFromAll,
        // #4599
    isCartesian = series.isCartesian,
        xExtremes,
        val2lin = xAxis && xAxis.val2lin,
        isLog = xAxis && xAxis.isLog,
        throwOnUnsorted = series.requireSorting,
        min,
        max; // If the series data or axes haven't changed, don't go through this.
    // Return false to pass the message on to override methods like in data
    // grouping.

    if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
      return false;
    }

    if (xAxis) {
      xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)

      min = xExtremes.min;
      max = xExtremes.max;
    } // optionally filter out points outside the plot area


    if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
      // it's outside current extremes
      if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
        processedXData = [];
        processedYData = []; // only crop if it's actually spilling out
      } else if (series.yData && (processedXData[0] < min || processedXData[dataLength - 1] > max)) {
        croppedData = this.cropData(series.xData, series.yData, min, max);
        processedXData = croppedData.xData;
        processedYData = croppedData.yData;
        cropStart = croppedData.start;
        cropped = true;
      }
    } // Find the closest distance between processed points


    i = processedXData.length || 1;

    while (--i) {
      distance = isLog ? val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) : processedXData[i] - processedXData[i - 1];

      if (distance > 0 && (closestPointRange === undefined || distance < closestPointRange)) {
        closestPointRange = distance; // Unsorted data is not supported by the line tooltip, as well as
        // data grouping and navigation in Stock charts (#725) and width
        // calculation of columns (#1900)
      } else if (distance < 0 && throwOnUnsorted) {
        Highcharts.error(15);
        throwOnUnsorted = false; // Only once
      }
    } // Record the properties


    series.cropped = cropped; // undefined or true

    series.cropStart = cropStart;
    series.processedXData = processedXData;
    series.processedYData = processedYData;
    series.closestPointRange = closestPointRange;
  },

  /**
   * Iterate over xData and crop values between min and max. Returns object
   * containing crop start/end cropped xData with corresponding part of yData,
   * dataMin and dataMax within the cropped range.
   *
   * @private
   * @function Highcharts.Series#cropData
   *
   * @param {Array<number>} xData
   *
   * @param {Array<number>} yData
   *
   * @param {number} min
   *
   * @param {number} max
   *
   * @param {number} [cropShoulder]
   *
   * @return {*}
   */
  cropData: function (xData, yData, min, max, cropShoulder) {
    var dataLength = xData.length,
        cropStart = 0,
        cropEnd = dataLength,
        i,
        j; // line-type series need one point outside

    cropShoulder = pick$d(cropShoulder, this.cropShoulder, 1); // iterate up to find slice start

    for (i = 0; i < dataLength; i++) {
      if (xData[i] >= min) {
        cropStart = Math.max(0, i - cropShoulder);
        break;
      }
    } // proceed to find slice end


    for (j = i; j < dataLength; j++) {
      if (xData[j] > max) {
        cropEnd = j + cropShoulder;
        break;
      }
    }

    return {
      xData: xData.slice(cropStart, cropEnd),
      yData: yData.slice(cropStart, cropEnd),
      start: cropStart,
      end: cropEnd
    };
  },

  /**
   * Generate the data point after the data has been processed by cropping
   * away unused points and optionally grouped in Highcharts Stock.
   *
   * @private
   * @function Highcharts.Series#generatePoints
   */
  generatePoints: function () {
    var series = this,
        options = series.options,
        dataOptions = options.data,
        data = series.data,
        dataLength,
        processedXData = series.processedXData,
        processedYData = series.processedYData,
        PointClass = series.pointClass,
        processedDataLength = processedXData.length,
        cropStart = series.cropStart || 0,
        cursor,
        hasGroupedData = series.hasGroupedData,
        keys = options.keys,
        point,
        points = [],
        i;

    if (!data && !hasGroupedData) {
      var arr = [];
      arr.length = dataOptions.length;
      data = series.data = arr;
    }

    if (keys && hasGroupedData) {
      // grouped data has already applied keys (#6590)
      series.options.keys = false;
    }

    for (i = 0; i < processedDataLength; i++) {
      cursor = cropStart + i;

      if (!hasGroupedData) {
        point = data[cursor];

        if (!point && dataOptions[cursor] !== undefined) {
          // #970
          data[cursor] = point = new PointClass().init(series, dataOptions[cursor], processedXData[i]);
        }
      } else {
        // splat the y data in case of ohlc data array
        point = new PointClass().init(series, [processedXData[i]].concat(splat$5(processedYData[i])));
        /**
         * Highstock only. If a point object is created by data
         * grouping, it doesn't reflect actual points in the raw data.
         * In this case, the `dataGroup` property holds information
         * that points back to the raw data.
         *
         * - `dataGroup.start` is the index of the first raw data point
         * in the group.
         * - `dataGroup.length` is the amount of points in the group.
         *
         * @name Highcharts.Point#dataGroup
         * @type {Highcharts.SVGElement|undefined}
         *
         * @product highstock
         */

        point.dataGroup = series.groupMap[i];

        if (point.dataGroup.options) {
          point.options = point.dataGroup.options;
          extend$a(point, point.dataGroup.options);
        }
      }

      if (point) {
        // #6279
        point.index = cursor; // For faster access in Point.update

        points[i] = point;
      }
    } // restore keys options (#6590)


    series.options.keys = keys; // Hide cropped-away points - this only runs when the number of points
    // is above cropThreshold, or when swithching view from non-grouped
    // data to grouped data (#637)

    if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
      for (i = 0; i < dataLength; i++) {
        // when has grouped data, clear all points
        if (i === cropStart && !hasGroupedData) {
          i += processedDataLength;
        }

        if (data[i]) {
          data[i].destroyElements();
          data[i].plotX = undefined; // #1003
        }
      }
    }
    /**
     * Read only. An array containing those values converted to points.
     * In case the series data length exceeds the `cropThreshold`, or if the
     * data is grouped, `series.data` doesn't contain all the points. Also,
     * in case a series is hidden, the `data` array may be empty. To access
     * raw values, `series.options.data` will always be up to date.
     * `Series.data` only contains the points that have been created on
     * demand. To modify the data, use {@link Highcharts.Series#setData} or
     * {@link Highcharts.Point#update}.
     *
     * @see Series.points
     *
     * @name Highcharts.Series#data
     * @type {Array<Point>}
     */


    series.data = data;
    /**
     * An array containing all currently visible point objects. In case of
     * cropping, the cropped-away points are not part of this array. The
     * `series.points` array starts at `series.cropStart` compared to
     * `series.data` and `series.options.data`. If however the series data
     * is grouped, these can't be correlated one to one. To
     * modify the data, use {@link Highcharts.Series#setData} or {@link
     * Highcharts.Point#update}.
     *
     * @name Highcharts.Series#points
     * @type {Array<Highcharts.Point>}
     */

    series.points = points;
  },

  /**
   * Calculate Y extremes for the visible data. The result is set as
   * `dataMin` and `dataMax` on the Series item.
   *
   * @function Highcharts.Series#getExtremes
   *
   * @param {Array<number>} [yData]
   *        The data to inspect. Defaults to the current data within the
   *        visible range.
   */
  getExtremes: function (yData) {
    var xAxis = this.xAxis,
        yAxis = this.yAxis,
        xData = this.processedXData,
        yDataLength,
        activeYData = [],
        activeCounter = 0,
        // #2117, need to compensate for log X axis
    xExtremes = xAxis.getExtremes(),
        xMin = xExtremes.min,
        xMax = xExtremes.max,
        validValue,
        withinRange,
        // Handle X outside the viewed area. This does not work with non-
    // sorted data like scatter (#7639).
    shoulder = this.requireSorting ? 1 : 0,
        x,
        y,
        i,
        j;
    yData = yData || this.stackedYData || this.processedYData || [];
    yDataLength = yData.length;

    for (i = 0; i < yDataLength; i++) {
      x = xData[i];
      y = yData[i]; // For points within the visible range, including the first point
      // outside the visible range (#7061), consider y extremes.

      validValue = (isNumber$7(y, true) || isArray$3(y)) && (!yAxis.positiveValuesOnly || y.length || y > 0);
      withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (xData[i + shoulder] || x) >= xMin && (xData[i - shoulder] || x) <= xMax;

      if (validValue && withinRange) {
        j = y.length;

        if (j) {
          // array, like ohlc or range data
          while (j--) {
            if (typeof y[j] === 'number') {
              // #7380
              activeYData[activeCounter++] = y[j];
            }
          }
        } else {
          activeYData[activeCounter++] = y;
        }
      }
    }

    this.dataMin = arrayMin$2(activeYData);
    this.dataMax = arrayMax$2(activeYData);
  },

  /**
   * Translate data points from raw data values to chart specific positioning
   * data needed later in the `drawPoints` and `drawGraph` functions. This
   * function can be overridden in plugins and custom series type
   * implementations.
   *
   * @function Highcharts.Series#translate
   *
   * @todo
   * Make events official: Fires the event `afterTranslate`.
   */
  translate: function () {
    if (!this.processedXData) {
      // hidden series
      this.processData();
    }

    this.generatePoints();
    var series = this,
        options = series.options,
        stacking = options.stacking,
        xAxis = series.xAxis,
        categories = xAxis.categories,
        yAxis = series.yAxis,
        points = series.points,
        dataLength = points.length,
        hasModifyValue = !!series.modifyValue,
        i,
        pointPlacement = options.pointPlacement,
        dynamicallyPlaced = pointPlacement === 'between' || isNumber$7(pointPlacement),
        threshold = options.threshold,
        stackThreshold = options.startFromThreshold ? threshold : 0,
        plotX,
        plotY,
        lastPlotX,
        stackIndicator,
        closestPointRangePx = Number.MAX_VALUE;
    /*
     * Plotted coordinates need to be within a limited range. Drawing too
     * far outside the viewport causes various rendering issues (#3201,
     * #3923, #7555).
     */

    function limitedRange(val) {
      return Math.min(Math.max(-1e5, val), 1e5);
    } // Point placement is relative to each series pointRange (#5889)


    if (pointPlacement === 'between') {
      pointPlacement = 0.5;
    }

    if (isNumber$7(pointPlacement)) {
      pointPlacement *= pick$d(options.pointRange || xAxis.pointRange);
    } // Translate each point


    for (i = 0; i < dataLength; i++) {
      var point = points[i],
          xValue = point.x,
          yValue = point.y,
          yBottom = point.low,
          stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],
          pointStack,
          stackValues; // Discard disallowed y values for log axes (#3434)

      if (yAxis.positiveValuesOnly && yValue !== null && yValue <= 0) {
        point.isNull = true;
      } // Get the plotX translation


      point.plotX = plotX = correctFloat$2( // #5236
      limitedRange(xAxis.translate( // #3923
      xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags')) // #3923
      ); // Calculate the bottom y value for stacked series

      if (stacking && series.visible && !point.isNull && stack && stack[xValue]) {
        stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
        pointStack = stack[xValue];
        stackValues = pointStack.points[stackIndicator.key];
        yBottom = stackValues[0];
        yValue = stackValues[1];

        if (yBottom === stackThreshold && stackIndicator.key === stack[xValue].base) {
          yBottom = pick$d(isNumber$7(threshold) && threshold, yAxis.min);
        }

        if (yAxis.positiveValuesOnly && yBottom <= 0) {
          // #1200, #1232
          yBottom = null;
        }

        point.total = point.stackTotal = pointStack.total;
        point.percentage = pointStack.total && point.y / pointStack.total * 100;
        point.stackY = yValue; // Place the stack label

        pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);
      } // Set translated yBottom or remove it


      point.yBottom = defined$9(yBottom) ? limitedRange(yAxis.translate(yBottom, 0, 1, 0, 1)) : null; // general hook, used for Highstock compare mode

      if (hasModifyValue) {
        yValue = series.modifyValue(yValue, point);
      } // Set the the plotY value, reset it for redraws


      point.plotY = plotY = typeof yValue === 'number' && yValue !== Infinity ? limitedRange(yAxis.translate(yValue, 0, 1, 0, 1)) : // #3201
      undefined;
      point.isInside = plotY !== undefined && plotY >= 0 && plotY <= yAxis.len && // #3519
      plotX >= 0 && plotX <= xAxis.len; // Set client related positions for mouse tracking

      point.clientX = dynamicallyPlaced ? correctFloat$2(xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)) : plotX; // #1514, #5383, #5518

      point.negative = point.y < (threshold || 0); // some API data

      point.category = categories && categories[point.x] !== undefined ? categories[point.x] : point.x; // Determine auto enabling of markers (#3635, #5099)

      if (!point.isNull) {
        if (lastPlotX !== undefined) {
          closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));
        }

        lastPlotX = plotX;
      } // Find point zone


      point.zone = this.zones.length && point.getZone();
    }

    series.closestPointRangePx = closestPointRangePx;
    fireEvent$6(this, 'afterTranslate');
  },

  /**
   * Return the series points with null points filtered out.
   *
   * @param {Array<Highcharts.Point>} [points]
   *        The points to inspect, defaults to {@link Series.points}.
   *
   * @param {boolean} [insideOnly=false]
   *        Whether to inspect only the points that are inside the visible
   *        view.
   *
   * @return {Array<Highcharts.Point>}
   *         The valid points.
   */
  getValidPoints: function (points, insideOnly) {
    var chart = this.chart; // #3916, #5029, #5085

    return grep$3(points || this.points || [], function isValidPoint(point) {
      if (insideOnly && !chart.isInsidePlot(point.plotX, point.plotY, chart.inverted)) {
        return false;
      }

      return !point.isNull;
    });
  },

  /**
   * Set the clipping for the series. For animated series it is called twice,
   * first to initiate animating the clip then the second time without the
   * animation to set the final clip.
   *
   * @private
   * @function Highcharts.Series#setClip
   *
   * @param {boolean} [animation]
   */
  setClip: function (animation) {
    var chart = this.chart,
        options = this.options,
        renderer = chart.renderer,
        inverted = chart.inverted,
        seriesClipBox = this.clipBox,
        clipBox = seriesClipBox || chart.clipBox,
        sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height, options.xAxis, options.yAxis].join(','),
        // #4526
    clipRect = chart[sharedClipKey],
        markerClipRect = chart[sharedClipKey + 'm']; // If a clipping rectangle with the same properties is currently present
    // in the chart, use that.

    if (!clipRect) {
      // When animation is set, prepare the initial positions
      if (animation) {
        clipBox.width = 0;

        if (inverted) {
          clipBox.x = chart.plotSizeX;
        }

        chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect( // include the width of the first marker
        inverted ? chart.plotSizeX + 99 : -99, inverted ? -chart.plotLeft : -chart.plotTop, 99, inverted ? chart.chartWidth : chart.chartHeight);
      }

      chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox); // Create hashmap for series indexes

      clipRect.count = {
        length: 0
      };
    }

    if (animation) {
      if (!clipRect.count[this.index]) {
        clipRect.count[this.index] = true;
        clipRect.count.length += 1;
      }
    }

    if (options.clip !== false) {
      this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
      this.markerGroup.clip(markerClipRect);
      this.sharedClipKey = sharedClipKey;
    } // Remove the shared clipping rectangle when all series are shown


    if (!animation) {
      if (clipRect.count[this.index]) {
        delete clipRect.count[this.index];
        clipRect.count.length -= 1;
      }

      if (clipRect.count.length === 0 && sharedClipKey && chart[sharedClipKey]) {
        if (!seriesClipBox) {
          chart[sharedClipKey] = chart[sharedClipKey].destroy();
        }

        if (chart[sharedClipKey + 'm']) {
          chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
        }
      }
    }
  },

  /**
   * Animate in the series. Called internally twice. First with the `init`
   * parameter set to true, which sets up the initial state of the animation.
   * Then when ready, it is called with the `init` parameter undefined, in
   * order to perform the actual animation. After the second run, the function
   * is removed.
   *
   * @function Highcharts.Series#animate
   *
   * @param {boolean} init
   *        Initialize the animation.
   */
  animate: function (init) {
    var series = this,
        chart = series.chart,
        clipRect,
        animation = animObject$2(series.options.animation),
        sharedClipKey; // Initialize the animation. Set up the clipping rectangle.

    if (init) {
      series.setClip(animation); // Run the animation
    } else {
      sharedClipKey = this.sharedClipKey;
      clipRect = chart[sharedClipKey];

      if (clipRect) {
        clipRect.animate({
          width: chart.plotSizeX,
          x: 0
        }, animation);
      }

      if (chart[sharedClipKey + 'm']) {
        chart[sharedClipKey + 'm'].animate({
          width: chart.plotSizeX + 99,
          x: 0
        }, animation);
      } // Delete this function to allow it only once


      series.animate = null;
    }
  },

  /**
   * This runs after animation to land on the final plot clipping.
   *
   * @private
   * @function Highcharts.Series#afterAnimate
   *
   * @todo
   * Make events official: Fires the event `afterAnimate`.
   */
  afterAnimate: function () {
    this.setClip();
    fireEvent$6(this, 'afterAnimate');
    this.finishedAnimating = true;
  },

  /**
   * Draw the markers for line-like series types, and columns or other
   * graphical representation for {@link Point} objects for other series
   * types. The resulting element is typically stored as {@link
   * Point.graphic}, and is created on the first call and updated and moved on
   * subsequent calls.
   *
   * @function Highcharts.Series#drawPoints
   */
  drawPoints: function () {
    var series = this,
        points = series.points,
        chart = series.chart,
        i,
        point,
        symbol,
        graphic,
        options = series.options,
        seriesMarkerOptions = options.marker,
        pointMarkerOptions,
        hasPointMarker,
        enabled,
        isInside,
        markerGroup = series[series.specialGroup] || series.markerGroup,
        xAxis = series.xAxis,
        markerAttribs,
        globallyEnabled = pick$d(seriesMarkerOptions.enabled, xAxis.isRadial ? true : null, // Use larger or equal as radius is null in bubbles (#6321)
    series.closestPointRangePx >= seriesMarkerOptions.enabledThreshold * seriesMarkerOptions.radius);

    if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {
      for (i = 0; i < points.length; i++) {
        point = points[i];
        graphic = point.graphic;
        pointMarkerOptions = point.marker || {};
        hasPointMarker = !!point.marker;
        enabled = globallyEnabled && pointMarkerOptions.enabled === undefined || pointMarkerOptions.enabled;
        isInside = point.isInside; // only draw the point if y is defined

        if (enabled && !point.isNull) {
          // Shortcuts
          symbol = pick$d(pointMarkerOptions.symbol, series.symbol);
          markerAttribs = series.markerAttribs(point, point.selected && 'select');

          if (graphic) {
            // update
            // Since the marker group isn't clipped, each individual
            // marker must be toggled
            graphic[isInside ? 'show' : 'hide'](true).animate(markerAttribs);
          } else if (isInside && (markerAttribs.width > 0 || point.hasImage)) {
            /**
             * The graphic representation of the point. Typically
             * this is a simple shape, like a `rect` for column
             * charts or `path` for line markers, but for some
             * complex series types like boxplot or 3D charts, the
             * graphic may be a `g` element containing other shapes.
             * The graphic is generated the first time {@link
             * Series#drawPoints} runs, and updated and moved on
             * subsequent runs.
             *
             * @memberof Point
             * @name graphic
             * @type {SVGElement}
             */
            point.graphic = graphic = chart.renderer.symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ? pointMarkerOptions : seriesMarkerOptions).add(markerGroup);
          }

          if (graphic) {
            graphic.addClass(point.getClassName(), true);
          }
        } else if (graphic) {
          point.graphic = graphic.destroy(); // #1269
        }
      }
    }
  },

  /**
   * Get non-presentational attributes for a point. Used internally for both
   * styled mode and classic. Can be overridden for different series types.
   *
   * @see Series#pointAttribs
   *
   * @param {Highcharts.Point} point
   *        The Point to inspect.
   *
   * @param {string} [state]
   *        The state, can be either `hover`, `select` or undefined.
   *
   * @return {Highcharts.SVGAttributes}
   *         A hash containing those attributes that are not settable from
   *         CSS.
   */
  markerAttribs: function (point, state) {
    var seriesMarkerOptions = this.options.marker,
        seriesStateOptions,
        pointMarkerOptions = point.marker || {},
        symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol,
        pointStateOptions,
        radius = pick$d(pointMarkerOptions.radius, seriesMarkerOptions.radius),
        attribs; // Handle hover and select states

    if (state) {
      seriesStateOptions = seriesMarkerOptions.states[state];
      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state];
      radius = pick$d(pointStateOptions && pointStateOptions.radius, seriesStateOptions && seriesStateOptions.radius, radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0));
    }

    point.hasImage = symbol && symbol.indexOf('url') === 0;

    if (point.hasImage) {
      radius = 0; // and subsequently width and height is not set
    }

    attribs = {
      x: Math.floor(point.plotX) - radius,
      // Math.floor for #1843
      y: point.plotY - radius
    };

    if (radius) {
      attribs.width = attribs.height = 2 * radius;
    }

    return attribs;
  },

  /**
   * Clear DOM objects and free up memory.
   *
   * @private
   * @function Highcharts.Series#destroy
   *
   * @todo
   * Make events official: Fires the event `destroy`.
   */
  destroy: function () {
    var series = this,
        chart = series.chart,
        issue134 = /AppleWebKit\/533/.test(win$8.navigator.userAgent),
        destroy,
        i,
        data = series.data || [],
        point,
        axis; // add event hook

    fireEvent$6(series, 'destroy'); // remove all events

    removeEvent$5(series); // erase from axes

    each$d(series.axisTypes || [], function (AXIS) {
      axis = series[AXIS];

      if (axis && axis.series) {
        erase$3(axis.series, series);
        axis.isDirty = axis.forceRedraw = true;
      }
    }); // remove legend items

    if (series.legendItem) {
      series.chart.legend.destroyItem(series);
    } // destroy all points with their elements


    i = data.length;

    while (i--) {
      point = data[i];

      if (point && point.destroy) {
        point.destroy();
      }
    }

    series.points = null; // Clear the animation timeout if we are destroying the series during
    // initial animation

    Highcharts.clearTimeout(series.animationTimeout); // Destroy all SVGElements associated to the series

    objectEach$3(series, function (val, prop) {
      // Survive provides a hook for not destroying
      if (val instanceof SVGElement$2 && !val.survive) {
        // issue 134 workaround
        destroy = issue134 && prop === 'group' ? 'hide' : 'destroy';
        val[destroy]();
      }
    }); // remove from hoverSeries

    if (chart.hoverSeries === series) {
      chart.hoverSeries = null;
    }

    erase$3(chart.series, series);
    chart.orderSeries(); // clear all members

    objectEach$3(series, function (val, prop) {
      delete series[prop];
    });
  },

  /**
   * Get the graph path.
   *
   * @private
   * @function Highcharts.Series#getGraphPath
   *
   * @param {Array<*>} points
   *
   * @param {boolean} nullsAsZeroes
   *
   * @param {boolean} connectCliffs
   *
   * @return {Array<number|string>}
   */
  getGraphPath: function (points, nullsAsZeroes, connectCliffs) {
    var series = this,
        options = series.options,
        step = options.step,
        reversed,
        graphPath = [],
        xMap = [],
        gap;
    points = points || series.points; // Bottom of a stack is reversed

    reversed = points.reversed;

    if (reversed) {
      points.reverse();
    } // Reverse the steps (#5004)


    step = {
      right: 1,
      center: 2
    }[step] || step && 3;

    if (step && reversed) {
      step = 4 - step;
    } // Remove invalid points, especially in spline (#5015)


    if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {
      points = this.getValidPoints(points);
    } // Build the line


    each$d(points, function (point, i) {
      var plotX = point.plotX,
          plotY = point.plotY,
          lastPoint = points[i - 1],
          pathToPoint; // the path to this point from the previous

      if ((point.leftCliff || lastPoint && lastPoint.rightCliff) && !connectCliffs) {
        gap = true; // ... and continue
      } // Line series, nullsAsZeroes is not handled


      if (point.isNull && !defined$9(nullsAsZeroes) && i > 0) {
        gap = !options.connectNulls; // Area series, nullsAsZeroes is set
      } else if (point.isNull && !nullsAsZeroes) {
        gap = true;
      } else {
        if (i === 0 || gap) {
          pathToPoint = ['M', point.plotX, point.plotY]; // Generate the spline as defined in the SplineSeries object
        } else if (series.getPointSpline) {
          pathToPoint = series.getPointSpline(points, point, i);
        } else if (step) {
          if (step === 1) {
            // right
            pathToPoint = ['L', lastPoint.plotX, plotY];
          } else if (step === 2) {
            // center
            pathToPoint = ['L', (lastPoint.plotX + plotX) / 2, lastPoint.plotY, 'L', (lastPoint.plotX + plotX) / 2, plotY];
          } else {
            pathToPoint = ['L', plotX, lastPoint.plotY];
          }

          pathToPoint.push('L', plotX, plotY);
        } else {
          // normal line to next point
          pathToPoint = ['L', plotX, plotY];
        } // Prepare for animation. When step is enabled, there are two
        // path nodes for each x value.


        xMap.push(point.x);

        if (step) {
          xMap.push(point.x);

          if (step === 2) {
            // step = center (#8073)
            xMap.push(point.x);
          }
        }

        graphPath.push.apply(graphPath, pathToPoint);
        gap = false;
      }
    });
    graphPath.xMap = xMap;
    series.graphPath = graphPath;
    return graphPath;
  },

  /**
   * Draw the graph. Called internally when rendering line-like series types.
   * The first time it generates the `series.graph` item and optionally other
   * series-wide items like `series.area` for area charts. On subsequent calls
   * these items are updated with new positions and attributes.
   *
   * @function Highcharts.Series#drawGraph
   */
  drawGraph: function () {
    var series = this,
        options = this.options,
        graphPath = (this.gappedPath || this.getGraphPath).call(this),
        props = [['graph', 'highcharts-graph']];
    props = series.getZonesGraphs(props); // Draw the graph

    each$d(props, function (prop, i) {
      var graphKey = prop[0],
          graph = series[graphKey];

      if (graph) {
        graph.endX = series.preventGraphAnimation ? null : graphPath.xMap;
        graph.animate({
          d: graphPath
        });
      } else if (graphPath.length) {
        // #1487
        series[graphKey] = series.chart.renderer.path(graphPath).addClass(prop[1]).attr({
          zIndex: 1
        }) // #1069
        .add(series.group);
      } // Helpers for animation


      if (graph) {
        graph.startX = graphPath.xMap;
        graph.isArea = graphPath.isArea; // For arearange animation
      }
    });
  },

  /**
   * Get zones properties for building graphs.
   * Extendable by series with multiple lines within one series.
   *
   * @private
   * @function Highcharts.Series#getZonesGraphs
   *
   * @param {Array<Array<string>>} props
   *
   * @return {Array<Array<string>>}
   */
  getZonesGraphs: function (props) {
    // Add the zone properties if any
    each$d(this.zones, function (zone, i) {
      props.push(['zone-graph-' + i, 'highcharts-graph highcharts-zone-graph-' + i + ' ' + (zone.className || '')]);
    }, this);
    return props;
  },

  /**
   * Clip the graphs into zones for colors and styling.
   *
   * @private
   * @function Highcharts.Series#applyZones
   */
  applyZones: function () {
    var series = this,
        chart = this.chart,
        renderer = chart.renderer,
        zones = this.zones,
        translatedFrom,
        translatedTo,
        clips = this.clips || [],
        clipAttr,
        graph = this.graph,
        area = this.area,
        chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight),
        axis = this[(this.zoneAxis || 'y') + 'Axis'],
        extremes,
        reversed,
        inverted = chart.inverted,
        horiz,
        pxRange,
        pxPosMin,
        pxPosMax,
        ignoreZones = false;

    if (zones.length && (graph || area) && axis && axis.min !== undefined) {
      reversed = axis.reversed;
      horiz = axis.horiz; // The use of the Color Threshold assumes there are no gaps
      // so it is safe to hide the original graph and area
      // unless it is not waterfall series, then use showLine property to
      // set lines between columns to be visible (#7862)

      if (graph && !this.showLine) {
        graph.hide();
      }

      if (area) {
        area.hide();
      } // Create the clips


      extremes = axis.getExtremes();
      each$d(zones, function (threshold, i) {
        translatedFrom = reversed ? horiz ? chart.plotWidth : 0 : horiz ? 0 : axis.toPixels(extremes.min);
        translatedFrom = Math.min(Math.max(pick$d(translatedTo, translatedFrom), 0), chartSizeMax);
        translatedTo = Math.min(Math.max(Math.round(axis.toPixels(pick$d(threshold.value, extremes.max), true)), 0), chartSizeMax);

        if (ignoreZones) {
          translatedFrom = translatedTo = axis.toPixels(extremes.max);
        }

        pxRange = Math.abs(translatedFrom - translatedTo);
        pxPosMin = Math.min(translatedFrom, translatedTo);
        pxPosMax = Math.max(translatedFrom, translatedTo);

        if (axis.isXAxis) {
          clipAttr = {
            x: inverted ? pxPosMax : pxPosMin,
            y: 0,
            width: pxRange,
            height: chartSizeMax
          };

          if (!horiz) {
            clipAttr.x = chart.plotHeight - clipAttr.x;
          }
        } else {
          clipAttr = {
            x: 0,
            y: inverted ? pxPosMax : pxPosMin,
            width: chartSizeMax,
            height: pxRange
          };

          if (horiz) {
            clipAttr.y = chart.plotWidth - clipAttr.y;
          }
        }

        if (clips[i]) {
          clips[i].animate(clipAttr);
        } else {
          clips[i] = renderer.clipRect(clipAttr);

          if (graph) {
            series['zone-graph-' + i].clip(clips[i]);
          }

          if (area) {
            series['zone-area-' + i].clip(clips[i]);
          }
        } // if this zone extends out of the axis, ignore the others


        ignoreZones = threshold.value > extremes.max; // Clear translatedTo for indicators

        if (series.resetZones && translatedTo === 0) {
          translatedTo = undefined;
        }
      });
      this.clips = clips;
    }
  },

  /**
   * Initialize and perform group inversion on series.group and
   * series.markerGroup.
   *
   * @private
   * @function Highcharts.Series#invertGroups
   *
   * @param {boolean} inverted
   */
  invertGroups: function (inverted) {
    var series = this,
        chart = series.chart,
        remover;

    function setInvert() {
      each$d(['group', 'markerGroup'], function (groupName) {
        if (series[groupName]) {
          // VML/HTML needs explicit attributes for flipping
          if (chart.renderer.isVML) {
            series[groupName].attr({
              width: series.yAxis.len,
              height: series.xAxis.len
            });
          }

          series[groupName].width = series.yAxis.len;
          series[groupName].height = series.xAxis.len;
          series[groupName].invert(inverted);
        }
      });
    } // Pie, go away (#1736)


    if (!series.xAxis) {
      return;
    } // A fixed size is needed for inversion to work


    remover = addEvent$7(chart, 'resize', setInvert);
    addEvent$7(series, 'destroy', remover); // Do it now

    setInvert(inverted); // do it now
    // On subsequent render and redraw, just do setInvert without setting up
    // events again

    series.invertGroups = setInvert;
  },

  /**
   * General abstraction for creating plot groups like series.group,
   * series.dataLabelsGroup and series.markerGroup. On subsequent calls, the
   * group will only be adjusted to the updated plot size.
   *
   * @private
   * @function Highcharts.Series#plotGroup
   *
   * @param {string} prop
   *
   * @param {string} name
   *
   * @param {string} visibility
   *
   * @param {number} zIndex
   *
   * @param {Highcharts.SVGElement} parent
   *
   * @return {Highcharts.SVGElement}
   */
  plotGroup: function (prop, name, visibility, zIndex, parent) {
    var group = this[prop],
        isNew = !group; // Generate it on first call

    if (isNew) {
      this[prop] = group = this.chart.renderer.g().attr({
        zIndex: zIndex || 0.1 // IE8 and pointer logic use this

      }).add(parent);
    } // Add the class names, and replace existing ones as response to
    // Series.update (#6660)


    group.addClass('highcharts-' + name + ' highcharts-series-' + this.index + ' highcharts-' + this.type + '-series ' + (defined$9(this.colorIndex) ? 'highcharts-color-' + this.colorIndex + ' ' : '') + (this.options.className || '') + (group.hasClass('highcharts-tracker') ? ' highcharts-tracker' : ''), true); // Place it on first and subsequent (redraw) calls

    group.attr({
      visibility: visibility
    })[isNew ? 'attr' : 'animate'](this.getPlotBox());
    return group;
  },

  /**
   * Get the translation and scale for the plot area of this series.
   *
   * @function Highcharts.Series#getPlotBox
   *
   * @return {Highcharts.SeriesPlotBoxObject}
   */
  getPlotBox: function () {
    var chart = this.chart,
        xAxis = this.xAxis,
        yAxis = this.yAxis; // Swap axes for inverted (#2339)

    if (chart.inverted) {
      xAxis = yAxis;
      yAxis = this.xAxis;
    }

    return {
      translateX: xAxis ? xAxis.left : chart.plotLeft,
      translateY: yAxis ? yAxis.top : chart.plotTop,
      scaleX: 1,
      // #1623
      scaleY: 1
    };
  },

  /**
   * Render the graph and markers. Called internally when first rendering and
   * later when redrawing the chart. This function can be extended in plugins,
   * but normally shouldn't be called directly.
   *
   * @function Highcharts.Series#render
   *
   * @todo
   * Make events official: Fires the event `afterRender`.
   */
  render: function () {
    var series = this,
        chart = series.chart,
        group,
        options = series.options,
        // Animation doesn't work in IE8 quirks when the group div is
    // hidden, and looks bad in other oldIE
    animDuration = !!series.animate && chart.renderer.isSVG && animObject$2(options.animation).duration,
        visibility = series.visible ? 'inherit' : 'hidden',
        // #2597
    zIndex = options.zIndex,
        hasRendered = series.hasRendered,
        chartSeriesGroup = chart.seriesGroup,
        inverted = chart.inverted; // the group

    group = series.plotGroup('group', 'series', visibility, zIndex, chartSeriesGroup);
    series.markerGroup = series.plotGroup('markerGroup', 'markers', visibility, zIndex, chartSeriesGroup); // initiate the animation

    if (animDuration) {
      series.animate(true);
    } // SVGRenderer needs to know this before drawing elements (#1089, #1795)


    group.inverted = series.isCartesian ? inverted : false; // draw the graph if any

    if (series.drawGraph) {
      series.drawGraph();
      series.applyZones();
    }
    /*        each(series.points, function (point) {
                if (point.redraw) {
                    point.redraw();
                }
            });*/
    // draw the data labels (inn pies they go before the points)


    if (series.drawDataLabels) {
      series.drawDataLabels();
    } // draw the points


    if (series.visible) {
      series.drawPoints();
    } // draw the mouse tracking area


    if (series.drawTracker && series.options.enableMouseTracking !== false) {
      series.drawTracker();
    } // Handle inverted series and tracker groups


    series.invertGroups(inverted); // Initial clipping, must be defined after inverting groups for VML.
    // Applies to columns etc. (#3839).

    if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
      group.clip(chart.clipRect);
    } // Run the animation


    if (animDuration) {
      series.animate();
    } // Call the afterAnimate function on animation complete (but don't
    // overwrite the animation.complete option which should be available to
    // the user).


    if (!hasRendered) {
      series.animationTimeout = syncTimeout$3(function () {
        series.afterAnimate();
      }, animDuration);
    }

    series.isDirty = false; // means data is in accordance with what you see
    // (See #322) series.isDirty = series.isDirtyData = false; // means
    // data is in accordance with what you see

    series.hasRendered = true;
    fireEvent$6(series, 'afterRender');
  },

  /**
   * Redraw the series. This function is called internally from `chart.redraw`
   * and normally shouldn't be called directly.
   *
   * @private
   * @function Highcharts.Series#redraw
   */
  redraw: function () {
    var series = this,
        chart = series.chart,
        // cache it here as it is set to false in render, but used after
    wasDirty = series.isDirty || series.isDirtyData,
        group = series.group,
        xAxis = series.xAxis,
        yAxis = series.yAxis; // reposition on resize

    if (group) {
      if (chart.inverted) {
        group.attr({
          width: chart.plotWidth,
          height: chart.plotHeight
        });
      }

      group.animate({
        translateX: pick$d(xAxis && xAxis.left, chart.plotLeft),
        translateY: pick$d(yAxis && yAxis.top, chart.plotTop)
      });
    }

    series.translate();
    series.render();

    if (wasDirty) {
      // #3868, #3945
      delete this.kdTree;
    }
  },
  kdAxisArray: ['clientX', 'plotY'],

  /**
   * @private
   * @function Highcharts.Series#searchPoint
   *
   * @param {*} e
   *
   * @param {*} compareX
   *
   * @return {Highcharts.Point}
   */
  searchPoint: function (e, compareX) {
    var series = this,
        xAxis = series.xAxis,
        yAxis = series.yAxis,
        inverted = series.chart.inverted;
    return this.searchKDTree({
      clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
      plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
    }, compareX);
  },

  /**
   * Build the k-d-tree that is used by mouse and touch interaction to get the
   * closest point. Line-like series typically have a one-dimensional tree
   * where points are searched along the X axis, while scatter-like series
   * typically search in two dimensions, X and Y.
   *
   * @private
   * @function Highcharts.Series#buildKDTree
   */
  buildKDTree: function () {
    // Prevent multiple k-d-trees from being built simultaneously (#6235)
    this.buildingKdTree = true;
    var series = this,
        dimensions = series.options.findNearestPointBy.indexOf('y') > -1 ? 2 : 1; // Internal function

    function _kdtree(points, depth, dimensions) {
      var axis,
          median,
          length = points && points.length;

      if (length) {
        // alternate between the axis
        axis = series.kdAxisArray[depth % dimensions]; // sort point array

        points.sort(function (a, b) {
          return a[axis] - b[axis];
        });
        median = Math.floor(length / 2); // build and return nod

        return {
          point: points[median],
          left: _kdtree(points.slice(0, median), depth + 1, dimensions),
          right: _kdtree(points.slice(median + 1), depth + 1, dimensions)
        };
      }
    } // Start the recursive build process with a clone of the points array
    // and null points filtered out (#3873)


    function startRecursive() {
      series.kdTree = _kdtree(series.getValidPoints(null, // For line-type series restrict to plot area, but
      // column-type series not (#3916, #4511)
      !series.directTouch), dimensions, dimensions);
      series.buildingKdTree = false;
    }

    delete series.kdTree; // For testing tooltips, don't build async

    syncTimeout$3(startRecursive, series.options.kdNow ? 0 : 1);
  },

  /**
   * @private
   * @function Highcharts.Series#searchKDTree
   *
   * @param {*} point
   *
   * @param {*} compareX
   *
   * @return {Highcharts.Point}
   */
  searchKDTree: function (point, compareX) {
    var series = this,
        kdX = this.kdAxisArray[0],
        kdY = this.kdAxisArray[1],
        kdComparer = compareX ? 'distX' : 'dist',
        kdDimensions = series.options.findNearestPointBy.indexOf('y') > -1 ? 2 : 1; // Set the one and two dimensional distance on the point object

    function setDistance(p1, p2) {
      var x = defined$9(p1[kdX]) && defined$9(p2[kdX]) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,
          y = defined$9(p1[kdY]) && defined$9(p2[kdY]) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,
          r = (x || 0) + (y || 0);
      p2.dist = defined$9(r) ? Math.sqrt(r) : Number.MAX_VALUE;
      p2.distX = defined$9(x) ? Math.sqrt(x) : Number.MAX_VALUE;
    }

    function _search(search, tree, depth, dimensions) {
      var point = tree.point,
          axis = series.kdAxisArray[depth % dimensions],
          tdist,
          sideA,
          sideB,
          ret = point,
          nPoint1,
          nPoint2;
      setDistance(search, point); // Pick side based on distance to splitting point

      tdist = search[axis] - point[axis];
      sideA = tdist < 0 ? 'left' : 'right';
      sideB = tdist < 0 ? 'right' : 'left'; // End of tree

      if (tree[sideA]) {
        nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);
        ret = nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point;
      }

      if (tree[sideB]) {
        // compare distance to current best to splitting point to decide
        // wether to check side B or not
        if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
          nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
          ret = nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret;
        }
      }

      return ret;
    }

    if (!this.kdTree && !this.buildingKdTree) {
      this.buildKDTree();
    }

    if (this.kdTree) {
      return _search(point, this.kdTree, kdDimensions, kdDimensions);
    }
  }
}); // end Series prototype

/**
 * A line series displays information as a series of data points connected by
 * straight line segments.
 *
 * @sample {highcharts} highcharts/demo/line-basic/
 *         Line chart
 * @sample {highstock} stock/demo/basic-line/
 *         Line chart
 *
 * @extends   plotOptions.series
 * @product   highcharts highstock
 * @apioption plotOptions.line
 */

/**
 * A `line` series. If the [type](#series.line.type) option is not
 * specified, it is inherited from [chart.type](#chart.type).
 *
 * @extends   series,plotOptions.line
 * @excluding dataParser,dataURL
 * @product   highcharts highstock
 * @apioption series.line
 */

/**
 * An array of data points for the series. For the `line` series type,
 * points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 *
 *  ```js
 *     data: [
 *         [0, 1],
 *         [1, 2],
 *         [2, 8]
 *     ]
 *  ```
 *
 * 3.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.line.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 9,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 6,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @sample {highcharts} highcharts/chart/reflow-true/
 *         Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/
 *         Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *         Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/
 *         Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/
 *         Config objects
 *
 * @type      {Array<number|Array<number|string|Date>|*>}
 * @apioption series.line.data
 */

/**
 * An additional, individual class name for the data point's graphic
 * representation.
 *
 * @type      {string}
 * @since     5.0.0
 * @product   highcharts
 * @apioption series.line.data.className
 */

/**
 * Individual color for the point. By default the color is pulled from
 * the global `colors` array.
 *
 * In styled mode, the `color` option doesn't take effect. Instead, use
 * `colorIndex`.
 *
 * @sample {highcharts} highcharts/point/color/
 *         Mark the highest point
 *
 * @type      {Highcharts.ColorString}
 * @product   highcharts highstock
 * @apioption series.line.data.color
 */

/**
 * A specific color index to use for the point, so its graphic representations
 * are given the class name `highcharts-color-{n}`. In styled mode this will
 * change the color of the graphic. In non-styled mode, the color by is set by
 * the `fill` attribute, so the change in class name won't have a visual effect
 * by default.
 *
 * @type      {number}
 * @since     5.0.0
 * @product   highcharts
 * @apioption series.line.data.colorIndex
 */

/**
 * Individual data label for each point. The options are the same as
 * the ones for [plotOptions.series.dataLabels](
 * #plotOptions.series.dataLabels).
 *
 * @sample highcharts/point/datalabels/
 *         Show a label for the last value
 *
 * @type      {Highcharts.PlotSeriesDataLabelsOptions}
 * @product   highcharts highstock
 * @apioption series.line.data.dataLabels
 */

/**
 * A description of the point to add to the screen reader information
 * about the point. Requires the Accessibility module.
 *
 * @type      {string}
 * @since     5.0.0
 * @apioption series.line.data.description
 */

/**
 * An id for the point. This can be used after render time to get a
 * pointer to the point object through `chart.get()`.
 *
 * @sample {highcharts} highcharts/point/id/
 *         Remove an id'd point
 *
 * @type      {string}
 * @since     1.2.0
 * @product   highcharts highstock
 * @apioption series.line.data.id
 */

/**
 * The rank for this point's data label in case of collision. If two
 * data labels are about to overlap, only the one with the highest `labelrank`
 * will be drawn.
 *
 * @type      {number}
 * @apioption series.line.data.labelrank
 */

/**
 * The name of the point as shown in the legend, tooltip, dataLabel
 * etc.
 *
 * @see [xAxis.uniqueNames](#xAxis.uniqueNames)
 *
 * @sample {highcharts} highcharts/series/data-array-of-objects/
 *         Point names
 *
 * @type      {string}
 * @apioption series.line.data.name
 */

/**
 * Whether the data point is selected initially.
 *
 * @type      {boolean}
 * @default   false
 * @product   highcharts highstock
 * @apioption series.line.data.selected
 */

/**
 * The x value of the point. For datetime axes, the X value is the timestamp
 * in milliseconds since 1970.
 *
 * @type      {number}
 * @product   highcharts highstock
 * @apioption series.line.data.x
 */

/**
 * The y value of the point.
 *
 * @type      {number}
 * @product   highcharts highstock
 * @apioption series.line.data.y
 */

/**
 * Individual point events
 *
 * @extends   plotOptions.series.point.events
 * @product   highcharts highstock
 * @apioption series.line.data.events
 */

/**
 * @extends   plotOptions.series.marker
 * @product   highcharts highstock
 * @apioption series.line.data.marker
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var Axis$4 = Highcharts.Axis,
    Chart$2 = Highcharts.Chart,
    correctFloat$3 = Highcharts.correctFloat,
    defined$a = Highcharts.defined,
    destroyObjectProperties$4 = Highcharts.destroyObjectProperties,
    each$e = Highcharts.each,
    format$3 = Highcharts.format,
    objectEach$4 = Highcharts.objectEach,
    pick$e = Highcharts.pick,
    Series = Highcharts.Series;
/**
 * The class for stacks. Each stack, on a specific X value and either negative
 * or positive, has its own stack item.
 *
 * @class
 */

Highcharts.StackItem = function (axis, options, isNegative, x, stackOption) {
  var inverted = axis.chart.inverted;
  this.axis = axis; // Tells if the stack is negative

  this.isNegative = isNegative; // Save the options to be able to style the label

  this.options = options; // Save the x value to be able to position the label later

  this.x = x; // Initialize total value

  this.total = null; // This will keep each points' extremes stored by series.index and point
  // index

  this.points = {}; // Save the stack option on the series configuration object, and whether to
  // treat it as percent

  this.stack = stackOption;
  this.leftCliff = 0;
  this.rightCliff = 0; // The align options and text align varies on whether the stack is negative
  // and if the chart is inverted or not.
  // First test the user supplied value, then use the dynamic.

  this.alignOptions = {
    align: options.align || (inverted ? isNegative ? 'left' : 'right' : 'center'),
    verticalAlign: options.verticalAlign || (inverted ? 'middle' : isNegative ? 'bottom' : 'top'),
    y: pick$e(options.y, inverted ? 4 : isNegative ? 14 : -6),
    x: pick$e(options.x, inverted ? isNegative ? -6 : 6 : 0)
  };
  this.textAlign = options.textAlign || (inverted ? isNegative ? 'right' : 'left' : 'center');
};

Highcharts.StackItem.prototype = {
  destroy: function () {
    destroyObjectProperties$4(this, this.axis);
  },

  /**
   * Renders the stack total label and adds it to the stack label group.
   */
  render: function (group) {
    var chart = this.axis.chart,
        options = this.options,
        formatOption = options.format,
        str = formatOption ? format$3(formatOption, this, chart.time) : options.formatter.call(this); // format the text in the label
    // Change the text to reflect the new total and set visibility to hidden
    // in case the serie is hidden

    if (this.label) {
      this.label.attr({
        text: str,
        visibility: 'hidden'
      }); // Create new label
    } else {
      this.label = chart.renderer.text(str, null, null, options.useHTML).css(options.style).attr({
        align: this.textAlign,
        rotation: options.rotation,
        visibility: 'hidden' // hidden until setOffset is called

      }).add(group); // add to the labels-group
    } // Rank it higher than data labels (#8742)


    this.label.labelrank = chart.plotHeight;
  },

  /**
   * Sets the offset that the stack has from the x value and repositions the
   * label.
   */
  setOffset: function (xOffset, xWidth) {
    var stackItem = this,
        axis = stackItem.axis,
        chart = axis.chart,
        // stack value translated mapped to chart coordinates
    y = axis.translate(axis.usePercentage ? 100 : stackItem.total, 0, 0, 0, 1),
        yZero = axis.translate(0),
        // stack origin
    h = defined$a(y) && Math.abs(y - yZero),
        // stack height
    x = chart.xAxis[0].translate(stackItem.x) + xOffset,
        // x position
    stackBox = defined$a(y) && stackItem.getStackBox(chart, stackItem, x, y, xWidth, h, axis),
        label = stackItem.label,
        alignAttr;

    if (label && stackBox) {
      // Align the label to the box
      label.align(stackItem.alignOptions, null, stackBox); // Set visibility (#678)

      alignAttr = label.alignAttr;
      label[stackItem.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);
    }
  },
  getStackBox: function (chart, stackItem, x, y, xWidth, h, axis) {
    var reversed = stackItem.axis.reversed,
        inverted = chart.inverted,
        axisPos = axis.height + axis.pos - (inverted ? chart.plotLeft : chart.plotTop),
        neg = stackItem.isNegative && !reversed || !stackItem.isNegative && reversed; // #4056

    return {
      // this is the box for the complete stack
      x: inverted ? neg ? y : y - h : x,
      y: inverted ? axisPos - x - xWidth : neg ? axisPos - y - h : axisPos - y,
      width: inverted ? h : xWidth,
      height: inverted ? xWidth : h
    };
  }
};
/**
 * Generate stacks for each series and calculate stacks total values
 */

Chart$2.prototype.getStacks = function () {
  var chart = this; // reset stacks for each yAxis

  each$e(chart.yAxis, function (axis) {
    if (axis.stacks && axis.hasVisibleSeries) {
      axis.oldStacks = axis.stacks;
    }
  });
  each$e(chart.series, function (series) {
    if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
      series.stackKey = series.type + pick$e(series.options.stack, '');
    }
  });
}; // Stacking methods defined on the Axis prototype

/**
 * Build the stacks from top down
 *
 * @ignore
 */


Axis$4.prototype.buildStacks = function () {
  var axisSeries = this.series,
      reversedStacks = pick$e(this.options.reversedStacks, true),
      len = axisSeries.length,
      i;

  if (!this.isXAxis) {
    this.usePercentage = false;
    i = len;

    while (i--) {
      axisSeries[reversedStacks ? i : len - i - 1].setStackedPoints();
    } // Loop up again to compute percent and stream stack


    for (i = 0; i < len; i++) {
      axisSeries[i].modifyStacks();
    }
  }
};

Axis$4.prototype.renderStackTotals = function () {
  var axis = this,
      chart = axis.chart,
      renderer = chart.renderer,
      stacks = axis.stacks,
      stackTotalGroup = axis.stackTotalGroup; // Create a separate group for the stack total labels

  if (!stackTotalGroup) {
    axis.stackTotalGroup = stackTotalGroup = renderer.g('stack-labels').attr({
      visibility: 'visible',
      zIndex: 6
    }).add();
  } // plotLeft/Top will change when y axis gets wider so we need to translate
  // the stackTotalGroup at every render call. See bug #506 and #516


  stackTotalGroup.translate(chart.plotLeft, chart.plotTop); // Render each stack total

  objectEach$4(stacks, function (type) {
    objectEach$4(type, function (stack) {
      stack.render(stackTotalGroup);
    });
  });
};
/**
 * Set all the stacks to initial states and destroy unused ones.
 *
 * @ignore
 */


Axis$4.prototype.resetStacks = function () {
  var axis = this,
      stacks = axis.stacks;

  if (!axis.isXAxis) {
    objectEach$4(stacks, function (type) {
      objectEach$4(type, function (stack, key) {
        // Clean up memory after point deletion (#1044, #4320)
        if (stack.touched < axis.stacksTouched) {
          stack.destroy();
          delete type[key]; // Reset stacks
        } else {
          stack.total = null;
          stack.cumulative = null;
        }
      });
    });
  }
};

Axis$4.prototype.cleanStacks = function () {
  var stacks;

  if (!this.isXAxis) {
    if (this.oldStacks) {
      stacks = this.stacks = this.oldStacks;
    } // reset stacks


    objectEach$4(stacks, function (type) {
      objectEach$4(type, function (stack) {
        stack.cumulative = stack.total;
      });
    });
  }
}; // Stacking methods defnied for Series prototype

/**
 * Adds series' points value to corresponding stack
 */


Series.prototype.setStackedPoints = function () {
  if (!this.options.stacking || this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false) {
    return;
  }

  var series = this,
      xData = series.processedXData,
      yData = series.processedYData,
      stackedYData = [],
      yDataLength = yData.length,
      seriesOptions = series.options,
      threshold = seriesOptions.threshold,
      stackThreshold = pick$e(seriesOptions.startFromThreshold && threshold, 0),
      stackOption = seriesOptions.stack,
      stacking = seriesOptions.stacking,
      stackKey = series.stackKey,
      negKey = '-' + stackKey,
      negStacks = series.negStacks,
      yAxis = series.yAxis,
      stacks = yAxis.stacks,
      oldStacks = yAxis.oldStacks,
      stackIndicator,
      isNegative,
      stack,
      other,
      key,
      pointKey,
      i,
      x,
      y;
  yAxis.stacksTouched += 1; // loop over the non-null y values and read them into a local array

  for (i = 0; i < yDataLength; i++) {
    x = xData[i];
    y = yData[i];
    stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
    pointKey = stackIndicator.key; // Read stacked values into a stack based on the x value,
    // the sign of y and the stack key. Stacking is also handled for null
    // values (#739)

    isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
    key = isNegative ? negKey : stackKey; // Create empty object for this stack if it doesn't exist yet

    if (!stacks[key]) {
      stacks[key] = {};
    } // Initialize StackItem for this x


    if (!stacks[key][x]) {
      if (oldStacks[key] && oldStacks[key][x]) {
        stacks[key][x] = oldStacks[key][x];
        stacks[key][x].total = null;
      } else {
        stacks[key][x] = new Highcharts.StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
      }
    } // If the StackItem doesn't exist, create it first


    stack = stacks[key][x];

    if (y !== null) {
      stack.points[pointKey] = stack.points[series.index] = [pick$e(stack.cumulative, stackThreshold)]; // Record the base of the stack

      if (!defined$a(stack.cumulative)) {
        stack.base = pointKey;
      }

      stack.touched = yAxis.stacksTouched; // In area charts, if there are multiple points on the same X value,
      // let the area fill the full span of those points

      if (stackIndicator.index > 0 && series.singleStacks === false) {
        stack.points[pointKey][0] = stack.points[series.index + ',' + x + ',0'][0];
      } // When updating to null, reset the point stack (#7493)

    } else {
      stack.points[pointKey] = stack.points[series.index] = null;
    } // Add value to the stack total


    if (stacking === 'percent') {
      // Percent stacked column, totals are the same for the positive and
      // negative stacks
      other = isNegative ? stackKey : negKey;

      if (negStacks && stacks[other] && stacks[other][x]) {
        other = stacks[other][x];
        stack.total = other.total = Math.max(other.total, stack.total) + Math.abs(y) || 0; // Percent stacked areas
      } else {
        stack.total = correctFloat$3(stack.total + (Math.abs(y) || 0));
      }
    } else {
      stack.total = correctFloat$3(stack.total + (y || 0));
    }

    stack.cumulative = pick$e(stack.cumulative, stackThreshold) + (y || 0);

    if (y !== null) {
      stack.points[pointKey].push(stack.cumulative);
      stackedYData[i] = stack.cumulative;
    }
  }

  if (stacking === 'percent') {
    yAxis.usePercentage = true;
  }

  this.stackedYData = stackedYData; // To be used in getExtremes
  // Reset old stacks

  yAxis.oldStacks = {};
};
/**
 * Iterate over all stacks and compute the absolute values to percent
 */


Series.prototype.modifyStacks = function () {
  var series = this,
      stackKey = series.stackKey,
      stacks = series.yAxis.stacks,
      processedXData = series.processedXData,
      stackIndicator,
      stacking = series.options.stacking;

  if (series[stacking + 'Stacker']) {
    // Modifier function exists
    each$e([stackKey, '-' + stackKey], function (key) {
      var i = processedXData.length,
          x,
          stack,
          pointExtremes;

      while (i--) {
        x = processedXData[i];
        stackIndicator = series.getStackIndicator(stackIndicator, x, series.index, key);
        stack = stacks[key] && stacks[key][x];
        pointExtremes = stack && stack.points[stackIndicator.key];

        if (pointExtremes) {
          series[stacking + 'Stacker'](pointExtremes, stack, i);
        }
      }
    });
  }
};
/**
 * Modifier function for percent stacks. Blows up the stack to 100%.
 */


Series.prototype.percentStacker = function (pointExtremes, stack, i) {
  var totalFactor = stack.total ? 100 / stack.total : 0; // Y bottom value

  pointExtremes[0] = correctFloat$3(pointExtremes[0] * totalFactor); // Y value

  pointExtremes[1] = correctFloat$3(pointExtremes[1] * totalFactor);
  this.stackedYData[i] = pointExtremes[1];
};
/**
* Get stack indicator, according to it's x-value, to determine points with the
* same x-value
*/


Series.prototype.getStackIndicator = function (stackIndicator, x, index, key) {
  // Update stack indicator, when:
  // first point in a stack || x changed || stack type (negative vs positive)
  // changed:
  if (!defined$a(stackIndicator) || stackIndicator.x !== x || key && stackIndicator.key !== key) {
    stackIndicator = {
      x: x,
      index: 0,
      key: key
    };
  } else {
    stackIndicator.index++;
  }

  stackIndicator.key = [index, x, stackIndicator.index].join(',');
  return stackIndicator;
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$8 = Highcharts.addEvent,
    animate$3 = Highcharts.animate,
    Axis$5 = Highcharts.Axis,
    Chart$3 = Highcharts.Chart,
    createElement$3 = Highcharts.createElement,
    css$6 = Highcharts.css,
    defined$b = Highcharts.defined,
    each$f = Highcharts.each,
    erase$4 = Highcharts.erase,
    extend$b = Highcharts.extend,
    fireEvent$7 = Highcharts.fireEvent,
    inArray$2 = Highcharts.inArray,
    isNumber$8 = Highcharts.isNumber,
    isObject$4 = Highcharts.isObject,
    isArray$4 = Highcharts.isArray,
    merge$b = Highcharts.merge,
    objectEach$5 = Highcharts.objectEach,
    pick$f = Highcharts.pick,
    Point$2 = Highcharts.Point,
    Series$1 = Highcharts.Series,
    seriesTypes$1 = Highcharts.seriesTypes,
    setAnimation$1 = Highcharts.setAnimation,
    splat$6 = Highcharts.splat; // Extend the Chart prototype for dynamic methods

extend$b(Chart$3.prototype,
/** @lends Highcharts.Chart.prototype */
{
  /**
   * Add a series to the chart after render time. Note that this method should
   * never be used when adding data synchronously at chart render time, as it
   * adds expense to the calculations and rendering. When adding data at the
   * same time as the chart is initialized, add the series as a configuration
   * option instead. With multiple axes, the `offset` is dynamically adjusted.
   *
   * @sample highcharts/members/chart-addseries/
   *         Add a series from a button
   * @sample stock/members/chart-addseries/
   *         Add a series in Highstock
   *
   * @function Highcharts.Chart#addSeries
   *
   * @param {Highcharts.SeriesOptions} options
   *        The config options for the series.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after adding.
   *
   * @param {boolean|Highcharts.AnimationOptionsObject} [animation]
   *        Whether to apply animation, and optionally animation
   *        configuration.
   *
   * @return {Highcharts.Series}
   *         The newly created series object.
   *
   * @fires Highcharts.Chart#event:addSeries
   * @fires Highcharts.Chart#event:afterAddSeries
   */
  addSeries: function (options, redraw, animation) {
    var series,
        chart = this;

    if (options) {
      redraw = pick$f(redraw, true); // defaults to true

      fireEvent$7(chart, 'addSeries', {
        options: options
      }, function () {
        series = chart.initSeries(options);
        chart.isDirtyLegend = true;
        chart.linkSeries();
        fireEvent$7(chart, 'afterAddSeries');

        if (redraw) {
          chart.redraw(animation);
        }
      });
    }

    return series;
  },

  /**
   * Add an axis to the chart after render time. Note that this method should
   * never be used when adding data synchronously at chart render time, as it
   * adds expense to the calculations and rendering. When adding data at the
   * same time as the chart is initialized, add the axis as a configuration
   * option instead.
   *
   * @sample highcharts/members/chart-addaxis/
   *         Add and remove axes
   *
   * @function Highcharts.Chart#addAxis
   *
   * @param {Highcharts.XAxisOptions|Highcharts.YAxisOptions|Highcharts.ZAxisOptions} options
   *        The axis options.
   *
   * @param {boolean} [isX=false]
   *        Whether it is an X axis or a value axis.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after adding.
   *
   * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]
   *        Whether and how to apply animation in the redraw.
   *
   * @return {Highcharts.Axis}
   *         The newly generated Axis object.
   */
  addAxis: function (options, isX, redraw, animation) {
    var key = isX ? 'xAxis' : 'yAxis',
        chartOptions = this.options,
        userOptions = merge$b(options, {
      index: this[key].length,
      isX: isX
    }),
        axis;
    axis = new Axis$5(this, userOptions); // Push the new axis options to the chart options

    chartOptions[key] = splat$6(chartOptions[key] || {});
    chartOptions[key].push(userOptions);

    if (pick$f(redraw, true)) {
      this.redraw(animation);
    }

    return axis;
  },

  /**
   * Dim the chart and show a loading text or symbol. Options for the loading
   * screen are defined in {@link
   * https://api.highcharts.com/highcharts/loading|the loading options}.
   *
   * @sample highcharts/members/chart-hideloading/
   *         Show and hide loading from a button
   * @sample highcharts/members/chart-showloading/
   *         Apply different text labels
   * @sample stock/members/chart-show-hide-loading/
   *         Toggle loading in Highstock
   *
   * @function Highcharts.Chart#showLoading
   *
   * @param {string} str
   *        An optional text to show in the loading label instead of the
   *        default one. The default text is set in
   *        {@link http://api.highcharts.com/highcharts/lang.loading|lang.loading}.
   */
  showLoading: function (str) {
    var chart = this,
        options = chart.options,
        loadingDiv = chart.loadingDiv,
        loadingOptions = options.loading,
        setLoadingSize = function () {
      if (loadingDiv) {
        css$6(loadingDiv, {
          left: chart.plotLeft + 'px',
          top: chart.plotTop + 'px',
          width: chart.plotWidth + 'px',
          height: chart.plotHeight + 'px'
        });
      }
    }; // create the layer at the first call


    if (!loadingDiv) {
      chart.loadingDiv = loadingDiv = createElement$3('div', {
        className: 'highcharts-loading highcharts-loading-hidden'
      }, null, chart.container);
      chart.loadingSpan = createElement$3('span', {
        className: 'highcharts-loading-inner'
      }, null, loadingDiv);
      addEvent$8(chart, 'redraw', setLoadingSize); // #1080
    }

    loadingDiv.className = 'highcharts-loading'; // Update text

    chart.loadingSpan.innerHTML = str || options.lang.loading;
    chart.loadingShown = true;
    setLoadingSize();
  },

  /**
   * Hide the loading layer.
   *
   * @see Highcharts.Chart#showLoading
   *
   * @sample highcharts/members/chart-hideloading/
   *         Show and hide loading from a button
   * @sample stock/members/chart-show-hide-loading/
   *         Toggle loading in Highstock
   *
   * @function Highcharts.Chart#hideLoading
   */
  hideLoading: function () {
    var options = this.options,
        loadingDiv = this.loadingDiv;

    if (loadingDiv) {
      loadingDiv.className = 'highcharts-loading highcharts-loading-hidden';
    }

    this.loadingShown = false;
  },

  /**
   * These properties cause isDirtyBox to be set to true when updating. Can be
   * extended from plugins.
   */
  propsRequireDirtyBox: ['backgroundColor', 'borderColor', 'borderWidth', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'spacing', 'spacingTop', 'spacingRight', 'spacingBottom', 'spacingLeft', 'borderRadius', 'plotBackgroundColor', 'plotBackgroundImage', 'plotBorderColor', 'plotBorderWidth', 'plotShadow', 'shadow'],

  /**
   * These properties cause all series to be updated when updating. Can be
   * extended from plugins.
   */
  propsRequireUpdateSeries: ['chart.inverted', 'chart.polar', 'chart.ignoreHiddenSeries', 'chart.type', 'colors', 'plotOptions', 'time', 'tooltip'],

  /**
   * A generic function to update any element of the chart. Elements can be
   * enabled and disabled, moved, re-styled, re-formatted etc.
   *
   * A special case is configuration objects that take arrays, for example
   * {@link https://api.highcharts.com/highcharts/xAxis|xAxis},
   * {@link https://api.highcharts.com/highcharts/yAxis|yAxis} or
   * {@link https://api.highcharts.com/highcharts/series|series}. For these
   * collections, an `id` option is used to map the new option set to an
   * existing object. If an existing object of the same id is not found, the
   * corresponding item is updated. So for example, running `chart.update`
   * with a series item without an id, will cause the existing chart's series
   * with the same index in the series array to be updated. When the
   * `oneToOne` parameter is true, `chart.update` will also take care of
   * adding and removing items from the collection. Read more under the
   * parameter description below.
   *
   * See also the
   * {@link https://api.highcharts.com/highcharts/responsive|responsive option set}.
   * Switching between `responsive.rules` basically runs `chart.update` under
   * the hood.
   *
   * @sample highcharts/members/chart-update/
   *         Update chart geometry
   *
   * @function Highcharts.Chart#update
   *
   * @param {Highcharts.Options} options
   *        A configuration object for the new chart options.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart.
   *
   * @param {boolean} [oneToOne=false]
   *        When `true`, the `series`, `xAxis` and `yAxis` collections will
   *        be updated one to one, and items will be either added or removed
   *        to match the new updated options. For example, if the chart has
   *        two series and we call `chart.update` with a configuration
   *        containing three series, one will be added. If we call
   *        `chart.update` with one series, one will be removed. Setting an
   *        empty `series` array will remove all series, but leaving out the
   *        `series` property will leave all series untouched. If the series
   *        have id's, the new series options will be matched by id, and the
   *        remaining ones removed.
   *
   * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]
   *        Whether to apply animation, and optionally animation
   *        configuration.
   *
   * @fires Highcharts.Chart#event:update
   * @fires Highcharts.Chart#event:afterUpdate
   */
  update: function (options, redraw, oneToOne, animation) {
    var chart = this,
        adders = {
      credits: 'addCredits',
      title: 'setTitle',
      subtitle: 'setSubtitle'
    },
        optionsChart = options.chart,
        updateAllAxes,
        updateAllSeries,
        newWidth,
        newHeight,
        itemsForRemoval = [];
    fireEvent$7(chart, 'update', {
      options: options
    }); // If the top-level chart option is present, some special updates are
    // required

    if (optionsChart) {
      merge$b(true, chart.options.chart, optionsChart); // Setter function

      if ('className' in optionsChart) {
        chart.setClassName(optionsChart.className);
      }

      if ('reflow' in optionsChart) {
        chart.setReflow(optionsChart.reflow);
      }

      if ('inverted' in optionsChart || 'polar' in optionsChart || 'type' in optionsChart) {
        // Parse options.chart.inverted and options.chart.polar together
        // with the available series.
        chart.propFromSeries();
        updateAllAxes = true;
      }

      if ('alignTicks' in optionsChart) {
        // #6452
        updateAllAxes = true;
      }

      objectEach$5(optionsChart, function (val, key) {
        if (inArray$2('chart.' + key, chart.propsRequireUpdateSeries) !== -1) {
          updateAllSeries = true;
        } // Only dirty box


        if (inArray$2(key, chart.propsRequireDirtyBox) !== -1) {
          chart.isDirtyBox = true;
        }
      });
    } // Moved up, because tooltip needs updated plotOptions (#6218)


    if (options.plotOptions) {
      merge$b(true, this.options.plotOptions, options.plotOptions);
    } // Some option stuctures correspond one-to-one to chart objects that
    // have update methods, for example
    // options.credits => chart.credits
    // options.legend => chart.legend
    // options.title => chart.title
    // options.tooltip => chart.tooltip
    // options.subtitle => chart.subtitle
    // options.mapNavigation => chart.mapNavigation
    // options.navigator => chart.navigator
    // options.scrollbar => chart.scrollbar


    objectEach$5(options, function (val, key) {
      if (chart[key] && typeof chart[key].update === 'function') {
        chart[key].update(val, false); // If a one-to-one object does not exist, look for an adder function
      } else if (typeof chart[adders[key]] === 'function') {
        chart[adders[key]](val);
      }

      if (key !== 'chart' && inArray$2(key, chart.propsRequireUpdateSeries) !== -1) {
        updateAllSeries = true;
      }
    }); // Setters for collections. For axes and series, each item is referred
    // by an id. If the id is not found, it defaults to the corresponding
    // item in the collection, so setting one series without an id, will
    // update the first series in the chart. Setting two series without
    // an id will update the first and the second respectively (#6019)
    // chart.update and responsive.

    each$f(['xAxis', 'yAxis', 'zAxis', 'series', 'colorAxis', 'pane'], function (coll) {
      var indexMap;

      if (options[coll]) {
        // In stock charts, the navigator series are also part of the
        // chart.series array, but those series should not be handled
        // here (#8196).
        if (coll === 'series') {
          indexMap = [];
          each$f(chart[coll], function (s, i) {
            if (!s.options.isInternal) {
              indexMap.push(i);
            }
          });
        }

        each$f(splat$6(options[coll]), function (newOptions, i) {
          var item = defined$b(newOptions.id) && chart.get(newOptions.id) || chart[coll][indexMap ? indexMap[i] : i];

          if (item && item.coll === coll) {
            item.update(newOptions, false);

            if (oneToOne) {
              item.touched = true;
            }
          } // If oneToOne and no matching item is found, add one


          if (!item && oneToOne) {
            if (coll === 'series') {
              chart.addSeries(newOptions, false).touched = true;
            } else if (coll === 'xAxis' || coll === 'yAxis') {
              chart.addAxis(newOptions, coll === 'xAxis', false).touched = true;
            }
          }
        }); // Add items for removal

        if (oneToOne) {
          each$f(chart[coll], function (item) {
            if (!item.touched && !item.options.isInternal) {
              itemsForRemoval.push(item);
            } else {
              delete item.touched;
            }
          });
        }
      }
    });
    each$f(itemsForRemoval, function (item) {
      item.remove(false);
    });

    if (updateAllAxes) {
      each$f(chart.axes, function (axis) {
        axis.update({}, false);
      });
    } // Certain options require the whole series structure to be thrown away
    // and rebuilt


    if (updateAllSeries) {
      each$f(chart.series, function (series) {
        series.update({}, false);
      });
    } // For loading, just update the options, do not redraw


    if (options.loading) {
      merge$b(true, chart.options.loading, options.loading);
    } // Update size. Redraw is forced.


    newWidth = optionsChart && optionsChart.width;
    newHeight = optionsChart && optionsChart.height;

    if (isNumber$8(newWidth) && newWidth !== chart.chartWidth || isNumber$8(newHeight) && newHeight !== chart.chartHeight) {
      chart.setSize(newWidth, newHeight, animation);
    } else if (pick$f(redraw, true)) {
      chart.redraw(animation);
    }

    fireEvent$7(chart, 'afterUpdate', {
      options: options
    });
  },

  /**
   * Shortcut to set the subtitle options. This can also be done from {@link
   * Chart#update} or {@link Chart#setTitle}.
   *
   * @function Highcharts.Chart#setSubtitle
   *
   * @param {Highcharts.SubtitleOptions} options
   *        New subtitle options. The subtitle text itself is set by the
   *        `options.text` property.
   */
  setSubtitle: function (options) {
    this.setTitle(undefined, options);
  }
}); // extend the Point prototype for dynamic methods

extend$b(Point$2.prototype,
/** @lends Highcharts.Point.prototype */
{
  /**
   * Update point with new options (typically x/y data) and optionally redraw
   * the series.
   *
   * @sample highcharts/members/point-update-column/
   *         Update column value
   * @sample highcharts/members/point-update-pie/
   *         Update pie slice
   * @sample maps/members/point-update/
   *         Update map area value in Highmaps
   *
   * @function Highcharts.Point#update
   *
   * @param {*} options
   *        The point options. Point options are handled as described under
   *        the `series.type.data` item for each series type. For example
   *        for a line series, if options is a single number, the point will
   *        be given that number as the main y value. If it is an array, it
   *        will be interpreted as x and y values respectively. If it is an
   *        object, advanced options are applied.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after the point is updated. If doing
   *        more operations on the chart, it is best practice to set
   *        `redraw` to false and call `chart.redraw()` after.
   *
   * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]
   *        Whether to apply animation, and optionally animation
   *        configuration.
   *
   * @fires Highcharts.Point#event:update
   */
  update: function (options, redraw, animation, runEvent) {
    var point = this,
        series = point.series,
        graphic = point.graphic,
        i,
        chart = series.chart,
        seriesOptions = series.options;
    redraw = pick$f(redraw, true);

    function update() {
      point.applyOptions(options); // Update visuals

      if (point.y === null && graphic) {
        // #4146
        point.graphic = graphic.destroy();
      }

      if (isObject$4(options, true)) {
        // Destroy so we can get new elements
        if (graphic && graphic.element) {
          // "null" is also a valid symbol
          if (options && options.marker && options.marker.symbol !== undefined) {
            point.graphic = graphic.destroy();
          }
        }

        if (options && options.dataLabels && point.dataLabel) {
          // #2468
          point.dataLabel = point.dataLabel.destroy();
        }

        if (point.connector) {
          point.connector = point.connector.destroy(); // #7243
        }
      } // record changes in the parallel arrays


      i = point.index;
      series.updateParallelArrays(point, i); // Record the options to options.data. If the old or the new config
      // is an object, use point options, otherwise use raw options
      // (#4701, #4916).

      seriesOptions.data[i] = isObject$4(seriesOptions.data[i], true) || isObject$4(options, true) ? point.options : pick$f(options, seriesOptions.data[i]); // redraw

      series.isDirty = series.isDirtyData = true;

      if (!series.fixedBox && series.hasCartesianSeries) {
        // #1906, #2320
        chart.isDirtyBox = true;
      }

      if (seriesOptions.legendType === 'point') {
        // #1831, #1885
        chart.isDirtyLegend = true;
      }

      if (redraw) {
        chart.redraw(animation);
      }
    } // Fire the event with a default handler of doing the update


    if (runEvent === false) {
      // When called from setData
      update();
    } else {
      point.firePointEvent('update', {
        options: options
      }, update);
    }
  },

  /**
   * Remove a point and optionally redraw the series and if necessary the axes
   *
   * @sample highcharts/plotoptions/series-point-events-remove/
   *         Remove point and confirm
   * @sample highcharts/members/point-remove/
   *         Remove pie slice
   * @sample maps/members/point-remove/
   *         Remove selected points in Highmaps
   *
   * @function Highcharts.Point#remove
   *
   * @param {boolean} redraw
   *        Whether to redraw the chart or wait for an explicit call. When
   *        doing more operations on the chart, for example running
   *        `point.remove()` in a loop, it is best practice to set `redraw`
   *        to false and call `chart.redraw()` after.
   *
   * @param {boolean|Highcharts.AnimationOptionsObject} [animation=false]
   *        Whether to apply animation, and optionally animation
   *        configuration.
   */
  remove: function (redraw, animation) {
    this.series.removePoint(inArray$2(this, this.series.data), redraw, animation);
  }
}); // Extend the series prototype for dynamic methods

extend$b(Series$1.prototype,
/** @lends Series.prototype */
{
  /**
   * Add a point to the series after render time. The point can be added at
   * the end, or by giving it an X value, to the start or in the middle of the
   * series.
   *
   * @sample highcharts/members/series-addpoint-append/
   *         Append point
   * @sample highcharts/members/series-addpoint-append-and-shift/
   *         Append and shift
   * @sample highcharts/members/series-addpoint-x-and-y/
   *         Both X and Y values given
   * @sample highcharts/members/series-addpoint-pie/
   *         Append pie slice
   * @sample stock/members/series-addpoint/
   *         Append 100 points in Highstock
   * @sample stock/members/series-addpoint-shift/
   *         Append and shift in Highstock
   * @sample maps/members/series-addpoint/
   *         Add a point in Highmaps
   *
   * @function Highcharts.Series#addPoint
   *
   * @param {number|Array<number>|*} options
   *        The point options. If options is a single number, a point with
   *        that y value is appended to the series. If it is an array, it will
   *        be interpreted as x and y values respectively. If it is an
   *        object, advanced options as outlined under `series.data` are
   *        applied.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after the point is added. When adding
   *        more than one point, it is highly recommended that the redraw
   *        option be set to false, and instead {@link Chart#redraw} is
   *        explicitly called after the adding of points is finished.
   *        Otherwise, the chart will redraw after adding each point.
   *
   * @param {boolean} [shift=false]
   *        If true, a point is shifted off the start of the series as one is
   *        appended to the end.
   *
   * @param {boolean|Highcharts.AnimationOptionsObject} [animation]
   *        Whether to apply animation, and optionally animation
   *        configuration.
   */
  addPoint: function (options, redraw, shift, animation) {
    var series = this,
        seriesOptions = series.options,
        data = series.data,
        chart = series.chart,
        xAxis = series.xAxis,
        names = xAxis && xAxis.hasNames && xAxis.names,
        dataOptions = seriesOptions.data,
        point,
        isInTheMiddle,
        xData = series.xData,
        i,
        x; // Optional redraw, defaults to true

    redraw = pick$f(redraw, true); // Get options and push the point to xData, yData and series.options. In
    // series.generatePoints the Point instance will be created on demand
    // and pushed to the series.data array.

    point = {
      series: series
    };
    series.pointClass.prototype.applyOptions.apply(point, [options]);
    x = point.x; // Get the insertion point

    i = xData.length;

    if (series.requireSorting && x < xData[i - 1]) {
      isInTheMiddle = true;

      while (i && xData[i - 1] > x) {
        i--;
      }
    } // Insert undefined item


    series.updateParallelArrays(point, 'splice', i, 0, 0); // Update it

    series.updateParallelArrays(point, i);

    if (names && point.name) {
      names[x] = point.name;
    }

    dataOptions.splice(i, 0, options);

    if (isInTheMiddle) {
      series.data.splice(i, 0, null);
      series.processData();
    } // Generate points to be added to the legend (#1329)


    if (seriesOptions.legendType === 'point') {
      series.generatePoints();
    } // Shift the first point off the parallel arrays


    if (shift) {
      if (data[0] && data[0].remove) {
        data[0].remove(false);
      } else {
        data.shift();
        series.updateParallelArrays(point, 'shift');
        dataOptions.shift();
      }
    } // redraw


    series.isDirty = true;
    series.isDirtyData = true;

    if (redraw) {
      chart.redraw(animation); // Animation is set anyway on redraw, #5665
    }
  },

  /**
   * Remove a point from the series. Unlike the
   * {@link Highcharts.Point#remove} method, this can also be done on a point
   * that is not instanciated because it is outside the view or subject to
   * Highstock data grouping.
   *
   * @sample highcharts/members/series-removepoint/
   *         Remove cropped point
   *
   * @function Highcharts.Series#removePoint
   *
   * @param {number} i
   *        The index of the point in the {@link Highcharts.Series.data|data}
   *        array.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after the point is added. When
   *        removing more than one point, it is highly recommended that the
   *        `redraw` option be set to `false`, and instead {@link
   *        Highcharts.Chart#redraw} is explicitly called after the adding of
   *        points is finished.
   *
   * @param {boolean|Highcharts.AnimationOptionsObject} [animation]
   *        Whether and optionally how the series should be animated.
   *
   * @fires Highcharts.Point#event:remove
   */
  removePoint: function (i, redraw, animation) {
    var series = this,
        data = series.data,
        point = data[i],
        points = series.points,
        chart = series.chart,
        remove = function () {
      if (points && points.length === data.length) {
        // #4935
        points.splice(i, 1);
      }

      data.splice(i, 1);
      series.options.data.splice(i, 1);
      series.updateParallelArrays(point || {
        series: series
      }, 'splice', i, 1);

      if (point) {
        point.destroy();
      } // redraw


      series.isDirty = true;
      series.isDirtyData = true;

      if (redraw) {
        chart.redraw();
      }
    };

    setAnimation$1(animation, chart);
    redraw = pick$f(redraw, true); // Fire the event with a default handler of removing the point

    if (point) {
      point.firePointEvent('remove', null, remove);
    } else {
      remove();
    }
  },

  /**
   * Remove a series and optionally redraw the chart.
   *
   * @sample highcharts/members/series-remove/
   *         Remove first series from a button
   *
   * @function Highcharts.Series#remove
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart or wait for an explicit call to
   *        {@link Highcharts.Chart#redraw}.
   *
   * @param {boolean|Highcharts.AnimationOptionsObject} [animation]
   *        Whether to apply animation, and optionally animation
   *        configuration.
   *
   * @param {boolean} [withEvent=true]
   *        Used internally, whether to fire the series `remove` event.
   *
   * @fires Highcharts.Series#event:remove
   */
  remove: function (redraw, animation, withEvent) {
    var series = this,
        chart = series.chart;

    function remove() {
      // Destroy elements
      series.destroy(); // Redraw

      chart.isDirtyLegend = chart.isDirtyBox = true;
      chart.linkSeries();

      if (pick$f(redraw, true)) {
        chart.redraw(animation);
      }
    } // Fire the event with a default handler of removing the point


    if (withEvent !== false) {
      fireEvent$7(series, 'remove', null, remove);
    } else {
      remove();
    }
  },

  /**
   * Update the series with a new set of options. For a clean and precise
   * handling of new options, all methods and elements from the series are
   * removed, and it is initiated from scratch. Therefore, this method is more
   * performance expensive than some other utility methods like {@link
   * Series#setData} or {@link Series#setVisible}.
   *
   * @sample highcharts/members/series-update/
   *         Updating series options
   * @sample maps/members/series-update/
   *         Update series options in Highmaps
   *
   * @function Highcharts.Series#update
   *
   * @param {Highcharts.SeriesOptions} options
   *        New options that will be merged with the series' existing options.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after the series is altered. If doing
   *        more operations on the chart, it is a good idea to set redraw to
   *        false and call {@link Chart#redraw} after.
   *
   * @fires Highcharts.Series#event:afterUpdate
   */
  update: function (newOptions, redraw) {
    var series = this,
        chart = series.chart,
        // must use user options when changing type because series.options
    // is merged in with type specific plotOptions
    oldOptions = series.userOptions,
        oldType = series.oldType || series.type,
        newType = newOptions.type || oldOptions.type || chart.options.chart.type,
        proto = seriesTypes$1[oldType].prototype,
        n,
        groups = ['group', 'markerGroup', 'dataLabelsGroup'],
        preserve = ['navigatorSeries', 'baseSeries'],
        // Animation must be enabled when calling update before the initial
    // animation has first run. This happens when calling update
    // directly after chart initialization, or when applying responsive
    // rules (#6912).
    animation = series.finishedAnimating && {
      animation: false
    },
        allowSoftUpdate = ['data', 'name', 'turboThreshold'],
        keys = Highcharts.keys(newOptions),
        doSoftUpdate = keys.length > 0; // Running Series.update to update the data only is an intuitive usage,
    // so we want to make sure that when used like this, we run the
    // cheaper setData function and allow animation instead of completely
    // recreating the series instance. This includes sideways animation when
    // adding points to the data set. The `name` should also support soft
    // update because the data module sets name and data when setting new
    // data by `chart.update`.

    each$f(keys, function (key) {
      if (inArray$2(key, allowSoftUpdate) === -1) {
        doSoftUpdate = false;
      }
    });

    if (doSoftUpdate) {
      if (newOptions.data) {
        this.setData(newOptions.data, false);
      }

      if (newOptions.name) {
        this.setName(newOptions.name, false);
      }
    } else {
      // Make sure preserved properties are not destroyed (#3094)
      preserve = groups.concat(preserve);
      each$f(preserve, function (prop) {
        preserve[prop] = series[prop];
        delete series[prop];
      }); // Do the merge, with some forced options

      newOptions = merge$b(oldOptions, animation, {
        index: series.index,
        pointStart: pick$f(oldOptions.pointStart, // when updating from blank (#7933)
        series.xData[0] // when updating after addPoint
        )
      }, {
        data: series.options.data
      }, newOptions); // Destroy the series and delete all properties. Reinsert all
      // methods and properties from the new type prototype (#2270,
      // #3719).

      series.remove(false, null, false);

      for (n in proto) {
        series[n] = undefined;
      }

      if (seriesTypes$1[newType || oldType]) {
        extend$b(series, seriesTypes$1[newType || oldType].prototype);
      } else {
        Highcharts.error(17, true);
      } // Re-register groups (#3094) and other preserved properties


      each$f(preserve, function (prop) {
        series[prop] = preserve[prop];
      });
      series.init(chart, newOptions); // Update the Z index of groups (#3380, #7397)

      if (newOptions.zIndex !== oldOptions.zIndex) {
        each$f(groups, function (groupName) {
          if (series[groupName]) {
            series[groupName].attr({
              zIndex: newOptions.zIndex
            });
          }
        });
      }

      series.oldType = oldType;
      chart.linkSeries(); // Links are lost in series.remove (#3028)
    }

    fireEvent$7(this, 'afterUpdate');

    if (pick$f(redraw, true)) {
      chart.redraw(doSoftUpdate ? undefined : false);
    }
  },

  /**
   * Used from within series.update
   *
   * @private
   * @function Highcharts.Series#setName
   *
   * @param {string} name
   */
  setName: function (name) {
    this.name = this.options.name = this.userOptions.name = name;
    this.chart.isDirtyLegend = true;
  }
}); // Extend the Axis.prototype for dynamic methods

extend$b(Axis$5.prototype,
/** @lends Highcharts.Axis.prototype */
{
  /**
   * Update an axis object with a new set of options. The options are merged
   * with the existing options, so only new or altered options need to be
   * specified.
   *
   * @sample highcharts/members/axis-update/
   *         Axis update demo
   *
   * @function Highcharts.Axis#update
   *
   * @param {Highcharts.XAxisOptions|Highcharts.YAxisOptions|Highcharts.ZAxisOptions} options
   *        The new options that will be merged in with existing options on
   *        the axis.
   */
  update: function (options, redraw) {
    var chart = this.chart,
        newEvents = options && options.events || {};
    options = merge$b(this.userOptions, options); // Color Axis is not an array,
    // This change is applied in the ColorAxis wrapper

    if (chart.options[this.coll].indexOf) {
      // Don't use this.options.index,
      // StockChart has Axes in navigator too
      chart.options[this.coll][chart.options[this.coll].indexOf(this.userOptions)] = options;
    } // Remove old events, if no new exist (#8161)


    objectEach$5(chart.options[this.coll].events, function (fn, ev) {
      if (typeof newEvents[ev] === 'undefined') {
        newEvents[ev] = undefined;
      }
    });
    this.destroy(true);
    this.init(chart, extend$b(options, {
      events: newEvents
    }));
    chart.isDirtyBox = true;

    if (pick$f(redraw, true)) {
      chart.redraw();
    }
  },

  /**
   * Remove the axis from the chart.
   *
   * @sample highcharts/members/chart-addaxis/
   *         Add and remove axes
   *
   * @function Highcharts.Axis#remove
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart following the remove.
   */
  remove: function (redraw) {
    var chart = this.chart,
        key = this.coll,
        // xAxis or yAxis
    axisSeries = this.series,
        i = axisSeries.length; // Remove associated series (#2687)

    while (i--) {
      if (axisSeries[i]) {
        axisSeries[i].remove(false);
      }
    } // Remove the axis


    erase$4(chart.axes, this);
    erase$4(chart[key], this);

    if (isArray$4(chart.options[key])) {
      chart.options[key].splice(this.options.index, 1);
    } else {
      // color axis, #6488
      delete chart.options[key];
    }

    each$f(chart[key], function (axis, i) {
      // Re-index, #1706, #8075
      axis.options.index = axis.userOptions.index = i;
    });
    this.destroy();
    chart.isDirtyBox = true;

    if (pick$f(redraw, true)) {
      chart.redraw();
    }
  },

  /**
   * Update the axis title by options after render time.
   *
   * @sample highcharts/members/axis-settitle/
   *         Set a new Y axis title
   *
   * @function Highcharts.Axis#setTitle
   *
   * @param {Highcharts.XAxisTitleOptions|Highcharts.YAxisTitleOptions|Highcharts.ZAxisTitleOptions} titleOptions
   *        The additional title options.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after setting the title.
   */
  setTitle: function (titleOptions, redraw) {
    this.update({
      title: titleOptions
    }, redraw);
  },

  /**
   * Set new axis categories and optionally redraw.
   *
   * @sample highcharts/members/axis-setcategories/
   *         Set categories by click on a button
   *
   * @function Highcharts.Axis#setCategories
   *
   * @param {Array<string>} categories
   *        The new categories.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart.
   */
  setCategories: function (categories, redraw) {
    this.update({
      categories: categories
    }, redraw);
  }
});

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var color$4 = Highcharts.color,
    each$g = Highcharts.each,
    LegendSymbolMixin$1 = Highcharts.LegendSymbolMixin,
    map$4 = Highcharts.map,
    pick$g = Highcharts.pick,
    Series$2 = Highcharts.Series,
    seriesType = Highcharts.seriesType;
/**
 * Area series type.
 *
 * @ignore
 * @constructor Highcharts.seriesTypes.area
 * @implements  {Highcharts.Series}
 */

seriesType('area', 'line', {
  /**
   * The area series type.
   *
   * @sample {highcharts} highcharts/demo/area-basic/
   *         Area chart
   * @sample {highstock} stock/demo/area/
   *         Area chart
   *
   * @type          {*}
   * @extends       plotOptions.line
   * @product       highcharts highstock
   * @optionparent  plotOptions.area
   */

  /**
   * Fill color or gradient for the area. When `null`, the series' `color`
   * is used with the series' `fillOpacity`.
   *
   * In styled mode, the fill color can be set with the `.highcharts-area`
   * class name.
   *
   * @sample {highcharts} highcharts/plotoptions/area-fillcolor-default/
   *         Null by default
   * @sample {highcharts} highcharts/plotoptions/area-fillcolor-gradient/
   *         Gradient
   *
   * @type       {Highcharts.ColorString}
   * @product    highcharts highstock
   * @apioption  plotOptions.area.fillColor
   */

  /**
   * Fill opacity for the area. When you set an explicit `fillColor`,
   * the `fillOpacity` is not applied. Instead, you should define the
   * opacity in the `fillColor` with an rgba color definition. The
   * `fillOpacity` setting, also the default setting, overrides the alpha
   * component of the `color` setting.
   *
   * In styled mode, the fill opacity can be set with the `.highcharts-area`
   * class name.
   *
   * @sample {highcharts} highcharts/plotoptions/area-fillopacity/
   *         Automatic fill color and fill opacity of 0.1
   *
   * @type       {number}
   * @default    {highcharts} 0.75
   * @default    {highstock} .75
   * @product    highcharts highstock
   * @apioption  plotOptions.area.fillOpacity
   */

  /**
   * A separate color for the graph line. By default the line takes the
   * `color` of the series, but the lineColor setting allows setting a
   * separate color for the line without altering the `fillColor`.
   *
   * In styled mode, the line stroke can be set with the `.highcharts-graph`
   * class name.
   *
   * @sample {highcharts} highcharts/plotoptions/area-linecolor/
   *         Dark gray line
   *
   * @type       {Highcharts.ColorString}
   * @product    highcharts highstock
   * @apioption  plotOptions.area.lineColor
   */

  /**
   * A separate color for the negative part of the area.
   *
   * In styled mode, a negative color is set with the `.highcharts-negative`
   * class name.
   *
   * @see [negativeColor](#plotOptions.area.negativeColor)
   *
   * @sample {highcharts} highcharts/css/series-negative-color/
   *         Negative color in styled mode
   *
   * @type       {Highcharts.ColorString}
   * @since      3.0
   * @product    highcharts
   * @apioption  plotOptions.area.negativeFillColor
   */

  /**
   * Whether the whole area or just the line should respond to mouseover
   * tooltips and other mouse or touch events.
   *
   * @sample {highcharts|highstock} highcharts/plotoptions/area-trackbyarea/
   *         Display the tooltip when the area is hovered
   *
   * @type       {boolean}
   * @default    false
   * @since      1.1.6
   * @product    highcharts highstock
   * @apioption  plotOptions.area.trackByArea
   */

  /**
   * When this is true, the series will not cause the Y axis to cross
   * the zero plane (or [threshold](#plotOptions.series.threshold) option)
   * unless the data actually crosses the plane.
   *
   * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
   * 3 will make the Y axis show negative values according to the `minPadding`
   * option. If `softThreshold` is `true`, the Y axis starts at 0.
   *
   * @type       {boolean}
   * @since      4.1.9
   * @product    highcharts highstock
   * @apioption  plotOptions.area.softThreshold
   */
  softThreshold: false,

  /**
   * The Y axis value to serve as the base for the area, for distinguishing
   * between values above and below a threshold. The area between the graph
   * and the threshold is filled.
   *
   * * If a number is given, the Y axis will scale to the threshold.
   * * If `null`, the scaling behaves like a line series with fill between the
   *   graph and the Y axis minimum.
   * * If `Infinity` or `-Infinity`, the area between the graph and the
   *   corresponing Y axis extreme is filled (since v6.1.0).
   *
   * @sample  {highcharts} highcharts/plotoptions/area-threshold/
   *          A threshold of 100
   * @sample  {highcharts} highcharts/plotoptions/area-threshold-infinity/
   *          A threshold of Infinity
   *
   * @type       {number}
   * @since      2.0
   * @product    highcharts highstock
   * @apioption  plotOptions.area.threshold
   */
  threshold: 0
},
/** @lends seriesTypes.area.prototype */
{
  singleStacks: false,

  /**
   * Return an array of stacked points, where null and missing points are
   * replaced by dummy points in order for gaps to be drawn correctly
   * in stacks.
   *
   * @ignore
   * @function Highcharts.seriesTypes.area#getStackPoints
   *
   * @param  {Array<Highcharts.Point>} points
   *
   * @return {Array<*>}
   */
  getStackPoints: function (points) {
    var series = this,
        segment = [],
        keys = [],
        xAxis = this.xAxis,
        yAxis = this.yAxis,
        stack = yAxis.stacks[this.stackKey],
        pointMap = {},
        seriesIndex = series.index,
        yAxisSeries = yAxis.series,
        seriesLength = yAxisSeries.length,
        visibleSeries,
        upOrDown = pick$g(yAxis.options.reversedStacks, true) ? 1 : -1,
        i;
    points = points || this.points;

    if (this.options.stacking) {
      for (i = 0; i < points.length; i++) {
        // Reset after point update (#7326)
        points[i].leftNull = points[i].rightNull = null; // Create a map where we can quickly look up the points by their
        // X values.

        pointMap[points[i].x] = points[i];
      } // Sort the keys (#1651)


      Highcharts.objectEach(stack, function (stackX, x) {
        // nulled after switching between
        // grouping and not (#1651, #2336)
        if (stackX.total !== null) {
          keys.push(x);
        }
      });
      keys.sort(function (a, b) {
        return a - b;
      });
      visibleSeries = map$4(yAxisSeries, function () {
        return this.visible;
      });
      each$g(keys, function (x, idx) {
        var y = 0,
            stackPoint,
            stackedValues;

        if (pointMap[x] && !pointMap[x].isNull) {
          segment.push(pointMap[x]); // Find left and right cliff. -1 goes left, 1 goes right.

          each$g([-1, 1], function (direction) {
            var nullName = direction === 1 ? 'rightNull' : 'leftNull',
                cliffName = direction === 1 ? 'rightCliff' : 'leftCliff',
                cliff = 0,
                otherStack = stack[keys[idx + direction]]; // If there is a stack next to this one,
            // to the left or to the right...

            if (otherStack) {
              i = seriesIndex; // Can go either up or down,
              // depending on reversedStacks

              while (i >= 0 && i < seriesLength) {
                stackPoint = otherStack.points[i];

                if (!stackPoint) {
                  // If the next point in this series
                  // is missing, mark the point
                  // with point.leftNull or
                  // point.rightNull = true.
                  if (i === seriesIndex) {
                    pointMap[x][nullName] = true; // If there are missing points in
                    // the next stack in any of the
                    // series below this one, we need
                    // to substract the missing values
                    // and add a hiatus to the left or right.
                  } else if (visibleSeries[i]) {
                    stackedValues = stack[x].points[i];

                    if (stackedValues) {
                      cliff -= stackedValues[1] - stackedValues[0];
                    }
                  }
                } // When reversedStacks is true, loop up,
                // else loop down


                i += upOrDown;
              }
            }

            pointMap[x][cliffName] = cliff;
          }); // There is no point for this X value in this series, so we
          // insert a dummy point in order for the areas to be drawn
          // correctly.
        } else {
          // Loop down the stack to find the series below this
          // one that has a value (#1991)
          i = seriesIndex;

          while (i >= 0 && i < seriesLength) {
            stackPoint = stack[x].points[i];

            if (stackPoint) {
              y = stackPoint[1];
              break;
            } // When reversedStacks is true, loop up, else loop down


            i += upOrDown;
          }

          y = yAxis.translate(y, 0, 1, 0, 1); // #6272

          segment.push({
            isNull: true,
            plotX: xAxis.translate(x, 0, 0, 0, 1),
            // #6272
            x: x,
            plotY: y,
            yBottom: y
          });
        }
      });
    }

    return segment;
  },

  /**
   * @ignore
   * @function Highcharts.seriesTypes.area#getGraphPath
   *
   * @param  {Array<Highcharts.Points>} points
   *
   * @return {Array<number|string>}
   */
  getGraphPath: function (points) {
    var getGraphPath = Series$2.prototype.getGraphPath,
        graphPath,
        options = this.options,
        stacking = options.stacking,
        yAxis = this.yAxis,
        topPath,
        bottomPath,
        bottomPoints = [],
        graphPoints = [],
        seriesIndex = this.index,
        i,
        areaPath,
        plotX,
        stacks = yAxis.stacks[this.stackKey],
        threshold = options.threshold,
        translatedThreshold = yAxis.getThreshold(options.threshold),
        isNull,
        yBottom,
        connectNulls = options.connectNulls || stacking === 'percent',

    /**
     * To display null points in underlying stacked series, this
     * series graph must be broken, and the area also fall down
     * to fill the gap left by the null point. #2069
     */
    addDummyPoints = function (i, otherI, side) {
      var point = points[i],
          stackedValues = stacking && stacks[point.x].points[seriesIndex],
          nullVal = point[side + 'Null'] || 0,
          cliffVal = point[side + 'Cliff'] || 0,
          top,
          bottom,
          isNull = true;

      if (cliffVal || nullVal) {
        top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;
        bottom = stackedValues[0] + cliffVal;
        isNull = !!nullVal;
      } else if (!stacking && points[otherI] && points[otherI].isNull) {
        top = bottom = threshold;
      } // Add to the top and bottom line of the area


      if (top !== undefined) {
        graphPoints.push({
          plotX: plotX,
          plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),
          isNull: isNull,
          isCliff: true
        });
        bottomPoints.push({
          plotX: plotX,
          plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom),
          doCurve: false // #1041, gaps in areaspline areas

        });
      }
    }; // Find what points to use


    points = points || this.points; // Fill in missing points

    if (stacking) {
      points = this.getStackPoints(points);
    }

    for (i = 0; i < points.length; i++) {
      isNull = points[i].isNull;
      plotX = pick$g(points[i].rectPlotX, points[i].plotX);
      yBottom = pick$g(points[i].yBottom, translatedThreshold);

      if (!isNull || connectNulls) {
        if (!connectNulls) {
          addDummyPoints(i, i - 1, 'left');
        } // Skip null point when stacking is false and connectNulls true


        if (!(isNull && !stacking && connectNulls)) {
          graphPoints.push(points[i]);
          bottomPoints.push({
            x: i,
            plotX: plotX,
            plotY: yBottom
          });
        }

        if (!connectNulls) {
          addDummyPoints(i, i + 1, 'right');
        }
      }
    }

    topPath = getGraphPath.call(this, graphPoints, true, true);
    bottomPoints.reversed = true;
    bottomPath = getGraphPath.call(this, bottomPoints, true, true);

    if (bottomPath.length) {
      bottomPath[0] = 'L';
    }

    areaPath = topPath.concat(bottomPath); // TODO: don't set leftCliff and rightCliff when connectNulls?

    graphPath = getGraphPath.call(this, graphPoints, false, connectNulls);
    areaPath.xMap = topPath.xMap;
    this.areaPath = areaPath;
    return graphPath;
  },

  /**
   * Draw the graph and the underlying area. This method calls the Series base
   * function and adds the area. The areaPath is calculated in the
   * getSegmentPath method called from Series.prototype.drawGraph.
   *
   * @ignore
   * @function Highcharts.seriesTypes.area#drawGraph
   *
   * @return {void}
   */
  drawGraph: function () {
    // Define or reset areaPath
    this.areaPath = []; // Call the base method

    Series$2.prototype.drawGraph.apply(this); // Define local variables

    var series = this,
        areaPath = this.areaPath,
        options = this.options,
        zones = this.zones,
        props = [['area', 'highcharts-area']]; // area name, main color, fill color

    each$g(zones, function (zone, i) {
      props.push(['zone-area-' + i, 'highcharts-area highcharts-zone-area-' + i + ' ' + zone.className]);
    });
    each$g(props, function (prop) {
      var areaKey = prop[0],
          area = series[areaKey]; // Create or update the area

      if (area) {
        // update
        area.endX = series.preventGraphAnimation ? null : areaPath.xMap;
        area.animate({
          d: areaPath
        });
      } else {
        // create
        area = series[areaKey] = series.chart.renderer.path(areaPath).addClass(prop[1]).attr({
          zIndex: 0 // #1069

        }).add(series.group);
        area.isArea = true;
      }

      area.startX = areaPath.xMap;
      area.shiftUnit = options.step ? 2 : 1;
    });
  },
  drawLegendSymbol: LegendSymbolMixin$1.drawRectangle
});
/**
 * A `area` series. If the [type](#series.area.type) option is not
 * specified, it is inherited from [chart.type](#chart.type).
 *
 * @type       {*}
 * @extends    series,plotOptions.area
 * @excluding  dataParser,dataURL
 * @product    highcharts highstock
 * @apioption  series.area
 */

/**
 * An array of data points for the series. For the `area` series type,
 * points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 *
 *  ```js
 *     data: [
 *         [0, 9],
 *         [1, 7],
 *         [2, 6]
 *     ]
 *  ```
 *
 * 3.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.area.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 9,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 6,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 *
 * @type       {Array<number|Array<number>|*>}
 * @extends    series.line.data
 * @product    highcharts highstock
 * @apioption  series.area.data
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var pick$h = Highcharts.pick,
    seriesType$1 = Highcharts.seriesType;
/**
 * A spline series is a special type of line series, where the segments between
 * the data points are smoothed.
 *
 * @sample    {highcharts} highcharts/demo/spline-irregular-time/
 *            Spline chart
 * @sample    {highstock} stock/demo/spline/
 *            Spline chart
 * @extends   plotOptions.series
 * @excluding step
 * @product   highcharts highstock
 * @apioption plotOptions.spline
 */

/**
 * Spline series type.
 *
 * @constructor seriesTypes.spline
 * @extends     {Series}
 */

seriesType$1('spline', 'line', {},
/** @lends seriesTypes.spline.prototype */
{
  /**
   * Get the spline segment from a given point's previous neighbour to the
   * given point
   */
  getPointSpline: function (points, point, i) {
    var // 1 means control points midway between points, 2 means 1/3 from
    // the point, 3 is 1/4 etc
    smoothing = 1.5,
        denom = smoothing + 1,
        plotX = point.plotX,
        plotY = point.plotY,
        lastPoint = points[i - 1],
        nextPoint = points[i + 1],
        leftContX,
        leftContY,
        rightContX,
        rightContY,
        ret;

    function doCurve(otherPoint) {
      return otherPoint && !otherPoint.isNull && otherPoint.doCurve !== false && !point.isCliff; // #6387, area splines next to null
    } // Find control points


    if (doCurve(lastPoint) && doCurve(nextPoint)) {
      var lastX = lastPoint.plotX,
          lastY = lastPoint.plotY,
          nextX = nextPoint.plotX,
          nextY = nextPoint.plotY,
          correction = 0;
      leftContX = (smoothing * plotX + lastX) / denom;
      leftContY = (smoothing * plotY + lastY) / denom;
      rightContX = (smoothing * plotX + nextX) / denom;
      rightContY = (smoothing * plotY + nextY) / denom; // Have the two control points make a straight line through main
      // point

      if (rightContX !== leftContX) {
        // #5016, division by zero
        correction = (rightContY - leftContY) * (rightContX - plotX) / (rightContX - leftContX) + plotY - rightContY;
      }

      leftContY += correction;
      rightContY += correction; // to prevent false extremes, check that control points are between
      // neighbouring points' y values

      if (leftContY > lastY && leftContY > plotY) {
        leftContY = Math.max(lastY, plotY); // mirror of left control point

        rightContY = 2 * plotY - leftContY;
      } else if (leftContY < lastY && leftContY < plotY) {
        leftContY = Math.min(lastY, plotY);
        rightContY = 2 * plotY - leftContY;
      }

      if (rightContY > nextY && rightContY > plotY) {
        rightContY = Math.max(nextY, plotY);
        leftContY = 2 * plotY - rightContY;
      } else if (rightContY < nextY && rightContY < plotY) {
        rightContY = Math.min(nextY, plotY);
        leftContY = 2 * plotY - rightContY;
      } // record for drawing in next point


      point.rightContX = rightContX;
      point.rightContY = rightContY;
    } // Visualize control points for debugging

    /*
    if (leftContX) {
        this.chart.renderer.circle(
                leftContX + this.chart.plotLeft,
                leftContY + this.chart.plotTop,
                2
            )
            .attr({
                stroke: 'red',
                'stroke-width': 2,
                fill: 'none',
                zIndex: 9
            })
            .add();
        this.chart.renderer.path(['M', leftContX + this.chart.plotLeft,
            leftContY + this.chart.plotTop,
            'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
            .attr({
                stroke: 'red',
                'stroke-width': 2,
                zIndex: 9
            })
            .add();
    }
    if (rightContX) {
        this.chart.renderer.circle(
                rightContX + this.chart.plotLeft,
                rightContY + this.chart.plotTop,
                2
            )
            .attr({
                stroke: 'green',
                'stroke-width': 2,
                fill: 'none',
                zIndex: 9
            })
            .add();
        this.chart.renderer.path(['M', rightContX + this.chart.plotLeft,
            rightContY + this.chart.plotTop,
            'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
            .attr({
                stroke: 'green',
                'stroke-width': 2,
                zIndex: 9
            })
            .add();
    }
    // */


    ret = ['C', pick$h(lastPoint.rightContX, lastPoint.plotX), pick$h(lastPoint.rightContY, lastPoint.plotY), pick$h(leftContX, plotX), pick$h(leftContY, plotY), plotX, plotY]; // reset for updating series later

    lastPoint.rightContX = lastPoint.rightContY = null;
    return ret;
  }
});
/**
 * A `spline` series. If the [type](#series.spline.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.spline
 * @excluding dataParser,dataURL,step
 * @product   highcharts highstock
 * @apioption series.spline
 */

/**
 * An array of data points for the series. For the `spline` series type,
 * points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 *
 *  ```js
 *     data: [
 *         [0, 9],
 *         [1, 2],
 *         [2, 8]
 *     ]
 *  ```
 *
 * 3.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.spline.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 9,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 0,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Array|Number>}
 * @extends   series.line.data
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts highstock
 * @apioption series.spline.data
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var areaProto = Highcharts.seriesTypes.area.prototype,
    defaultPlotOptions$1 = Highcharts.defaultPlotOptions,
    LegendSymbolMixin$2 = Highcharts.LegendSymbolMixin,
    seriesType$2 = Highcharts.seriesType;
/**
 * AreaSplineSeries object
 */

/**
 * The area spline series is an area series where the graph between the points
 * is smoothed into a spline.
 *
 * @extends   plotOptions.area
 * @excluding step
 * @sample    {highcharts} highcharts/demo/areaspline/ Area spline chart
 * @sample    {highstock} stock/demo/areaspline/ Area spline chart
 * @product   highcharts highstock
 * @apioption plotOptions.areaspline
 */

seriesType$2('areaspline', 'spline', defaultPlotOptions$1.area, {
  getStackPoints: areaProto.getStackPoints,
  getGraphPath: areaProto.getGraphPath,
  drawGraph: areaProto.drawGraph,
  drawLegendSymbol: LegendSymbolMixin$2.drawRectangle
});
/**
 * A `areaspline` series. If the [type](#series.areaspline.type) option
 * is not specified, it is inherited from [chart.type](#chart.type).
 *
 *
 * @type      {Object}
 * @extends   series,plotOptions.areaspline
 * @excluding dataParser,dataURL
 * @product   highcharts highstock
 * @apioption series.areaspline
 */

/**
 * An array of data points for the series. For the `areaspline` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 *
 *  ```js
 *     data: [
 *         [0, 10],
 *         [1, 9],
 *         [2, 3]
 *     ]
 *  ```
 *
 * 3.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series'
 * [turboThreshold](#series.areaspline.turboThreshold), this option is not
 * available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 4,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 4,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Array|Number>}
 * @extends   series.line.data
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts highstock
 * @apioption series.areaspline.data
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var animObject$3 = Highcharts.animObject,
    color$5 = Highcharts.color,
    each$h = Highcharts.each,
    extend$c = Highcharts.extend,
    isNumber$9 = Highcharts.isNumber,
    LegendSymbolMixin$3 = Highcharts.LegendSymbolMixin,
    merge$c = Highcharts.merge,
    noop$3 = Highcharts.noop,
    pick$i = Highcharts.pick,
    Series$3 = Highcharts.Series,
    seriesType$3 = Highcharts.seriesType,
    svg$3 = Highcharts.svg;
/**
 * The column series type.
 *
 * @constructor seriesTypes.column
 * @augments    Series
 */

/**
 * Column series display one column per value along an X axis.
 *
 * @sample       {highcharts} highcharts/demo/column-basic/ Column chart
 * @sample       {highstock} stock/demo/column/ Column chart
 *
 * @extends      {plotOptions.line}
 * @product      highcharts highstock
 * @excluding    connectNulls,dashStyle,gapSize,gapUnit,linecap,lineWidth,
 *               marker,connectEnds,step
 * @optionparent plotOptions.column
 */

seriesType$3('column', 'line', {
  /**
   * The corner radius of the border surrounding each column or bar.
   *
   * @type    {Number}
   * @sample  {highcharts} highcharts/plotoptions/column-borderradius/
   *          Rounded columns
   * @default 0
   * @product highcharts highstock
   */
  borderRadius: 0,

  /**
   * When using automatic point colors pulled from the global [colors](colors)
   * or series-specific [plotOptions.column.colors](series.colors)
   * collections, this option determines whether the chart should receive
   * one color per series or one color per point.
   *
   * In styled mode, the `colors` or `series.colors` arrays are not supported,
   * and instead this option gives the points individual color class names on
   * the form `highcharts-color-{n}`.
   *
   * @type      {Boolean}
   * @see       [series colors](#plotOptions.column.colors)
   * @sample    {highcharts} highcharts/plotoptions/column-colorbypoint-false/
   *            False by default
   * @sample    {highcharts} highcharts/plotoptions/column-colorbypoint-true/
   *            True
   * @default   false
   * @since     2.0
   * @product   highcharts highstock
   * @apioption plotOptions.column.colorByPoint
   */

  /**
   * A series specific or series type specific color set to apply instead
   * of the global [colors](#colors) when [colorByPoint](
   * #plotOptions.column.colorByPoint) is true.
   *
   * @type      {Array<Color>}
   * @since     3.0
   * @product   highcharts highstock
   * @apioption plotOptions.column.colors
   */

  /**
   * When true, each column edge is rounded to its nearest pixel in order
   * to render sharp on screen. In some cases, when there are a lot of
   * densely packed columns, this leads to visible difference in column
   * widths or distance between columns. In these cases, setting `crisp`
   * to `false` may look better, even though each column is rendered
   * blurry.
   *
   * @sample  {highcharts} highcharts/plotoptions/column-crisp-false/
   *          Crisp is false
   * @since   5.0.10
   * @product highcharts highstock
   */
  crisp: true,

  /**
   * Padding between each value groups, in x axis units.
   *
   * @sample  {highcharts} highcharts/plotoptions/column-grouppadding-default/
   *          0.2 by default
   * @sample  {highcharts} highcharts/plotoptions/column-grouppadding-none/
   *          No group padding - all columns are evenly spaced
   * @product highcharts highstock
   */
  groupPadding: 0.2,

  /**
   * Whether to group non-stacked columns or to let them render independent
   * of each other. Non-grouped columns will be laid out individually
   * and overlap each other.
   *
   * @type      {Boolean}
   * @sample    {highcharts} highcharts/plotoptions/column-grouping-false/
   *            Grouping disabled
   * @sample    {highstock} highcharts/plotoptions/column-grouping-false/
   *            Grouping disabled
   * @default   true
   * @since     2.3.0
   * @product   highcharts highstock
   * @apioption plotOptions.column.grouping
   */

  /**
   * @ignore-option
   */
  marker: null,
  // point options are specified in the base options

  /**
   * The maximum allowed pixel width for a column, translated to the height
   * of a bar in a bar chart. This prevents the columns from becoming
   * too wide when there is a small number of points in the chart.
   *
   * @type      {Number}
   * @see       [pointWidth](#plotOptions.column.pointWidth)
   * @sample    {highcharts} highcharts/plotoptions/column-maxpointwidth-20/
   *            Limited to 50
   * @sample    {highstock} highcharts/plotoptions/column-maxpointwidth-20/
   *            Limited to 50
   * @default   null
   * @since     4.1.8
   * @product   highcharts highstock
   * @apioption plotOptions.column.maxPointWidth
   */

  /**
   * Padding between each column or bar, in x axis units.
   *
   * @sample  {highcharts} highcharts/plotoptions/column-pointpadding-default/
   *          0.1 by default
   * @sample  {highcharts} highcharts/plotoptions/column-pointpadding-025/
   *          0.25
   * @sample  {highcharts} highcharts/plotoptions/column-pointpadding-none/
   *          0 for tightly packed columns
   * @product highcharts highstock
   */
  pointPadding: 0.1,

  /**
   * A pixel value specifying a fixed width for each column or bar. When
   * `null`, the width is calculated from the `pointPadding` and
   * `groupPadding`.
   *
   * @type      {Number}
   * @see       [maxPointWidth](#plotOptions.column.maxPointWidth)
   * @sample    {highcharts} highcharts/plotoptions/column-pointwidth-20/
   *            20px wide columns regardless of chart width or the amount
   *            of data points
   * @default   null
   * @since     1.2.5
   * @product   highcharts highstock
   * @apioption plotOptions.column.pointWidth
   */

  /**
   * The minimal height for a column or width for a bar. By default,
   * 0 values are not shown. To visualize a 0 (or close to zero) point,
   * set the minimal point length to a pixel value like 3\. In stacked
   * column charts, minPointLength might not be respected for tightly
   * packed values.
   *
   * @sample  {highcharts}
   *          highcharts/plotoptions/column-minpointlength/
   *          Zero base value
   * @sample  {highcharts}
   *          highcharts/plotoptions/column-minpointlength-pos-and-neg/
   *          Positive and negative close to zero values
   * @product highcharts highstock
   */
  minPointLength: 0,

  /**
   * When the series contains less points than the crop threshold, all
   * points are drawn, event if the points fall outside the visible plot
   * area at the current zoom. The advantage of drawing all points (including
   * markers and columns), is that animation is performed on updates.
   * On the other hand, when the series contains more points than the
   * crop threshold, the series data is cropped to only contain points
   * that fall within the plot area. The advantage of cropping away invisible
   * points is to increase performance on large series. .
   *
   * @product highcharts highstock
   */
  cropThreshold: 50,

  /**
   * The X axis range that each point is valid for. This determines the
   * width of the column. On a categorized axis, the range will be 1
   * by default (one category unit). On linear and datetime axes, the
   * range will be computed as the distance between the two closest data
   * points.
   *
   * The default `null` means it is computed automatically, but this option
   * can be used to override the automatic value.
   *
   * @type    {Number}
   * @sample  {highcharts} highcharts/plotoptions/column-pointrange/
   *          Set the point range to one day on a data set with one week
   *          between the points
   * @since   2.3
   * @product highcharts highstock
   */
  pointRange: null,
  states: {
    /**
     * Options for the hovered point. These settings override the normal
     * state options when a point is moused over or touched.
     *
     * @extends   plotOptions.series.states.hover
     * @excluding halo,lineWidth,lineWidthPlus,marker
     * @product   highcharts highstock
     */
    hover: {
      /** @ignore-option */
      halo: false
      /**
       * A specific border color for the hovered point. Defaults to
       * inherit the normal state border color.
       *
       * @type      {Color}
       * @product   highcharts
       * @apioption plotOptions.column.states.hover.borderColor
       */

      /**
       * A specific color for the hovered point.
       *
       * @type      {Color}
       * @default   undefined
       * @product   highcharts
       * @apioption plotOptions.column.states.hover.color
       */

    }
  },
  dataLabels: {
    align: null,
    // auto
    verticalAlign: null,
    // auto
    y: null
  },

  /**
   * When this is true, the series will not cause the Y axis to cross
   * the zero plane (or [threshold](#plotOptions.series.threshold) option)
   * unless the data actually crosses the plane.
   *
   * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
   * 3 will make the Y axis show negative values according to the `minPadding`
   * option. If `softThreshold` is `true`, the Y axis starts at 0.
   *
   * @since   4.1.9
   * @product highcharts highstock
   */
  softThreshold: false,
  // false doesn't work well: https://jsfiddle.net/highcharts/hz8fopan/14/

  /**
   * @ignore-option
   */
  startFromThreshold: true,
  stickyTracking: false,
  tooltip: {
    distance: 6
  },

  /**
   * The Y axis value to serve as the base for the columns, for distinguishing
   * between values above and below a threshold. If `null`, the columns
   * extend from the padding Y axis minimum.
   *
   * @since   2.0
   * @product highcharts
   */
  threshold: 0
},
/** @lends seriesTypes.column.prototype */
{
  cropShoulder: 0,
  // When tooltip is not shared, this series (and derivatives) requires direct
  // touch/hover. KD-tree does not apply.
  directTouch: true,
  trackerGroups: ['group', 'dataLabelsGroup'],
  // use separate negative stacks, unlike area stacks where a negative point
  // is substracted from previous (#1910)
  negStacks: true,

  /**
   * Initialize the series. Extends the basic Series.init method by
   * marking other series of the same type as dirty.
   *
   * @function #init
   * @memberof seriesTypes.column
   *
   */
  init: function () {
    Series$3.prototype.init.apply(this, arguments);
    var series = this,
        chart = series.chart; // if the series is added dynamically, force redraw of other
    // series affected by a new column

    if (chart.hasRendered) {
      each$h(chart.series, function (otherSeries) {
        if (otherSeries.type === series.type) {
          otherSeries.isDirty = true;
        }
      });
    }
  },

  /**
   * Return the width and x offset of the columns adjusted for grouping,
   * groupPadding, pointPadding, pointWidth etc.
   */
  getColumnMetrics: function () {
    var series = this,
        options = series.options,
        xAxis = series.xAxis,
        yAxis = series.yAxis,
        reversedStacks = xAxis.options.reversedStacks,
        // Keep backward compatibility: reversed xAxis had reversed stacks
    reverseStacks = xAxis.reversed && !reversedStacks || !xAxis.reversed && reversedStacks,
        stackKey,
        stackGroups = {},
        columnCount = 0; // Get the total number of column type series. This is called on every
    // series. Consider moving this logic to a chart.orderStacks() function
    // and call it on init, addSeries and removeSeries

    if (options.grouping === false) {
      columnCount = 1;
    } else {
      each$h(series.chart.series, function (otherSeries) {
        var otherOptions = otherSeries.options,
            otherYAxis = otherSeries.yAxis,
            columnIndex;

        if (otherSeries.type === series.type && (otherSeries.visible || !series.chart.options.chart.ignoreHiddenSeries) && yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {
          // #642, #2086
          if (otherOptions.stacking) {
            stackKey = otherSeries.stackKey;

            if (stackGroups[stackKey] === undefined) {
              stackGroups[stackKey] = columnCount++;
            }

            columnIndex = stackGroups[stackKey];
          } else if (otherOptions.grouping !== false) {
            // #1162
            columnIndex = columnCount++;
          }

          otherSeries.columnIndex = columnIndex;
        }
      });
    }

    var categoryWidth = Math.min(Math.abs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610
    xAxis.len // #1535
    ),
        groupPadding = categoryWidth * options.groupPadding,
        groupWidth = categoryWidth - 2 * groupPadding,
        pointOffsetWidth = groupWidth / (columnCount || 1),
        pointWidth = Math.min(options.maxPointWidth || xAxis.len, pick$i(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))),
        pointPadding = (pointOffsetWidth - pointWidth) / 2,
        // #1251, #3737
    colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0),
        pointXOffset = pointPadding + (groupPadding + colIndex * pointOffsetWidth - categoryWidth / 2) * (reverseStacks ? -1 : 1); // Save it for reading in linked series (Error bars particularly)

    series.columnMetrics = {
      width: pointWidth,
      offset: pointXOffset
    };
    return series.columnMetrics;
  },

  /**
   * Make the columns crisp. The edges are rounded to the nearest full pixel.
   */
  crispCol: function (x, y, w, h) {
    var chart = this.chart,
        borderWidth = this.borderWidth,
        xCrisp = -(borderWidth % 2 ? 0.5 : 0),
        yCrisp = borderWidth % 2 ? 0.5 : 1,
        right,
        bottom,
        fromTop;

    if (chart.inverted && chart.renderer.isVML) {
      yCrisp += 1;
    } // Horizontal. We need to first compute the exact right edge, then round
    // it and compute the width from there.


    if (this.options.crisp) {
      right = Math.round(x + w) + xCrisp;
      x = Math.round(x) + xCrisp;
      w = right - x;
    } // Vertical


    bottom = Math.round(y + h) + yCrisp;
    fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656

    y = Math.round(y) + yCrisp;
    h = bottom - y; // Top edges are exceptions

    if (fromTop && h) {
      // #5146
      y -= 1;
      h += 1;
    }

    return {
      x: x,
      y: y,
      width: w,
      height: h
    };
  },

  /**
   * Translate each point to the plot area coordinate system and find shape
   * positions
   */
  translate: function () {
    var series = this,
        chart = series.chart,
        options = series.options,
        dense = series.dense = series.closestPointRange * series.xAxis.transA < 2,
        borderWidth = series.borderWidth = pick$i(options.borderWidth, dense ? 0 : 1 // #3635
    ),
        yAxis = series.yAxis,
        threshold = options.threshold,
        translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
        minPointLength = pick$i(options.minPointLength, 5),
        metrics = series.getColumnMetrics(),
        pointWidth = metrics.width,
        // postprocessed for border width
    seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth),
        pointXOffset = series.pointXOffset = metrics.offset;

    if (chart.inverted) {
      translatedThreshold -= 0.5; // #3355
    } // When the pointPadding is 0, we want the columns to be packed tightly,
    // so we allow individual columns to have individual sizes. When
    // pointPadding is greater, we strive for equal-width columns (#2694).


    if (options.pointPadding) {
      seriesBarW = Math.ceil(seriesBarW);
    }

    Series$3.prototype.translate.apply(series); // Record the new values

    each$h(series.points, function (point) {
      var yBottom = pick$i(point.yBottom, translatedThreshold),
          safeDistance = 999 + Math.abs(yBottom),
          plotY = Math.min(Math.max(-safeDistance, point.plotY), yAxis.len + safeDistance),
          // Don't draw too far outside plot area (#1303, #2241, #4264)
      barX = point.plotX + pointXOffset,
          barW = seriesBarW,
          barY = Math.min(plotY, yBottom),
          up,
          barH = Math.max(plotY, yBottom) - barY; // Handle options.minPointLength

      if (minPointLength && Math.abs(barH) < minPointLength) {
        barH = minPointLength;
        up = !yAxis.reversed && !point.negative || yAxis.reversed && point.negative; // Reverse zeros if there's no positive value in the series
        // in visible range (#7046)

        if (point.y === threshold && series.dataMax <= threshold && yAxis.min < threshold // and if there's room for it (#7311)
        ) {
            up = !up;
          } // If stacked...


        barY = Math.abs(barY - translatedThreshold) > minPointLength ? // ...keep position
        yBottom - minPointLength : // #1485, #4051
        translatedThreshold - (up ? minPointLength : 0);
      } // Cache for access in polar


      point.barX = barX;
      point.pointWidth = pointWidth; // Fix the tooltip on center of grouped columns (#1216, #424, #3648)

      point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] : [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH]; // Register shape type and arguments to be used in drawPoints

      point.shapeType = 'rect';
      point.shapeArgs = series.crispCol.apply(series, point.isNull ? // #3169, drilldown from null must have a position to work
      // from #6585, dataLabel should be placed on xAxis, not
      // floating in the middle of the chart
      [barX, translatedThreshold, barW, 0] : [barX, barY, barW, barH]);
    });
  },
  getSymbol: noop$3,

  /**
   * Use a solid rectangle like the area series types
   */
  drawLegendSymbol: LegendSymbolMixin$3.drawRectangle,

  /**
   * Columns have no graph
   */
  drawGraph: function () {
    this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');
  },

  /**
   * Draw the columns. For bars, the series.group is rotated, so the same
   * coordinates apply for columns and bars. This method is inherited by
   * scatter series.
   */
  drawPoints: function () {
    var series = this,
        chart = this.chart,
        options = series.options,
        renderer = chart.renderer,
        animationLimit = options.animationLimit || 250,
        shapeArgs; // draw the columns

    each$h(series.points, function (point) {
      var plotY = point.plotY,
          graphic = point.graphic,
          verb = graphic && chart.pointCount < animationLimit ? 'animate' : 'attr';

      if (isNumber$9(plotY) && point.y !== null) {
        shapeArgs = point.shapeArgs;

        if (graphic) {
          // update
          graphic[verb](merge$c(shapeArgs));
        } else {
          point.graphic = graphic = renderer[point.shapeType](shapeArgs).add(point.group || series.group);
        } // Border radius is not stylable (#6900)


        if (options.borderRadius) {
          graphic.attr({
            r: options.borderRadius
          });
        }

        graphic.addClass(point.getClassName(), true);
      } else if (graphic) {
        point.graphic = graphic.destroy(); // #1269
      }
    });
  },

  /**
   * Animate the column heights one by one from zero
   * @param {Boolean} init Whether to initialize the animation or run it
   */
  animate: function (init) {
    var series = this,
        yAxis = this.yAxis,
        options = series.options,
        inverted = this.chart.inverted,
        attr = {},
        translateProp = inverted ? 'translateX' : 'translateY',
        translateStart,
        translatedThreshold;

    if (svg$3) {
      // VML is too slow anyway
      if (init) {
        attr.scaleY = 0.001;
        translatedThreshold = Math.min(yAxis.pos + yAxis.len, Math.max(yAxis.pos, yAxis.toPixels(options.threshold)));

        if (inverted) {
          attr.translateX = translatedThreshold - yAxis.len;
        } else {
          attr.translateY = translatedThreshold;
        }

        series.group.attr(attr);
      } else {
        // run the animation
        translateStart = series.group.attr(translateProp);
        series.group.animate({
          scaleY: 1
        }, extend$c(animObject$3(series.options.animation), {
          // Do the scale synchronously to ensure smooth updating
          // (#5030, #7228)
          step: function (val, fx) {
            attr[translateProp] = translateStart + fx.pos * (yAxis.pos - translateStart);
            series.group.attr(attr);
          }
        })); // delete this function to allow it only once

        series.animate = null;
      }
    }
  },

  /**
   * Remove this series from the chart
   */
  remove: function () {
    var series = this,
        chart = series.chart; // column and bar series affects other series of the same type
    // as they are either stacked or grouped

    if (chart.hasRendered) {
      each$h(chart.series, function (otherSeries) {
        if (otherSeries.type === series.type) {
          otherSeries.isDirty = true;
        }
      });
    }

    Series$3.prototype.remove.apply(series, arguments);
  }
});
/**
 * A `column` series. If the [type](#series.column.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.column
 * @excluding connectNulls,dashStyle,dataParser,dataURL,gapSize,gapUnit,linecap,
 *            lineWidth,marker,connectEnds,step
 * @product   highcharts highstock
 * @apioption series.column
 */

/**
 * @excluding halo,lineWidth,lineWidthPlus,marker
 * @product   highcharts highstock
 * @apioption series.column.states.hover
 */

/**
 * @excluding halo,lineWidth,lineWidthPlus,marker
 * @product   highcharts highstock
 * @apioption series.column.states.select
 */

/**
 * An array of data points for the series. For the `column` series type,
 * points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 *
 *  ```js
 *     data: [
 *         [0, 6],
 *         [1, 2],
 *         [2, 6]
 *     ]
 *  ```
 *
 * 3.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.column.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 9,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 6,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Array|Number>}
 * @extends   series.line.data
 * @excluding marker
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts highstock
 * @apioption series.column.data
 */

/**
 * The color of the border surrounding the column or bar.
 *
 * In styled mode, the border stroke can be set with the `.highcharts-point`
 * rule.
 *
 * @type      {Color}
 * @sample    {highcharts} highcharts/plotoptions/column-bordercolor/
 *            Dark gray border
 * @default   undefined
 * @product   highcharts highstock
 * @apioption series.column.data.borderColor
 */

/**
 * The width of the border surrounding the column or bar.
 *
 * In styled mode, the stroke width can be set with the `.highcharts-point`
 * rule.
 *
 * @type      {Number}
 * @sample    {highcharts} highcharts/plotoptions/column-borderwidth/
 *            2px black border
 * @default   undefined
 * @product   highcharts highstock
 * @apioption series.column.data.borderWidth
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var seriesType$4 = Highcharts.seriesType;
/**
 * The Bar series class
 */

seriesType$4('bar', 'column', null, {
  inverted: true
});
/**
 * A bar series is a special type of column series where the columns are
 * horizontal.
 *
 * @sample       highcharts/demo/bar-basic/
 *               Bar chart
 * @extends      {plotOptions.column}
 * @product      highcharts
 * @optionparent plotOptions.bar
 */

/**
 * A `bar` series. If the [type](#series.bar.type) option is not specified,
 * it is inherited from [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.bar
 * @excluding connectNulls,dashStyle,dataParser,dataURL,gapSize,gapUnit,linecap,
 *            lineWidth,marker,connectEnds,step
 * @product   highcharts
 * @apioption series.bar
 */

/**
 * An array of data points for the series. For the `bar` series type,
 * points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 *
 *  ```js
 *     data: [
 *         [0, 5],
 *         [1, 10],
 *         [2, 3]
 *     ]
 *  ```
 *
 * 3.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.bar.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 1,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 10,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Array|Number>}
 * @extends   series.column.data
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts
 * @apioption series.bar.data
 */

/**
 * @excluding halo,lineWidth,lineWidthPlus,marker
 * @product   highcharts highstock
 * @apioption series.bar.states.hover
 */

/**
 * @excluding halo,lineWidth,lineWidthPlus,marker
 * @product   highcharts highstock
 * @apioption series.bar.states.select
 */

/**
 * Alignment of the data label relative to the data point.
 *
 * @type      {String}
 * @sample    {highcharts}
 *            highcharts/plotoptions/bar-datalabels-align-inside-bar/
 *            Data labels inside the bar
 * @default   left
 * @product   highcharts
 * @apioption plotOptions.bar.dataLabels.align
 */

/**
 * The x position of the data label relative to the data point.
 *
 * @type      {Number}
 * @sample    {highcharts}
 *            highcharts/plotoptions/bar-datalabels-align-inside-bar/
 *            Data labels inside the bar
 * @default   5
 * @product   highcharts
 * @apioption plotOptions.bar.dataLabels.x
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var Series$4 = Highcharts.Series,
    seriesType$5 = Highcharts.seriesType;
/**
 * A scatter plot uses cartesian coordinates to display values for two variables
 * for a set of data.
 *
 * @sample       {highcharts} highcharts/demo/scatter/
 *               Scatter plot
 * @extends      {plotOptions.line}
 * @excluding    pointPlacement, shadow
 * @product      highcharts highstock
 * @optionparent plotOptions.scatter
 */

seriesType$5('scatter', 'line', {
  /**
   * The width of the line connecting the data points.
   *
   * @sample  {highcharts} highcharts/plotoptions/scatter-linewidth-none/
   *          0 by default
   * @sample  {highcharts} highcharts/plotoptions/scatter-linewidth-1/
   *          1px
   * @product highcharts highstock
   */
  lineWidth: 0,
  findNearestPointBy: 'xy',
  marker: {
    enabled: true // Overrides auto-enabling in line series (#3647)

  },

  /**
   * Sticky tracking of mouse events. When true, the `mouseOut` event
   * on a series isn't triggered until the mouse moves over another series,
   * or out of the plot area. When false, the `mouseOut` event on a series
   * is triggered when the mouse leaves the area around the series' graph
   * or markers. This also implies the tooltip. When `stickyTracking`
   * is false and `tooltip.shared` is false, the tooltip will be hidden
   * when moving the mouse between series.
   *
   * @type      {Boolean}
   * @default   false
   * @product   highcharts highstock
   * @apioption plotOptions.scatter.stickyTracking
   */

  /**
   * A configuration object for the tooltip rendering of each single
   * series. Properties are inherited from [tooltip](#tooltip).
   * Overridable properties are `headerFormat`, `pointFormat`, `yDecimals`,
   * `xDateFormat`, `yPrefix` and `ySuffix`. Unlike other series, in
   * a scatter plot the series.name by default shows in the headerFormat
   * and point.x and point.y in the pointFormat.
   *
   * @product highcharts highstock
   */
  tooltip: {
    headerFormat: '<span class="highcharts-color-{point.colorIndex}">\u25CF</span> ' + '<span class="highcharts-header"> {series.name}</span><br/>',
    pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>' // Prototype members

  }
}, {
  sorted: false,
  requireSorting: false,
  noSharedTooltip: true,
  trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
  takeOrdinalPosition: false,
  // #2342
  drawGraph: function () {
    if (this.options.lineWidth) {
      Series$4.prototype.drawGraph.call(this);
    }
  }
});
/**
 * A `scatter` series. If the [type](#series.scatter.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.scatter
 * @excluding dataParser,dataURL
 * @product   highcharts highstock
 * @apioption series.scatter
 */

/**
 * An array of data points for the series. For the `scatter` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 *
 *  ```js
 *     data: [
 *         [0, 0],
 *         [1, 8],
 *         [2, 9]
 *     ]
 *  ```
 *
 * 3.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.scatter.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 2,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 4,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Array|Number>}
 * @extends   series.line.data
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts highstock
 * @apioption series.scatter.data
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var deg2rad$3 = Highcharts.deg2rad,
    isNumber$a = Highcharts.isNumber,
    pick$j = Highcharts.pick,
    relativeLength = Highcharts.relativeLength;
/**
 * @private
 * @mixin Highcharts.CenteredSeriesMixin
 */

Highcharts.CenteredSeriesMixin = {
  /**
   * Get the center of the pie based on the size and center options relative
   * to the plot area. Borrowed by the polar and gauge series types.
   *
   * @private
   * @function Highcharts.CenteredSeriesMixin.getCenter
   *
   * @return {Array<number>}
   */
  getCenter: function () {
    var options = this.options,
        chart = this.chart,
        slicingRoom = 2 * (options.slicedOffset || 0),
        handleSlicingRoom,
        plotWidth = chart.plotWidth - 2 * slicingRoom,
        plotHeight = chart.plotHeight - 2 * slicingRoom,
        centerOption = options.center,
        positions = [pick$j(centerOption[0], '50%'), pick$j(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
        smallestSize = Math.min(plotWidth, plotHeight),
        i,
        value;

    for (i = 0; i < 4; ++i) {
      value = positions[i];
      handleSlicingRoom = i < 2 || i === 2 && /%$/.test(value); // i == 0: centerX, relative to width
      // i == 1: centerY, relative to height
      // i == 2: size, relative to smallestSize
      // i == 3: innerSize, relative to size

      positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) + (handleSlicingRoom ? slicingRoom : 0);
    } // innerSize cannot be larger than size (#3632)


    if (positions[3] > positions[2]) {
      positions[3] = positions[2];
    }

    return positions;
  },

  /**
   * getStartAndEndRadians - Calculates start and end angles in radians.
   * Used in series types such as pie and sunburst.
   *
   * @private
   * @function Highcharts.CenteredSeriesMixin.getStartAndEndRadians
   *
   * @param {number} start
   *        Start angle in degrees.
   *
   * @param {number} end
   *        Start angle in degrees.
   *
   * @return {Highcharts.RadianAngles}
   *         Returns an object containing start and end angles as radians.
   */
  getStartAndEndRadians: function getStartAndEndRadians(start, end) {
    var startAngle = isNumber$a(start) ? start : 0,
        // must be a number
    endAngle = isNumber$a(end) && // must be a number
    end > startAngle && // must be larger than the start angle
    // difference must be less than 360 degrees
    end - startAngle < 360 ? end : startAngle + 360,
        correction = -90;
    return {
      start: deg2rad$3 * (startAngle + correction),
      end: deg2rad$3 * (endAngle + correction)
    };
  }
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$9 = Highcharts.addEvent,
    CenteredSeriesMixin = Highcharts.CenteredSeriesMixin,
    defined$c = Highcharts.defined,
    each$i = Highcharts.each,
    extend$d = Highcharts.extend,
    getStartAndEndRadians = CenteredSeriesMixin.getStartAndEndRadians,
    inArray$3 = Highcharts.inArray,
    LegendSymbolMixin$4 = Highcharts.LegendSymbolMixin,
    noop$4 = Highcharts.noop,
    pick$k = Highcharts.pick,
    Point$3 = Highcharts.Point,
    Series$5 = Highcharts.Series,
    seriesType$6 = Highcharts.seriesType,
    seriesTypes$2 = Highcharts.seriesTypes,
    setAnimation$2 = Highcharts.setAnimation;
/**
 * The pie series type.
 *
 * @constructor seriesTypes.pie
 * @augments Series
 */

/**
 * A pie chart is a circular graphic which is divided into slices to illustrate
 * numerical proportion.
 *
 * @sample highcharts/demo/pie-basic/ Pie chart
 *
 * @extends plotOptions.line
 * @excluding animationLimit,boostThreshold,connectEnds,connectNulls,
 *          cropThreshold,dashStyle,findNearestPointBy,getExtremesFromAll,
 *          lineWidth,marker,negativeColor,pointInterval,pointIntervalUnit,
 *          pointPlacement,pointStart,softThreshold,stacking,step,threshold,
 *          turboThreshold,zoneAxis,zones
 * @product highcharts
 * @optionparent plotOptions.pie
 */

seriesType$6('pie', 'line', {
  /**
   * The center of the pie chart relative to the plot area. Can be percentages
   * or pixel values. The default behaviour (as of 3.0) is to center
   * the pie so that all slices and data labels are within the plot area.
   * As a consequence, the pie may actually jump around in a chart with
   * dynamic values, as the data labels move. In that case, the center
   * should be explicitly set, for example to `["50%", "50%"]`.
   *
   * @type {Array<String|Number>}
   * @sample {highcharts} highcharts/plotoptions/pie-center/
   *         Centered at 100, 100
   * @default [null, null]
   * @product highcharts
   */
  center: [null, null],
  clip: false,

  /**
   * @ignore
   */
  colorByPoint: true,
  // always true for pies

  /**
   * A series specific or series type specific color set to use instead
   * of the global [colors](#colors).
   *
   * @type {Array<Color>}
   * @sample {highcharts} highcharts/demo/pie-monochrome/
   *         Set default colors for all pies
   * @since 3.0
   * @product highcharts
   * @apioption plotOptions.pie.colors
   */

  /**
   * @extends plotOptions.series.dataLabels
   * @excluding align,allowOverlap,staggerLines,step
   * @product highcharts
   */
  dataLabels: {
    allowOverlap: true,

    /**
     * The color of the line connecting the data label to the pie slice.
     * The default color is the same as the point's color.
     *
     * In styled mode, the connector stroke is given in the
     * `.highcharts-data-label-connector` class.
     *
     * @type {String}
     * @sample {highcharts}
     *         highcharts/plotoptions/pie-datalabels-connectorcolor/
     *         Blue connectors
     * @sample {highcharts} highcharts/css/pie-point/ Styled connectors
     * @default {point.color}
     * @since 2.1
     * @product highcharts
     * @apioption plotOptions.pie.dataLabels.connectorColor
     */

    /**
     * The distance from the data label to the connector.
     *
     * @type {Number}
     * @sample {highcharts}
     *         highcharts/plotoptions/pie-datalabels-connectorpadding/
     *         No padding
     * @default 5
     * @since 2.1
     * @product highcharts
     * @apioption plotOptions.pie.dataLabels.connectorPadding
     */

    /**
     * The width of the line connecting the data label to the pie slice.
     *
     *
     * In styled mode, the connector stroke width is given in the
     * `.highcharts-data-label-connector` class.
     *
     * @type {Number}
     * @sample {highcharts}
     *         highcharts/plotoptions/pie-datalabels-connectorwidth-disabled/
     *         Disable the connector
     * @sample {highcharts}
     *         highcharts/css/pie-point/
     *         Styled connectors
     * @default 1
     * @since 2.1
     * @product highcharts
     * @apioption plotOptions.pie.dataLabels.connectorWidth
     */

    /**
     *
     * @sample {highcharts}
     *         highcharts/plotOptions/pie-datalabels-overflow
     *         Long labels truncated with an ellipsis
     * @sample {highcharts}
     *         highcharts/plotOptions/pie-datalabels-overflow-wrap
     *         Long labels are wrapped
     * @apioption plotOptions.pie.dataLabels.style
     */

    /**
     * The distance of the data label from the pie's edge. Negative numbers
     * put the data label on top of the pie slices. Connectors are only
     * shown for data labels outside the pie.
     *
     * @type {Number}
     * @sample {highcharts}
     *         highcharts/plotoptions/pie-datalabels-distance/
     *         Data labels on top of the pie
     * @default 30
     * @since 2.1
     * @product highcharts
     */
    distance: 30,

    /**
     * Enable or disable the data labels.
     *
     * @type {Boolean}
     * @since 2.1
     * @product highcharts
     */
    enabled: true,
    formatter: function () {
      // #2945
      return this.point.isNull ? undefined : this.point.name;
    },

    /**
     * Whether to render the connector as a soft arc or a line with sharp
     * break.
     *
     * @type {Number}
     * @sample {highcharts}
     *         highcharts/plotoptions/pie-datalabels-softconnector-true/
     *         Soft
     * @sample {highcharts}
     *         highcharts/plotoptions/pie-datalabels-softconnector-false/
     *         Non soft
     * @since 2.1.7
     * @product highcharts
     * @apioption plotOptions.pie.dataLabels.softConnector
     */
    x: 0
  },

  /**
   * The end angle of the pie in degrees where 0 is top and 90 is right.
   * Defaults to `startAngle` plus 360.
   *
   * @type {Number}
   * @sample {highcharts} highcharts/demo/pie-semi-circle/ Semi-circle donut
   * @default null
   * @since 1.3.6
   * @product highcharts
   * @apioption plotOptions.pie.endAngle
   */

  /**
   * Equivalent to [chart.ignoreHiddenSeries](#chart.ignoreHiddenSeries),
   * this option tells whether the series shall be redrawn as if the
   * hidden point were `null`.
   *
   * The default value changed from `false` to `true` with Highcharts
   * 3.0.
   *
   * @type {Boolean}
   * @sample {highcharts} highcharts/plotoptions/pie-ignorehiddenpoint/
   *         True, the hiddden point is ignored
   * @default true
   * @since 2.3.0
   * @product highcharts
   */
  ignoreHiddenPoint: true,

  /**
   * The size of the inner diameter for the pie. A size greater than 0
   * renders a donut chart. Can be a percentage or pixel value. Percentages
   * are relative to the pie size. Pixel values are given as integers.
   *
   *
   * Note: in Highcharts < 4.1.2, the percentage was relative to the plot
   * area, not the pie size.
   *
   * @type {String|Number}
   * @sample {highcharts} highcharts/plotoptions/pie-innersize-80px/
   *         80px inner size
   * @sample {highcharts} highcharts/plotoptions/pie-innersize-50percent/
   *         50% of the plot area
   * @sample {highcharts} highcharts/demo/3d-pie-donut/ 3D donut
   * @default 0
   * @since 2.0
   * @product highcharts
   * @apioption plotOptions.pie.innerSize
   */

  /**
   * @ignore-option
   */
  legendType: 'point',

  /**    @ignore */
  marker: null,
  // point options are specified in the base options

  /**
   * The minimum size for a pie in response to auto margins. The pie will
   * try to shrink to make room for data labels in side the plot area,
   *  but only to this size.
   *
   * @type {Number}
   * @default 80
   * @since 3.0
   * @product highcharts
   * @apioption plotOptions.pie.minSize
   */

  /**
   * The diameter of the pie relative to the plot area. Can be a percentage
   * or pixel value. Pixel values are given as integers. The default
   * behaviour (as of 3.0) is to scale to the plot area and give room
   * for data labels within the plot area.
   * [slicedOffset](#plotOptions.pie.slicedOffset) is also included
   * in the default size calculation. As a consequence, the size
   * of the pie may vary when points are updated and data labels more
   * around. In that case it is best to set a fixed value, for example
   * `"75%"`.
   *
   * @type    {String|Number}
   * @sample  {highcharts} highcharts/plotoptions/pie-size/
   *          Smaller pie
   * @product highcharts
   */
  size: null,

  /**
   * Whether to display this particular series or series type in the
   * legend. Since 2.1, pies are not shown in the legend by default.
   *
   * @type {Boolean}
   * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
   *         One series in the legend, one hidden
   * @product highcharts
   */
  showInLegend: false,

  /**
   * If a point is sliced, moved out from the center, how many pixels
   * should it be moved?.
   *
   * @type {Number}
   * @sample {highcharts} highcharts/plotoptions/pie-slicedoffset-20/
   *         20px offset
   * @default 10
   * @product highcharts
   */
  slicedOffset: 10,

  /**
   * The start angle of the pie slices in degrees where 0 is top and 90
   * right.
   *
   * @type {Number}
   * @sample {highcharts} highcharts/plotoptions/pie-startangle-90/
   *         Start from right
   * @default 0
   * @since 2.3.4
   * @product highcharts
   * @apioption plotOptions.pie.startAngle
   */

  /**
   * Sticky tracking of mouse events. When true, the `mouseOut` event
   * on a series isn't triggered until the mouse moves over another series,
   * or out of the plot area. When false, the `mouseOut` event on a
   * series is triggered when the mouse leaves the area around the series'
   * graph or markers. This also implies the tooltip. When `stickyTracking`
   * is false and `tooltip.shared` is false, the tooltip will be hidden
   * when moving the mouse between series.
   *
   * @product highcharts
   */
  stickyTracking: false,
  tooltip: {
    followPointer: true
  }
},
/** @lends seriesTypes.pie.prototype */
{
  isCartesian: false,
  requireSorting: false,
  directTouch: true,
  noSharedTooltip: true,
  trackerGroups: ['group', 'dataLabelsGroup'],
  axisTypes: [],
  pointAttribs: seriesTypes$2.column.prototype.pointAttribs,

  /**
   * Animate the pies in
   */
  animate: function (init) {
    var series = this,
        points = series.points,
        startAngleRad = series.startAngleRad;

    if (!init) {
      each$i(points, function (point) {
        var graphic = point.graphic,
            args = point.shapeArgs;

        if (graphic) {
          // start values
          graphic.attr({
            // animate from inner radius (#779)
            r: point.startR || series.center[3] / 2,
            start: startAngleRad,
            end: startAngleRad
          }); // animate

          graphic.animate({
            r: args.r,
            start: args.start,
            end: args.end
          }, series.options.animation);
        }
      }); // delete this function to allow it only once

      series.animate = null;
    }
  },

  /**
   * Recompute total chart sum and update percentages of points.
   */
  updateTotals: function () {
    var i,
        total = 0,
        points = this.points,
        len = points.length,
        point,
        ignoreHiddenPoint = this.options.ignoreHiddenPoint; // Get the total sum

    for (i = 0; i < len; i++) {
      point = points[i];
      total += ignoreHiddenPoint && !point.visible ? 0 : point.isNull ? 0 : point.y;
    }

    this.total = total; // Set each point's properties

    for (i = 0; i < len; i++) {
      point = points[i];
      point.percentage = total > 0 && (point.visible || !ignoreHiddenPoint) ? point.y / total * 100 : 0;
      point.total = total;
    }
  },

  /**
   * Extend the generatePoints method by adding total and percentage
   * properties to each point
   */
  generatePoints: function () {
    Series$5.prototype.generatePoints.call(this);
    this.updateTotals();
  },

  /**
   * Do translation for pie slices
   */
  translate: function (positions) {
    this.generatePoints();
    var series = this,
        cumulative = 0,
        precision = 1000,
        // issue #172
    options = series.options,
        slicedOffset = options.slicedOffset,
        connectorOffset = slicedOffset + (options.borderWidth || 0),
        finalConnectorOffset,
        start,
        end,
        angle,
        radians = getStartAndEndRadians(options.startAngle, options.endAngle),
        startAngleRad = series.startAngleRad = radians.start,
        endAngleRad = series.endAngleRad = radians.end,
        circ = endAngleRad - startAngleRad,
        // 2 * Math.PI,
    points = series.points,
        radiusX,
        // the x component of the radius vector for a given point
    radiusY,
        labelDistance = options.dataLabels.distance,
        ignoreHiddenPoint = options.ignoreHiddenPoint,
        i,
        len = points.length,
        point; // Get positions - either an integer or a percentage string must be
    // given. If positions are passed as a parameter, we're in a recursive
    // loop for adjusting space for data labels.

    if (!positions) {
      series.center = positions = series.getCenter();
    } // Utility for getting the x value from a given y, used for
    // anticollision logic in data labels. Added point for using specific
    // points' label distance.


    series.getX = function (y, left, point) {
      angle = Math.asin(Math.min((y - positions[1]) / (positions[2] / 2 + point.labelDistance), 1));
      return positions[0] + (left ? -1 : 1) * (Math.cos(angle) * (positions[2] / 2 + point.labelDistance));
    }; // Calculate the geometry for each point


    for (i = 0; i < len; i++) {
      point = points[i]; // Used for distance calculation for specific point.

      point.labelDistance = pick$k(point.options.dataLabels && point.options.dataLabels.distance, labelDistance); // Saved for later dataLabels distance calculation.

      series.maxLabelDistance = Math.max(series.maxLabelDistance || 0, point.labelDistance); // set start and end angle

      start = startAngleRad + cumulative * circ;

      if (!ignoreHiddenPoint || point.visible) {
        cumulative += point.percentage / 100;
      }

      end = startAngleRad + cumulative * circ; // set the shape

      point.shapeType = 'arc';
      point.shapeArgs = {
        x: positions[0],
        y: positions[1],
        r: positions[2] / 2,
        innerR: positions[3] / 2,
        start: Math.round(start * precision) / precision,
        end: Math.round(end * precision) / precision
      }; // The angle must stay within -90 and 270 (#2645)

      angle = (end + start) / 2;

      if (angle > 1.5 * Math.PI) {
        angle -= 2 * Math.PI;
      } else if (angle < -Math.PI / 2) {
        angle += 2 * Math.PI;
      } // Center for the sliced out slice


      point.slicedTranslation = {
        translateX: Math.round(Math.cos(angle) * slicedOffset),
        translateY: Math.round(Math.sin(angle) * slicedOffset)
      }; // set the anchor point for tooltips

      radiusX = Math.cos(angle) * positions[2] / 2;
      radiusY = Math.sin(angle) * positions[2] / 2;
      point.tooltipPos = [positions[0] + radiusX * 0.7, positions[1] + radiusY * 0.7];
      point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;
      point.angle = angle; // Set the anchor point for data labels. Use point.labelDistance
      // instead of labelDistance // #1174
      // finalConnectorOffset - not override connectorOffset value.

      finalConnectorOffset = Math.min(connectorOffset, point.labelDistance / 5); // #1678

      point.labelPos = [// first break of connector
      positions[0] + radiusX + Math.cos(angle) * point.labelDistance, positions[1] + radiusY + Math.sin(angle) * point.labelDistance, // second break, right outside pie
      positions[0] + radiusX + Math.cos(angle) * finalConnectorOffset, positions[1] + radiusY + Math.sin(angle) * finalConnectorOffset, // a/a
      positions[0] + radiusX, // landing point for connector
      positions[1] + radiusY, // a/a
      point.labelDistance < 0 ? // alignment
      'center' : point.half ? 'right' : 'left', // alignment
      angle // center angle
      ];
    }
  },
  drawGraph: null,

  /**
   * Draw the data points
   */
  drawPoints: function () {
    var series = this,
        chart = series.chart,
        renderer = chart.renderer,
        groupTranslation,
        graphic,
        shapeArgs; // draw the slices

    each$i(series.points, function (point) {
      graphic = point.graphic;

      if (!point.isNull) {
        shapeArgs = point.shapeArgs; // If the point is sliced, use special translation, else use
        // plot area traslation

        groupTranslation = point.getTranslate(); // Draw the slice

        if (graphic) {
          graphic.setRadialReference(series.center).animate(extend$d(shapeArgs, groupTranslation));
        } else {
          point.graphic = graphic = renderer[point.shapeType](shapeArgs).setRadialReference(series.center).attr(groupTranslation).add(series.group);
        }

        graphic.attr({
          visibility: point.visible ? 'inherit' : 'hidden'
        });
        graphic.addClass(point.getClassName());
      } else if (graphic) {
        point.graphic = graphic.destroy();
      }
    });
  },
  searchPoint: noop$4,

  /**
   * Utility for sorting data labels
   */
  sortByAngle: function (points, sign) {
    points.sort(function (a, b) {
      return a.angle !== undefined && (b.angle - a.angle) * sign;
    });
  },

  /**
   * Use a simple symbol from LegendSymbolMixin
   */
  drawLegendSymbol: LegendSymbolMixin$4.drawRectangle,

  /**
   * Use the getCenter method from drawLegendSymbol
   */
  getCenter: CenteredSeriesMixin.getCenter,

  /**
   * Pies don't have point marker symbols
   */
  getSymbol: noop$4
},
/** @lends seriesTypes.pie.prototype.pointClass.prototype */
{
  /**
   * Initiate the pie slice
   */
  init: function () {
    Point$3.prototype.init.apply(this, arguments);
    var point = this,
        toggleSlice;
    point.name = pick$k(point.name, 'Slice'); // add event listener for select

    toggleSlice = function (e) {
      point.slice(e.type === 'select');
    };

    addEvent$9(point, 'select', toggleSlice);
    addEvent$9(point, 'unselect', toggleSlice);
    return point;
  },

  /**
   * Negative points are not valid (#1530, #3623, #5322)
   */
  isValid: function () {
    return Highcharts.isNumber(this.y, true) && this.y >= 0;
  },

  /**
   * Toggle the visibility of the pie slice
   * @param {Boolean} vis Whether to show the slice or not. If undefined, the
   *    visibility is toggled
   */
  setVisible: function (vis, redraw) {
    var point = this,
        series = point.series,
        chart = series.chart,
        ignoreHiddenPoint = series.options.ignoreHiddenPoint;
    redraw = pick$k(redraw, ignoreHiddenPoint);

    if (vis !== point.visible) {
      // If called without an argument, toggle visibility
      point.visible = point.options.visible = vis = vis === undefined ? !point.visible : vis; // update userOptions.data

      series.options.data[inArray$3(point, series.data)] = point.options; // Show and hide associated elements. This is performed regardless
      // of redraw or not, because chart.redraw only handles full series.

      each$i(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {
        if (point[key]) {
          point[key][vis ? 'show' : 'hide'](true);
        }
      });

      if (point.legendItem) {
        chart.legend.colorizeItem(point, vis);
      } // #4170, hide halo after hiding point


      if (!vis && point.state === 'hover') {
        point.setState('');
      } // Handle ignore hidden slices


      if (ignoreHiddenPoint) {
        series.isDirty = true;
      }

      if (redraw) {
        chart.redraw();
      }
    }
  },

  /**
   * Set or toggle whether the slice is cut out from the pie
   * @param {Boolean} sliced When undefined, the slice state is toggled
   * @param {Boolean} redraw Whether to redraw the chart. True by default.
   */
  slice: function (sliced, redraw, animation) {
    var point = this,
        series = point.series,
        chart = series.chart;
    setAnimation$2(animation, chart); // redraw is true by default

    redraw = pick$k(redraw, true); // if called without an argument, toggle

    point.sliced = point.options.sliced = sliced = defined$c(sliced) ? sliced : !point.sliced; // update userOptions.data

    series.options.data[inArray$3(point, series.data)] = point.options;
    point.graphic.animate(this.getTranslate());
  },
  getTranslate: function () {
    return this.sliced ? this.slicedTranslation : {
      translateX: 0,
      translateY: 0
    };
  },
  haloPath: function (size) {
    var shapeArgs = this.shapeArgs;
    return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(shapeArgs.x, shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
      // Substract 1px to ensure the background is not bleeding
      // through between the halo and the slice (#7495).
      innerR: this.shapeArgs.r - 1,
      start: shapeArgs.start,
      end: shapeArgs.end
    });
  }
});
/**
 * A `pie` series. If the [type](#series.pie.type) option is not specified,
 * it is inherited from [chart.type](#chart.type).
 *
 * @type {Object}
 * @extends series,plotOptions.pie
 * @excluding dataParser,dataURL,stack,xAxis,yAxis
 * @product highcharts
 * @apioption series.pie
 */

/**
 * An array of data points for the series. For the `pie` series type,
 * points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.pie.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *     y: 1,
 *     name: "Point2",
 *     color: "#00FF00"
 * }, {
 *     y: 7,
 *     name: "Point1",
 *     color: "#FF00FF"
 * }]</pre>
 *
 * @type {Array<Object|Number>}
 * @extends series.line.data
 * @excluding marker,x
 * @sample {highcharts} highcharts/chart/reflow-true/
 *         Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/
 *         Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *         Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/
 *         Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/
 *         Config objects
 * @product highcharts
 * @apioption series.pie.data
 */

/**
 * The sequential index of the data point in the legend.
 *
 * @type {Number}
 * @product highcharts
 * @apioption series.pie.data.legendIndex
 */

/**
 * Whether to display a slice offset from the center.
 *
 * @type {Boolean}
 * @sample {highcharts} highcharts/point/sliced/ One sliced point
 * @product highcharts
 * @apioption series.pie.data.sliced
 */

/**
 * Fires when the checkbox next to the point name in the legend is clicked.
 * One parameter, event, is passed to the function. The state of the
 * checkbox is found by event.checked. The checked item is found by
 * event.item. Return false to prevent the default action which is to
 * toggle the select state of the series.
 *
 * @type {Function}
 * @context Point
 * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
 *         Alert checkbox status
 * @since 1.2.0
 * @product highcharts
 * @apioption plotOptions.pie.events.checkboxClick
 */

/**
 * Not applicable to pies, as the legend item is per point. See point.
 * events.
 *
 * @type {Function}
 * @since 1.2.0
 * @product highcharts
 * @apioption plotOptions.pie.events.legendItemClick
 */

/**
 * Fires when the legend item belonging to the pie point (slice) is
 * clicked. The `this` keyword refers to the point itself. One parameter,
 * `event`, is passed to the function, containing common event information. The
 * default action is to toggle the visibility of the point. This can be
 * prevented by calling `event.preventDefault()`.
 *
 * @type {Function}
 * @sample {highcharts} highcharts/plotoptions/pie-point-events-legenditemclick/
 *         Confirm toggle visibility
 * @since 1.2.0
 * @product highcharts
 * @apioption plotOptions.pie.point.events.legendItemClick
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$a = Highcharts.addEvent,
    arrayMax$3 = Highcharts.arrayMax,
    defined$d = Highcharts.defined,
    each$j = Highcharts.each,
    extend$e = Highcharts.extend,
    format$4 = Highcharts.format,
    map$5 = Highcharts.map,
    merge$d = Highcharts.merge,
    noop$5 = Highcharts.noop,
    pick$l = Highcharts.pick,
    relativeLength$1 = Highcharts.relativeLength,
    Series$6 = Highcharts.Series,
    seriesTypes$3 = Highcharts.seriesTypes,
    some = Highcharts.some,
    stableSort$1 = Highcharts.stableSort;
/**
 * General distribution algorithm for distributing labels of differing size
 * along a confined length in two dimensions. The algorithm takes an array of
 * objects containing a size, a target and a rank. It will place the labels as
 * close as possible to their targets, skipping the lowest ranked labels if
 * necessary.
 *
 * @function Highcharts.distribute
 *
 * @param  {Array<Highcharts.DataLabelBoxObject>} boxes
 *
 * @param  {number} len
 *
 * @param  {number} maxDistance
 *
 * @return {void}
 */

Highcharts.distribute = function (boxes, len, maxDistance) {
  var i,
      overlapping = true,
      origBoxes = boxes,
      // Original array will be altered with added .pos
  restBoxes = [],
      // The outranked overshoot
  box,
      target,
      total = 0,
      reducedLen = origBoxes.reducedLen || len;

  function sortByTarget(a, b) {
    return a.target - b.target;
  } // If the total size exceeds the len, remove those boxes with the lowest
  // rank


  i = boxes.length;

  while (i--) {
    total += boxes[i].size;
  } // Sort by rank, then slice away overshoot


  if (total > reducedLen) {
    stableSort$1(boxes, function (a, b) {
      return (b.rank || 0) - (a.rank || 0);
    });
    i = 0;
    total = 0;

    while (total <= reducedLen) {
      total += boxes[i].size;
      i++;
    }

    restBoxes = boxes.splice(i - 1, boxes.length);
  } // Order by target


  stableSort$1(boxes, sortByTarget); // So far we have been mutating the original array. Now
  // create a copy with target arrays

  boxes = map$5(boxes, function (box) {
    return {
      size: box.size,
      targets: [box.target],
      align: pick$l(box.align, 0.5)
    };
  });

  while (overlapping) {
    // Initial positions: target centered in box
    i = boxes.length;

    while (i--) {
      box = boxes[i]; // Composite box, average of targets

      target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;
      box.pos = Math.min(Math.max(0, target - box.size * box.align), len - box.size);
    } // Detect overlap and join boxes


    i = boxes.length;
    overlapping = false;

    while (i--) {
      // Overlap
      if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) {
        // Add this size to the previous box
        boxes[i - 1].size += boxes[i].size;
        boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);
        boxes[i - 1].align = 0.5; // Overlapping right, push left

        if (boxes[i - 1].pos + boxes[i - 1].size > len) {
          boxes[i - 1].pos = len - boxes[i - 1].size;
        }

        boxes.splice(i, 1); // Remove this item

        overlapping = true;
      }
    }
  } // Add the rest (hidden boxes)


  origBoxes.push.apply(origBoxes, restBoxes); // Now the composite boxes are placed, we need to put the original boxes
  // within them

  i = 0;
  some(boxes, function (box) {
    var posInCompositeBox = 0;

    if (some(box.targets, function () {
      origBoxes[i].pos = box.pos + posInCompositeBox; // If the distance between the position and the target exceeds
      // maxDistance, abort the loop and decrease the length in increments
      // of 10% to recursively reduce the  number of visible boxes by
      // rank. Once all boxes are within the maxDistance, we're good.

      if (Math.abs(origBoxes[i].pos - origBoxes[i].target) > maxDistance) {
        // Reset the positions that are already set
        each$j(origBoxes.slice(0, i + 1), function (box) {
          delete box.pos;
        }); // Try with a smaller length

        origBoxes.reducedLen = (origBoxes.reducedLen || len) - len * 0.1; // Recurse

        if (origBoxes.reducedLen > len * 0.1) {
          Highcharts.distribute(origBoxes, len, maxDistance);
        } // Exceeded maxDistance => abort


        return true;
      }

      posInCompositeBox += origBoxes[i].size;
      i++;
    })) {
      // Exceeded maxDistance => abort
      return true;
    }
  }); // Add the rest (hidden) boxes and sort by target

  stableSort$1(origBoxes, sortByTarget);
};
/**
 * Draw the data labels
 *
 * @function Highcharts.Series#drawDataLabels
 *
 * @return {void}
 *
 * @todo
 * Make events official: Fires the event `afterDrawDataLabels`.
 */


Series$6.prototype.drawDataLabels = function () {
  var series = this,
      chart = series.chart,
      seriesOptions = series.options,
      options = seriesOptions.dataLabels,
      points = series.points,
      pointOptions,
      generalOptions,
      hasRendered = series.hasRendered || 0,
      str,
      dataLabelsGroup,
      defer = pick$l(options.defer, !!seriesOptions.animation),
      renderer = chart.renderer;
  /*
   * Handle the dataLabels.filter option.
   */

  function applyFilter(point, options) {
    var filter = options.filter,
        op,
        prop,
        val;

    if (filter) {
      op = filter.operator;
      prop = point[filter.property];
      val = filter.value;

      if (op === '>' && prop > val || op === '<' && prop < val || op === '>=' && prop >= val || op === '<=' && prop <= val || op === '==' && prop == val || // eslint-disable-line eqeqeq
      op === '===' && prop === val) {
        return true;
      }

      return false;
    }

    return true;
  }

  if (options.enabled || series._hasPointLabels) {
    // Process default alignment of data labels for columns
    if (series.dlProcessOptions) {
      series.dlProcessOptions(options);
    } // Create a separate group for the data labels to avoid rotation


    dataLabelsGroup = series.plotGroup('dataLabelsGroup', 'data-labels', defer && !hasRendered ? 'hidden' : 'visible', // #5133
    options.zIndex || 6);

    if (defer) {
      dataLabelsGroup.attr({
        opacity: +hasRendered
      }); // #3300

      if (!hasRendered) {
        addEvent$a(series, 'afterAnimate', function () {
          if (series.visible) {
            // #2597, #3023, #3024
            dataLabelsGroup.show(true);
          }

          dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({
            opacity: 1
          }, {
            duration: 200
          });
        });
      }
    } // Make the labels for each point


    generalOptions = options;
    each$j(points, function (point) {
      var enabled,
          dataLabel = point.dataLabel,
          labelConfig,
          attr,
          rotation,
          connector = point.connector,
          isNew = !dataLabel,
          style,
          formatString; // Determine if each data label is enabled
      // @note dataLabelAttribs (like pointAttribs) would eradicate
      // the need for dlOptions, and simplify the section below.

      pointOptions = point.dlOptions || // dlOptions is used in treemaps
      point.options && point.options.dataLabels;
      enabled = pick$l(pointOptions && pointOptions.enabled, generalOptions.enabled) && !point.isNull; // #2282, #4641, #7112

      if (enabled) {
        enabled = applyFilter(point, pointOptions || options) === true;
      }

      if (enabled) {
        // Create individual options structure that can be extended
        // without affecting others
        options = merge$d(generalOptions, pointOptions);
        labelConfig = point.getLabelConfig();
        formatString = options[point.formatPrefix + 'Format'] || options.format;
        str = defined$d(formatString) ? format$4(formatString, labelConfig, chart.time) : (options[point.formatPrefix + 'Formatter'] || options.formatter).call(labelConfig, options);
        style = options.style;
        rotation = options.rotation;
        attr = {
          r: options.borderRadius || 0,
          rotation: rotation,
          padding: options.padding,
          zIndex: 1
        }; // Remove unused attributes (#947)

        Highcharts.objectEach(attr, function (val, name) {
          if (val === undefined) {
            delete attr[name];
          }
        });
      } // If the point is outside the plot area, destroy it. #678, #820


      if (dataLabel && (!enabled || !defined$d(str))) {
        point.dataLabel = dataLabel = dataLabel.destroy();

        if (connector) {
          point.connector = connector.destroy();
        } // Individual labels are disabled if the are explicitly disabled
        // in the point options, or if they fall outside the plot area.

      } else if (enabled && defined$d(str)) {
        // create new label
        if (!dataLabel) {
          dataLabel = point.dataLabel = rotation ? renderer.text( // labels don't rotate
          str, 0, -9999, options.useHTML).addClass('highcharts-data-label') : renderer.label(str, 0, -9999, options.shape, null, null, options.useHTML, null, 'data-label');
          dataLabel.addClass(' highcharts-data-label-color-' + point.colorIndex + ' ' + (options.className || '') + (options.useHTML ? ' highcharts-tracker' : '') // #3398
          );
        } else {
          attr.text = str;
        }

        dataLabel.attr(attr);

        if (!dataLabel.added) {
          dataLabel.add(dataLabelsGroup);
        } // Now the data label is created and placed at 0,0, so we need
        // to align it


        series.alignDataLabel(point, dataLabel, options, null, isNew);
      }
    });
  }

  Highcharts.fireEvent(this, 'afterDrawDataLabels');
};
/**
 * Align each individual data label.
 *
 * @function Highcharts.Series#alignDataLabel
 *
 * @param  {Highcharts.Point} point
 *
 * @param  {Highcharts.SVGElement} dataLabel
 *
 * @param  {Highcharts.PlotSeriesDataLabelsOptions} options
 *
 * @param  {Highcharts.BBoxObject} alignTo
 *
 * @param  {boolean} isNew
 *
 * @return {void}
 */


Series$6.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {
  var chart = this.chart,
      inverted = chart.inverted,
      plotX = pick$l(point.dlBox && point.dlBox.centerX, point.plotX, -9999),
      plotY = pick$l(point.plotY, -9999),
      bBox = dataLabel.getBBox(),
      fontSize,
      baseline,
      rotation = options.rotation,
      normRotation,
      negRotation,
      align = options.align,
      rotCorr,
      // rotation correction
  // Math.round for rounding errors (#2683), alignTo to allow column
  // labels (#2700)
  visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, Math.round(plotY), inverted) || alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted)),
      alignAttr,
      // the final position;
  justify = pick$l(options.overflow, 'justify') === 'justify';

  if (visible) {
    baseline = chart.renderer.fontMetrics(fontSize, dataLabel).b; // The alignment box is a singular point

    alignTo = extend$e({
      x: inverted ? this.yAxis.len - plotY : plotX,
      y: Math.round(inverted ? this.xAxis.len - plotX : plotY),
      width: 0,
      height: 0
    }, alignTo); // Add the text size for alignment calculation

    extend$e(options, {
      width: bBox.width,
      height: bBox.height
    }); // Allow a hook for changing alignment in the last moment, then do the
    // alignment

    if (rotation) {
      justify = false; // Not supported for rotated text

      rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723

      alignAttr = {
        x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
        y: alignTo.y + options.y + {
          top: 0,
          middle: 0.5,
          bottom: 1
        }[options.verticalAlign] * alignTo.height
      };
      dataLabel[isNew ? 'attr' : 'animate'](alignAttr).attr({
        // #3003
        align: align
      }); // Compensate for the rotated label sticking out on the sides

      normRotation = (rotation + 720) % 360;
      negRotation = normRotation > 180 && normRotation < 360;

      if (align === 'left') {
        alignAttr.y -= negRotation ? bBox.height : 0;
      } else if (align === 'center') {
        alignAttr.x -= bBox.width / 2;
        alignAttr.y -= bBox.height / 2;
      } else if (align === 'right') {
        alignAttr.x -= bBox.width;
        alignAttr.y -= negRotation ? 0 : bBox.height;
      }

      dataLabel.placed = true;
      dataLabel.alignAttr = alignAttr;
    } else {
      dataLabel.align(options, null, alignTo);
      alignAttr = dataLabel.alignAttr;
    } // Handle justify or crop


    if (justify && alignTo.height >= 0) {
      // #8830
      point.isLabelJustified = this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew); // Now check that the data label is within the plot area
    } else if (pick$l(options.crop, true)) {
      visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);
    } // When we're using a shape, make it possible with a connector or an
    // arrow pointing to thie point


    if (options.shape && !rotation) {
      dataLabel[isNew ? 'attr' : 'animate']({
        anchorX: inverted ? chart.plotWidth - point.plotY : point.plotX,
        anchorY: inverted ? chart.plotHeight - point.plotX : point.plotY
      });
    }
  } // Show or hide based on the final aligned position


  if (!visible) {
    dataLabel.attr({
      y: -9999
    });
    dataLabel.placed = false; // don't animate back in
  }
};
/**
 * If data labels fall partly outside the plot area, align them back in, in a
 * way that doesn't hide the point.
 *
 * @function Highcharts.Series#justifyDataLabel
 *
 * @param  {Highcharts.SVGElement} dataLabel
 *
 * @param  {Highcharts.PlotSeriesDataLabelsOptions} options
 *
 * @param  {Highcharts.DataLabelAlignObject} alignAttr
 *
 * @param  {Highcharts.BBoxObject} bBox
 *
 * @param  {boolean} isNew
 *
 * @return {boolean}
 */


Series$6.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {
  var chart = this.chart,
      align = options.align,
      verticalAlign = options.verticalAlign,
      off,
      justified,
      padding = dataLabel.box ? 0 : dataLabel.padding || 0; // Off left

  off = alignAttr.x + padding;

  if (off < 0) {
    if (align === 'right') {
      options.align = 'left';
    } else {
      options.x = -off;
    }

    justified = true;
  } // Off right


  off = alignAttr.x + bBox.width - padding;

  if (off > chart.plotWidth) {
    if (align === 'left') {
      options.align = 'right';
    } else {
      options.x = chart.plotWidth - off;
    }

    justified = true;
  } // Off top


  off = alignAttr.y + padding;

  if (off < 0) {
    if (verticalAlign === 'bottom') {
      options.verticalAlign = 'top';
    } else {
      options.y = -off;
    }

    justified = true;
  } // Off bottom


  off = alignAttr.y + bBox.height - padding;

  if (off > chart.plotHeight) {
    if (verticalAlign === 'top') {
      options.verticalAlign = 'bottom';
    } else {
      options.y = chart.plotHeight - off;
    }

    justified = true;
  }

  if (justified) {
    dataLabel.placed = !isNew;
    dataLabel.align(options, null, alignTo);
  }

  return justified;
};

if (seriesTypes$3.pie) {
  /**
   * Override the base drawDataLabels method by pie specific functionality
   *
   * @function Highcharts.seriesTypes.pie#drawDataLabels
   *
   * @return {void}
   */
  seriesTypes$3.pie.prototype.drawDataLabels = function () {
    var series = this,
        data = series.data,
        point,
        chart = series.chart,
        options = series.options.dataLabels,
        connectorPadding = pick$l(options.connectorPadding, 10),
        connectorWidth = pick$l(options.connectorWidth, 1),
        plotWidth = chart.plotWidth,
        plotHeight = chart.plotHeight,
        maxWidth = Math.round(chart.chartWidth / 3),
        connector,
        seriesCenter = series.center,
        radius = seriesCenter[2] / 2,
        centerY = seriesCenter[1],
        dataLabel,
        dataLabelWidth,
        labelPos,
        labelHeight,
        // divide the points into right and left halves for anti collision
    halves = [[], // right
    [] // left
    ],
        x,
        y,
        visibility,
        j,
        overflow = [0, 0, 0, 0]; // top, right, bottom, left
    // get out if not enabled

    if (!series.visible || !options.enabled && !series._hasPointLabels) {
      return;
    } // Reset all labels that have been shortened


    each$j(data, function (point) {
      if (point.dataLabel && point.visible && point.dataLabel.shortened) {
        point.dataLabel.attr({
          width: 'auto'
        }).css({
          width: 'auto',
          textOverflow: 'clip'
        });
        point.dataLabel.shortened = false;
      }
    }); // run parent method

    Series$6.prototype.drawDataLabels.apply(series);
    each$j(data, function (point) {
      if (point.dataLabel) {
        if (point.visible) {
          // #407, #2510
          // Arrange points for detection collision
          halves[point.half].push(point); // Reset positions (#4905)

          point.dataLabel._pos = null; // Avoid long labels squeezing the pie size too far down

          if (point.dataLabel.getBBox().width > maxWidth) {
            point.dataLabel.css({
              // Use a fraction of the maxWidth to avoid
              // wrapping close to the end of the string.
              width: maxWidth * 0.7
            });
            point.dataLabel.shortened = true;
          }
        } else {
          point.dataLabel = point.dataLabel.destroy();
        }
      }
    });
    /* Loop over the points in each half, starting from the top and bottom
     * of the pie to detect overlapping labels.
     */

    each$j(halves, function (points, i) {
      var top,
          bottom,
          length = points.length,
          positions = [],
          naturalY,
          sideOverflow,
          size,
          distributionLength;

      if (!length) {
        return;
      } // Sort by angle


      series.sortByAngle(points, i - 0.5); // Only do anti-collision when we have dataLabels outside the pie
      // and have connectors. (#856)

      if (series.maxLabelDistance > 0) {
        top = Math.max(0, centerY - radius - series.maxLabelDistance);
        bottom = Math.min(centerY + radius + series.maxLabelDistance, chart.plotHeight);
        each$j(points, function (point) {
          // check if specific points' label is outside the pie
          if (point.labelDistance > 0 && point.dataLabel) {
            // point.top depends on point.labelDistance value
            // Used for calculation of y value in getX method
            point.top = Math.max(0, centerY - radius - point.labelDistance);
            point.bottom = Math.min(centerY + radius + point.labelDistance, chart.plotHeight);
            size = point.dataLabel.getBBox().height || 21; // point.positionsIndex is needed for getting index of
            // parameter related to specific point inside positions
            // array - not every point is in positions array.

            point.distributeBox = {
              target: point.labelPos[1] - point.top + size / 2,
              size: size,
              rank: point.y
            };
            positions.push(point.distributeBox);
          }
        });
        distributionLength = bottom + size - top;
        Highcharts.distribute(positions, distributionLength, distributionLength / 5);
      } // Now the used slots are sorted, fill them up sequentially


      for (j = 0; j < length; j++) {
        point = points[j];
        labelPos = point.labelPos;
        dataLabel = point.dataLabel;
        visibility = point.visible === false ? 'hidden' : 'inherit';
        naturalY = labelPos[1];
        y = naturalY;

        if (positions && defined$d(point.distributeBox)) {
          if (point.distributeBox.pos === undefined) {
            visibility = 'hidden';
          } else {
            labelHeight = point.distributeBox.size;
            y = point.top + point.distributeBox.pos;
          }
        } // It is needed to delete point.positionIndex for
        // dynamically added points etc.


        delete point.positionIndex; // get the x - use the natural x position for labels near the
        // top and bottom, to prevent the top and botton slice
        // connectors from touching each other on either side

        if (options.justify) {
          x = seriesCenter[0] + (i ? -1 : 1) * (radius + point.labelDistance);
        } else {
          x = series.getX(y < point.top + 2 || y > point.bottom - 2 ? naturalY : y, i, point);
        } // Record the placement and visibility


        dataLabel._attr = {
          visibility: visibility,
          align: labelPos[6]
        };
        dataLabel._pos = {
          x: x + options.x + ({
            left: connectorPadding,
            right: -connectorPadding
          }[labelPos[6]] || 0),
          // 10 is for the baseline (label vs text)
          y: y + options.y - 10
        };
        labelPos.x = x;
        labelPos.y = y; // Detect overflowing data labels

        if (pick$l(options.crop, true)) {
          dataLabelWidth = dataLabel.getBBox().width;
          sideOverflow = null; // Overflow left

          if (x - dataLabelWidth < connectorPadding && i === 1 // left half
          ) {
              sideOverflow = Math.round(dataLabelWidth - x + connectorPadding);
              overflow[3] = Math.max(sideOverflow, overflow[3]); // Overflow right
            } else if (x + dataLabelWidth > plotWidth - connectorPadding && i === 0 // right half
          ) {
              sideOverflow = Math.round(x + dataLabelWidth - plotWidth + connectorPadding);
              overflow[1] = Math.max(sideOverflow, overflow[1]);
            } // Overflow top


          if (y - labelHeight / 2 < 0) {
            overflow[0] = Math.max(Math.round(-y + labelHeight / 2), overflow[0]); // Overflow left
          } else if (y + labelHeight / 2 > plotHeight) {
            overflow[2] = Math.max(Math.round(y + labelHeight / 2 - plotHeight), overflow[2]);
          }

          dataLabel.sideOverflow = sideOverflow;
        }
      } // for each point

    }); // for each half
    // Do not apply the final placement and draw the connectors until we
    // have verified that labels are not spilling over.

    if (arrayMax$3(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {
      // Place the labels in the final position
      this.placeDataLabels(); // Draw the connectors

      if (connectorWidth) {
        each$j(this.points, function (point) {
          var isNew;
          connector = point.connector;
          dataLabel = point.dataLabel;

          if (dataLabel && dataLabel._pos && point.visible && point.labelDistance > 0) {
            visibility = dataLabel._attr.visibility;
            isNew = !connector;

            if (isNew) {
              point.connector = connector = chart.renderer.path().addClass('highcharts-data-label-connector ' + ' highcharts-color-' + point.colorIndex + (point.className ? ' ' + point.className : '')).add(series.dataLabelsGroup);
            }

            connector[isNew ? 'attr' : 'animate']({
              d: series.connectorPath(point.labelPos)
            });
            connector.attr('visibility', visibility);
          } else if (connector) {
            point.connector = connector.destroy();
          }
        });
      }
    }
  };
  /**
   * Extendable method for getting the path of the connector between the data
   * label and the pie slice.
   *
   * @function Highcharts.seriesTypes.pie#connectorPath
   *
   * @param  {Highcharts.DataLabelPiePosObject} labelPos
   *
   * @return {Highcharts.PathObject}
   */


  seriesTypes$3.pie.prototype.connectorPath = function (labelPos) {
    var x = labelPos.x,
        y = labelPos.y;
    return pick$l(this.options.dataLabels.softConnector, true) ? ['M', // end of the string at the label
    x + (labelPos[6] === 'left' ? 5 : -5), y, 'C', x, y, // first break, next to the label
    2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5], labelPos[2], labelPos[3], // second break
    'L', labelPos[4], labelPos[5] // base
    ] : ['M', // end of the string at the label
    x + (labelPos[6] === 'left' ? 5 : -5), y, 'L', labelPos[2], labelPos[3], // second break
    'L', labelPos[4], labelPos[5] // base
    ];
  };
  /**
   * Perform the final placement of the data labels after we have verified
   * that they fall within the plot area.
   *
   * @function Highcharts.seriesTypes.pie#placeDataLabels
   *
   * @return {void}
   */


  seriesTypes$3.pie.prototype.placeDataLabels = function () {
    each$j(this.points, function (point) {
      var dataLabel = point.dataLabel,
          _pos;

      if (dataLabel && point.visible) {
        _pos = dataLabel._pos;

        if (_pos) {
          // Shorten data labels with ellipsis if they still overflow
          // after the pie has reached minSize (#223).
          if (dataLabel.sideOverflow) {
            dataLabel._attr.width = dataLabel.getBBox().width - dataLabel.sideOverflow;
            dataLabel.css({
              width: dataLabel._attr.width + 'px',
              textOverflow: (this.options.dataLabels.style || {}).textOverflow || 'ellipsis'
            });
            dataLabel.shortened = true;
          }

          dataLabel.attr(dataLabel._attr);
          dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
          dataLabel.moved = true;
        } else if (dataLabel) {
          dataLabel.attr({
            y: -9999
          });
        }
      }
    }, this);
  };

  seriesTypes$3.pie.prototype.alignDataLabel = noop$5;
  /**
   * Verify whether the data labels are allowed to draw, or we should run more
   * translation and data label positioning to keep them inside the plot area.
   * Returns true when data labels are ready to draw.
   *
   * @function Highcharts.seriesTypes.pie#verifyDataLabelOverflow
   *
   * @param  {boolean} overflow
   *
   * @return {boolean}
   */

  seriesTypes$3.pie.prototype.verifyDataLabelOverflow = function (overflow) {
    var center = this.center,
        options = this.options,
        centerOption = options.center,
        minSize = options.minSize || 80,
        newSize = minSize,
        // If a size is set, return true and don't try to shrink the pie
    // to fit the labels.
    ret = options.size !== null;

    if (!ret) {
      // Handle horizontal size and center
      if (centerOption[0] !== null) {
        // Fixed center
        newSize = Math.max(center[2] - Math.max(overflow[1], overflow[3]), minSize);
      } else {
        // Auto center
        newSize = Math.max( // horizontal overflow
        center[2] - overflow[1] - overflow[3], minSize); // horizontal center

        center[0] += (overflow[3] - overflow[1]) / 2;
      } // Handle vertical size and center


      if (centerOption[1] !== null) {
        // Fixed center
        newSize = Math.max(Math.min(newSize, center[2] - Math.max(overflow[0], overflow[2])), minSize);
      } else {
        // Auto center
        newSize = Math.max(Math.min(newSize, // vertical overflow
        center[2] - overflow[0] - overflow[2]), minSize); // vertical center

        center[1] += (overflow[0] - overflow[2]) / 2;
      } // If the size must be decreased, we need to run translate and
      // drawDataLabels again


      if (newSize < center[2]) {
        center[2] = newSize;
        center[3] = Math.min( // #3632
        relativeLength$1(options.innerSize || 0, newSize), newSize);
        this.translate(center);

        if (this.drawDataLabels) {
          this.drawDataLabels();
        } // Else, return true to indicate that the pie and its labels is
        // within the plot area

      } else {
        ret = true;
      }
    }

    return ret;
  };
}

if (seriesTypes$3.column) {
  /**
   * Override the basic data label alignment by adjusting for the position of
   * the column.
   *
   * @function Highcharts.seriesTypes.column#alignDataLabel
   *
   * @param  {Highcharts.Point} point
   *
   * @param  {Highcharts.SVGElement} dataLabel
   *
   * @param  {Highcharts.PlotSeriesDataLabelsOptions} options
   *
   * @param  {Highcharts.BBoxObject} alignTo
   *
   * @param  {boolean} isNew
   *
   * @return {void}
   */
  seriesTypes$3.column.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {
    var inverted = this.chart.inverted,
        series = point.series,
        // data label box for alignment
    dlBox = point.dlBox || point.shapeArgs,
        below = pick$l(point.below, // range series
    point.plotY > pick$l(this.translatedThreshold, series.yAxis.len)),
        // draw it inside the box?
    inside = pick$l(options.inside, !!this.options.stacking),
        overshoot; // Align to the column itself, or the top of it

    if (dlBox) {
      // Area range uses this method but not alignTo
      alignTo = merge$d(dlBox);

      if (alignTo.y < 0) {
        alignTo.height += alignTo.y;
        alignTo.y = 0;
      }

      overshoot = alignTo.y + alignTo.height - series.yAxis.len;

      if (overshoot > 0) {
        alignTo.height -= overshoot;
      }

      if (inverted) {
        alignTo = {
          x: series.yAxis.len - alignTo.y - alignTo.height,
          y: series.xAxis.len - alignTo.x - alignTo.width,
          width: alignTo.height,
          height: alignTo.width
        };
      } // Compute the alignment box


      if (!inside) {
        if (inverted) {
          alignTo.x += below ? 0 : alignTo.width;
          alignTo.width = 0;
        } else {
          alignTo.y += below ? alignTo.height : 0;
          alignTo.height = 0;
        }
      }
    } // When alignment is undefined (typically columns and bars), display the
    // individual point below or above the point depending on the threshold


    options.align = pick$l(options.align, !inverted || inside ? 'center' : below ? 'right' : 'left');
    options.verticalAlign = pick$l(options.verticalAlign, inverted || inside ? 'middle' : below ? 'top' : 'bottom'); // Call the parent method

    Series$6.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew); // If label was justified and we have contrast, set it:

    if (point.isLabelJustified && point.contrastColor) {
      point.dataLabel.css({
        color: point.contrastColor
      });
    }
  };
}

/**
 * (c) 2009-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * Highcharts module to hide overlapping data labels. This module is included in
 * Highcharts.
 *
 * @ignore
 */

var Chart$4 = Highcharts.Chart,
    each$k = Highcharts.each,
    objectEach$6 = Highcharts.objectEach,
    pick$m = Highcharts.pick,
    addEvent$b = Highcharts.addEvent; // Collect potensial overlapping data labels. Stack labels probably don't need
// to be considered because they are usually accompanied by data labels that lie
// inside the columns.

addEvent$b(Chart$4, 'render', function collectAndHide() {
  var labels = []; // Consider external label collectors

  each$k(this.labelCollectors || [], function (collector) {
    labels = labels.concat(collector());
  });
  each$k(this.yAxis || [], function (yAxis) {
    if (yAxis.options.stackLabels && !yAxis.options.stackLabels.allowOverlap) {
      objectEach$6(yAxis.stacks, function (stack) {
        objectEach$6(stack, function (stackItem) {
          labels.push(stackItem.label);
        });
      });
    }
  });
  each$k(this.series || [], function (series) {
    var dlOptions = series.options.dataLabels,
        // Range series have two collections
    collections = series.dataLabelCollections || ['dataLabel'];

    if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) {
      // #3866
      each$k(collections, function (coll) {
        each$k(series.points, function (point) {
          if (point[coll] && point.visible) {
            // #7815
            point[coll].labelrank = pick$m(point.labelrank, point.shapeArgs && point.shapeArgs.height); // #4118

            labels.push(point[coll]);
          }
        });
      });
    }
  });
  this.hideOverlappingLabels(labels);
});
/**
 * Hide overlapping labels. Labels are moved and faded in and out on zoom to
 * provide a smooth visual imression.
 */

Chart$4.prototype.hideOverlappingLabels = function (labels) {
  var len = labels.length,
      ren = this.renderer,
      label,
      i,
      j,
      label1,
      label2,
      isIntersecting,
      box1,
      box2,
      intersectRect = function (x1, y1, w1, h1, x2, y2, w2, h2) {
    return !(x2 > x1 + w1 || x2 + w2 < x1 || y2 > y1 + h1 || y2 + h2 < y1);
  },

  /**
   * Get the box with its position inside the chart, as opposed to getBBox
   * that only reports the position relative to the parent.
   */
  getAbsoluteBox = function (label) {
    var pos,
        parent,
        bBox,
        // Substract the padding if no background or border (#4333)
    padding = 2 * (label.box ? 0 : label.padding || 0),
        lineHeightCorrection = 0;

    if (label && (!label.alignAttr || label.placed)) {
      pos = label.alignAttr || {
        x: label.attr('x'),
        y: label.attr('y')
      };
      parent = label.parentGroup; // Get width and height if pure text nodes (stack labels)

      if (!label.width) {
        bBox = label.getBBox();
        label.width = bBox.width;
        label.height = bBox.height; // Labels positions are computed from top left corner, so
        // we need to substract the text height from text nodes too.

        lineHeightCorrection = ren.fontMetrics(null, label.element).h;
      }

      return {
        x: pos.x + (parent.translateX || 0),
        y: pos.y + (parent.translateY || 0) - lineHeightCorrection,
        width: label.width - padding,
        height: label.height - padding
      };
    }
  };

  for (i = 0; i < len; i++) {
    label = labels[i];

    if (label) {
      // Mark with initial opacity
      label.oldOpacity = label.opacity;
      label.newOpacity = 1;
      label.absoluteBox = getAbsoluteBox(label);
    }
  } // Prevent a situation in a gradually rising slope, that each label will
  // hide the previous one because the previous one always has lower rank.


  labels.sort(function (a, b) {
    return (b.labelrank || 0) - (a.labelrank || 0);
  }); // Detect overlapping labels

  for (i = 0; i < len; i++) {
    label1 = labels[i];
    box1 = label1 && label1.absoluteBox;

    for (j = i + 1; j < len; ++j) {
      label2 = labels[j];
      box2 = label2 && label2.absoluteBox;

      if (box1 && box2 && label1 !== label2 && // #6465, polar chart with connectEnds
      label1.newOpacity !== 0 && label2.newOpacity !== 0) {
        isIntersecting = intersectRect(box1.x, box1.y, box1.width, box1.height, box2.x, box2.y, box2.width, box2.height);

        if (isIntersecting) {
          (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
        }
      }
    }
  } // Hide or show


  each$k(labels, function (label) {
    var complete, newOpacity;

    if (label) {
      newOpacity = label.newOpacity;

      if (label.oldOpacity !== newOpacity) {
        // Make sure the label is completely hidden to avoid catching
        // clicks (#4362)
        if (label.alignAttr && label.placed) {
          // data labels
          if (newOpacity) {
            label.show(true);
          } else {
            complete = function () {
              label.hide();
            };
          } // Animate or set the opacity


          label.alignAttr.opacity = newOpacity;
          label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);
        } else {
          // other labels, tick labels
          label.attr({
            opacity: newOpacity
          });
        }
      }

      label.isOld = true;
    }
  });
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$c = Highcharts.addEvent,
    Chart$5 = Highcharts.Chart,
    createElement$4 = Highcharts.createElement,
    css$7 = Highcharts.css,
    defaultOptions$3 = Highcharts.defaultOptions,
    defaultPlotOptions$2 = Highcharts.defaultPlotOptions,
    each$l = Highcharts.each,
    extend$f = Highcharts.extend,
    fireEvent$8 = Highcharts.fireEvent,
    hasTouch$2 = Highcharts.hasTouch,
    inArray$4 = Highcharts.inArray,
    isObject$5 = Highcharts.isObject,
    Legend$1 = Highcharts.Legend,
    merge$e = Highcharts.merge,
    pick$n = Highcharts.pick,
    Point$4 = Highcharts.Point,
    Series$7 = Highcharts.Series,
    seriesTypes$4 = Highcharts.seriesTypes,
    svg$4 = Highcharts.svg,
    TrackerMixin;
/**
 * TrackerMixin for points and graphs.
 *
 * @ignore
 */

TrackerMixin = Highcharts.TrackerMixin = {
  /**
   * Draw the tracker for a point.
   */
  drawTrackerPoint: function () {
    var series = this,
        chart = series.chart,
        pointer = chart.pointer,
        onMouseOver = function (e) {
      var point = pointer.getPointFromEvent(e); // undefined on graph in scatterchart

      if (point !== undefined) {
        pointer.isDirectTouch = true;
        point.onMouseOver(e);
      }
    }; // Add reference to the point


    each$l(series.points, function (point) {
      if (point.graphic) {
        point.graphic.element.point = point;
      }

      if (point.dataLabel) {
        if (point.dataLabel.div) {
          point.dataLabel.div.point = point;
        } else {
          point.dataLabel.element.point = point;
        }
      }
    }); // Add the event listeners, we need to do this only once

    if (!series._hasTracking) {
      each$l(series.trackerGroups, function (key) {
        if (series[key]) {
          // we don't always have dataLabelsGroup
          series[key].addClass('highcharts-tracker').on('mouseover', onMouseOver).on('mouseout', function (e) {
            pointer.onTrackerMouseOut(e);
          });

          if (hasTouch$2) {
            series[key].on('touchstart', onMouseOver);
          }
        }
      });
      series._hasTracking = true;
    }

    fireEvent$8(this, 'afterDrawTracker');
  },

  /**
   * Draw the tracker object that sits above all data labels and markers to
   * track mouse events on the graph or points. For the line type charts
   * the tracker uses the same graphPath, but with a greater stroke width
   * for better control.
   */
  drawTrackerGraph: function () {
    var series = this,
        options = series.options,
        trackByArea = options.trackByArea,
        trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
        trackerPathLength = trackerPath.length,
        chart = series.chart,
        pointer = chart.pointer,
        renderer = chart.renderer,
        snap = chart.options.tooltip.snap,
        tracker = series.tracker,
        i,
        onMouseOver = function () {
      if (chart.hoverSeries !== series) {
        series.onMouseOver();
      }
    };
 // Extend end points. A better way would be to use round linecaps,
    // but those are not clickable in VML.


    if (trackerPathLength && !trackByArea) {
      i = trackerPathLength + 1;

      while (i--) {
        if (trackerPath[i] === 'M') {
          // extend left side
          trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], 'L');
        }

        if (i && trackerPath[i] === 'M' || i === trackerPathLength) {
          // extend right side
          trackerPath.splice(i, 0, 'L', trackerPath[i - 2] + snap, trackerPath[i - 1]);
        }
      }
    } // draw the tracker


    if (tracker) {
      tracker.attr({
        d: trackerPath
      });
    } else if (series.graph) {
      // create
      series.tracker = renderer.path(trackerPath).attr({
        visibility: series.visible ? 'visible' : 'hidden',
        zIndex: 2
      }).addClass(trackByArea ? 'highcharts-tracker-area' : 'highcharts-tracker-line').add(series.group); // The tracker is added to the series group, which is clipped, but
      // is covered by the marker group. So the marker group also needs to
      // capture events.

      each$l([series.tracker, series.markerGroup], function (tracker) {
        tracker.addClass('highcharts-tracker').on('mouseover', onMouseOver).on('mouseout', function (e) {
          pointer.onTrackerMouseOut(e);
        });

        if (hasTouch$2) {
          tracker.on('touchstart', onMouseOver);
        }
      });
    }

    fireEvent$8(this, 'afterDrawTracker');
  }
};
/* End TrackerMixin */

/**
 * Add tracking event listener to the series group, so the point graphics
 * themselves act as trackers
 */

if (seriesTypes$4.column) {
  seriesTypes$4.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
}

if (seriesTypes$4.pie) {
  seriesTypes$4.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
}

if (seriesTypes$4.scatter) {
  seriesTypes$4.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
}
/*
 * Extend Legend for item events
 */


extend$f(Legend$1.prototype, {
  setItemEvents: function (item, legendItem, useHTML) {
    var legend = this,
        boxWrapper = legend.chart.renderer.boxWrapper,
        activeClass = 'highcharts-legend-' + (item instanceof Point$4 ? 'point' : 'series') + '-active'; // Set the events on the item group, or in case of useHTML, the item
    // itself (#1249)

    (useHTML ? legendItem : item.legendGroup).on('mouseover', function () {
      item.setState('hover'); // A CSS class to dim or hide other than the hovered series

      boxWrapper.addClass(activeClass);
    }).on('mouseout', function () {
      // A CSS class to dim or hide other than the hovered series
      boxWrapper.removeClass(activeClass);
      item.setState();
    }).on('click', function (event) {
      var strLegendItemClick = 'legendItemClick',
          fnLegendItemClick = function () {
        if (item.setVisible) {
          item.setVisible();
        }
      }; // A CSS class to dim or hide other than the hovered series. Event
      // handling in iOS causes the activeClass to be added prior to click
      // in some cases (#7418).


      boxWrapper.removeClass(activeClass); // Pass over the click/touch event. #4.

      event = {
        browserEvent: event
      }; // click the name or symbol

      if (item.firePointEvent) {
        // point
        item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
      } else {
        fireEvent$8(item, strLegendItemClick, event, fnLegendItemClick);
      }
    });
  },
  createCheckboxForItem: function (item) {
    var legend = this;
    item.checkbox = createElement$4('input', {
      type: 'checkbox',
      className: 'highcharts-legend-checkbox',
      checked: item.selected,
      defaultChecked: item.selected // required by IE7

    }, legend.options.itemCheckboxStyle, legend.chart.container);
    addEvent$c(item.checkbox, 'click', function (event) {
      var target = event.target;
      fireEvent$8(item.series || item, 'checkboxClick', {
        // #3712
        checked: target.checked,
        item: item
      }, function () {
        item.select();
      });
    });
  }
});
/*
 * Extend the Chart object with interaction
 */

extend$f(Chart$5.prototype,
/** @lends Chart.prototype */
{
  /**
   * Display the zoom button.
   *
   * @private
   */
  showResetZoom: function () {
    var chart = this,
        lang = defaultOptions$3.lang,
        btnOptions = chart.options.chart.resetZoomButton,
        theme = btnOptions.theme,
        states = theme.states,
        alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';

    function zoomOut() {
      chart.zoomOut();
    }

    fireEvent$8(this, 'beforeShowResetZoom', null, function () {
      chart.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover).attr({
        align: btnOptions.position.align,
        title: lang.resetZoomTitle
      }).addClass('highcharts-reset-zoom').add().align(btnOptions.position, false, alignTo);
    });
  },

  /**
   * Zoom the chart out after a user has zoomed in. See also
   * [Axis.setExtremes](/class-reference/Highcharts.Axis#setExtremes).
   */
  zoomOut: function () {
    fireEvent$8(this, 'selection', {
      resetSelection: true
    }, this.zoom);
  },

  /**
   * Zoom into a given portion of the chart given by axis coordinates.
   * @param {Object} event
   *
   * @private
   */
  zoom: function (event) {
    var chart = this,
        hasZoomed,
        pointer = chart.pointer,
        displayButton = false,
        resetZoomButton; // If zoom is called with no arguments, reset the axes

    if (!event || event.resetSelection) {
      each$l(chart.axes, function (axis) {
        hasZoomed = axis.zoom();
      });
      pointer.initiated = false; // #6804
    } else {
      // else, zoom in on all axes
      each$l(event.xAxis.concat(event.yAxis), function (axisData) {
        var axis = axisData.axis,
            isXAxis = axis.isXAxis; // don't zoom more than minRange

        if (pointer[isXAxis ? 'zoomX' : 'zoomY']) {
          hasZoomed = axis.zoom(axisData.min, axisData.max);

          if (axis.displayBtn) {
            displayButton = true;
          }
        }
      });
    } // Show or hide the Reset zoom button


    resetZoomButton = chart.resetZoomButton;

    if (displayButton && !resetZoomButton) {
      chart.showResetZoom();
    } else if (!displayButton && isObject$5(resetZoomButton)) {
      chart.resetZoomButton = resetZoomButton.destroy();
    } // Redraw


    if (hasZoomed) {
      chart.redraw(pick$n(chart.options.chart.animation, event && event.animation, chart.pointCount < 100));
    }
  },

  /**
   * Pan the chart by dragging the mouse across the pane. This function is
   * called on mouse move, and the distance to pan is computed from chartX
   * compared to the first chartX position in the dragging operation.
   *
   * @private
   */
  pan: function (e, panning) {
    var chart = this,
        hoverPoints = chart.hoverPoints,
        doRedraw; // remove active points for shared tooltip

    if (hoverPoints) {
      each$l(hoverPoints, function (point) {
        point.setState();
      });
    } // xy is used in maps


    each$l(panning === 'xy' ? [1, 0] : [1], function (isX) {
      var axis = chart[isX ? 'xAxis' : 'yAxis'][0],
          horiz = axis.horiz,
          mousePos = e[horiz ? 'chartX' : 'chartY'],
          mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',
          startPos = chart[mouseDown],
          halfPointRange = (axis.pointRange || 0) / 2,
          pointRangeDirection = axis.reversed && !chart.inverted || !axis.reversed && chart.inverted ? -1 : 1,
          extremes = axis.getExtremes(),
          panMin = axis.toValue(startPos - mousePos, true) + halfPointRange * pointRangeDirection,
          panMax = axis.toValue(startPos + axis.len - mousePos, true) - halfPointRange * pointRangeDirection,
          flipped = panMax < panMin,
          newMin = flipped ? panMax : panMin,
          newMax = flipped ? panMin : panMax,
          paddedMin = Math.min(extremes.dataMin, halfPointRange ? extremes.min : axis.toValue(axis.toPixels(extremes.min) - axis.minPixelPadding)),
          paddedMax = Math.max(extremes.dataMax, halfPointRange ? extremes.max : axis.toValue(axis.toPixels(extremes.max) + axis.minPixelPadding)),
          spill; // If the new range spills over, either to the min or max, adjust
      // the new range.

      spill = paddedMin - newMin;

      if (spill > 0) {
        newMax += spill;
        newMin = paddedMin;
      }

      spill = newMax - paddedMax;

      if (spill > 0) {
        newMax = paddedMax;
        newMin -= spill;
      } // Set new extremes if they are actually new


      if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max) {
        axis.setExtremes(newMin, newMax, false, false, {
          trigger: 'pan'
        });
        doRedraw = true;
      }

      chart[mouseDown] = mousePos; // set new reference for next run
    });

    if (doRedraw) {
      chart.redraw(false);
    }

    css$7(chart.container, {
      cursor: 'move'
    });
  }
});
/*
 * Extend the Point object with interaction
 */

extend$f(Point$4.prototype,
/** @lends Highcharts.Point.prototype */
{
  /**
   * Toggle the selection status of a point.
   * @param  {Boolean} [selected]
   *         When `true`, the point is selected. When `false`, the point is
   *         unselected. When `null` or `undefined`, the selection state is
   *         toggled.
   * @param  {Boolean} [accumulate=false]
   *         When `true`, the selection is added to other selected points.
   *         When `false`, other selected points are deselected. Internally in
   *         Highcharts, when {@link http://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect|allowPointSelect}
   *         is `true`, selected points are accumulated on Control, Shift or
   *         Cmd clicking the point.
   *
   * @see    Highcharts.Chart#getSelectedPoints
   *
   * @sample highcharts/members/point-select/
   *         Select a point from a button
   * @sample highcharts/chart/events-selection-points/
   *         Select a range of points through a drag selection
   * @sample maps/series/data-id/
   *         Select a point in Highmaps
   */
  select: function (selected, accumulate) {
    var point = this,
        series = point.series,
        chart = series.chart;
    selected = pick$n(selected, !point.selected); // fire the event with the default handler

    point.firePointEvent(selected ? 'select' : 'unselect', {
      accumulate: accumulate
    }, function () {
      /**
       * Whether the point is selected or not.
       * @see Point#select
       * @see Chart#getSelectedPoints
       * @memberof Point
       * @name selected
       * @type {Boolean}
       */
      point.selected = point.options.selected = selected;
      series.options.data[inArray$4(point, series.data)] = point.options;
      point.setState(selected && 'select'); // unselect all other points unless Ctrl or Cmd + click

      if (!accumulate) {
        each$l(chart.getSelectedPoints(), function (loopPoint) {
          if (loopPoint.selected && loopPoint !== point) {
            loopPoint.selected = loopPoint.options.selected = false;
            series.options.data[inArray$4(loopPoint, series.data)] = loopPoint.options;
            loopPoint.setState('');
            loopPoint.firePointEvent('unselect');
          }
        });
      }
    });
  },

  /**
   * Runs on mouse over the point. Called internally from mouse and touch
   * events.
   *
   * @param {Object} e The event arguments
   */
  onMouseOver: function (e) {
    var point = this,
        series = point.series,
        chart = series.chart,
        pointer = chart.pointer;
    e = e ? pointer.normalize(e) : // In cases where onMouseOver is called directly without an event
    pointer.getChartCoordinatesFromPoint(point, chart.inverted);
    pointer.runPointActions(e, point);
  },

  /**
   * Runs on mouse out from the point. Called internally from mouse and touch
   * events.
   */
  onMouseOut: function () {
    var point = this,
        chart = point.series.chart;
    point.firePointEvent('mouseOut');
    each$l(chart.hoverPoints || [], function (p) {
      p.setState();
    });
    chart.hoverPoints = chart.hoverPoint = null;
  },

  /**
   * Import events from the series' and point's options. Only do it on
   * demand, to save processing time on hovering.
   *
   * @private
   */
  importEvents: function () {
    if (!this.hasImportedEvents) {
      var point = this,
          options = merge$e(point.series.options.point, point.options),
          events = options.events;
      point.events = events;
      Highcharts.objectEach(events, function (event, eventType) {
        addEvent$c(point, eventType, event);
      });
      this.hasImportedEvents = true;
    }
  },

  /**
   * Set the point's state.
   * @param  {String} [state]
   *         The new state, can be one of `''` (an empty string), `hover` or
   *         `select`.
   */
  setState: function (state, move) {
    var point = this,
        plotX = Math.floor(point.plotX),
        // #4586
    plotY = point.plotY,
        series = point.series,
        stateOptions = series.options.states[state || 'normal'] || {},
        markerOptions = defaultPlotOptions$2[series.type].marker && series.options.marker,
        normalDisabled = markerOptions && markerOptions.enabled === false,
        markerStateOptions = markerOptions && markerOptions.states && markerOptions.states[state || 'normal'] || {},
        stateDisabled = markerStateOptions.enabled === false,
        stateMarkerGraphic = series.stateMarkerGraphic,
        pointMarker = point.marker || {},
        chart = series.chart,
        halo = series.halo,
        haloOptions,
        markerAttribs,
        hasMarkers = markerOptions && series.markerAttribs,
        newSymbol;
    state = state || ''; // empty string

    if ( // already has this state
    state === point.state && !move || // selected points don't respond to hover
    point.selected && state !== 'select' || // series' state options is disabled
    stateOptions.enabled === false || // general point marker's state options is disabled
    state && (stateDisabled || normalDisabled && markerStateOptions.enabled === false) || // individual point marker's state options is disabled
    state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false // #1610
    ) {
        return;
      }

    if (hasMarkers) {
      markerAttribs = series.markerAttribs(point, state);
    } // Apply hover styles to the existing point


    if (point.graphic) {
      if (point.state) {
        point.graphic.removeClass('highcharts-point-' + point.state);
      }

      if (state) {
        point.graphic.addClass('highcharts-point-' + state);
      }

      if (markerAttribs) {
        point.graphic.animate(markerAttribs, pick$n(chart.options.chart.animation, // Turn off globally
        markerStateOptions.animation, markerOptions.animation));
      } // Zooming in from a range with no markers to a range with markers


      if (stateMarkerGraphic) {
        stateMarkerGraphic.hide();
      }
    } else {
      // if a graphic is not applied to each point in the normal state,
      // create a shared graphic for the hover state
      if (state && markerStateOptions) {
        newSymbol = pointMarker.symbol || series.symbol; // If the point has another symbol than the previous one, throw
        // away the state marker graphic and force a new one (#1459)

        if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
          stateMarkerGraphic = stateMarkerGraphic.destroy();
        } // Add a new state marker graphic


        if (!stateMarkerGraphic) {
          if (newSymbol) {
            series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height).add(series.markerGroup);
            stateMarkerGraphic.currentSymbol = newSymbol;
          } // Move the existing graphic

        } else {
          stateMarkerGraphic[move ? 'animate' : 'attr']({
            // #1054
            x: markerAttribs.x,
            y: markerAttribs.y
          });
        }
      }

      if (stateMarkerGraphic) {
        stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450

        stateMarkerGraphic.element.point = point; // #4310
      }
    } // Show me your halo


    haloOptions = stateOptions.halo;

    if (haloOptions && haloOptions.size) {
      if (!halo) {
        series.halo = halo = chart.renderer.path() // #5818, #5903, #6705
        .add((point.graphic || stateMarkerGraphic).parentGroup);
      }

      halo.show()[move ? 'animate' : 'attr']({
        d: point.haloPath(haloOptions.size)
      });
      halo.attr({
        'class': 'highcharts-halo highcharts-color-' + pick$n(point.colorIndex, series.colorIndex) + (point.className ? ' ' + point.className : ''),
        'zIndex': -1 // #4929, #8276

      });
      halo.point = point; // #6055
    } else if (halo && halo.point && halo.point.haloPath) {
      // Animate back to 0 on the current halo point (#6055)
      halo.animate({
        d: halo.point.haloPath(0)
      }, null, // Hide after unhovering. The `complete` callback runs in the
      // halo's context (#7681).
      halo.hide);
    }

    point.state = state;
    fireEvent$8(point, 'afterSetState');
  },

  /**
   * Get the path definition for the halo, which is usually a shadow-like
   * circle around the currently hovered point.
   * @param  {Number} size
   *         The radius of the circular halo.
   * @return {Array} The path definition
   */
  haloPath: function (size) {
    var series = this.series,
        chart = series.chart;
    return chart.renderer.symbols.circle(Math.floor(this.plotX) - size, this.plotY - size, size * 2, size * 2);
  }
});
/*
 * Extend the Series object with interaction
 */

extend$f(Series$7.prototype,
/** @lends Highcharts.Series.prototype */
{
  /**
   * Runs on mouse over the series graphical items.
   */
  onMouseOver: function () {
    var series = this,
        chart = series.chart,
        hoverSeries = chart.hoverSeries; // set normal state to previous series

    if (hoverSeries && hoverSeries !== series) {
      hoverSeries.onMouseOut();
    } // trigger the event, but to save processing time,
    // only if defined


    if (series.options.events.mouseOver) {
      fireEvent$8(series, 'mouseOver');
    } // hover this


    series.setState('hover');
    chart.hoverSeries = series;
  },

  /**
   * Runs on mouse out of the series graphical items.
   */
  onMouseOut: function () {
    // trigger the event only if listeners exist
    var series = this,
        options = series.options,
        chart = series.chart,
        tooltip = chart.tooltip,
        hoverPoint = chart.hoverPoint; // #182, set to null before the mouseOut event fires

    chart.hoverSeries = null; // trigger mouse out on the point, which must be in this series

    if (hoverPoint) {
      hoverPoint.onMouseOut();
    } // fire the mouse out event


    if (series && options.events.mouseOut) {
      fireEvent$8(series, 'mouseOut');
    } // hide the tooltip


    if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
      tooltip.hide();
    } // set normal state


    series.setState();
  },

  /**
   * Set the state of the series. Called internally on mouse interaction
   * operations, but it can also be called directly to visually
   * highlight a series.
   *
   * @param  {String} [state]
   *         Can be either `hover` or undefined to set to normal
   *         state.
   */
  setState: function (state) {
    var series = this,
        options = series.options,
        graph = series.graph,
        stateOptions = options.states,
        lineWidth = options.lineWidth;
    state = state || '';

    if (series.state !== state) {
      // Toggle class names
      each$l([series.group, series.markerGroup, series.dataLabelsGroup], function (group) {
        if (group) {
          // Old state
          if (series.state) {
            group.removeClass('highcharts-series-' + series.state);
          } // New state


          if (state) {
            group.addClass('highcharts-series-' + state);
          }
        }
      });
      series.state = state;
    }
  },

  /**
   * Show or hide the series.
   *
   * @param  {Boolean} [visible]
   *         True to show the series, false to hide. If undefined, the
   *         visibility is toggled.
   * @param  {Boolean} [redraw=true]
   *         Whether to redraw the chart after the series is altered. If doing
   *         more operations on the chart, it is a good idea to set redraw to
   *         false and call {@link Chart#redraw|chart.redraw()} after.
   */
  setVisible: function (vis, redraw) {
    var series = this,
        chart = series.chart,
        legendItem = series.legendItem,
        showOrHide,
        ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
        oldVisibility = series.visible; // if called without an argument, toggle visibility

    series.visible = vis = series.options.visible = series.userOptions.visible = vis === undefined ? !oldVisibility : vis; // #5618

    showOrHide = vis ? 'show' : 'hide'; // show or hide elements

    each$l(['group', 'dataLabelsGroup', 'markerGroup', 'tracker', 'tt'], function (key) {
      if (series[key]) {
        series[key][showOrHide]();
      }
    }); // hide tooltip (#1361)

    if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
      series.onMouseOut();
    }

    if (legendItem) {
      chart.legend.colorizeItem(series, vis);
    } // rescale or adapt to resized chart


    series.isDirty = true; // in a stack, all other series are affected

    if (series.options.stacking) {
      each$l(chart.series, function (otherSeries) {
        if (otherSeries.options.stacking && otherSeries.visible) {
          otherSeries.isDirty = true;
        }
      });
    } // show or hide linked series


    each$l(series.linkedSeries, function (otherSeries) {
      otherSeries.setVisible(vis, false);
    });

    if (ignoreHiddenSeries) {
      chart.isDirtyBox = true;
    }

    fireEvent$8(series, showOrHide);

    if (redraw !== false) {
      chart.redraw();
    }
  },

  /**
   * Show the series if hidden.
   *
   * @sample highcharts/members/series-hide/
   *         Toggle visibility from a button
   */
  show: function () {
    this.setVisible(true);
  },

  /**
   * Hide the series if visible. If the {@link
   * https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries|
   * chart.ignoreHiddenSeries} option is true, the chart is redrawn without
   * this series.
   *
   * @sample highcharts/members/series-hide/
   *         Toggle visibility from a button
   */
  hide: function () {
    this.setVisible(false);
  },

  /**
   * Select or unselect the series. This means its {@link
   * Highcharts.Series.selected|selected} property is set, the checkbox in the
   * legend is toggled and when selected, the series is returned by the
   * {@link Highcharts.Chart#getSelectedSeries} function.
   *
   * @param  {Boolean} [selected]
   *         True to select the series, false to unselect. If undefined, the
   *         selection state is toggled.
   *
   * @sample highcharts/members/series-select/
   *         Select a series from a button
   */
  select: function (selected) {
    var series = this;
    series.selected = selected = selected === undefined ? !series.selected : selected;

    if (series.checkbox) {
      series.checkbox.checked = selected;
    }

    fireEvent$8(series, selected ? 'select' : 'unselect');
  },
  drawTracker: TrackerMixin.drawTrackerGraph
});

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var Chart$6 = Highcharts.Chart,
    each$m = Highcharts.each,
    inArray$5 = Highcharts.inArray,
    isArray$5 = Highcharts.isArray,
    isObject$6 = Highcharts.isObject,
    pick$o = Highcharts.pick,
    splat$7 = Highcharts.splat;
/**
 * Allows setting a set of rules to apply for different screen or chart
 * sizes. Each rule specifies additional chart options.
 *
 * @sample {highstock} stock/demo/responsive/ Stock chart
 * @sample highcharts/responsive/axis/ Axis
 * @sample highcharts/responsive/legend/ Legend
 * @sample highcharts/responsive/classname/ Class name
 * @since 5.0.0
 * @apioption responsive
 */

/**
 * A set of rules for responsive settings. The rules are executed from
 * the top down.
 *
 * @type {Array<Object>}
 * @sample {highcharts} highcharts/responsive/axis/ Axis changes
 * @sample {highstock} highcharts/responsive/axis/ Axis changes
 * @sample {highmaps} highcharts/responsive/axis/ Axis changes
 * @since 5.0.0
 * @apioption responsive.rules
 */

/**
 * A full set of chart options to apply as overrides to the general
 * chart options. The chart options are applied when the given rule
 * is active.
 *
 * A special case is configuration objects that take arrays, for example
 * [xAxis](#xAxis), [yAxis](#yAxis) or [series](#series). For these
 * collections, an `id` option is used to map the new option set to
 * an existing object. If an existing object of the same id is not found,
 * the item of the same indexupdated. So for example, setting `chartOptions`
 * with two series items without an `id`, will cause the existing chart's
 * two series to be updated with respective options.
 *
 * @type {Object}
 * @sample {highstock} stock/demo/responsive/ Stock chart
 * @sample highcharts/responsive/axis/ Axis
 * @sample highcharts/responsive/legend/ Legend
 * @sample highcharts/responsive/classname/ Class name
 * @since 5.0.0
 * @apioption responsive.rules.chartOptions
 */

/**
 * Under which conditions the rule applies.
 *
 * @type {Object}
 * @since 5.0.0
 * @apioption responsive.rules.condition
 */

/**
 * A callback function to gain complete control on when the responsive
 * rule applies. Return `true` if it applies. This opens for checking
 * against other metrics than the chart size, or example the document
 * size or other elements.
 *
 * @type {Function}
 * @context Chart
 * @since 5.0.0
 * @apioption responsive.rules.condition.callback
 */

/**
 * The responsive rule applies if the chart height is less than this.
 *
 * @type {Number}
 * @since 5.0.0
 * @apioption responsive.rules.condition.maxHeight
 */

/**
 * The responsive rule applies if the chart width is less than this.
 *
 * @type {Number}
 * @sample highcharts/responsive/axis/ Max width is 500
 * @since 5.0.0
 * @apioption responsive.rules.condition.maxWidth
 */

/**
 * The responsive rule applies if the chart height is greater than this.
 *
 * @type {Number}
 * @default 0
 * @since 5.0.0
 * @apioption responsive.rules.condition.minHeight
 */

/**
 * The responsive rule applies if the chart width is greater than this.
 *
 * @type {Number}
 * @default 0
 * @since 5.0.0
 * @apioption responsive.rules.condition.minWidth
 */

/**
 * Update the chart based on the current chart/document size and options for
 * responsiveness.
 */

Chart$6.prototype.setResponsive = function (redraw) {
  var options = this.options.responsive,
      ruleIds = [],
      currentResponsive = this.currentResponsive,
      currentRuleIds;

  if (options && options.rules) {
    each$m(options.rules, function (rule) {
      if (rule._id === undefined) {
        rule._id = Highcharts.uniqueKey();
      }

      this.matchResponsiveRule(rule, ruleIds, redraw);
    }, this);
  } // Merge matching rules


  var mergedOptions = Highcharts.merge.apply(0, Highcharts.map(ruleIds, function (ruleId) {
    return Highcharts.find(options.rules, function (rule) {
      return rule._id === ruleId;
    }).chartOptions;
  })); // Stringified key for the rules that currently apply.

  ruleIds = ruleIds.toString() || undefined;
  currentRuleIds = currentResponsive && currentResponsive.ruleIds; // Changes in what rules apply

  if (ruleIds !== currentRuleIds) {
    // Undo previous rules. Before we apply a new set of rules, we need to
    // roll back completely to base options (#6291).
    if (currentResponsive) {
      this.update(currentResponsive.undoOptions, redraw);
    }

    if (ruleIds) {
      // Get undo-options for matching rules
      this.currentResponsive = {
        ruleIds: ruleIds,
        mergedOptions: mergedOptions,
        undoOptions: this.currentOptions(mergedOptions)
      };
      this.update(mergedOptions, redraw);
    } else {
      this.currentResponsive = undefined;
    }
  }
};
/**
 * Handle a single responsiveness rule
 */


Chart$6.prototype.matchResponsiveRule = function (rule, matches) {
  var condition = rule.condition,
      fn = condition.callback || function () {
    return this.chartWidth <= pick$o(condition.maxWidth, Number.MAX_VALUE) && this.chartHeight <= pick$o(condition.maxHeight, Number.MAX_VALUE) && this.chartWidth >= pick$o(condition.minWidth, 0) && this.chartHeight >= pick$o(condition.minHeight, 0);
  };

  if (fn.call(this)) {
    matches.push(rule._id);
  }
};
/**
 * Get the current values for a given set of options. Used before we update
 * the chart with a new responsiveness rule.
 * TODO: Restore axis options (by id?)
 */


Chart$6.prototype.currentOptions = function (options) {
  var ret = {};
  /**
   * Recurse over a set of options and its current values,
   * and store the current values in the ret object.
   */

  function getCurrent(options, curr, ret, depth) {
    var i;
    Highcharts.objectEach(options, function (val, key) {
      if (!depth && inArray$5(key, ['series', 'xAxis', 'yAxis']) > -1) {
        val = splat$7(val);
        ret[key] = []; // Iterate over collections like series, xAxis or yAxis and map
        // the items by index.

        for (i = 0; i < val.length; i++) {
          if (curr[key][i]) {
            // Item exists in current data (#6347)
            ret[key][i] = {};
            getCurrent(val[i], curr[key][i], ret[key][i], depth + 1);
          }
        }
      } else if (isObject$6(val)) {
        ret[key] = isArray$5(val) ? [] : {};
        getCurrent(val, curr[key] || {}, ret[key], depth + 1);
      } else {
        ret[key] = curr[key] || null;
      }
    });
  }

  getCurrent(options, this.options, ret, 0);
  return ret;
};

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 *
 * (c) 2009-2016 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$d = Highcharts.addEvent,
    Axis$6 = Highcharts.Axis,
    Chart$7 = Highcharts.Chart,
    css$8 = Highcharts.css,
    defined$e = Highcharts.defined,
    each$n = Highcharts.each,
    extend$g = Highcharts.extend,
    noop$6 = Highcharts.noop,
    pick$p = Highcharts.pick,
    Series$8 = Highcharts.Series,
    timeUnits$3 = Highcharts.timeUnits,
    wrap$5 = Highcharts.wrap;
/* ****************************************************************************
 * Start ordinal axis logic                                                   *
 *****************************************************************************/

wrap$5(Series$8.prototype, 'init', function (proceed) {
  var series = this,
      xAxis; // call the original function

  proceed.apply(this, Array.prototype.slice.call(arguments, 1));
  xAxis = series.xAxis; // Destroy the extended ordinal index on updated data

  if (xAxis && xAxis.options.ordinal) {
    addEvent$d(series, 'updatedData', function () {
      delete xAxis.ordinalIndex;
    });
  }
});
/**
 * In an ordinal axis, there might be areas with dense consentrations of points, then large
 * gaps between some. Creating equally distributed ticks over this entire range
 * may lead to a huge number of ticks that will later be removed. So instead, break the
 * positions up in segments, find the tick positions for each segment then concatenize them.
 * This method is used from both data grouping logic and X axis tick position logic.
 */

wrap$5(Axis$6.prototype, 'getTimeTicks', function (proceed, normalizedInterval, min, max, startOfWeek, positions, closestDistance, findHigherRanks) {
  var start = 0,
      end,
      segmentPositions,
      higherRanks = {},
      hasCrossedHigherRank,
      info,
      posLength,
      outsideMax,
      groupPositions = [],
      lastGroupPosition = -Number.MAX_VALUE,
      tickPixelIntervalOption = this.options.tickPixelInterval,
      time = this.chart.time; // The positions are not always defined, for example for ordinal positions
  // when data has regular interval (#1557, #2090)

  if (!this.options.ordinal && !this.options.breaks || !positions || positions.length < 3 || min === undefined) {
    return proceed.call(this, normalizedInterval, min, max, startOfWeek);
  } // Analyze the positions array to split it into segments on gaps larger than 5 times
  // the closest distance. The closest distance is already found at this point, so
  // we reuse that instead of computing it again.


  posLength = positions.length;

  for (end = 0; end < posLength; end++) {
    outsideMax = end && positions[end - 1] > max;

    if (positions[end] < min) {
      // Set the last position before min
      start = end;
    }

    if (end === posLength - 1 || positions[end + 1] - positions[end] > closestDistance * 5 || outsideMax) {
      // For each segment, calculate the tick positions from the getTimeTicks utility
      // function. The interval will be the same regardless of how long the segment is.
      if (positions[end] > lastGroupPosition) {
        // #1475
        segmentPositions = proceed.call(this, normalizedInterval, positions[start], positions[end], startOfWeek); // Prevent duplicate groups, for example for multiple segments within one larger time frame (#1475)

        while (segmentPositions.length && segmentPositions[0] <= lastGroupPosition) {
          segmentPositions.shift();
        }

        if (segmentPositions.length) {
          lastGroupPosition = segmentPositions[segmentPositions.length - 1];
        }

        groupPositions = groupPositions.concat(segmentPositions);
      } // Set start of next segment


      start = end + 1;
    }

    if (outsideMax) {
      break;
    }
  } // Get the grouping info from the last of the segments. The info is the same for
  // all segments.


  info = segmentPositions.info; // Optionally identify ticks with higher rank, for example when the ticks
  // have crossed midnight.

  if (findHigherRanks && info.unitRange <= timeUnits$3.hour) {
    end = groupPositions.length - 1; // Compare points two by two

    for (start = 1; start < end; start++) {
      if (time.dateFormat('%d', groupPositions[start]) !== time.dateFormat('%d', groupPositions[start - 1])) {
        higherRanks[groupPositions[start]] = 'day';
        hasCrossedHigherRank = true;
      }
    } // If the complete array has crossed midnight, we want to mark the first
    // positions also as higher rank


    if (hasCrossedHigherRank) {
      higherRanks[groupPositions[0]] = 'day';
    }

    info.higherRanks = higherRanks;
  } // Save the info


  groupPositions.info = info; // Don't show ticks within a gap in the ordinal axis, where the space between
  // two points is greater than a portion of the tick pixel interval

  if (findHigherRanks && defined$e(tickPixelIntervalOption)) {
    // check for squashed ticks
    var length = groupPositions.length,
        i = length,
        itemToRemove,
        translated,
        translatedArr = [],
        lastTranslated,
        medianDistance,
        distance,
        distances = []; // Find median pixel distance in order to keep a reasonably even distance between
    // ticks (#748)

    while (i--) {
      translated = this.translate(groupPositions[i]);

      if (lastTranslated) {
        distances[i] = lastTranslated - translated;
      }

      translatedArr[i] = lastTranslated = translated;
    }

    distances.sort();
    medianDistance = distances[Math.floor(distances.length / 2)];

    if (medianDistance < tickPixelIntervalOption * 0.6) {
      medianDistance = null;
    } // Now loop over again and remove ticks where needed


    i = groupPositions[length - 1] > max ? length - 1 : length; // #817

    lastTranslated = undefined;

    while (i--) {
      translated = translatedArr[i];
      distance = Math.abs(lastTranslated - translated); // #4175 - when axis is reversed, the distance, is negative but
      // tickPixelIntervalOption positive, so we need to compare the same values
      // Remove ticks that are closer than 0.6 times the pixel interval from the one to the right,
      // but not if it is close to the median distance (#748).

      if (lastTranslated && distance < tickPixelIntervalOption * 0.8 && (medianDistance === null || distance < medianDistance * 0.8)) {
        // Is this a higher ranked position with a normal position to the right?
        if (higherRanks[groupPositions[i]] && !higherRanks[groupPositions[i + 1]]) {
          // Yes: remove the lower ranked neighbour to the right
          itemToRemove = i + 1;
          lastTranslated = translated; // #709
        } else {
          // No: remove this one
          itemToRemove = i;
        }

        groupPositions.splice(itemToRemove, 1);
      } else {
        lastTranslated = translated;
      }
    }
  }

  return groupPositions;
}); // Extend the Axis prototype

extend$g(Axis$6.prototype,
/** @lends Axis.prototype */
{
  /**
   * Calculate the ordinal positions before tick positions are calculated.
   */
  beforeSetTickPositions: function () {
    var axis = this,
        len,
        ordinalPositions = [],
        uniqueOrdinalPositions,
        useOrdinal = false,
        dist,
        extremes = axis.getExtremes(),
        min = extremes.min,
        max = extremes.max,
        minIndex,
        maxIndex,
        slope,
        hasBreaks = axis.isXAxis && !!axis.options.breaks,
        isOrdinal = axis.options.ordinal,
        overscrollPointsRange = Number.MAX_VALUE,
        ignoreHiddenSeries = axis.chart.options.chart.ignoreHiddenSeries,
        isNavigatorAxis = axis.options.className === 'highcharts-navigator-xaxis',
        i,
        hasBoostedSeries;

    if (axis.options.overscroll && axis.max === axis.dataMax && ( // Panning is an execption,
    // We don't want to apply overscroll when panning over the dataMax
    !axis.chart.mouseIsDown || isNavigatorAxis) && ( // Scrollbar buttons are the other execption:
    !axis.eventArgs || axis.eventArgs && axis.eventArgs.trigger !== 'navigator')) {
      axis.max += axis.options.overscroll; // Live data and buttons require translation for the min:

      if (!isNavigatorAxis && defined$e(axis.userMin)) {
        axis.min += axis.options.overscroll;
      }
    } // Apply the ordinal logic


    if (isOrdinal || hasBreaks) {
      // #4167 YAxis is never ordinal ?
      each$n(axis.series, function (series, i) {
        uniqueOrdinalPositions = [];

        if ((!ignoreHiddenSeries || series.visible !== false) && (series.takeOrdinalPosition !== false || hasBreaks)) {
          // concatenate the processed X data into the existing positions, or the empty array
          ordinalPositions = ordinalPositions.concat(series.processedXData);
          len = ordinalPositions.length; // remove duplicates (#1588)

          ordinalPositions.sort(function (a, b) {
            return a - b; // without a custom function it is sorted as strings
          });
          overscrollPointsRange = Math.min(overscrollPointsRange, pick$p( // Check for a single-point series:
          series.closestPointRange, overscrollPointsRange));

          if (len) {
            i = 0;

            while (i < len - 1) {
              if (ordinalPositions[i] !== ordinalPositions[i + 1]) {
                uniqueOrdinalPositions.push(ordinalPositions[i + 1]);
              }

              i++;
            } // Check first item:


            if (uniqueOrdinalPositions[0] !== ordinalPositions[0]) {
              uniqueOrdinalPositions.unshift(ordinalPositions[0]);
            }

            ordinalPositions = uniqueOrdinalPositions;
          }
        }

        if (series.isSeriesBoosting) {
          hasBoostedSeries = true;
        }
      });

      if (hasBoostedSeries) {
        ordinalPositions.length = 0;
      } // cache the length


      len = ordinalPositions.length; // Check if we really need the overhead of mapping axis data against the ordinal positions.
      // If the series consist of evenly spaced data any way, we don't need any ordinal logic.

      if (len > 2) {
        // two points have equal distance by default
        dist = ordinalPositions[1] - ordinalPositions[0];
        i = len - 1;

        while (i-- && !useOrdinal) {
          if (ordinalPositions[i + 1] - ordinalPositions[i] !== dist) {
            useOrdinal = true;
          }
        } // When zooming in on a week, prevent axis padding for weekends even though the data within
        // the week is evenly spaced.


        if (!axis.options.keepOrdinalPadding && (ordinalPositions[0] - min > dist || max - ordinalPositions[ordinalPositions.length - 1] > dist)) {
          useOrdinal = true;
        }
      } else if (axis.options.overscroll) {
        if (len === 2) {
          // Exactly two points, distance for overscroll is fixed:
          overscrollPointsRange = ordinalPositions[1] - ordinalPositions[0];
        } else if (len === 1) {
          // We have just one point, closest distance is unknown.
          // Assume then it is last point and overscrolled range:
          overscrollPointsRange = axis.options.overscroll;
          ordinalPositions = [ordinalPositions[0], ordinalPositions[0] + overscrollPointsRange];
        } else {
          // In case of zooming in on overscrolled range, stick to the old range:
          overscrollPointsRange = axis.overscrollPointsRange;
        }
      } // Record the slope and offset to compute the linear values from the array index.
      // Since the ordinal positions may exceed the current range, get the start and
      // end positions within it (#719, #665b)


      if (useOrdinal) {
        if (axis.options.overscroll) {
          axis.overscrollPointsRange = overscrollPointsRange;
          ordinalPositions = ordinalPositions.concat(axis.getOverscrollPositions());
        } // Register


        axis.ordinalPositions = ordinalPositions; // This relies on the ordinalPositions being set. Use Math.max
        // and Math.min to prevent padding on either sides of the data.

        minIndex = axis.ordinal2lin( // #5979
        Math.max(min, ordinalPositions[0]), true);
        maxIndex = Math.max(axis.ordinal2lin(Math.min(max, ordinalPositions[ordinalPositions.length - 1]), true), 1); // #3339
        // Set the slope and offset of the values compared to the indices in the ordinal positions

        axis.ordinalSlope = slope = (max - min) / (maxIndex - minIndex);
        axis.ordinalOffset = min - minIndex * slope;
      } else {
        axis.overscrollPointsRange = pick$p(axis.closestPointRange, axis.overscrollPointsRange);
        axis.ordinalPositions = axis.ordinalSlope = axis.ordinalOffset = undefined;
      }
    }

    axis.isOrdinal = isOrdinal && useOrdinal; // #3818, #4196, #4926

    axis.groupIntervalFactor = null; // reset for next run
  },

  /**
   * Translate from a linear axis value to the corresponding ordinal axis position. If there
   * are no gaps in the ordinal axis this will be the same. The translated value is the value
   * that the point would have if the axis were linear, using the same min and max.
   *
   * @param Number val The axis value
   * @param Boolean toIndex Whether to return the index in the ordinalPositions or the new value
   */
  val2lin: function (val, toIndex) {
    var axis = this,
        ordinalPositions = axis.ordinalPositions,
        ret;

    if (!ordinalPositions) {
      ret = val;
    } else {
      var ordinalLength = ordinalPositions.length,
          i,
          distance,
          ordinalIndex; // first look for an exact match in the ordinalpositions array

      i = ordinalLength;

      while (i--) {
        if (ordinalPositions[i] === val) {
          ordinalIndex = i;
          break;
        }
      } // if that failed, find the intermediate position between the two nearest values


      i = ordinalLength - 1;

      while (i--) {
        if (val > ordinalPositions[i] || i === 0) {
          // interpolate
          distance = (val - ordinalPositions[i]) / (ordinalPositions[i + 1] - ordinalPositions[i]); // something between 0 and 1

          ordinalIndex = i + distance;
          break;
        }
      }

      ret = toIndex ? ordinalIndex : axis.ordinalSlope * (ordinalIndex || 0) + axis.ordinalOffset;
    }

    return ret;
  },

  /**
   * Translate from linear (internal) to axis value
   *
   * @param Number val The linear abstracted value
   * @param Boolean fromIndex Translate from an index in the ordinal positions rather than a value
   */
  lin2val: function (val, fromIndex) {
    var axis = this,
        ordinalPositions = axis.ordinalPositions,
        ret;

    if (!ordinalPositions) {
      // the visible range contains only equally spaced values
      ret = val;
    } else {
      var ordinalSlope = axis.ordinalSlope,
          ordinalOffset = axis.ordinalOffset,
          i = ordinalPositions.length - 1,
          linearEquivalentLeft,
          linearEquivalentRight,
          distance; // Handle the case where we translate from the index directly, used only
      // when panning an ordinal axis

      if (fromIndex) {
        if (val < 0) {
          // out of range, in effect panning to the left
          val = ordinalPositions[0];
        } else if (val > i) {
          // out of range, panning to the right
          val = ordinalPositions[i];
        } else {
          // split it up
          i = Math.floor(val);
          distance = val - i; // the decimal
        } // Loop down along the ordinal positions. When the linear equivalent of i matches
        // an ordinal position, interpolate between the left and right values.

      } else {
        while (i--) {
          linearEquivalentLeft = ordinalSlope * i + ordinalOffset;

          if (val >= linearEquivalentLeft) {
            linearEquivalentRight = ordinalSlope * (i + 1) + ordinalOffset;
            distance = (val - linearEquivalentLeft) / (linearEquivalentRight - linearEquivalentLeft); // something between 0 and 1

            break;
          }
        }
      } // If the index is within the range of the ordinal positions, return the associated
      // or interpolated value. If not, just return the value


      return distance !== undefined && ordinalPositions[i] !== undefined ? ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + 1] - ordinalPositions[i]) : 0) : val;
    }

    return ret;
  },

  /**
   * Get the ordinal positions for the entire data set. This is necessary in chart panning
   * because we need to find out what points or data groups are available outside the
   * visible range. When a panning operation starts, if an index for the given grouping
   * does not exists, it is created and cached. This index is deleted on updated data, so
   * it will be regenerated the next time a panning operation starts.
   */
  getExtendedPositions: function () {
    var axis = this,
        chart = axis.chart,
        grouping = axis.series[0].currentDataGrouping,
        ordinalIndex = axis.ordinalIndex,
        key = grouping ? grouping.count + grouping.unitName : 'raw',
        overscroll = axis.options.overscroll,
        extremes = axis.getExtremes(),
        fakeAxis,
        fakeSeries; // If this is the first time, or the ordinal index is deleted by updatedData,
    // create it.

    if (!ordinalIndex) {
      ordinalIndex = axis.ordinalIndex = {};
    }

    if (!ordinalIndex[key]) {
      // Create a fake axis object where the extended ordinal positions are emulated
      fakeAxis = {
        series: [],
        chart: chart,
        getExtremes: function () {
          return {
            min: extremes.dataMin,
            max: extremes.dataMax + overscroll
          };
        },
        options: {
          ordinal: true
        },
        val2lin: Axis$6.prototype.val2lin,
        // #2590
        ordinal2lin: Axis$6.prototype.ordinal2lin // #6276

      }; // Add the fake series to hold the full data, then apply processData to it

      each$n(axis.series, function (series) {
        fakeSeries = {
          xAxis: fakeAxis,
          xData: series.xData.slice(),
          chart: chart,
          destroyGroupedData: noop$6
        };
        fakeSeries.xData = fakeSeries.xData.concat(axis.getOverscrollPositions());
        fakeSeries.options = {
          dataGrouping: grouping ? {
            enabled: true,
            forced: true,
            approximation: 'open',
            // doesn't matter which, use the fastest
            units: [[grouping.unitName, [grouping.count]]]
          } : {
            enabled: false
          }
        };
        series.processData.apply(fakeSeries);
        fakeAxis.series.push(fakeSeries);
      }); // Run beforeSetTickPositions to compute the ordinalPositions

      axis.beforeSetTickPositions.apply(fakeAxis); // Cache it

      ordinalIndex[key] = fakeAxis.ordinalPositions;
    }

    return ordinalIndex[key];
  },

  /**
   * Get ticks for an ordinal axis within a range where points don't exist.
   * It is required when overscroll is enabled. We can't base on points,
   * because we may not have any, so we use approximated pointRange and
   * generate these ticks between <Axis.dataMax, Axis.dataMax + Axis.overscroll>
   * evenly spaced. Used in panning and navigator scrolling.
   *
   * @returns positions {Array} Generated ticks
   * @private
   */
  getOverscrollPositions: function () {
    var axis = this,
        extraRange = axis.options.overscroll,
        distance = axis.overscrollPointsRange,
        positions = [],
        max = axis.dataMax;

    if (Highcharts.defined(distance)) {
      // Max + pointRange because we need to scroll to the last
      positions.push(max);

      while (max <= axis.dataMax + extraRange) {
        max += distance;
        positions.push(max);
      }
    }

    return positions;
  },

  /**
   * Find the factor to estimate how wide the plot area would have been if ordinal
   * gaps were included. This value is used to compute an imagined plot width in order
   * to establish the data grouping interval.
   *
   * A real world case is the intraday-candlestick
   * example. Without this logic, it would show the correct data grouping when viewing
   * a range within each day, but once moving the range to include the gap between two
   * days, the interval would include the cut-away night hours and the data grouping
   * would be wrong. So the below method tries to compensate by identifying the most
   * common point interval, in this case days.
   *
   * An opposite case is presented in issue #718. We have a long array of daily data,
   * then one point is appended one hour after the last point. We expect the data grouping
   * not to change.
   *
   * In the future, if we find cases where this estimation doesn't work optimally, we
   * might need to add a second pass to the data grouping logic, where we do another run
   * with a greater interval if the number of data groups is more than a certain fraction
   * of the desired group count.
   */
  getGroupIntervalFactor: function (xMin, xMax, series) {
    var i,
        processedXData = series.processedXData,
        len = processedXData.length,
        distances = [],
        median,
        groupIntervalFactor = this.groupIntervalFactor; // Only do this computation for the first series, let the other inherit it (#2416)

    if (!groupIntervalFactor) {
      // Register all the distances in an array
      for (i = 0; i < len - 1; i++) {
        distances[i] = processedXData[i + 1] - processedXData[i];
      } // Sort them and find the median


      distances.sort(function (a, b) {
        return a - b;
      });
      median = distances[Math.floor(len / 2)]; // Compensate for series that don't extend through the entire axis extent. #1675.

      xMin = Math.max(xMin, processedXData[0]);
      xMax = Math.min(xMax, processedXData[len - 1]);
      this.groupIntervalFactor = groupIntervalFactor = len * median / (xMax - xMin);
    } // Return the factor needed for data grouping


    return groupIntervalFactor;
  },

  /**
   * Make the tick intervals closer because the ordinal gaps make the ticks spread out or cluster
   */
  postProcessTickInterval: function (tickInterval) {
    // Problem: https://jsfiddle.net/highcharts/FQm4E/1/
    // This is a case where this algorithm doesn't work optimally. In this case, the
    // tick labels are spread out per week, but all the gaps reside within weeks. So
    // we have a situation where the labels are courser than the ordinal gaps, and
    // thus the tick interval should not be altered
    var ordinalSlope = this.ordinalSlope,
        ret;

    if (ordinalSlope) {
      if (!this.options.breaks) {
        ret = tickInterval / (ordinalSlope / this.closestPointRange);
      } else {
        ret = this.closestPointRange || tickInterval; // #7275
      }
    } else {
      ret = tickInterval;
    }

    return ret;
  }
}); // Record this to prevent overwriting by broken-axis module (#5979)

Axis$6.prototype.ordinal2lin = Axis$6.prototype.val2lin; // Extending the Chart.pan method for ordinal axes

wrap$5(Chart$7.prototype, 'pan', function (proceed, e) {
  var chart = this,
      xAxis = chart.xAxis[0],
      overscroll = xAxis.options.overscroll,
      chartX = e.chartX,
      runBase = false;

  if (xAxis.options.ordinal && xAxis.series.length) {
    var mouseDownX = chart.mouseDownX,
        extremes = xAxis.getExtremes(),
        dataMax = extremes.dataMax,
        min = extremes.min,
        max = extremes.max,
        trimmedRange,
        hoverPoints = chart.hoverPoints,
        closestPointRange = xAxis.closestPointRange || xAxis.overscrollPointsRange,
        pointPixelWidth = xAxis.translationSlope * (xAxis.ordinalSlope || closestPointRange),
        movedUnits = (mouseDownX - chartX) / pointPixelWidth,
        // how many ordinal units did we move?
    extendedAxis = {
      ordinalPositions: xAxis.getExtendedPositions()
    },
        // get index of all the chart's points
    ordinalPositions,
        searchAxisLeft,
        lin2val = xAxis.lin2val,
        val2lin = xAxis.val2lin,
        searchAxisRight;

    if (!extendedAxis.ordinalPositions) {
      // we have an ordinal axis, but the data is equally spaced
      runBase = true;
    } else if (Math.abs(movedUnits) > 1) {
      // Remove active points for shared tooltip
      if (hoverPoints) {
        each$n(hoverPoints, function (point) {
          point.setState();
        });
      }

      if (movedUnits < 0) {
        searchAxisLeft = extendedAxis;
        searchAxisRight = xAxis.ordinalPositions ? xAxis : extendedAxis;
      } else {
        searchAxisLeft = xAxis.ordinalPositions ? xAxis : extendedAxis;
        searchAxisRight = extendedAxis;
      } // In grouped data series, the last ordinal position represents the grouped data, which is
      // to the left of the real data max. If we don't compensate for this, we will be allowed
      // to pan grouped data series passed the right of the plot area.


      ordinalPositions = searchAxisRight.ordinalPositions;

      if (dataMax > ordinalPositions[ordinalPositions.length - 1]) {
        ordinalPositions.push(dataMax);
      } // Get the new min and max values by getting the ordinal index for the current extreme,
      // then add the moved units and translate back to values. This happens on the
      // extended ordinal positions if the new position is out of range, else it happens
      // on the current x axis which is smaller and faster.


      chart.fixedRange = max - min;
      trimmedRange = xAxis.toFixedRange(null, null, lin2val.apply(searchAxisLeft, [val2lin.apply(searchAxisLeft, [min, true]) + movedUnits, // the new index
      true // translate from index
      ]), lin2val.apply(searchAxisRight, [val2lin.apply(searchAxisRight, [max, true]) + movedUnits, // the new index
      true // translate from index
      ])); // Apply it if it is within the available data range

      if (trimmedRange.min >= Math.min(extremes.dataMin, min) && trimmedRange.max <= Math.max(dataMax, max) + overscroll) {
        xAxis.setExtremes(trimmedRange.min, trimmedRange.max, true, false, {
          trigger: 'pan'
        });
      }

      chart.mouseDownX = chartX; // set new reference for next run

      css$8(chart.container, {
        cursor: 'move'
      });
    }
  } else {
    runBase = true;
  } // revert to the linear chart.pan version


  if (runBase) {
    if (overscroll) {
      xAxis.max = xAxis.dataMax + overscroll;
    } // call the original function


    proceed.apply(this, Array.prototype.slice.call(arguments, 1));
  }
});
/* ****************************************************************************
 * End ordinal axis logic                                                   *
 *****************************************************************************/

/**
 * (c) 2009-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$e = Highcharts.addEvent,
    pick$q = Highcharts.pick,
    wrap$6 = Highcharts.wrap,
    each$o = Highcharts.each,
    extend$h = Highcharts.extend,
    isArray$6 = Highcharts.isArray,
    fireEvent$9 = Highcharts.fireEvent,
    Axis$7 = Highcharts.Axis,
    Series$9 = Highcharts.Series;

function stripArguments() {
  return Array.prototype.slice.call(arguments, 1);
}

extend$h(Axis$7.prototype, {
  isInBreak: function (brk, val) {
    var ret,
        repeat = brk.repeat || Infinity,
        from = brk.from,
        length = brk.to - brk.from,
        test = val >= from ? (val - from) % repeat : repeat - (from - val) % repeat;

    if (!brk.inclusive) {
      ret = test < length && test !== 0;
    } else {
      ret = test <= length;
    }

    return ret;
  },
  isInAnyBreak: function (val, testKeep) {
    var breaks = this.options.breaks,
        i = breaks && breaks.length,
        inbrk,
        keep,
        ret;

    if (i) {
      while (i--) {
        if (this.isInBreak(breaks[i], val)) {
          inbrk = true;

          if (!keep) {
            keep = pick$q(breaks[i].showPoints, this.isXAxis ? false : true);
          }
        }
      }

      if (inbrk && testKeep) {
        ret = inbrk && !keep;
      } else {
        ret = inbrk;
      }
    }

    return ret;
  }
});
addEvent$e(Axis$7, 'afterSetTickPositions', function () {
  if (this.options.breaks) {
    var axis = this,
        tickPositions = this.tickPositions,
        info = this.tickPositions.info,
        newPositions = [],
        i;

    for (i = 0; i < tickPositions.length; i++) {
      if (!axis.isInAnyBreak(tickPositions[i])) {
        newPositions.push(tickPositions[i]);
      }
    }

    this.tickPositions = newPositions;
    this.tickPositions.info = info;
  }
}); // Force Axis to be not-ordinal when breaks are defined

addEvent$e(Axis$7, 'afterSetOptions', function () {
  if (this.options.breaks && this.options.breaks.length) {
    this.options.ordinal = false;
  }
});
addEvent$e(Axis$7, 'afterInit', function () {
  var axis = this,
      breaks;
  breaks = this.options.breaks;
  axis.isBroken = isArray$6(breaks) && !!breaks.length;

  if (axis.isBroken) {
    axis.val2lin = function (val) {
      var nval = val,
          brk,
          i;

      for (i = 0; i < axis.breakArray.length; i++) {
        brk = axis.breakArray[i];

        if (brk.to <= val) {
          nval -= brk.len;
        } else if (brk.from >= val) {
          break;
        } else if (axis.isInBreak(brk, val)) {
          nval -= val - brk.from;
          break;
        }
      }

      return nval;
    };

    axis.lin2val = function (val) {
      var nval = val,
          brk,
          i;

      for (i = 0; i < axis.breakArray.length; i++) {
        brk = axis.breakArray[i];

        if (brk.from >= nval) {
          break;
        } else if (brk.to < nval) {
          nval += brk.len;
        } else if (axis.isInBreak(brk, nval)) {
          nval += brk.len;
        }
      }

      return nval;
    };

    axis.setExtremes = function (newMin, newMax, redraw, animation, eventArguments) {
      // If trying to set extremes inside a break, extend it to before and
      // after the break ( #3857 )
      while (this.isInAnyBreak(newMin)) {
        newMin -= this.closestPointRange;
      }

      while (this.isInAnyBreak(newMax)) {
        newMax -= this.closestPointRange;
      }

      Axis$7.prototype.setExtremes.call(this, newMin, newMax, redraw, animation, eventArguments);
    };

    axis.setAxisTranslation = function (saveOld) {
      Axis$7.prototype.setAxisTranslation.call(this, saveOld);
      var breaks = axis.options.breaks,
          breakArrayT = [],
          // Temporary one
      breakArray = [],
          length = 0,
          inBrk,
          repeat,
          min = axis.userMin || axis.min,
          max = axis.userMax || axis.max,
          pointRangePadding = pick$q(axis.pointRangePadding, 0),
          start,
          i; // Min & max check (#4247)

      each$o(breaks, function (brk) {
        repeat = brk.repeat || Infinity;

        if (axis.isInBreak(brk, min)) {
          min += brk.to % repeat - min % repeat;
        }

        if (axis.isInBreak(brk, max)) {
          max -= max % repeat - brk.from % repeat;
        }
      }); // Construct an array holding all breaks in the axis

      each$o(breaks, function (brk) {
        start = brk.from;
        repeat = brk.repeat || Infinity;

        while (start - repeat > min) {
          start -= repeat;
        }

        while (start < min) {
          start += repeat;
        }

        for (i = start; i < max; i += repeat) {
          breakArrayT.push({
            value: i,
            move: 'in'
          });
          breakArrayT.push({
            value: i + (brk.to - brk.from),
            move: 'out',
            size: brk.breakSize
          });
        }
      });
      breakArrayT.sort(function (a, b) {
        var ret;

        if (a.value === b.value) {
          ret = (a.move === 'in' ? 0 : 1) - (b.move === 'in' ? 0 : 1);
        } else {
          ret = a.value - b.value;
        }

        return ret;
      }); // Simplify the breaks

      inBrk = 0;
      start = min;
      each$o(breakArrayT, function (brk) {
        inBrk += brk.move === 'in' ? 1 : -1;

        if (inBrk === 1 && brk.move === 'in') {
          start = brk.value;
        }

        if (inBrk === 0) {
          breakArray.push({
            from: start,
            to: brk.value,
            len: brk.value - start - (brk.size || 0)
          });
          length += brk.value - start - (brk.size || 0);
        }
      });
      axis.breakArray = breakArray; // Used with staticScale, and below, the actual axis length when
      // breaks are substracted.

      axis.unitLength = max - min - length + pointRangePadding;
      fireEvent$9(axis, 'afterBreaks');

      if (axis.options.staticScale) {
        axis.transA = axis.options.staticScale;
      } else if (axis.unitLength) {
        axis.transA *= (max - axis.min + pointRangePadding) / axis.unitLength;
      }

      if (pointRangePadding) {
        axis.minPixelPadding = axis.transA * axis.minPointOffset;
      }

      axis.min = min;
      axis.max = max;
    };
  }
});
wrap$6(Series$9.prototype, 'generatePoints', function (proceed) {
  proceed.apply(this, stripArguments(arguments));
  var series = this,
      xAxis = series.xAxis,
      yAxis = series.yAxis,
      points = series.points,
      point,
      i = points.length,
      connectNulls = series.options.connectNulls,
      nullGap;

  if (xAxis && yAxis && (xAxis.options.breaks || yAxis.options.breaks)) {
    while (i--) {
      point = points[i]; // Respect nulls inside the break (#4275)

      nullGap = point.y === null && connectNulls === false;

      if (!nullGap && (xAxis.isInAnyBreak(point.x, true) || yAxis.isInAnyBreak(point.y, true))) {
        points.splice(i, 1);

        if (this.data[i]) {
          // Removes the graphics for this point if they exist
          this.data[i].destroyElements();
        }
      }
    }
  }
});

function drawPointsWrapped(proceed) {
  proceed.apply(this);
  this.drawBreaks(this.xAxis, ['x']);
  this.drawBreaks(this.yAxis, pick$q(this.pointArrayMap, ['y']));
}

Highcharts.Series.prototype.drawBreaks = function (axis, keys) {
  var series = this,
      points = series.points,
      breaks,
      threshold,
      eventName,
      y;

  if (!axis) {
    return; // #5950
  }

  each$o(keys, function (key) {
    breaks = axis.breakArray || [];
    threshold = axis.isXAxis ? axis.min : pick$q(series.options.threshold, axis.min);
    each$o(points, function (point) {
      y = pick$q(point['stack' + key.toUpperCase()], point[key]);
      each$o(breaks, function (brk) {
        eventName = false;

        if (threshold < brk.from && y > brk.to || threshold > brk.from && y < brk.from) {
          eventName = 'pointBreak';
        } else if (threshold < brk.from && y > brk.from && y < brk.to || threshold > brk.from && y > brk.to && y < brk.from) {
          eventName = 'pointInBreak';
        }

        if (eventName) {
          fireEvent$9(axis, eventName, {
            point: point,
            brk: brk
          });
        }
      });
    });
  });
};
/**
 * Extend getGraphPath by identifying gaps in the data so that we can draw a gap
 * in the line or area. This was moved from ordinal axis module to broken axis
 * module as of #5045.
 */


Highcharts.Series.prototype.gappedPath = function () {
  var currentDataGrouping = this.currentDataGrouping,
      groupingSize = currentDataGrouping && currentDataGrouping.totalRange,
      gapSize = this.options.gapSize,
      points = this.points.slice(),
      i = points.length - 1,
      yAxis = this.yAxis,
      xRange,
      stack;
  /**
   * Defines when to display a gap in the graph, together with the
   * [gapUnit](plotOptions.series.gapUnit) option.
   *
   * In case when `dataGrouping` is enabled, points can be grouped into a
   * larger time span. This can make the grouped points to have a greater
   * distance than the absolute value of `gapSize` property, which will result
   * in disappearing graph completely. To prevent this situation the mentioned
   * distance between grouped points is used instead of previously defined
   * `gapSize`.
   *
   * In practice, this option is most often used to visualize gaps in
   * time series. In a stock chart, intraday data is available for daytime
   * hours, while gaps will appear in nights and weekends.
   *
   * @type    {Number}
   * @see     [gapUnit](plotOptions.series.gapUnit) and
   *          [xAxis.breaks](#xAxis.breaks)
   * @sample  {highstock} stock/plotoptions/series-gapsize/
   *          Setting the gap size to 2 introduces gaps for weekends in daily
   *          datasets.
   * @default 0
   * @product highstock
   * @apioption plotOptions.series.gapSize
   */

  /**
   * Together with [gapSize](plotOptions.series.gapSize), this option defines
   * where to draw gaps in the graph.
   *
   * When the `gapUnit` is `relative` (default), a gap size of 5 means
   * that if the distance between two points is greater than five times
   * that of the two closest points, the graph will be broken.
   *
   * When the `gapUnit` is `value`, the gap is based on absolute axis values,
   * which on a datetime axis is milliseconds. This also applies to the
   * navigator series that inherits gap options from the base series.
   *
   * @type {String}
   * @see [gapSize](plotOptions.series.gapSize)
   * @default relative
   * @validvalue ["relative", "value"]
   * @since 5.0.13
   * @product highstock
   * @apioption plotOptions.series.gapUnit
   */

  if (gapSize && i > 0) {
    // #5008
    // Gap unit is relative
    if (this.options.gapUnit !== 'value') {
      gapSize *= this.closestPointRange;
    } // Setting a new gapSize in case dataGrouping is enabled (#7686)


    if (groupingSize && groupingSize > gapSize) {
      gapSize = groupingSize;
    } // extension for ordinal breaks


    while (i--) {
      if (points[i + 1].x - points[i].x > gapSize) {
        xRange = (points[i].x + points[i + 1].x) / 2;
        points.splice( // insert after this one
        i + 1, 0, {
          isNull: true,
          x: xRange
        }); // For stacked chart generate empty stack items, #6546

        if (this.options.stacking) {
          stack = yAxis.stacks[this.stackKey][xRange] = new Highcharts.StackItem(yAxis, yAxis.options.stackLabels, false, xRange, this.stack);
          stack.total = 0;
        }
      }
    }
  } // Call base method


  return this.getGraphPath(points);
};

wrap$6(Highcharts.seriesTypes.column.prototype, 'drawPoints', drawPointsWrapped);
wrap$6(Highcharts.Series.prototype, 'drawPoints', drawPointsWrapped);

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 *
 * (c) 2009-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$f = Highcharts.addEvent,
    arrayMax$4 = Highcharts.arrayMax,
    arrayMin$3 = Highcharts.arrayMin,
    Axis$8 = Highcharts.Axis,
    defaultPlotOptions$3 = Highcharts.defaultPlotOptions,
    defined$f = Highcharts.defined,
    each$p = Highcharts.each,
    extend$i = Highcharts.extend,
    format$5 = Highcharts.format,
    isNumber$b = Highcharts.isNumber,
    merge$f = Highcharts.merge,
    pick$r = Highcharts.pick,
    Point$5 = Highcharts.Point,
    Series$a = Highcharts.Series,
    Tooltip$1 = Highcharts.Tooltip,
    wrap$7 = Highcharts.wrap;
/* ****************************************************************************
 * Start data grouping module                                                 *
 ******************************************************************************/

/**
 * Data grouping is the concept of sampling the data values into larger
 * blocks in order to ease readability and increase performance of the
 * JavaScript charts. Highstock by default applies data grouping when
 * the points become closer than a certain pixel value, determined by
 * the `groupPixelWidth` option.
 *
 * If data grouping is applied, the grouping information of grouped
 * points can be read from the [Point.dataGroup](
 * /class-reference/Highcharts.Point#.dataGroup). If point options other than
 * the data itself are set, for example `name` or `color` or custom properties,
 * the grouping logic doesn't know how to group it. In this case the options of
 * the first point instance are copied over to the group point. This can be
 * altered through a custom `approximation` callback function.
 *
 * @product highstock
 * @apioption plotOptions.series.dataGrouping
 */

/**
 * The method of approximation inside a group. When for example 30 days
 * are grouped into one month, this determines what value should represent
 * the group. Possible values are "average", "averages", "open", "high",
 * "low", "close" and "sum". For OHLC and candlestick series the approximation
 * is "ohlc" by default, which finds the open, high, low and close values
 * within all the grouped data. For ranges, the approximation is "range",
 * which finds the low and high values. For multi-dimensional data,
 * like ranges and OHLC, "averages" will compute the average for each
 * dimension.
 *
 * Custom aggregate methods can be added by assigning a callback function
 * as the approximation. This function takes a numeric array as the
 * argument and should return a single numeric value or `null`. Note
 * that the numeric array will never contain null values, only true
 * numbers. Instead, if null values are present in the raw data, the
 * numeric array will have an `.hasNulls` property set to `true`. For
 * single-value data sets the data is available in the first argument
 * of the callback function. For OHLC data sets, all the open values
 * are in the first argument, all high values in the second etc.
 *
 * Since v4.2.7, grouping meta data is available in the approximation
 * callback from `this.dataGroupInfo`. It can be used to extract information
 * from the raw data.
 *
 * Defaults to `average` for line-type series, `sum` for columns, `range`
 * for range series and `ohlc` for OHLC and candlestick.
 *
 * @validvalue ["average", "averages", "open", "high", "low", "close", "sum"]
 * @type {String|Function}
 * @sample {highstock} stock/plotoptions/series-datagrouping-approximation
 *         Approximation callback with custom data
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.approximation
 */

/**
 * Datetime formats for the header of the tooltip in a stock chart.
 * The format can vary within a chart depending on the currently selected
 * time range and the current data grouping.
 *
 * The default formats are:
 *
 * <pre>{
 *     millisecond: [
 *         '%A, %b %e, %H:%M:%S.%L', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L'
 *     ],
 *     second: ['%A, %b %e, %H:%M:%S', '%A, %b %e, %H:%M:%S', '-%H:%M:%S'],
 *     minute: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
 *     hour: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
 *     day: ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
 *     week: ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
 *     month: ['%B %Y', '%B', '-%B %Y'],
 *     year: ['%Y', '%Y', '-%Y']
 * }</pre>
 *
 * For each of these array definitions, the first item is the format
 * used when the active time span is one unit. For instance, if the
 * current data applies to one week, the first item of the week array
 * is used. The second and third items are used when the active time
 * span is more than two units. For instance, if the current data applies
 * to two weeks, the second and third item of the week array are used,
 *  and applied to the start and end date of the time span.
 *
 * @type {Object}
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.dateTimeLabelFormats
 */

/**
 * Enable or disable data grouping.
 *
 * @type {Boolean}
 * @default true
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.enabled
 */

/**
 * When data grouping is forced, it runs no matter how small the intervals
 * are. This can be handy for example when the sum should be calculated
 * for values appearing at random times within each hour.
 *
 * @type {Boolean}
 * @default false
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.forced
 */

/**
 * The approximate pixel width of each group. If for example a series
 * with 30 points is displayed over a 600 pixel wide plot area, no grouping
 * is performed. If however the series contains so many points that
 * the spacing is less than the groupPixelWidth, Highcharts will try
 * to group it into appropriate groups so that each is more or less
 * two pixels wide. If multiple series with different group pixel widths
 * are drawn on the same x axis, all series will take the greatest width.
 * For example, line series have 2px default group width, while column
 * series have 10px. If combined, both the line and the column will
 * have 10px by default.
 *
 * @type {Number}
 * @default 2
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.groupPixelWidth
 */

/**
* By default only points within the visible range are grouped. Enabling this
* option will force data grouping to calculate all grouped points for a given
* dataset. That option prevents for example a column series from calculating
* a grouped point partially. The effect is similar to
* [Series.getExtremesFromAll](#plotOptions.series.getExtremesFromAll) but does
* not affect yAxis extremes.
*
* @type {Boolean}
* @sample {highstock} stock/plotoptions/series-datagrouping-groupall/
*         Two series with the same data but different groupAll setting
* @default false
* @since 6.1.0
* @product highstock
* @apioption plotOptions.series.dataGrouping.groupAll
*/

/**
 * Normally, a group is indexed by the start of that group, so for example
 * when 30 daily values are grouped into one month, that month's x value
 * will be the 1st of the month. This apparently shifts the data to
 * the left. When the smoothed option is true, this is compensated for.
 * The data is shifted to the middle of the group, and min and max
 * values are preserved. Internally, this is used in the Navigator series.
 *
 * @type {Boolean}
 * @default false
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.smoothed
 */

/**
 * An array determining what time intervals the data is allowed to be
 * grouped to. Each array item is an array where the first value is
 * the time unit and the second value another array of allowed multiples.
 * Defaults to:
 *
 * <pre>units: [[
 *     'millisecond', // unit name
 *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
 * ], [
 *     'second',
 *     [1, 2, 5, 10, 15, 30]
 * ], [
 *     'minute',
 *     [1, 2, 5, 10, 15, 30]
 * ], [
 *     'hour',
 *     [1, 2, 3, 4, 6, 8, 12]
 * ], [
 *     'day',
 *     [1]
 * ], [
 *     'week',
 *     [1]
 * ], [
 *     'month',
 *     [1, 3, 6]
 * ], [
 *     'year',
 *     null
 * ]]</pre>
 *
 * @type {Array}
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.units
 */

/**
 * The approximate pixel width of each group. If for example a series
 * with 30 points is displayed over a 600 pixel wide plot area, no grouping
 * is performed. If however the series contains so many points that
 * the spacing is less than the groupPixelWidth, Highcharts will try
 * to group it into appropriate groups so that each is more or less
 * two pixels wide. Defaults to `10`.
 *
 * @type {Number}
 * @sample {highstock} stock/plotoptions/series-datagrouping-grouppixelwidth/
 *         Two series with the same data density but different groupPixelWidth
 * @default 10
 * @product highstock
 * @apioption plotOptions.column.dataGrouping.groupPixelWidth
 */

var seriesProto = Series$a.prototype,
    baseProcessData = seriesProto.processData,
    baseGeneratePoints = seriesProto.generatePoints,

/**
 *
 */
commonOptions = {
  approximation: 'average',
  // average, open, high, low, close, sum
  // enabled: null, // (true for stock charts, false for basic),
  // forced: undefined,
  groupPixelWidth: 2,
  // the first one is the point or start value, the second is the start
  // value if we're dealing with range, the third one is the end value if
  // dealing with a range
  dateTimeLabelFormats: {
    millisecond: ['%A, %b %e, %H:%M:%S.%L', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L'],
    second: ['%A, %b %e, %H:%M:%S', '%A, %b %e, %H:%M:%S', '-%H:%M:%S'],
    minute: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
    hour: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
    day: ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
    week: ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
    month: ['%B %Y', '%B', '-%B %Y'],
    year: ['%Y', '%Y', '-%Y'] // smoothed = false, // enable this for navigator series only

  }
},
    specificOptions = {
  // extends common options
  line: {},
  spline: {},
  area: {},
  areaspline: {},
  column: {
    approximation: 'sum',
    groupPixelWidth: 10
  },
  arearange: {
    approximation: 'range'
  },
  areasplinerange: {
    approximation: 'range'
  },
  columnrange: {
    approximation: 'range',
    groupPixelWidth: 10
  },
  candlestick: {
    approximation: 'ohlc',
    groupPixelWidth: 10
  },
  ohlc: {
    approximation: 'ohlc',
    groupPixelWidth: 5
  }
},
    // units are defined in a separate array to allow complete overriding in
// case of a user option
defaultDataGroupingUnits = Highcharts.defaultDataGroupingUnits = [['millisecond', // unit name
[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
], ['second', [1, 2, 5, 10, 15, 30]], ['minute', [1, 2, 5, 10, 15, 30]], ['hour', [1, 2, 3, 4, 6, 8, 12]], ['day', [1]], ['week', [1]], ['month', [1, 3, 6]], ['year', null]],

/**
 * Define the available approximation types. The data grouping
 * approximations takes an array or numbers as the first parameter. In case
 * of ohlc, four arrays are sent in as four parameters. Each array consists
 * only of numbers. In case null values belong to the group, the property
 * .hasNulls will be set to true on the array.
 */
approximations = Highcharts.approximations = {
  sum: function (arr) {
    var len = arr.length,
        ret; // 1. it consists of nulls exclusively

    if (!len && arr.hasNulls) {
      ret = null; // 2. it has a length and real values
    } else if (len) {
      ret = 0;

      while (len--) {
        ret += arr[len];
      }
    } // 3. it has zero length, so just return undefined
    // => doNothing()


    return ret;
  },
  average: function (arr) {
    var len = arr.length,
        ret = approximations.sum(arr); // If we have a number, return it divided by the length. If not,
    // return null or undefined based on what the sum method finds.

    if (isNumber$b(ret) && len) {
      ret = ret / len;
    }

    return ret;
  },
  // The same as average, but for series with multiple values, like area
  // ranges.
  averages: function () {
    // #5479
    var ret = [];
    each$p(arguments, function (arr) {
      ret.push(approximations.average(arr));
    }); // Return undefined when first elem. is undefined and let
    // sum method handle null (#7377)

    return ret[0] === undefined ? undefined : ret;
  },
  open: function (arr) {
    return arr.length ? arr[0] : arr.hasNulls ? null : undefined;
  },
  high: function (arr) {
    return arr.length ? arrayMax$4(arr) : arr.hasNulls ? null : undefined;
  },
  low: function (arr) {
    return arr.length ? arrayMin$3(arr) : arr.hasNulls ? null : undefined;
  },
  close: function (arr) {
    return arr.length ? arr[arr.length - 1] : arr.hasNulls ? null : undefined;
  },
  // ohlc and range are special cases where a multidimensional array is
  // input and an array is output
  ohlc: function (open, high, low, close) {
    open = approximations.open(open);
    high = approximations.high(high);
    low = approximations.low(low);
    close = approximations.close(close);

    if (isNumber$b(open) || isNumber$b(high) || isNumber$b(low) || isNumber$b(close)) {
      return [open, high, low, close];
    } // else, return is undefined

  },
  range: function (low, high) {
    low = approximations.low(low);
    high = approximations.high(high);

    if (isNumber$b(low) || isNumber$b(high)) {
      return [low, high];
    } else if (low === null && high === null) {
      return null;
    } // else, return is undefined

  }
};
/**
 * Takes parallel arrays of x and y data and groups the data into intervals
 * defined by groupPositions, a collection of starting x values for each group.
 */

seriesProto.groupData = function (xData, yData, groupPositions, approximation) {
  var series = this,
      data = series.data,
      dataOptions = series.options.data,
      groupedXData = [],
      groupedYData = [],
      groupMap = [],
      dataLength = xData.length,
      pointX,
      pointY,
      groupedY,
      // when grouping the fake extended axis for panning,
  // we don't need to consider y
  handleYData = !!yData,
      values = [],
      approximationFn = typeof approximation === 'function' ? approximation : approximations[approximation] || // if the approximation is not found use default series type
  // approximation (#2914)
  specificOptions[series.type] && approximations[specificOptions[series.type].approximation] || approximations[commonOptions.approximation],
      pointArrayMap = series.pointArrayMap,
      pointArrayMapLength = pointArrayMap && pointArrayMap.length,
      extendedPointArrayMap = ['x'].concat(pointArrayMap || ['y']),
      pos = 0,
      start = 0,
      valuesLen,
      i,
      j; // Calculate values array size from pointArrayMap length

  if (pointArrayMapLength) {
    each$p(pointArrayMap, function () {
      values.push([]);
    });
  } else {
    values.push([]);
  }

  valuesLen = pointArrayMapLength || 1; // Start with the first point within the X axis range (#2696)

  for (i = 0; i <= dataLength; i++) {
    if (xData[i] >= groupPositions[0]) {
      break;
    }
  }

  for (i; i <= dataLength; i++) {
    // when a new group is entered, summarize and initiate
    // the previous group
    while (groupPositions[pos + 1] !== undefined && xData[i] >= groupPositions[pos + 1] || i === dataLength) {
      // get the last group
      // get group x and y
      pointX = groupPositions[pos];
      series.dataGroupInfo = {
        start: start,
        length: values[0].length
      };
      groupedY = approximationFn.apply(series, values); // By default, let options of the first grouped point be passed over
      // to the grouped point. This allows preserving properties like
      // `name` and `color` or custom properties. Implementers can
      // override this from the approximation function, where they can
      // write custom options to `this.dataGroupInfo.options`.

      if (!defined$f(series.dataGroupInfo.options)) {
        // Convert numbers and arrays into objects
        series.dataGroupInfo.options = series.pointClass.prototype.optionsToObject.call({
          series: series
        }, series.options.data[start]); // Make sure the raw data (x, y, open, high etc) is not copied
        // over and overwriting approximated data.

        each$p(extendedPointArrayMap, function (key) {
          delete series.dataGroupInfo.options[key];
        });
      } // push the grouped data


      if (groupedY !== undefined) {
        groupedXData.push(pointX);
        groupedYData.push(groupedY);
        groupMap.push(series.dataGroupInfo);
      } // reset the aggregate arrays


      start = i;

      for (j = 0; j < valuesLen; j++) {
        values[j].length = 0; // faster than values[j] = []

        values[j].hasNulls = false;
      } // Advance on the group positions


      pos += 1; // don't loop beyond the last group

      if (i === dataLength) {
        break;
      }
    } // break out


    if (i === dataLength) {
      break;
    } // for each raw data point, push it to an array that contains all values
    // for this specific group


    if (pointArrayMap) {
      var index = series.cropStart + i,
          point = data && data[index] || series.pointClass.prototype.applyOptions.apply({
        series: series
      }, [dataOptions[index]]),
          val;

      for (j = 0; j < pointArrayMapLength; j++) {
        val = point[pointArrayMap[j]];

        if (isNumber$b(val)) {
          values[j].push(val);
        } else if (val === null) {
          values[j].hasNulls = true;
        }
      }
    } else {
      pointY = handleYData ? yData[i] : null;

      if (isNumber$b(pointY)) {
        values[0].push(pointY);
      } else if (pointY === null) {
        values[0].hasNulls = true;
      }
    }
  }

  return [groupedXData, groupedYData, groupMap];
};
/**
 * Extend the basic processData method, that crops the data to the current zoom
 * range, with data grouping logic.
 */


seriesProto.processData = function () {
  var series = this,
      chart = series.chart,
      options = series.options,
      dataGroupingOptions = options.dataGrouping,
      groupingEnabled = series.allowDG !== false && dataGroupingOptions && pick$r(dataGroupingOptions.enabled, chart.options.isStock),
      visible = series.visible || !chart.options.chart.ignoreHiddenSeries,
      hasGroupedData,
      skip,
      lastDataGrouping = this.currentDataGrouping,
      currentDataGrouping,
      croppedData; // Run base method

  series.forceCrop = groupingEnabled; // #334

  series.groupPixelWidth = null; // #2110

  series.hasProcessed = true; // #2692
  // Skip if processData returns false or if grouping is disabled (in that
  // order)

  skip = baseProcessData.apply(series, arguments) === false || !groupingEnabled;

  if (!skip) {
    series.destroyGroupedData();
    var i,
        processedXData = dataGroupingOptions.groupAll ? series.xData : series.processedXData,
        processedYData = dataGroupingOptions.groupAll ? series.yData : series.processedYData,
        plotSizeX = chart.plotSizeX,
        xAxis = series.xAxis,
        ordinal = xAxis.options.ordinal,
        groupPixelWidth = series.groupPixelWidth = xAxis.getGroupPixelWidth && xAxis.getGroupPixelWidth(); // Execute grouping if the amount of points is greater than the limit
    // defined in groupPixelWidth

    if (groupPixelWidth) {
      hasGroupedData = true; // Force recreation of point instances in series.translate, #5699

      series.isDirty = true;
      series.points = null; // #6709

      var extremes = xAxis.getExtremes(),
          xMin = extremes.min,
          xMax = extremes.max,
          groupIntervalFactor = ordinal && xAxis.getGroupIntervalFactor(xMin, xMax, series) || 1,
          interval = groupPixelWidth * (xMax - xMin) / plotSizeX * groupIntervalFactor,
          groupPositions = xAxis.getTimeTicks(xAxis.normalizeTimeTickInterval(interval, dataGroupingOptions.units || defaultDataGroupingUnits), // Processed data may extend beyond axis (#4907)
      Math.min(xMin, processedXData[0]), Math.max(xMax, processedXData[processedXData.length - 1]), xAxis.options.startOfWeek, processedXData, series.closestPointRange),
          groupedData = seriesProto.groupData.apply(series, [processedXData, processedYData, groupPositions, dataGroupingOptions.approximation]),
          groupedXData = groupedData[0],
          groupedYData = groupedData[1]; // Prevent the smoothed data to spill out left and right, and make
      // sure data is not shifted to the left

      if (dataGroupingOptions.smoothed && groupedXData.length) {
        i = groupedXData.length - 1;
        groupedXData[i] = Math.min(groupedXData[i], xMax);

        while (i-- && i > 0) {
          groupedXData[i] += interval / 2;
        }

        groupedXData[0] = Math.max(groupedXData[0], xMin);
      } // Record what data grouping values were used


      currentDataGrouping = groupPositions.info;
      series.closestPointRange = groupPositions.info.totalRange;
      series.groupMap = groupedData[2]; // Make sure the X axis extends to show the first group (#2533)
      // But only for visible series (#5493, #6393)

      if (defined$f(groupedXData[0]) && groupedXData[0] < xAxis.dataMin && visible) {
        if (!defined$f(xAxis.options.min) && xAxis.min <= xAxis.dataMin || xAxis.min === xAxis.dataMin) {
          xAxis.min = groupedXData[0];
        }

        xAxis.dataMin = groupedXData[0];
      } // We calculated all group positions but we should render
      // only the ones within the visible range


      if (dataGroupingOptions.groupAll) {
        croppedData = series.cropData(groupedXData, groupedYData, xAxis.min, xAxis.max, 1 // Ordinal xAxis will remove left-most points otherwise
        );
        groupedXData = croppedData.xData;
        groupedYData = croppedData.yData;
      } // Set series props


      series.processedXData = groupedXData;
      series.processedYData = groupedYData;
    } else {
      series.groupMap = null;
    }

    series.hasGroupedData = hasGroupedData;
    series.currentDataGrouping = currentDataGrouping;
    series.preventGraphAnimation = (lastDataGrouping && lastDataGrouping.totalRange) !== (currentDataGrouping && currentDataGrouping.totalRange);
  }
};
/**
 * Destroy the grouped data points. #622, #740
 */


seriesProto.destroyGroupedData = function () {
  var groupedData = this.groupedData; // clear previous groups

  each$p(groupedData || [], function (point, i) {
    if (point) {
      groupedData[i] = point.destroy ? point.destroy() : null;
    }
  });
  this.groupedData = null;
};
/**
 * Override the generatePoints method by adding a reference to grouped data
 */


seriesProto.generatePoints = function () {
  baseGeneratePoints.apply(this); // Record grouped data in order to let it be destroyed the next time
  // processData runs

  this.destroyGroupedData(); // #622

  this.groupedData = this.hasGroupedData ? this.points : null;
};
/**
 * Override point prototype to throw a warning when trying to update grouped
 * points
 */


addEvent$f(Point$5, 'update', function () {
  if (this.dataGroup) {
    Highcharts.error(24);
    return false;
  }
});
/**
 * Extend the original method, make the tooltip's header reflect the grouped
 * range
 */

wrap$7(Tooltip$1.prototype, 'tooltipFooterHeaderFormatter', function (proceed, labelConfig, isFooter) {
  var tooltip = this,
      time = this.chart.time,
      series = labelConfig.series,
      options = series.options,
      tooltipOptions = series.tooltipOptions,
      dataGroupingOptions = options.dataGrouping,
      xDateFormat = tooltipOptions.xDateFormat,
      xDateFormatEnd,
      xAxis = series.xAxis,
      currentDataGrouping,
      dateTimeLabelFormats,
      labelFormats,
      formattedKey; // apply only to grouped series

  if (xAxis && xAxis.options.type === 'datetime' && dataGroupingOptions && isNumber$b(labelConfig.key)) {
    // set variables
    currentDataGrouping = series.currentDataGrouping;
    dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats; // if we have grouped data, use the grouping information to get the
    // right format

    if (currentDataGrouping) {
      labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];

      if (currentDataGrouping.count === 1) {
        xDateFormat = labelFormats[0];
      } else {
        xDateFormat = labelFormats[1];
        xDateFormatEnd = labelFormats[2];
      } // if not grouped, and we don't have set the xDateFormat option, get the
      // best fit, so if the least distance between points is one minute, show
      // it, but if the least distance is one day, skip hours and minutes etc.

    } else if (!xDateFormat && dateTimeLabelFormats) {
      xDateFormat = tooltip.getXDateFormat(labelConfig, tooltipOptions, xAxis);
    } // now format the key


    formattedKey = time.dateFormat(xDateFormat, labelConfig.key);

    if (xDateFormatEnd) {
      formattedKey += time.dateFormat(xDateFormatEnd, labelConfig.key + currentDataGrouping.totalRange - 1);
    } // return the replaced format


    return format$5(tooltipOptions[(isFooter ? 'footer' : 'header') + 'Format'], {
      point: extend$i(labelConfig.point, {
        key: formattedKey
      }),
      series: series
    }, time);
  } // else, fall back to the regular formatter


  return proceed.call(tooltip, labelConfig, isFooter);
});
/**
 * Destroy grouped data on series destroy
 */

addEvent$f(Series$a, 'destroy', seriesProto.destroyGroupedData); // Handle default options for data grouping. This must be set at runtime because
// some series types are defined after this.

addEvent$f(Series$a, 'afterSetOptions', function (e) {
  var options = e.options,
      type = this.type,
      plotOptions = this.chart.options.plotOptions,
      defaultOptions = defaultPlotOptions$3[type].dataGrouping,
      // External series, for example technical indicators should also
  // inherit commonOptions which are not available outside this module
  baseOptions = this.useCommonDataGrouping && commonOptions;

  if (specificOptions[type] || baseOptions) {
    // #1284
    if (!defaultOptions) {
      defaultOptions = merge$f(commonOptions, specificOptions[type]);
    }

    options.dataGrouping = merge$f(baseOptions, defaultOptions, plotOptions.series && plotOptions.series.dataGrouping, // #1228
    plotOptions[type].dataGrouping, // Set by the StockChart constructor
    this.userOptions.dataGrouping);
  }

  if (this.chart.options.isStock) {
    this.requireSorting = true;
  }
});
/**
 * When resetting the scale reset the hasProccessed flag to avoid taking
 * previous data grouping of neighbour series into accound when determining
 * group pixel width (#2692).
 */

addEvent$f(Axis$8, 'afterSetScale', function () {
  each$p(this.series, function (series) {
    series.hasProcessed = false;
  });
});
/**
 * Get the data grouping pixel width based on the greatest defined individual
 * width
 * of the axis' series, and if whether one of the axes need grouping.
 */

Axis$8.prototype.getGroupPixelWidth = function () {
  var series = this.series,
      len = series.length,
      i,
      groupPixelWidth = 0,
      doGrouping = false,
      dataLength,
      dgOptions; // If multiple series are compared on the same x axis, give them the same
  // group pixel width (#334)

  i = len;

  while (i--) {
    dgOptions = series[i].options.dataGrouping;

    if (dgOptions) {
      groupPixelWidth = Math.max(groupPixelWidth, dgOptions.groupPixelWidth);
    }
  } // If one of the series needs grouping, apply it to all (#1634)


  i = len;

  while (i--) {
    dgOptions = series[i].options.dataGrouping;

    if (dgOptions && series[i].hasProcessed) {
      // #2692
      dataLength = (series[i].processedXData || series[i].data).length; // Execute grouping if the amount of points is greater than the
      // limit defined in groupPixelWidth

      if (series[i].groupPixelWidth || dataLength > this.chart.plotSizeX / groupPixelWidth || dataLength && dgOptions.forced) {
        doGrouping = true;
      }
    }
  }

  return doGrouping ? groupPixelWidth : 0;
};
/**
 * Highstock only. Force data grouping on all the axis' series.
 *
 * @param  {SeriesDatagroupingOptions} [dataGrouping]
 *         A `dataGrouping` configuration. Use `false` to disable data grouping
 *         dynamically.
 * @param  {Boolean} [redraw=true]
 *         Whether to redraw the chart or wait for a later call to {@link
 *         Chart#redraw}.
 *
 * @function setDataGrouping
 * @memberof Axis.prototype
 */


Axis$8.prototype.setDataGrouping = function (dataGrouping, redraw) {
  var i;
  redraw = pick$r(redraw, true);

  if (!dataGrouping) {
    dataGrouping = {
      forced: false,
      units: null
    };
  } // Axis is instantiated, update all series


  if (this instanceof Axis$8) {
    i = this.series.length;

    while (i--) {
      this.series[i].update({
        dataGrouping: dataGrouping
      }, false);
    } // Axis not yet instanciated, alter series options

  } else {
    each$p(this.chart.options.series, function (seriesOptions) {
      seriesOptions.dataGrouping = dataGrouping;
    }, false);
  } // Clear ordinal slope, so we won't accidentaly use the old one (#7827)


  this.ordinalSlope = null;

  if (redraw) {
    this.chart.redraw();
  }
};
/* ****************************************************************************
 * End data grouping module                                                   *
 ******************************************************************************/

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var each$q = Highcharts.each,
    Point$6 = Highcharts.Point,
    seriesType$7 = Highcharts.seriesType,
    seriesTypes$5 = Highcharts.seriesTypes;
/**
 * The ohlc series type.
 *
 * @constructor seriesTypes.ohlc
 * @augments seriesTypes.column
 */

/**
 * An OHLC chart is a style of financial chart used to describe price
 * movements over time. It displays open, high, low and close values per data
 * point.
 *
 * @sample stock/demo/ohlc/ OHLC chart
 * @extends plotOptions.column
 * @excluding borderColor,borderRadius,borderWidth,crisp,stacking,stack
 * @product highstock
 * @optionparent plotOptions.ohlc
 */

seriesType$7('ohlc', 'column', {
  /**
   * The approximate pixel width of each group. If for example a series
   * with 30 points is displayed over a 600 pixel wide plot area, no grouping
   * is performed. If however the series contains so many points that
   * the spacing is less than the groupPixelWidth, Highcharts will try
   * to group it into appropriate groups so that each is more or less
   * two pixels wide. Defaults to `5`.
   *
   * @type {Number}
   * @default 5
   * @product highstock
   * @apioption plotOptions.ohlc.dataGrouping.groupPixelWidth
   */

  /**
   * The pixel width of the line/border. Defaults to `1`.
   *
   * @type {Number}
   * @sample {highstock} stock/plotoptions/ohlc-linewidth/
   *         A greater line width
   * @default 1
   * @product highstock
   */
  lineWidth: 1,
  tooltip: {
    pointFormat: '<span class="highcharts-color-{point.colorIndex}">\u25CF</span> <b> {series.name}</b><br/>' + 'Open: {point.open}<br/>' + 'High: {point.high}<br/>' + 'Low: {point.low}<br/>' + 'Close: {point.close}<br/>'
  },
  threshold: null,
  stickyTracking: true
},
/** @lends seriesTypes.ohlc */
{
  directTouch: false,
  pointArrayMap: ['open', 'high', 'low', 'close'],
  toYData: function (point) {
    // return a plain array for speedy calculation
    return [point.open, point.high, point.low, point.close];
  },
  pointValKey: 'close',

  /**
   * Translate data points from raw values x and y to plotX and plotY
   */
  translate: function () {
    var series = this,
        yAxis = series.yAxis,
        hasModifyValue = !!series.modifyValue,
        translated = ['plotOpen', 'plotHigh', 'plotLow', 'plotClose', 'yBottom']; // translate OHLC for

    seriesTypes$5.column.prototype.translate.apply(series); // Do the translation

    each$q(series.points, function (point) {
      each$q([point.open, point.high, point.low, point.close, point.low], function (value, i) {
        if (value !== null) {
          if (hasModifyValue) {
            value = series.modifyValue(value);
          }

          point[translated[i]] = yAxis.toPixels(value, true);
        }
      }); // Align the tooltip to the high value to avoid covering the point

      point.tooltipPos[1] = point.plotHigh + yAxis.pos - series.chart.plotTop;
    });
  },

  /**
   * Draw the data points
   */
  drawPoints: function () {
    var series = this,
        points = series.points,
        chart = series.chart;
    each$q(points, function (point) {
      var plotOpen,
          plotClose,
          crispCorr,
          halfWidth,
          path,
          graphic = point.graphic,
          crispX,
          isNew = !graphic;

      if (point.plotY !== undefined) {
        // Create and/or update the graphic
        if (!graphic) {
          point.graphic = graphic = chart.renderer.path().add(series.group);
        } // crisp vector coordinates


        crispCorr = graphic.strokeWidth() % 2 / 2;
        crispX = Math.round(point.plotX) - crispCorr; // #2596

        halfWidth = Math.round(point.shapeArgs.width / 2); // the vertical stem

        path = ['M', crispX, Math.round(point.yBottom), 'L', crispX, Math.round(point.plotHigh)]; // open

        if (point.open !== null) {
          plotOpen = Math.round(point.plotOpen) + crispCorr;
          path.push('M', crispX, plotOpen, 'L', crispX - halfWidth, plotOpen);
        } // close


        if (point.close !== null) {
          plotClose = Math.round(point.plotClose) + crispCorr;
          path.push('M', crispX, plotClose, 'L', crispX + halfWidth, plotClose);
        }

        graphic[isNew ? 'attr' : 'animate']({
          d: path
        }).addClass(point.getClassName(), true);
      }
    });
  },
  animate: null // Disable animation

},
/** @lends seriesTypes.ohlc.prototype.pointClass.prototype */
{
  /**
    * Extend the parent method by adding up or down to the class name.
    */
  getClassName: function () {
    return Point$6.prototype.getClassName.call(this) + (this.open < this.close ? ' highcharts-point-up' : ' highcharts-point-down');
  }
});
/**
 * A `ohlc` series. If the [type](#series.ohlc.type) option is not
 * specified, it is inherited from [chart.type](#chart.type).
 *
 * @type {Object}
 * @extends series,plotOptions.ohlc
 * @excluding dataParser,dataURL
 * @product highstock
 * @apioption series.ohlc
 */

/**
 * An array of data points for the series. For the `ohlc` series type,
 * points can be given in the following ways:
 *
 * 1.  An array of arrays with 5 or 4 values. In this case, the values
 * correspond to `x,open,high,low,close`. If the first value is a string,
 * it is applied as the name of the point, and the `x` value is inferred.
 * The `x` value can also be omitted, in which case the inner arrays
 * should be of length 4\. Then the `x` value is automatically calculated,
 * either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options.
 *
 *  ```js
 *     data: [
 *         [0, 6, 5, 6, 7],
 *         [1, 9, 4, 8, 2],
 *         [2, 6, 3, 4, 10]
 *     ]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.ohlc.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         open: 3,
 *         high: 4,
 *         low: 5,
 *         close: 2,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         open: 4,
 *         high: 3,
 *         low: 6,
 *         close: 7,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type {Array<Object|Array>}
 * @extends series.arearange.data
 * @excluding y,marker
 * @product highstock
 * @apioption series.ohlc.data
 */

/**
 * The closing value of each data point.
 *
 * @type {Number}
 * @product highstock
 * @apioption series.ohlc.data.close
 */

/**
 * The opening value of each data point.
 *
 * @type {Number}
 * @product highstock
 * @apioption series.ohlc.data.open
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var defaultPlotOptions$4 = Highcharts.defaultPlotOptions,
    each$r = Highcharts.each,
    merge$g = Highcharts.merge,
    seriesType$8 = Highcharts.seriesType,
    seriesTypes$6 = Highcharts.seriesTypes;
/**
 * A candlestick chart is a style of financial chart used to describe price
 * movements over time.
 *
 * @sample stock/demo/candlestick/ Candlestick chart
 *
 * @extends plotOptions.ohlc
 * @excluding borderColor,borderRadius,borderWidth
 * @product highstock
 * @optionparent plotOptions.candlestick
 */

var candlestickOptions = {
  /**
   * The specific line color for up candle sticks. The default is to inherit
   * the general `lineColor` setting.
   *
   * @type {Color}
   * @sample  {highstock} stock/plotoptions/candlestick-linecolor/
   *          Candlestick line colors
   * @default null
   * @since 1.3.6
   * @product highstock
   * @apioption plotOptions.candlestick.upLineColor
   */

  /**
   * @default ohlc
   * @apioption plotOptions.candlestick.dataGrouping.approximation
   */
  states: {
    /**
     * @extends plotOptions.column.states.hover
     * @product highstock
     */
    hover: {
      /**
       * The pixel width of the line/border around the candlestick.
       *
       * @type {Number}
       * @default 2
       * @product highstock
       */
      lineWidth: 2
    }
  },

  /**
   * @extends plotOptions.ohlc.tooltip
   */
  tooltip: defaultPlotOptions$4.ohlc.tooltip,
  threshold: null,
  stickyTracking: true
};
/**
 * The candlestick series type.
 *
 * @constructor seriesTypes.candlestick
 * @augments seriesTypes.ohlc
 */

seriesType$8('candlestick', 'ohlc', merge$g(defaultPlotOptions$4.column, candlestickOptions),
/** @lends seriesTypes.candlestick */
{
  /**
   * Draw the data points
   */
  drawPoints: function () {
    var series = this,
        points = series.points,
        chart = series.chart,
        reversedYAxis = series.yAxis.reversed;
    each$r(points, function (point) {
      var graphic = point.graphic,
          plotOpen,
          plotClose,
          topBox,
          bottomBox,
          hasTopWhisker,
          hasBottomWhisker,
          crispCorr,
          crispX,
          path,
          halfWidth,
          isNew = !graphic;

      if (point.plotY !== undefined) {
        if (!graphic) {
          point.graphic = graphic = chart.renderer.path().add(series.group);
        } // Crisp vector coordinates


        crispCorr = graphic.strokeWidth() % 2 / 2;
        crispX = Math.round(point.plotX) - crispCorr; // #2596

        plotOpen = point.plotOpen;
        plotClose = point.plotClose;
        topBox = Math.min(plotOpen, plotClose);
        bottomBox = Math.max(plotOpen, plotClose);
        halfWidth = Math.round(point.shapeArgs.width / 2);
        hasTopWhisker = reversedYAxis ? bottomBox !== point.yBottom : Math.round(topBox) !== Math.round(point.plotHigh);
        hasBottomWhisker = reversedYAxis ? Math.round(topBox) !== Math.round(point.plotHigh) : bottomBox !== point.yBottom;
        topBox = Math.round(topBox) + crispCorr;
        bottomBox = Math.round(bottomBox) + crispCorr; // Create the path. Due to a bug in Chrome 49, the path is first
        // instanciated with no values, then the values pushed. For
        // unknown reasons, instanciating the path array with all the
        // values would lead to a crash when updating frequently
        // (#5193).

        path = [];
        path.push('M', crispX - halfWidth, bottomBox, 'L', crispX - halfWidth, topBox, 'L', crispX + halfWidth, topBox, 'L', crispX + halfWidth, bottomBox, 'Z', // Ensure a nice rectangle #2602
        'M', crispX, topBox, 'L', // #460, #2094
        crispX, hasTopWhisker ? Math.round(reversedYAxis ? point.yBottom : point.plotHigh) : topBox, 'M', crispX, bottomBox, 'L', // #460, #2094
        crispX, hasBottomWhisker ? Math.round(reversedYAxis ? point.plotHigh : point.yBottom) : bottomBox);
        graphic[isNew ? 'attr' : 'animate']({
          d: path
        }).addClass(point.getClassName(), true);
      }
    });
  }
});
/**
 * A `candlestick` series. If the [type](#series.candlestick.type)
 * option is not specified, it is inherited from [chart.type](
 * #chart.type).
 *
 * @type {Object}
 * @extends series,plotOptions.candlestick
 * @excluding dataParser,dataURL
 * @product highstock
 * @apioption series.candlestick
 */

/**
 * An array of data points for the series. For the `candlestick` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of arrays with 5 or 4 values. In this case, the values
 * correspond to `x,open,high,low,close`. If the first value is a string,
 * it is applied as the name of the point, and the `x` value is inferred.
 * The `x` value can also be omitted, in which case the inner arrays
 * should be of length 4\. Then the `x` value is automatically calculated,
 * either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options.
 *
 *  ```js
 *     data: [
 *         [0, 7, 2, 0, 4],
 *         [1, 1, 4, 2, 8],
 *         [2, 3, 3, 9, 3]
 *     ]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](
 * #series.candlestick.turboThreshold), this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         open: 9,
 *         high: 2,
 *         low: 4,
 *         close: 6,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         open: 1,
 *         high: 4,
 *         low: 7,
 *         close: 7,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type {Array<Object|Array>}
 * @extends series.ohlc.data
 * @excluding y
 * @product highstock
 * @apioption series.candlestick.data
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var each$s = Highcharts.each,
    defined$g = Highcharts.defined,
    seriesTypes$7 = Highcharts.seriesTypes,
    stableSort$2 = Highcharts.stableSort;
var onSeriesMixin = {
  /**
   * Override getPlotBox. If the onSeries option is valid, return the plot box
   * of the onSeries, otherwise proceed as usual.
   */
  getPlotBox: function () {
    return Highcharts.Series.prototype.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this);
  },

  /**
   * Extend the translate method by placing the point on the related series
   */
  translate: function () {
    seriesTypes$7.column.prototype.translate.apply(this);
    var series = this,
        options = series.options,
        chart = series.chart,
        points = series.points,
        cursor = points.length - 1,
        point,
        lastPoint,
        optionsOnSeries = options.onSeries,
        onSeries = optionsOnSeries && chart.get(optionsOnSeries),
        onKey = options.onKey || 'y',
        step = onSeries && onSeries.options.step,
        onData = onSeries && onSeries.points,
        i = onData && onData.length,
        inverted = chart.inverted,
        xAxis = series.xAxis,
        yAxis = series.yAxis,
        xOffset = 0,
        leftPoint,
        lastX,
        rightPoint,
        currentDataGrouping,
        distanceRatio; // relate to a master series

    if (onSeries && onSeries.visible && i) {
      xOffset = (onSeries.pointXOffset || 0) + (onSeries.barW || 0) / 2;
      currentDataGrouping = onSeries.currentDataGrouping;
      lastX = onData[i - 1].x + (currentDataGrouping ? currentDataGrouping.totalRange : 0); // #2374
      // sort the data points

      stableSort$2(points, function (a, b) {
        return a.x - b.x;
      });
      onKey = 'plot' + onKey[0].toUpperCase() + onKey.substr(1);

      while (i-- && points[cursor]) {
        leftPoint = onData[i];
        point = points[cursor];
        point.y = leftPoint.y;

        if (leftPoint.x <= point.x && leftPoint[onKey] !== undefined) {
          if (point.x <= lastX) {
            // #803
            point.plotY = leftPoint[onKey]; // interpolate between points, #666

            if (leftPoint.x < point.x && !step) {
              rightPoint = onData[i + 1];

              if (rightPoint && rightPoint[onKey] !== undefined) {
                // the distance ratio, between 0 and 1
                distanceRatio = (point.x - leftPoint.x) / (rightPoint.x - leftPoint.x);
                point.plotY += distanceRatio * ( // the plotY distance
                rightPoint[onKey] - leftPoint[onKey]);
                point.y += distanceRatio * (rightPoint.y - leftPoint.y);
              }
            }
          }

          cursor--;
          i++; // check again for points in the same x position

          if (cursor < 0) {
            break;
          }
        }
      }
    } // Add plotY position and handle stacking


    each$s(points, function (point, i) {
      var stackIndex;
      point.plotX += xOffset; // #2049
      // Undefined plotY means the point is either on axis, outside series
      // range or hidden series. If the series is outside the range of the
      // x axis it should fall through with an undefined plotY, but then
      // we must remove the shapeArgs (#847). For inverted charts, we need
      // to calculate position anyway, because series.invertGroups is not
      // defined

      if (point.plotY === undefined || inverted) {
        if (point.plotX >= 0 && point.plotX <= xAxis.len) {
          // We're inside xAxis range
          if (inverted) {
            point.plotY = xAxis.translate(point.x, 0, 1, 0, 1);
            point.plotX = defined$g(point.y) ? yAxis.translate(point.y, 0, 0, 0, 1) : 0;
          } else {
            point.plotY = chart.chartHeight - xAxis.bottom - (xAxis.opposite ? xAxis.height : 0) + xAxis.offset - yAxis.top; // #3517
          }
        } else {
          point.shapeArgs = {}; // 847
        }
      } // if multiple flags appear at the same x, order them into a stack


      lastPoint = points[i - 1];

      if (lastPoint && lastPoint.plotX === point.plotX) {
        if (lastPoint.stackIndex === undefined) {
          lastPoint.stackIndex = 0;
        }

        stackIndex = lastPoint.stackIndex + 1;
      }

      point.stackIndex = stackIndex; // #3639
    });
    this.onSeries = onSeries;
  }
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$g = Highcharts.addEvent,
    each$t = Highcharts.each,
    merge$h = Highcharts.merge,
    noop$7 = Highcharts.noop,
    Renderer = Highcharts.Renderer,
    Series$b = Highcharts.Series,
    seriesType$9 = Highcharts.seriesType,
    SVGRenderer$2 = Highcharts.SVGRenderer,
    TrackerMixin$1 = Highcharts.TrackerMixin,
    VMLRenderer = Highcharts.VMLRenderer,
    symbols = SVGRenderer$2.prototype.symbols;
/**
 * The Flags series.
 *
 * @constructor seriesTypes.flags
 * @augments seriesTypes.column
 */

/**
 * Flags are used to mark events in stock charts. They can be added on the
 * timeline, or attached to a specific series.
 *
 * @sample       stock/demo/flags-general/ Flags on a line series
 * @extends      {plotOptions.column}
 * @excluding    animation,borderColor,borderRadius,borderWidth,colorByPoint,
 *               dataGrouping,pointPadding,pointWidth,turboThreshold
 * @product      highstock
 * @optionparent plotOptions.flags
 */

seriesType$9('flags', 'column', {
  /**
   * In case the flag is placed on a series, on what point key to place
   * it. Line and columns have one key, `y`. In range or OHLC-type series,
   * however, the flag can optionally be placed on the `open`, `high`,
   *  `low` or `close` key.
   *
   * @validvalue ["y", "open", "high", "low", "close"]
   * @type       {String}
   * @sample     {highstock} stock/plotoptions/flags-onkey/
   *             Range series, flag on high
   * @default    y
   * @since      4.2.2
   * @product    highstock
   * @apioption  plotOptions.flags.onKey
   */

  /**
   * The id of the series that the flags should be drawn on. If no id
   * is given, the flags are drawn on the x axis.
   *
   * @type      {String}
   * @sample    {highstock} stock/plotoptions/flags/
   *            Flags on series and on x axis
   * @default   undefined
   * @product   highstock
   * @apioption plotOptions.flags.onSeries
   */
  pointRange: 0,
  // #673

  /**
   * Whether the flags are allowed to overlap sideways. If `false`, the flags
   * are moved sideways using an algorithm that seeks to place every flag as
   * close as possible to its original position.
   *
   * @sample {highstock} stock/plotoptions/flags-allowoverlapx
   *         Allow sideways overlap
   * @since  6.0.4
   */
  allowOverlapX: false,

  /**
   * The shape of the marker. Can be one of "flag", "circlepin", "squarepin",
   * or an image of the format `url(/path-to-image.jpg)`. Individual
   * shapes can also be set for each point.
   *
   * @validvalue ["flag", "circlepin", "squarepin"]
   * @sample     {highstock} stock/plotoptions/flags/ Different shapes
   * @product    highstock
   */
  shape: 'flag',

  /**
   * When multiple flags in the same series fall on the same value, this
   * number determines the vertical offset between them.
   *
   * @sample  {highstock} stock/plotoptions/flags-stackdistance/
   *          A greater stack distance
   * @product highstock
   */
  stackDistance: 12,

  /**
   * Text alignment for the text inside the flag.
   *
   * @validvalue ["left", "center", "right"]
   * @since      5.0.0
   * @product    highstock
   */
  textAlign: 'center',

  /**
   * Specific tooltip options for flag series. Flag series tooltips are
   * different from most other types in that a flag doesn't have a data
   * value, so the tooltip rather displays the `text` option for each
   * point.
   *
   * @type      {Object}
   * @extends   plotOptions.series.tooltip
   * @excluding changeDecimals,valueDecimals,valuePrefix,valueSuffix
   * @product   highstock
   */
  tooltip: {
    pointFormat: '{point.text}<br/>'
  },
  threshold: null,

  /**
   * The text to display on each flag. This can be defined on series level,
   *  or individually for each point. Defaults to `"A"`.
   *
   * @type      {String}
   * @default   A
   * @product   highstock
   * @apioption plotOptions.flags.title
   */

  /**
   * The y position of the top left corner of the flag relative to either
   * the series (if onSeries is defined), or the x axis. Defaults to
   * `-30`.
   *
   * @product highstock
   */
  y: -30
  /**
   * Whether to use HTML to render the flag texts. Using HTML allows for
   * advanced formatting, images and reliable bi-directional text rendering.
   * Note that exported images won't respect the HTML, and that HTML
   * won't respect Z-index settings.
   *
   * @type      {Boolean}
   * @default   false
   * @since     1.3
   * @product   highstock
   * @apioption plotOptions.flags.useHTML
   */

  /**
   * Fixed width of the flag's shape. By default, width is autocalculated
   * according to the flag's title.
   *
   * @type      {Number}
   * @default   undefined
   * @product   highstock
   * @sample    {highstock} stock/demo/flags-shapes/ Flags with fixed width
   * @apioption plotOptions.flags.width
   */

  /**
  * Fixed height of the flag's shape. By default, height is autocalculated
  * according to the flag's title.
  *
  * @type      {Number}
  * @default   undefined
  * @product   highstock
  * @apioption plotOptions.flags.height
  */

},
/** @lends seriesTypes.flags.prototype */
{
  sorted: false,
  noSharedTooltip: true,
  allowDG: false,
  takeOrdinalPosition: false,
  // #1074
  trackerGroups: ['markerGroup'],
  forceCrop: true,

  /**
   * Inherit the initialization from base Series.
   */
  init: Series$b.prototype.init,
  translate: onSeriesMixin.translate,
  getPlotBox: onSeriesMixin.getPlotBox,

  /**
   * Draw the markers
   */
  drawPoints: function () {
    var series = this,
        points = series.points,
        chart = series.chart,
        renderer = chart.renderer,
        plotX,
        plotY,
        inverted = chart.inverted,
        options = series.options,
        optionsY = options.y,
        shape,
        i,
        point,
        graphic,
        stackIndex,
        anchorY,
        attribs,
        outsideRight,
        yAxis = series.yAxis,
        boxesMap = {},
        boxes = [];
    i = points.length;

    while (i--) {
      point = points[i];
      outsideRight = (inverted ? point.plotY : point.plotX) > series.xAxis.len;
      plotX = point.plotX;
      stackIndex = point.stackIndex;
      shape = point.options.shape || options.shape;
      plotY = point.plotY;

      if (plotY !== undefined) {
        plotY = point.plotY + optionsY - (stackIndex !== undefined && stackIndex * options.stackDistance);
      } // skip connectors for higher level stacked points


      point.anchorX = stackIndex ? undefined : point.plotX;
      anchorY = stackIndex ? undefined : point.plotY;
      graphic = point.graphic; // Only draw the point if y is defined and the flag is within
      // the visible area

      if (plotY !== undefined && plotX >= 0 && !outsideRight) {
        // Create the flag
        if (!graphic) {
          graphic = point.graphic = renderer.label('', null, null, shape, null, null, options.useHTML).attr({
            align: shape === 'flag' ? 'left' : 'center',
            width: options.width,
            height: options.height,
            'text-align': options.textAlign
          }).addClass('highcharts-point').add(series.markerGroup); // Add reference to the point for tracker (#6303)

          if (point.graphic.div) {
            point.graphic.div.point = point;
          }

          graphic.isNew = true;
        }

        if (plotX > 0) {
          // #3119
          plotX -= graphic.strokeWidth() % 2; // #4285
        } // Plant the flag


        attribs = {
          y: plotY,
          anchorY: anchorY
        };

        if (options.allowOverlapX) {
          attribs.x = plotX;
          attribs.anchorX = point.anchorX;
        }

        graphic.attr({
          text: point.options.title || options.title || 'A'
        })[graphic.isNew ? 'attr' : 'animate'](attribs); // Rig for the distribute function

        if (!options.allowOverlapX) {
          if (!boxesMap[point.plotX]) {
            boxesMap[point.plotX] = {
              align: 0,
              size: graphic.width,
              target: plotX,
              anchorX: plotX
            };
          } else {
            boxesMap[point.plotX].size = Math.max(boxesMap[point.plotX].size, graphic.width);
          }
        } // Set the tooltip anchor position


        point.tooltipPos = [plotX, plotY + yAxis.pos - chart.plotTop]; // #6327
      } else if (graphic) {
        point.graphic = graphic.destroy();
      }
    } // Handle X-dimension overlapping


    if (!options.allowOverlapX) {
      Highcharts.objectEach(boxesMap, function (box) {
        box.plotX = box.anchorX;
        boxes.push(box);
      });
      Highcharts.distribute(boxes, inverted ? yAxis.len : this.xAxis.len, 100);
      each$t(points, function (point) {
        var box = point.graphic && boxesMap[point.plotX];

        if (box) {
          point.graphic[point.graphic.isNew ? 'attr' : 'animate']({
            x: box.pos,
            anchorX: point.anchorX
          }); // Hide flag when its box position is not specified (#8573)

          if (!box.pos) {
            point.graphic.attr({
              x: -9999,
              anchorX: -9999
            });
            point.graphic.isNew = true;
          } else {
            point.graphic.isNew = false;
          }
        }
      });
    } // Might be a mix of SVG and HTML and we need events for both (#6303)


    if (options.useHTML) {
      Highcharts.wrap(series.markerGroup, 'on', function (proceed) {
        return Highcharts.SVGElement.prototype.on.apply( // for HTML
        proceed.apply(this, [].slice.call(arguments, 1)), // and for SVG
        [].slice.call(arguments, 1));
      });
    }
  },

  /**
   * Extend the column trackers with listeners to expand and contract stacks
   */
  drawTracker: function () {
    var series = this,
        points = series.points;
    TrackerMixin$1.drawTrackerPoint.apply(this);
    /**
     * Bring each stacked flag up on mouse over, this allows readability
     * of vertically stacked elements as well as tight points on
     * the x axis. #1924.
     */

    each$t(points, function (point) {
      var graphic = point.graphic;

      if (graphic) {
        addEvent$g(graphic.element, 'mouseover', function () {
          // Raise this point
          if (point.stackIndex > 0 && !point.raised) {
            point._y = graphic.y;
            graphic.attr({
              y: point._y - 8
            });
            point.raised = true;
          } // Revert other raised points


          each$t(points, function (otherPoint) {
            if (otherPoint !== point && otherPoint.raised && otherPoint.graphic) {
              otherPoint.graphic.attr({
                y: otherPoint._y
              });
              otherPoint.raised = false;
            }
          });
        });
      }
    });
  },
  // Disable animation, but keep clipping (#8546):
  animate: function (init) {
    if (init) {
      this.setClip();
    } else {
      this.animate = null;
    }
  },
  setClip: function () {
    Series$b.prototype.setClip.apply(this, arguments);

    if (this.options.clip !== false && this.sharedClipKey) {
      this.markerGroup.clip(this.chart[this.sharedClipKey]);
    }
  },
  buildKDTree: noop$7,

  /**
   * Don't invert the flag marker group (#4960)
   */
  invertGroups: noop$7
}); // create the flag icon with anchor

symbols.flag = function (x, y, w, h, options) {
  var anchorX = options && options.anchorX || x,
      anchorY = options && options.anchorY || y;
  return symbols.circle(anchorX - 1, anchorY - 1, 2, 2).concat(['M', anchorX, anchorY, 'L', x, y + h, x, y, x + w, y, x + w, y + h, x, y + h, 'Z']);
};
/*
 * Create the circlepin and squarepin icons with anchor
 */


function createPinSymbol(shape) {
  symbols[shape + 'pin'] = function (x, y, w, h, options) {
    var anchorX = options && options.anchorX,
        anchorY = options && options.anchorY,
        path,
        labelTopOrBottomY; // For single-letter flags, make sure circular flags are not taller
    // than their width

    if (shape === 'circle' && h > w) {
      x -= Math.round((h - w) / 2);
      w = h;
    }

    path = symbols[shape](x, y, w, h);

    if (anchorX && anchorY) {
      /**
       * If the label is below the anchor, draw the connecting line
       * from the top edge of the label
       * otherwise start drawing from the bottom edge
       */
      labelTopOrBottomY = y > anchorY ? y : y + h;
      path.push('M', shape === 'circle' ? path[1] - path[4] : path[1] + path[4] / 2, labelTopOrBottomY, 'L', anchorX, anchorY);
      path = path.concat(symbols.circle(anchorX - 1, anchorY - 1, 2, 2));
    }

    return path;
  };
}

createPinSymbol('circle');
createPinSymbol('square');
/**
 * A `flags` series. If the [type](#series.flags.type) option is not
 * specified, it is inherited from [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.flags
 * @excluding dataParser,dataURL
 * @product   highstock
 * @apioption series.flags
 */

/**
 * An array of data points for the series. For the `flags` series type,
 * points can be given in the following ways:
 *
 * 1.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.flags.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *     x: 1,
 *     title: "A",
 *     text: "First event"
 * }, {
 *     x: 1,
 *     title: "B",
 *     text: "Second event"
 * }]</pre>
 *
 * @type {Array<Object>}
 * @extends series.line.data
 * @excluding y,dataLabels,marker,name
 * @product highstock
 * @apioption series.flags.data
 */

/**
 * The fill color of an individual flag. By default it inherits from
 * the series color.
 *
 * @type      {Color}
 * @product   highstock
 * @apioption series.flags.data.fillColor
 */

/**
 * The longer text to be shown in the flag's tooltip.
 *
 * @type      {String}
 * @product   highstock
 * @apioption series.flags.data.text
 */

/**
 * The short text to be shown on the flag.
 *
 * @type      {String}
 * @product   highstock
 * @apioption series.flags.data.title
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$h = Highcharts.addEvent,
    Axis$9 = Highcharts.Axis,
    correctFloat$4 = Highcharts.correctFloat,
    defaultOptions$4 = Highcharts.defaultOptions,
    defined$h = Highcharts.defined,
    destroyObjectProperties$5 = Highcharts.destroyObjectProperties,
    each$u = Highcharts.each,
    fireEvent$a = Highcharts.fireEvent,
    hasTouch$3 = Highcharts.hasTouch,
    isTouchDevice$1 = Highcharts.isTouchDevice,
    merge$i = Highcharts.merge,
    pick$s = Highcharts.pick,
    removeEvent$6 = Highcharts.removeEvent,
    swapXY;
/**
 *
 * The scrollbar is a means of panning over the X axis of a stock chart.
 * Scrollbars can  also be applied to other types of axes.
 *
 * Another approach to scrollable charts is the [chart.scrollablePlotArea](
 * https://api.highcharts.com/highcharts/chart.scrollablePlotArea) option that
 * is especially suitable for simpler cartesian charts on mobile.
 *
 * In styled mode, all the presentational options for the
 * scrollbar are replaced by the classes `.highcharts-scrollbar-thumb`,
 * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
 * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
 *
 * @sample stock/yaxis/inverted-bar-scrollbar/
 *         A scrollbar on a simple bar chart
 *
 * @product highstock
 * @optionparent scrollbar
 */

var defaultScrollbarOptions = {
  /**
   * The height of the scrollbar. The height also applies to the width
   * of the scroll arrows so that they are always squares. Defaults to
   * 20 for touch devices and 14 for mouse devices.
   *
   * @sample {highstock} stock/scrollbar/height/
   *         A 30px scrollbar
   *
   * @type       {number}
   * @default    20/14
   * @product    highstock
   * @apioption  scrollbar.height
   */
  height: isTouchDevice$1 ? 20 : 14,

  /**
   * The border rounding radius of the bar.
   *
   * @sample {highstock} stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type       {number}
   * @default    0
   * @product    highstock
   * @apioption  scrollbar.barBorderRadius
   */
  barBorderRadius: 0,

  /**
   * The corner radius of the scrollbar buttons.
   *
   * @sample {highstock} stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type       {number}
   * @default    0
   * @product    highstock
   * @apioption  scrollbar.buttonBorderRadius
   */
  buttonBorderRadius: 0,

  /**
   * Enable or disable the scrollbar.
   *
   * @type       {boolean}
   * @sample     {highstock} stock/scrollbar/enabled/
   *             Disable the scrollbar, only use navigator
   * @default    true
   * @product    highstock
   * @apioption  scrollbar.enabled
   */

  /**
   * Whether to redraw the main chart as the scrollbar or the navigator
   * zoomed window is moved. Defaults to `true` for modern browsers and
   * `false` for legacy IE browsers as well as mobile devices.
   *
   * @type       {boolean}
   * @since      1.3
   * @product    highstock
   * @apioption  scrollbar.liveRedraw
   */
  liveRedraw: undefined,

  /**
   * The margin between the scrollbar and its axis when the scrollbar is
   * applied directly to an axis.
   *
   * @type       {number}
   * @default    10
   * @apioption  scrollbar.margin
   */
  margin: 10,

  /**
   * The minimum width of the scrollbar.
   *
   * @type       {number}
   * @default    6
   * @since      1.2.5
   * @product    highstock
   * @apioption  scrollbar.minWidth
   */
  minWidth: 6,

  /**
   * Whether to show or hide the scrollbar when the scrolled content is
   * zoomed out to it full extent.
   *
   * @type       {boolean}
   * @default    true
   * @product    highstock
   * @apioption  scrollbar.showFull
   */

  /**
   * @type       {number}
   * @default    0.2
   * @apioption  scrollbar.step
   */
  step: 0.2,

  /**
   * The z index of the scrollbar group.
   *
   * @type       {number}
   * @default    3
   * @apioption  scrollbar.zIndex
   */
  zIndex: 3
};
defaultOptions$4.scrollbar = merge$i(true, defaultScrollbarOptions, defaultOptions$4.scrollbar);
/**
 * When we have vertical scrollbar, rifles and arrow in buttons should be
 * rotated. The same method is used in Navigator's handles, to rotate them.
 *
 * @function Highcharts.swapXY
 *
 * @param  {Array<number|string>} path
 *         Path to be rotated.
 *
 * @param  {boolean} vertical
 *         If vertical scrollbar, swap x-y values.
 *
 * @return {Array<number|string>}
 */

Highcharts.swapXY = swapXY = function (path, vertical) {
  var i,
      len = path.length,
      temp;

  if (vertical) {
    for (i = 0; i < len; i += 3) {
      temp = path[i + 1];
      path[i + 1] = path[i + 2];
      path[i + 2] = temp;
    }
  }

  return path;
};
/**
 * A reusable scrollbar, internally used in Highstock's navigator and optionally
 * on individual axes.
 *
 * @class Highcharts.Scrollbar
 *
 * @param {Highcharts.SVGRenderer} renderer
 *
 * @param {Highcharts.ScrollbarOptions} options
 *
 * @param {Highcharts.Chart} chart
 */


function Scrollbar(renderer, options, chart) {
  // docs
  this.init(renderer, options, chart);
}

Scrollbar.prototype = {
  /**
   * @function Highcharts.Scrollbar#init
   *
   * @param  {Highcharts.SVGRenderer} renderer
   *
   * @param  {Highcharts.ScrollbarOptions} options
   *
   * @param  {Highcharts.Chart} chart
   *
   * @return {void}
   */
  init: function (renderer, options, chart) {
    this.scrollbarButtons = [];
    this.renderer = renderer;
    this.userOptions = options;
    this.options = merge$i(defaultScrollbarOptions, options);
    this.chart = chart; // backward compatibility

    this.size = pick$s(this.options.size, this.options.height); // Init

    if (options.enabled) {
      this.render();
      this.initEvents();
      this.addEvents();
    }
  },

  /**
  * Render scrollbar with all required items.
  *
  * @function Highcharts.Scrollbar#render
  *
  * @return {void}
  */
  render: function () {
    var scroller = this,
        renderer = scroller.renderer,
        options = scroller.options,
        size = scroller.size,
        group; // Draw the scrollbar group

    scroller.group = group = renderer.g('scrollbar').attr({
      zIndex: options.zIndex,
      translateY: -99999
    }).add(); // Draw the scrollbar track:

    scroller.track = renderer.rect().addClass('highcharts-scrollbar-track').attr({
      x: 0,
      r: options.trackBorderRadius || 0,
      height: size,
      width: size
    }).add(group);
    this.trackBorderWidth = scroller.track.strokeWidth();
    scroller.track.attr({
      y: -this.trackBorderWidth % 2 / 2
    }); // Draw the scrollbar itself

    scroller.scrollbarGroup = renderer.g().add(group);
    scroller.scrollbar = renderer.rect().addClass('highcharts-scrollbar-thumb').attr({
      height: size,
      width: size,
      r: options.barBorderRadius || 0
    }).add(scroller.scrollbarGroup);
    scroller.scrollbarRifles = renderer.path(swapXY(['M', -3, size / 4, 'L', -3, 2 * size / 3, 'M', 0, size / 4, 'L', 0, 2 * size / 3, 'M', 3, size / 4, 'L', 3, 2 * size / 3], options.vertical)).addClass('highcharts-scrollbar-rifles').add(scroller.scrollbarGroup);
    scroller.scrollbarStrokeWidth = scroller.scrollbar.strokeWidth();
    scroller.scrollbarGroup.translate(-scroller.scrollbarStrokeWidth % 2 / 2, -scroller.scrollbarStrokeWidth % 2 / 2); // Draw the buttons:

    scroller.drawScrollbarButton(0);
    scroller.drawScrollbarButton(1);
  },

  /**
   * Position the scrollbar, method called from a parent with defined
   * dimensions.
   *
   * @function Highcharts.Scrollbar#position
   *
   * @param  {number} x
   *         x-position on the chart
   *
   * @param  {number} y
   *         y-position on the chart
   *
   * @param  {number} width
   *         width of the scrollbar
   *
   * @param  {number} height
   *         height of the scorllbar
   *
   * @return {void}
   */
  position: function (x, y, width, height) {
    var scroller = this,
        options = scroller.options,
        vertical = options.vertical,
        xOffset = height,
        yOffset = 0,
        method = scroller.rendered ? 'animate' : 'attr';
    scroller.x = x;
    scroller.y = y + this.trackBorderWidth;
    scroller.width = width; // width with buttons

    scroller.height = height;
    scroller.xOffset = xOffset;
    scroller.yOffset = yOffset; // If Scrollbar is a vertical type, swap options:

    if (vertical) {
      scroller.width = scroller.yOffset = width = yOffset = scroller.size;
      scroller.xOffset = xOffset = 0;
      scroller.barWidth = height - width * 2; // width without buttons

      scroller.x = x = x + scroller.options.margin;
    } else {
      scroller.height = scroller.xOffset = height = xOffset = scroller.size;
      scroller.barWidth = width - height * 2; // width without buttons

      scroller.y = scroller.y + scroller.options.margin;
    } // Set general position for a group:


    scroller.group[method]({
      translateX: x,
      translateY: scroller.y
    }); // Resize background/track:

    scroller.track[method]({
      width: width,
      height: height
    }); // Move right/bottom button ot it's place:

    scroller.scrollbarButtons[1][method]({
      translateX: vertical ? 0 : width - xOffset,
      translateY: vertical ? height - yOffset : 0
    });
  },

  /**
   * Draw the scrollbar buttons with arrows
   *
   * @function Highcharts.Scrollbar#drawScrollbarButton
   *
   * @param  {number} index
   *         0 is left, 1 is right
   *
   * @return {void}
   */
  drawScrollbarButton: function (index) {
    var scroller = this,
        renderer = scroller.renderer,
        scrollbarButtons = scroller.scrollbarButtons,
        options = scroller.options,
        size = scroller.size,
        group,
        tempElem;
    group = renderer.g().add(scroller.group);
    scrollbarButtons.push(group); // Create a rectangle for the scrollbar button

    tempElem = renderer.rect().addClass('highcharts-scrollbar-button').add(group); // Place the rectangle based on the rendered stroke width

    tempElem.attr(tempElem.crisp({
      x: -0.5,
      y: -0.5,
      width: size + 1,
      // +1 to compensate for crispifying in rect method
      height: size + 1,
      r: options.buttonBorderRadius
    }, tempElem.strokeWidth())); // Button arrow

    tempElem = renderer.path(swapXY(['M', size / 2 + (index ? -1 : 1), size / 2 - 3, 'L', size / 2 + (index ? -1 : 1), size / 2 + 3, 'L', size / 2 + (index ? 2 : -2), size / 2], options.vertical)).addClass('highcharts-scrollbar-arrow').add(scrollbarButtons[index]);
  },

  /**
  * Set scrollbar size, with a given scale.
  *
  * @function Highcharts.Scrollbar#setRange
  *
  * @param  {number} from
  *         scale (0-1) where bar should start
  *
  * @param  {number} to
  *         scale (0-1) where bar should end
  *
  * @return {void}
  */
  setRange: function (from, to) {
    var scroller = this,
        options = scroller.options,
        vertical = options.vertical,
        minWidth = options.minWidth,
        fullWidth = scroller.barWidth,
        fromPX,
        toPX,
        newPos,
        newSize,
        newRiflesPos,
        method = this.rendered && !this.hasDragged && !(this.chart.navigator && this.chart.navigator.hasDragged) ? 'animate' : 'attr';

    if (!defined$h(fullWidth)) {
      return;
    }

    from = Math.max(from, 0);
    fromPX = Math.ceil(fullWidth * from);
    toPX = fullWidth * Math.min(to, 1);
    scroller.calculatedWidth = newSize = correctFloat$4(toPX - fromPX); // We need to recalculate position, if minWidth is used

    if (newSize < minWidth) {
      fromPX = (fullWidth - minWidth + newSize) * from;
      newSize = minWidth;
    }

    newPos = Math.floor(fromPX + scroller.xOffset + scroller.yOffset);
    newRiflesPos = newSize / 2 - 0.5; // -0.5 -> rifle line width / 2
    // Store current position:

    scroller.from = from;
    scroller.to = to;

    if (!vertical) {
      scroller.scrollbarGroup[method]({
        translateX: newPos
      });
      scroller.scrollbar[method]({
        width: newSize
      });
      scroller.scrollbarRifles[method]({
        translateX: newRiflesPos
      });
      scroller.scrollbarLeft = newPos;
      scroller.scrollbarTop = 0;
    } else {
      scroller.scrollbarGroup[method]({
        translateY: newPos
      });
      scroller.scrollbar[method]({
        height: newSize
      });
      scroller.scrollbarRifles[method]({
        translateY: newRiflesPos
      });
      scroller.scrollbarTop = newPos;
      scroller.scrollbarLeft = 0;
    }

    if (newSize <= 12) {
      scroller.scrollbarRifles.hide();
    } else {
      scroller.scrollbarRifles.show(true);
    } // Show or hide the scrollbar based on the showFull setting


    if (options.showFull === false) {
      if (from <= 0 && to >= 1) {
        scroller.group.hide();
      } else {
        scroller.group.show();
      }
    }

    scroller.rendered = true;
  },

  /**
  * Init events methods, so we have an access to the Scrollbar itself
  *
  * @function Highcharts.Scrollbar#initEvents
  *
  * @return {void}
  *
  * @todo
  * Make events official: Fires the event `changed`.
  */
  initEvents: function () {
    var scroller = this;
    /**
     * Event handler for the mouse move event.
     */

    scroller.mouseMoveHandler = function (e) {
      var normalizedEvent = scroller.chart.pointer.normalize(e),
          options = scroller.options,
          direction = options.vertical ? 'chartY' : 'chartX',
          initPositions = scroller.initPositions,
          scrollPosition,
          chartPosition,
          change; // In iOS, a mousemove event with e.pageX === 0 is fired when
      // holding the finger down in the center of the scrollbar. This
      // should be ignored.

      if (scroller.grabbedCenter && ( // #4696, scrollbar failed on Android
      !e.touches || e.touches[0][direction] !== 0)) {
        chartPosition = scroller.cursorToScrollbarPosition(normalizedEvent)[direction];
        scrollPosition = scroller[direction];
        change = chartPosition - scrollPosition;
        scroller.hasDragged = true;
        scroller.updatePosition(initPositions[0] + change, initPositions[1] + change);

        if (scroller.hasDragged) {
          fireEvent$a(scroller, 'changed', {
            from: scroller.from,
            to: scroller.to,
            trigger: 'scrollbar',
            DOMType: e.type,
            DOMEvent: e
          });
        }
      }
    };
    /**
     * Event handler for the mouse up event.
     */


    scroller.mouseUpHandler = function (e) {
      if (scroller.hasDragged) {
        fireEvent$a(scroller, 'changed', {
          from: scroller.from,
          to: scroller.to,
          trigger: 'scrollbar',
          DOMType: e.type,
          DOMEvent: e
        });
      }

      scroller.grabbedCenter = scroller.hasDragged = scroller.chartX = scroller.chartY = null;
    };

    scroller.mouseDownHandler = function (e) {
      var normalizedEvent = scroller.chart.pointer.normalize(e),
          mousePosition = scroller.cursorToScrollbarPosition(normalizedEvent);
      scroller.chartX = mousePosition.chartX;
      scroller.chartY = mousePosition.chartY;
      scroller.initPositions = [scroller.from, scroller.to];
      scroller.grabbedCenter = true;
    };

    scroller.buttonToMinClick = function (e) {
      var range = correctFloat$4(scroller.to - scroller.from) * scroller.options.step;
      scroller.updatePosition(correctFloat$4(scroller.from - range), correctFloat$4(scroller.to - range));
      fireEvent$a(scroller, 'changed', {
        from: scroller.from,
        to: scroller.to,
        trigger: 'scrollbar',
        DOMEvent: e
      });
    };

    scroller.buttonToMaxClick = function (e) {
      var range = (scroller.to - scroller.from) * scroller.options.step;
      scroller.updatePosition(scroller.from + range, scroller.to + range);
      fireEvent$a(scroller, 'changed', {
        from: scroller.from,
        to: scroller.to,
        trigger: 'scrollbar',
        DOMEvent: e
      });
    };

    scroller.trackClick = function (e) {
      var normalizedEvent = scroller.chart.pointer.normalize(e),
          range = scroller.to - scroller.from,
          top = scroller.y + scroller.scrollbarTop,
          left = scroller.x + scroller.scrollbarLeft;

      if (scroller.options.vertical && normalizedEvent.chartY > top || !scroller.options.vertical && normalizedEvent.chartX > left) {
        // On the top or on the left side of the track:
        scroller.updatePosition(scroller.from + range, scroller.to + range);
      } else {
        // On the bottom or the right side of the track:
        scroller.updatePosition(scroller.from - range, scroller.to - range);
      }

      fireEvent$a(scroller, 'changed', {
        from: scroller.from,
        to: scroller.to,
        trigger: 'scrollbar',
        DOMEvent: e
      });
    };
  },

  /**
   * Get normalized (0-1) cursor position over the scrollbar
   *
   * @function Highcharts.Scrollbar#cursorToScrollbarPosition
   *
   * @param  {*} normalizedEvent
   *         normalized event, with chartX and chartY values
   *
   * @return {*}
   *         Local position {chartX, chartY}
   */
  cursorToScrollbarPosition: function (normalizedEvent) {
    var scroller = this,
        options = scroller.options,
        minWidthDifference = options.minWidth > scroller.calculatedWidth ? options.minWidth : 0; // minWidth distorts translation

    return {
      chartX: (normalizedEvent.chartX - scroller.x - scroller.xOffset) / (scroller.barWidth - minWidthDifference),
      chartY: (normalizedEvent.chartY - scroller.y - scroller.yOffset) / (scroller.barWidth - minWidthDifference)
    };
  },

  /**
  * Update position option in the Scrollbar, with normalized 0-1 scale
  *
  * @function Highcharts.Scrollbar#updatePosition
  *
  * @param  {number} from
  *
  * @param  {number} to
  *
  * @return {void}
  */
  updatePosition: function (from, to) {
    if (to > 1) {
      from = correctFloat$4(1 - correctFloat$4(to - from));
      to = 1;
    }

    if (from < 0) {
      to = correctFloat$4(to - from);
      from = 0;
    }

    this.from = from;
    this.to = to;
  },

  /**
   * Update the scrollbar with new options
   *
   * @function Highcharts.Scrollbar#update
   *
   * @param  {Highcharts.ScrollbarOptions} options
   *
   * @return {void}
   */
  update: function (options) {
    this.destroy();
    this.init(this.chart.renderer, merge$i(true, this.options, options), this.chart);
  },

  /**
   * Set up the mouse and touch events for the Scrollbar
   *
   * @function Highcharts.Scrollbar#addEvents
   *
   * @return {void}
   */
  addEvents: function () {
    var buttonsOrder = this.options.inverted ? [1, 0] : [0, 1],
        buttons = this.scrollbarButtons,
        bar = this.scrollbarGroup.element,
        track = this.track.element,
        mouseDownHandler = this.mouseDownHandler,
        mouseMoveHandler = this.mouseMoveHandler,
        mouseUpHandler = this.mouseUpHandler,
        _events; // Mouse events


    _events = [[buttons[buttonsOrder[0]].element, 'click', this.buttonToMinClick], [buttons[buttonsOrder[1]].element, 'click', this.buttonToMaxClick], [track, 'click', this.trackClick], [bar, 'mousedown', mouseDownHandler], [bar.ownerDocument, 'mousemove', mouseMoveHandler], [bar.ownerDocument, 'mouseup', mouseUpHandler]]; // Touch events

    if (hasTouch$3) {
      _events.push([bar, 'touchstart', mouseDownHandler], [bar.ownerDocument, 'touchmove', mouseMoveHandler], [bar.ownerDocument, 'touchend', mouseUpHandler]);
    } // Add them all


    each$u(_events, function (args) {
      addEvent$h.apply(null, args);
    });
    this._events = _events;
  },

  /**
   * Removes the event handlers attached previously with addEvents.
   *
   * @function Highcharts.Scrollbar#removeEvents
   *
   * @return {void}
   */
  removeEvents: function () {
    each$u(this._events, function (args) {
      removeEvent$6.apply(null, args);
    });
    this._events.length = 0;
  },

  /**
   * Destroys allocated elements.
   *
   * @function Highcharts.Scrollbar#destroy
   *
   * @return {void}
   */
  destroy: function () {
    var scroller = this.chart.scroller; // Disconnect events added in addEvents

    this.removeEvents(); // Destroy properties

    each$u(['track', 'scrollbarRifles', 'scrollbar', 'scrollbarGroup', 'group'], function (prop) {
      if (this[prop] && this[prop].destroy) {
        this[prop] = this[prop].destroy();
      }
    }, this); // #6421, chart may have more scrollbars

    if (scroller && this === scroller.scrollbar) {
      scroller.scrollbar = null; // Destroy elements in collection

      destroyObjectProperties$5(scroller.scrollbarButtons);
    }
  }
};
/*
 * Wrap axis initialization and create scrollbar if enabled:
 */

addEvent$h(Axis$9, 'afterInit', function () {
  var axis = this;

  if (axis.options.scrollbar && axis.options.scrollbar.enabled) {
    // Predefined options:
    axis.options.scrollbar.vertical = !axis.horiz;
    axis.options.startOnTick = axis.options.endOnTick = false;
    axis.scrollbar = new Scrollbar(axis.chart.renderer, axis.options.scrollbar, axis.chart);
    addEvent$h(axis.scrollbar, 'changed', function (e) {
      var unitedMin = Math.min(pick$s(axis.options.min, axis.min), axis.min, axis.dataMin),
          unitedMax = Math.max(pick$s(axis.options.max, axis.max), axis.max, axis.dataMax),
          range = unitedMax - unitedMin,
          to,
          from;

      if (axis.horiz && !axis.reversed || !axis.horiz && axis.reversed) {
        to = unitedMin + range * this.to;
        from = unitedMin + range * this.from;
      } else {
        // y-values in browser are reversed, but this also applies for
        // reversed horizontal axis:
        to = unitedMin + range * (1 - this.from);
        from = unitedMin + range * (1 - this.to);
      }

      axis.setExtremes(from, to, true, false, e);
    });
  }
});
/*
 * Wrap rendering axis, and update scrollbar if one is created:
 */

addEvent$h(Axis$9, 'afterRender', function () {
  var axis = this,
      scrollMin = Math.min(pick$s(axis.options.min, axis.min), axis.min, pick$s(axis.dataMin, axis.min) // #6930
  ),
      scrollMax = Math.max(pick$s(axis.options.max, axis.max), axis.max, pick$s(axis.dataMax, axis.max) // #6930
  ),
      scrollbar = axis.scrollbar,
      titleOffset = axis.titleOffset || 0,
      offsetsIndex,
      from,
      to;

  if (scrollbar) {
    if (axis.horiz) {
      scrollbar.position(axis.left, axis.top + axis.height + 2 + axis.chart.scrollbarsOffsets[1] + (axis.opposite ? 0 : titleOffset + axis.axisTitleMargin + axis.offset), axis.width, axis.height);
      offsetsIndex = 1;
    } else {
      scrollbar.position(axis.left + axis.width + 2 + axis.chart.scrollbarsOffsets[0] + (axis.opposite ? titleOffset + axis.axisTitleMargin + axis.offset : 0), axis.top, axis.width, axis.height);
      offsetsIndex = 0;
    }

    if (!axis.opposite && !axis.horiz || axis.opposite && axis.horiz) {
      axis.chart.scrollbarsOffsets[offsetsIndex] += axis.scrollbar.size + axis.scrollbar.options.margin;
    }

    if (isNaN(scrollMin) || isNaN(scrollMax) || !defined$h(axis.min) || !defined$h(axis.max)) {
      // default action: when there is not extremes on the axis, but
      // scrollbar exists, make it full size
      scrollbar.setRange(0, 0);
    } else {
      from = (axis.min - scrollMin) / (scrollMax - scrollMin);
      to = (axis.max - scrollMin) / (scrollMax - scrollMin);

      if (axis.horiz && !axis.reversed || !axis.horiz && axis.reversed) {
        scrollbar.setRange(from, to);
      } else {
        scrollbar.setRange(1 - to, 1 - from); // inverse vertical axis
      }
    }
  }
});
/*
 * Make space for a scrollbar
 */

addEvent$h(Axis$9, 'afterGetOffset', function () {
  var axis = this,
      index = axis.horiz ? 2 : 1,
      scrollbar = axis.scrollbar;

  if (scrollbar) {
    axis.chart.scrollbarsOffsets = [0, 0]; // reset scrollbars offsets

    axis.chart.axisOffset[index] += scrollbar.size + scrollbar.options.margin;
  }
});
Highcharts.Scrollbar = Scrollbar;

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

var addEvent$i = Highcharts.addEvent,
    Axis$a = Highcharts.Axis,
    Chart$8 = Highcharts.Chart,
    color$6 = Highcharts.color,
    defaultDataGroupingUnits$1 = Highcharts.defaultDataGroupingUnits,
    defaultOptions$5 = Highcharts.defaultOptions,
    defined$i = Highcharts.defined,
    destroyObjectProperties$6 = Highcharts.destroyObjectProperties,
    each$v = Highcharts.each,
    erase$5 = Highcharts.erase,
    error = Highcharts.error,
    extend$j = Highcharts.extend,
    grep$4 = Highcharts.grep,
    hasTouch$4 = Highcharts.hasTouch,
    isArray$7 = Highcharts.isArray,
    isNumber$c = Highcharts.isNumber,
    isObject$7 = Highcharts.isObject,
    isTouchDevice$2 = Highcharts.isTouchDevice,
    merge$j = Highcharts.merge,
    pick$t = Highcharts.pick,
    removeEvent$7 = Highcharts.removeEvent,
    Scrollbar$1 = Highcharts.Scrollbar,
    Series$c = Highcharts.Series,
    seriesTypes$8 = Highcharts.seriesTypes,
    wrap$8 = Highcharts.wrap,
    units = [].concat(defaultDataGroupingUnits$1),
    // copy
defaultSeriesType,
    // Finding the min or max of a set of variables where we don't know if they
// are defined, is a pattern that is repeated several places in Highcharts.
// Consider making this a global utility method.
numExt = function (extreme) {
  var numbers = grep$4(arguments, isNumber$c);

  if (numbers.length) {
    return Math[extreme].apply(0, numbers);
  }
}; // add more resolution to units


units[4] = ['day', [1, 2, 3, 4]]; // allow more days

units[5] = ['week', [1, 2, 3]]; // allow more weeks

defaultSeriesType = seriesTypes$8.areaspline === undefined ? 'line' : 'areaspline';
extend$j(defaultOptions$5, {
  /**
   * The navigator is a small series below the main series, displaying
   * a view of the entire data set. It provides tools to zoom in and
   * out on parts of the data as well as panning across the dataset.
   *
   * @product highstock
   * @optionparent navigator
   */
  navigator: {
    /**
     * Whether the navigator and scrollbar should adapt to updated data
     * in the base X axis. When loading data async, as in the demo below,
     * this should be `false`. Otherwise new data will trigger navigator
     * redraw, which will cause unwanted looping. In the demo below, the
     * data in the navigator is set only once. On navigating, only the main
     * chart content is updated.
     *
     * @sample {highstock} stock/demo/lazy-loading/
     *         Set to false with async data loading
     *
     * @type       {boolean}
     * @default    true
     * @product    highstock
     * @apioption  navigator.adaptToUpdatedData
     */

    /**
     * An integer identifying the index to use for the base series, or a
     * string representing the id of the series.
     *
     * **Note**: As of Highcharts 5.0, this is now a deprecated option.
     * Prefer [series.showInNavigator](#plotOptions.series.showInNavigator).
     *
     * @see [series.showInNavigator](#plotOptions.series.showInNavigator)
     *
     * @deprecated
     * @type       {*}
     * @default    0
     * @product    highstock
     * @apioption  navigator.baseSeries
     */

    /**
     * Enable or disable the navigator.
     *
     * @sample {highstock} stock/navigator/enabled/ Disable the navigator
     *
     * @type       {boolean}
     * @default    true
     * @product    highstock
     * @apioption  navigator.enabled
     */

    /**
     * When the chart is inverted, whether to draw the navigator on the
     * opposite side.
     *
     * @type       {boolean}
     * @default    false
     * @since      5.0.8
     * @product    highstock
     * @apioption  navigator.opposite
     */

    /**
     * The height of the navigator.
     *
     * @sample {highstock} stock/navigator/height/
     *         A higher navigator
     *
     * @type       {number}
     * @default    40
     * @product    highstock
     * @apioption  navigator.height
     */
    height: 40,

    /**
     * The distance from the nearest element, the X axis or X axis labels.
     *
     * @sample {highstock} stock/navigator/margin/
     *         A margin of 2 draws the navigator closer to the X axis labels
     *
     * @type       {number}
     * @default    25
     * @product    highstock
     * @apioption  navigator.margin
     */
    margin: 25,

    /**
     * Whether the mask should be inside the range marking the zoomed
     * range, or outside. In Highstock 1.x it was always `false`.
     *
     * @sample {highstock} stock/navigator/maskinside-false/
     *         False, mask outside
     *
     * @type       {boolean}
     * @default    true
     * @since      2.0
     * @product    highstock
     * @apioption  navigator.maskInside
     */
    maskInside: true,

    /**
     * Options for the handles for dragging the zoomed area.
     *
     * @sample {highstock} stock/navigator/handles/
     *         Colored handles
     *
     * @type       {*}
     * @product    highstock
     * @apioption  navigator.handles
     */
    handles: {
      /**
       * Width for handles.
       *
       * @sample {highstock} stock/navigator/styled-handles/
       *         Styled handles
       *
       * @type       {number}
       * @default    7
       * @since      6.0.0
       * @product    highstock
       * @apioption  navigator.handles.width
       */
      width: 7,

      /**
       * Height for handles.
       *
       * @sample {highstock} stock/navigator/styled-handles/
       *         Styled handles
       *
       * @type       {number}
       * @default    15
       * @since      6.0.0
       * @product    highstock
       * @apioption  navigator.handles.height
       */
      height: 15,

      /**
       * Array to define shapes of handles. 0-index for left, 1-index for
       * right.
       *
       * Additionally, the URL to a graphic can be given on this form:
       * `url(graphic.png)`. Note that for the image to be applied to
       * exported charts, its URL needs to be accessible by the export
       * server.
       *
       * Custom callbacks for symbol path generation can also be added to
       * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
       * used by its method name, as shown in the demo.
       *
       * @sample {highstock} stock/navigator/styled-handles/
       *         Styled handles
       *
       * @type       {Array<string>}
       * @default    ['navigator-handle', 'navigator-handle']
       * @since      6.0.0
       * @product    highstock
       * @apioption  navigator.handles.symbols
       */
      symbols: ['navigator-handle', 'navigator-handle'],

      /**
       * Allows to enable/disable handles.
       *
       * @type       {boolean}
       * @default    true
       * @since      6.0.0
       * @product    highstock
       * @apioption  navigator.handles.enabled
       */
      enabled: true
    },

    /**
     * Options for the navigator series. Available options are the same
     * as any series, documented at [plotOptions](#plotOptions.series)
     * and [series](#series).
     *
     * Unless data is explicitly defined on navigator.series, the data
     * is borrowed from the first series in the chart.
     *
     * Default series options for the navigator series are:
     *
     * <pre>series: {
     *     type: 'areaspline',
     *     fillOpacity: 0.05,
     *     dataGrouping: {
     *         smoothed: true
     *     },
     *     lineWidth: 1,
     *     marker: {
     *         enabled: false
     *     }
     * }</pre>
     *
     * @see In styled mode, the navigator series is styled with the
     *      `.highcharts-navigator-series` class.
     *
     * @sample {highstock} stock/navigator/series-data/
     *         Using a separate data set for the navigator
     * @sample {highstock} stock/navigator/series/
     *         A green navigator series
     *
     * @type       {*}
     * @product    highstock
     * @apioption  navigator.series
     */
    series: {
      /**
       * The type of the navigator series. Defaults to `areaspline` if
       * defined, otherwise `line`.
       *
       * @type       {string}
       * @default    areaspline
       * @apioption  navigator.series.type
       */
      type: defaultSeriesType,

      /**
       * @ignore-option
       */
      compare: null,

      /**
       * Data grouping options for the navigator series.
       *
       * @type       {*}
       * @extends    plotOptions.series.dataGrouping
       * @apioption  navigator.series.dataGrouping
       */
      dataGrouping: {
        approximation: 'average',
        enabled: true,
        groupPixelWidth: 2,
        smoothed: true,
        units: units
      },

      /**
       * Data label options for the navigator series. Data labels are
       * disabled by default on the navigator series.
       *
       * @type       {*}
       * @extends    plotOptions.series.dataLabels
       * @apioption  navigator.series.dataLabels
       */
      dataLabels: {
        enabled: false,
        zIndex: 2 // #1839

      },
      id: 'highcharts-navigator-series',
      className: 'highcharts-navigator-series',

      /**
       * Line color for the navigator series. Allows setting the color
       * while disallowing the default candlestick setting.
       *
       * @type       {Highcharts.ColorString|null}
       * @default    null
       * @apioption  navigator.series.lineColor
       */
      lineColor: null,
      // #4602
      marker: {
        enabled: false
      },
      pointRange: 0,

      /**
       * The threshold option. Setting it to 0 will make the default
       * navigator area series draw its area from the 0 value and up.
       *
       * @type       {number|null}
       * @default    null
       * @apioption  navigator.series.threshold
       */
      threshold: null
    },

    /**
     * Options for the navigator X axis. Default series options
     * for the navigator xAxis are:
     *
     * <pre>xAxis: {
     *     tickWidth: 0,
     *     lineWidth: 0,
     *     gridLineWidth: 1,
     *     tickPixelInterval: 200,
     *     labels: {
     *            align: 'left',
     *         style: {
     *             color: '#888'
     *         },
     *         x: 3,
     *         y: -4
     *     }
     * }</pre>
     *
     * @type       {*}
     * @extends    xAxis
     * @excluding  linkedTo,maxZoom,minRange,opposite,range,scrollbar,
     *             showEmpty,maxRange
     * @product    highstock
     * @apioption  navigator.xAxis
     */
    xAxis: {
      /**
       * Additional range on the right side of the xAxis. Works similar to
       * xAxis.maxPadding, but value is set in milliseconds.
       * Can be set for both, main xAxis and navigator's xAxis.
       *
       * @type       {number}
       * @default    0
       * @since      6.0.0
       * @product    highstock
       * @apioption  navigator.xAxis.overscroll
       */
      overscroll: 0,
      className: 'highcharts-navigator-xaxis',
      tickLength: 0,
      tickPixelInterval: 200,
      labels: {
        align: 'left',
        x: 3,
        y: -4
      },
      crosshair: false
    },

    /**
     * Options for the navigator Y axis. Default series options
     * for the navigator yAxis are:
     *
     * <pre>yAxis: {
     *     gridLineWidth: 0,
     *     startOnTick: false,
     *     endOnTick: false,
     *     minPadding: 0.1,
     *     maxPadding: 0.1,
     *     labels: {
     *         enabled: false
     *     },
     *     title: {
     *         text: null
     *     },
     *     tickWidth: 0
     * }</pre>
     *
     * @type       {*}
     * @extends    yAxis
     * @excluding  height,linkedTo,maxZoom,minRange,ordinal,range,showEmpty,
     *             scrollbar,top,units,maxRange,minLength,maxLength,resize
     * @product    highstock
     * @apioption  navigator.yAxis
     */
    yAxis: {
      className: 'highcharts-navigator-yaxis',
      startOnTick: false,
      endOnTick: false,
      minPadding: 0.1,
      maxPadding: 0.1,
      labels: {
        enabled: false
      },
      crosshair: false,
      title: {
        text: null
      },
      tickLength: 0,
      tickWidth: 0
    }
  }
});
/**
 * Draw one of the handles on the side of the zoomed range in the navigator
 *
 * @function Highcharts.Renderer#symbols.navigator-handle
 *
 * @param  {boolean} inverted
 *         flag for chart.inverted
 *
 * @return {Array<number|string>}
 *         Path to be used in a handle
 */

Highcharts.Renderer.prototype.symbols['navigator-handle'] = function (x, y, w, h, options) {
  var halfWidth = options.width / 2,
      markerPosition = Math.round(halfWidth / 3) + 0.5,
      height = options.height;
  return ['M', -halfWidth - 1, 0.5, 'L', halfWidth, 0.5, 'L', halfWidth, height + 0.5, 'L', -halfWidth - 1, height + 0.5, 'L', -halfWidth - 1, 0.5, 'M', -markerPosition, 4, 'L', -markerPosition, height - 3, 'M', markerPosition - 1, 4, 'L', markerPosition - 1, height - 3];
};
/**
 * The Navigator class
 *
 * @class Highcharts.Navigator
 *
 * @param {Highcharts.Chart} chart
 *        Chart object
 */


function Navigator(chart) {
  this.init(chart);
}

Navigator.prototype = {
  /**
   * Draw one of the handles on the side of the zoomed range in the navigator
   *
   * @function Highcharts.Navigator#drawHandle
   *
   * @param  {number} x
   *         The x center for the handle
   *
   * @param  {number} index
   *         0 for left and 1 for right
   * @param  {boolean} inverted
   *         flag for chart.inverted
   * @param  {string} verb
   *         use 'animate' or 'attr'
   *
   * @return {void}
   */
  drawHandle: function (x, index, inverted, verb) {
    var navigator = this,
        height = navigator.navigatorOptions.handles.height; // Place it

    navigator.handles[index][verb](inverted ? {
      translateX: Math.round(navigator.left + navigator.height / 2),
      translateY: Math.round(navigator.top + parseInt(x, 10) + 0.5 - height)
    } : {
      translateX: Math.round(navigator.left + parseInt(x, 10)),
      translateY: Math.round(navigator.top + navigator.height / 2 - height / 2 - 1)
    });
  },

  /**
   * Render outline around the zoomed range
   *
   * @function Highcharts.Navigator#drawOutline
   *
   * @param  {number} zoomedMin
   *         in pixels position where zoomed range starts
   *
   * @param  {number} zoomedMax
   *         in pixels position where zoomed range ends
   *
   * @param  {boolean} inverted
   *         flag if chart is inverted
   *
   * @param  {string} verb
   *         use 'animate' or 'attr'
   *
   * @return {void}
   */
  drawOutline: function (zoomedMin, zoomedMax, inverted, verb) {
    var navigator = this,
        maskInside = navigator.navigatorOptions.maskInside,
        outlineWidth = navigator.outline.strokeWidth(),
        halfOutline = outlineWidth / 2,
        outlineCorrection = outlineWidth % 2 / 2,
        // #5800
    outlineHeight = navigator.outlineHeight,
        scrollbarHeight = navigator.scrollbarHeight,
        navigatorSize = navigator.size,
        left = navigator.left - scrollbarHeight,
        navigatorTop = navigator.top,
        verticalMin,
        path;

    if (inverted) {
      left -= halfOutline;
      verticalMin = navigatorTop + zoomedMax + outlineCorrection;
      zoomedMax = navigatorTop + zoomedMin + outlineCorrection;
      path = ['M', left + outlineHeight, navigatorTop - scrollbarHeight - outlineCorrection, // top edge
      'L', left + outlineHeight, verticalMin, // top right of zoomed range
      'L', left, verticalMin, // top left of z.r.
      'L', left, zoomedMax, // bottom left of z.r.
      'L', left + outlineHeight, zoomedMax, // bottom right of z.r.
      'L', left + outlineHeight, navigatorTop + navigatorSize + scrollbarHeight // bottom edge
      ].concat(maskInside ? ['M', left + outlineHeight, verticalMin - halfOutline, // upper left of zoomed range
      'L', left + outlineHeight, zoomedMax + halfOutline // upper right of z.r.
      ] : []);
    } else {
      zoomedMin += left + scrollbarHeight - outlineCorrection;
      zoomedMax += left + scrollbarHeight - outlineCorrection;
      navigatorTop += halfOutline;
      path = ['M', left, navigatorTop, // left
      'L', zoomedMin, navigatorTop, // upper left of zoomed range
      'L', zoomedMin, navigatorTop + outlineHeight, // lower left of z.r.
      'L', zoomedMax, navigatorTop + outlineHeight, // lower right of z.r.
      'L', zoomedMax, navigatorTop, // upper right of z.r.
      'L', left + navigatorSize + scrollbarHeight * 2, navigatorTop // right
      ].concat(maskInside ? ['M', zoomedMin - halfOutline, navigatorTop, // upper left of zoomed range
      'L', zoomedMax + halfOutline, navigatorTop // upper right of z.r.
      ] : []);
    }

    navigator.outline[verb]({
      d: path
    });
  },

  /**
   * Render outline around the zoomed range
   *
   * @function Highcharts.Navigator#drawMasks
   *
   * @param  {number} zoomedMin
   *         in pixels position where zoomed range starts
   *
   * @param  {number} zoomedMax
   *         in pixels position where zoomed range ends
   *
   * @param  {boolean} inverted
   *         flag if chart is inverted
   *
   * @param  {string} verb
   *         use 'animate' or 'attr'
   *
   * @return {void}
   */
  drawMasks: function (zoomedMin, zoomedMax, inverted, verb) {
    var navigator = this,
        left = navigator.left,
        top = navigator.top,
        navigatorHeight = navigator.height,
        height,
        width,
        x,
        y; // Determine rectangle position & size
    // According to (non)inverted position:

    if (inverted) {
      x = [left, left, left];
      y = [top, top + zoomedMin, top + zoomedMax];
      width = [navigatorHeight, navigatorHeight, navigatorHeight];
      height = [zoomedMin, zoomedMax - zoomedMin, navigator.size - zoomedMax];
    } else {
      x = [left, left + zoomedMin, left + zoomedMax];
      y = [top, top, top];
      width = [zoomedMin, zoomedMax - zoomedMin, navigator.size - zoomedMax];
      height = [navigatorHeight, navigatorHeight, navigatorHeight];
    }

    each$v(navigator.shades, function (shade, i) {
      shade[verb]({
        x: x[i],
        y: y[i],
        width: width[i],
        height: height[i]
      });
    });
  },

  /**
   * Generate DOM elements for a navigator:
   * - main navigator group
   * - all shades
   * - outline
   * - handles
   *
   * @function Highcharts.Navigator#renderElements
   *
   * @return {void}
   */
  renderElements: function () {
    var navigator = this,
        navigatorOptions = navigator.navigatorOptions,
        maskInside = navigatorOptions.maskInside,
        chart = navigator.chart,
        inverted = chart.inverted,
        renderer = chart.renderer,
        navigatorGroup; // Create the main navigator group

    navigator.navigatorGroup = navigatorGroup = renderer.g('navigator').attr({
      zIndex: 8,
      visibility: 'hidden'
    }).add(); // Create masks, each mask will get events and fill:

    each$v([!maskInside, maskInside, !maskInside], function (hasMask, index) {
      navigator.shades[index] = renderer.rect().addClass('highcharts-navigator-mask' + (index === 1 ? '-inside' : '-outside')).add(navigatorGroup);
    }); // Create the outline:

    navigator.outline = renderer.path().addClass('highcharts-navigator-outline').add(navigatorGroup); // Create the handlers:

    if (navigatorOptions.handles.enabled) {
      each$v([0, 1], function (index) {
        navigatorOptions.handles.inverted = chart.inverted;
        navigator.handles[index] = renderer.symbol(navigatorOptions.handles.symbols[index], -navigatorOptions.handles.width / 2 - 1, 0, navigatorOptions.handles.width, navigatorOptions.handles.height, navigatorOptions.handles); // zIndex = 6 for right handle, 7 for left.
        // Can't be 10, because of the tooltip in inverted chart #2908

        navigator.handles[index].attr({
          zIndex: 7 - index
        }).addClass('highcharts-navigator-handle ' + 'highcharts-navigator-handle-' + ['left', 'right'][index]).add(navigatorGroup);
      });
    }
  },

  /**
   * Update navigator
   *
   * @function Highcharts.Navigator#update
   *
   * @param  {Highcharts.NavigatorOptions} options
   *         Options to merge in when updating navigator
   *
   * @return {void}
   */
  update: function (options) {
    // Remove references to old navigator series in base series
    each$v(this.series || [], function (series) {
      if (series.baseSeries) {
        delete series.baseSeries.navigatorSeries;
      }
    }); // Destroy and rebuild navigator

    this.destroy();
    var chartOptions = this.chart.options;
    merge$j(true, chartOptions.navigator, this.options, options);
    this.init(this.chart);
  },

  /**
   * Render the navigator
   *
   * @function Highcharts.Navigator#render
   *
   * @param  {number} min
   *         X axis value minimum
   *
   * @param  {number} max
   *         X axis value maximum
   *
   * @param  {number} pxMin
   *         Pixel value minimum
   *
   * @param  {number} pxMax
   *         Pixel value maximum
   *
   * @return {void}
   */
  render: function (min, max, pxMin, pxMax) {
    var navigator = this,
        chart = navigator.chart,
        navigatorWidth,
        scrollbarLeft,
        scrollbarTop,
        scrollbarHeight = navigator.scrollbarHeight,
        navigatorSize,
        xAxis = navigator.xAxis,
        scrollbarXAxis = xAxis.fake ? chart.xAxis[0] : xAxis,
        navigatorEnabled = navigator.navigatorEnabled,
        zoomedMin,
        zoomedMax,
        rendered = navigator.rendered,
        inverted = chart.inverted,
        verb,
        newMin,
        newMax,
        currentRange,
        minRange = chart.xAxis[0].minRange,
        maxRange = chart.xAxis[0].options.maxRange; // Don't redraw while moving the handles (#4703).

    if (this.hasDragged && !defined$i(pxMin)) {
      return;
    } // Don't render the navigator until we have data (#486, #4202, #5172).


    if (!isNumber$c(min) || !isNumber$c(max)) {
      // However, if navigator was already rendered, we may need to resize
      // it. For example hidden series, but visible navigator (#6022).
      if (rendered) {
        pxMin = 0;
        pxMax = pick$t(xAxis.width, scrollbarXAxis.width);
      } else {
        return;
      }
    }

    navigator.left = pick$t(xAxis.left, // in case of scrollbar only, without navigator
    chart.plotLeft + scrollbarHeight + (inverted ? chart.plotWidth : 0));
    navigator.size = zoomedMax = navigatorSize = pick$t(xAxis.len, (inverted ? chart.plotHeight : chart.plotWidth) - 2 * scrollbarHeight);

    if (inverted) {
      navigatorWidth = scrollbarHeight;
    } else {
      navigatorWidth = navigatorSize + 2 * scrollbarHeight;
    } // Get the pixel position of the handles


    pxMin = pick$t(pxMin, xAxis.toPixels(min, true));
    pxMax = pick$t(pxMax, xAxis.toPixels(max, true)); // Verify (#1851, #2238)

    if (!isNumber$c(pxMin) || Math.abs(pxMin) === Infinity) {
      pxMin = 0;
      pxMax = navigatorWidth;
    } // Are we below the minRange? (#2618, #6191)


    newMin = xAxis.toValue(pxMin, true);
    newMax = xAxis.toValue(pxMax, true);
    currentRange = Math.abs(Highcharts.correctFloat(newMax - newMin));

    if (currentRange < minRange) {
      if (this.grabbedLeft) {
        pxMin = xAxis.toPixels(newMax - minRange, true);
      } else if (this.grabbedRight) {
        pxMax = xAxis.toPixels(newMin + minRange, true);
      }
    } else if (defined$i(maxRange) && currentRange > maxRange) {
      /**
       * Maximum range which can be set using the navigator's handles.
       * Opposite of [xAxis.minRange](#xAxis.minRange).
       *
       * @type {Number}
       * @default undefined
       * @product highstock
       * @sample {highstock} stock/navigator/maxrange/
       *         Defined max and min range
       * @since 6.0.0
       * @apioption xAxis.maxRange
       */
      if (this.grabbedLeft) {
        pxMin = xAxis.toPixels(newMax - maxRange, true);
      } else if (this.grabbedRight) {
        pxMax = xAxis.toPixels(newMin + maxRange, true);
      }
    } // Handles are allowed to cross, but never exceed the plot area


    navigator.zoomedMax = Math.min(Math.max(pxMin, pxMax, 0), zoomedMax);
    navigator.zoomedMin = Math.min(Math.max(navigator.fixedWidth ? navigator.zoomedMax - navigator.fixedWidth : Math.min(pxMin, pxMax), 0), zoomedMax);
    navigator.range = navigator.zoomedMax - navigator.zoomedMin;
    zoomedMax = Math.round(navigator.zoomedMax);
    zoomedMin = Math.round(navigator.zoomedMin);

    if (navigatorEnabled) {
      navigator.navigatorGroup.attr({
        visibility: 'visible'
      }); // Place elements

      verb = rendered && !navigator.hasDragged ? 'animate' : 'attr';
      navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);
      navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);

      if (navigator.navigatorOptions.handles.enabled) {
        navigator.drawHandle(zoomedMin, 0, inverted, verb);
        navigator.drawHandle(zoomedMax, 1, inverted, verb);
      }
    }

    if (navigator.scrollbar) {
      if (inverted) {
        scrollbarTop = navigator.top - scrollbarHeight;
        scrollbarLeft = navigator.left - scrollbarHeight + (navigatorEnabled || !scrollbarXAxis.opposite ? 0 : // Multiple axes has offsets:
        (scrollbarXAxis.titleOffset || 0) + // Self margin from the axis.title
        scrollbarXAxis.axisTitleMargin);
        scrollbarHeight = navigatorSize + 2 * scrollbarHeight;
      } else {
        scrollbarTop = navigator.top + (navigatorEnabled ? navigator.height : -scrollbarHeight);
        scrollbarLeft = navigator.left - scrollbarHeight;
      } // Reposition scrollbar


      navigator.scrollbar.position(scrollbarLeft, scrollbarTop, navigatorWidth, scrollbarHeight); // Keep scale 0-1

      navigator.scrollbar.setRange( // Use real value, not rounded because range can be very small
      // (#1716)
      navigator.zoomedMin / (navigatorSize || 1), navigator.zoomedMax / (navigatorSize || 1));
    }

    navigator.rendered = true;
  },

  /**
   * Set up the mouse and touch events for the navigator
   *
   * @function Highcharts.Navigator#addMouseEvents
   *
   * @return {void}
   */
  addMouseEvents: function () {
    var navigator = this,
        chart = navigator.chart,
        container = chart.container,
        eventsToUnbind = [],
        mouseMoveHandler,
        mouseUpHandler;
    /**
     * Create mouse events' handlers.
     * Make them as separate functions to enable wrapping them:
     */

    navigator.mouseMoveHandler = mouseMoveHandler = function (e) {
      navigator.onMouseMove(e);
    };

    navigator.mouseUpHandler = mouseUpHandler = function (e) {
      navigator.onMouseUp(e);
    }; // Add shades and handles mousedown events


    eventsToUnbind = navigator.getPartsEvents('mousedown'); // Add mouse move and mouseup events. These are bind to doc/container,
    // because Navigator.grabbedSomething flags are stored in mousedown
    // events

    eventsToUnbind.push(addEvent$i(container, 'mousemove', mouseMoveHandler), addEvent$i(container.ownerDocument, 'mouseup', mouseUpHandler)); // Touch events

    if (hasTouch$4) {
      eventsToUnbind.push(addEvent$i(container, 'touchmove', mouseMoveHandler), addEvent$i(container.ownerDocument, 'touchend', mouseUpHandler));
      eventsToUnbind.concat(navigator.getPartsEvents('touchstart'));
    }

    navigator.eventsToUnbind = eventsToUnbind; // Data events

    if (navigator.series && navigator.series[0]) {
      eventsToUnbind.push(addEvent$i(navigator.series[0].xAxis, 'foundExtremes', function () {
        chart.navigator.modifyNavigatorAxisExtremes();
      }));
    }
  },

  /**
   * Generate events for handles and masks
   *
   * @function Highcharts.Navigator#getPartsEvents
   *
   * @param  {string} eventName
   *         Event name handler, 'mousedown' or 'touchstart'
   *
   * @return {Array<*>}
   *         An array of arrays: [DOMElement, eventName, callback].
   */
  getPartsEvents: function (eventName) {
    var navigator = this,
        events = [];
    each$v(['shades', 'handles'], function (name) {
      each$v(navigator[name], function (navigatorItem, index) {
        events.push(addEvent$i(navigatorItem.element, eventName, function (e) {
          navigator[name + 'Mousedown'](e, index);
        }));
      });
    });
    return events;
  },

  /**
   * Mousedown on a shaded mask, either:
   * - will be stored for future drag&drop
   * - will directly shift to a new range
   *
   * @function Highcharts.Navigator#shadesMousedown
   *
   * @param  {*} e
   *         Mouse event
   *
   * @param  {number} index
   *         Index of a mask in Navigator.shades array
   *
   * @return {void}
   */
  shadesMousedown: function (e, index) {
    e = this.chart.pointer.normalize(e);
    var navigator = this,
        chart = navigator.chart,
        xAxis = navigator.xAxis,
        zoomedMin = navigator.zoomedMin,
        navigatorPosition = navigator.left,
        navigatorSize = navigator.size,
        range = navigator.range,
        chartX = e.chartX,
        fixedMax,
        fixedMin,
        ext,
        left; // For inverted chart, swap some options:

    if (chart.inverted) {
      chartX = e.chartY;
      navigatorPosition = navigator.top;
    }

    if (index === 1) {
      // Store information for drag&drop
      navigator.grabbedCenter = chartX;
      navigator.fixedWidth = range;
      navigator.dragOffset = chartX - zoomedMin;
    } else {
      // Shift the range by clicking on shaded areas
      left = chartX - navigatorPosition - range / 2;

      if (index === 0) {
        left = Math.max(0, left);
      } else if (index === 2 && left + range >= navigatorSize) {
        left = navigatorSize - range;

        if (navigator.reversedExtremes) {
          // #7713
          left -= range;
          fixedMin = navigator.getUnionExtremes().dataMin;
        } else {
          // #2293, #3543
          fixedMax = navigator.getUnionExtremes().dataMax;
        }
      }

      if (left !== zoomedMin) {
        // it has actually moved
        navigator.fixedWidth = range; // #1370

        ext = xAxis.toFixedRange(left, left + range, fixedMin, fixedMax);

        if (defined$i(ext.min)) {
          // #7411
          chart.xAxis[0].setExtremes(Math.min(ext.min, ext.max), Math.max(ext.min, ext.max), true, null, // auto animation
          {
            trigger: 'navigator'
          });
        }
      }
    }
  },

  /**
   * Mousedown on a handle mask.
   * Will store necessary information for drag&drop.
   *
   * @function Highcharts.Navigator#handlesMousedown
   *
   * @param  {*} e
   *         Mouse event
   *
   * @param  {number} index
   *         Index of a handle in Navigator.handles array
   *
   * @return {void}
   */
  handlesMousedown: function (e, index) {
    e = this.chart.pointer.normalize(e);
    var navigator = this,
        chart = navigator.chart,
        baseXAxis = chart.xAxis[0],
        // For reversed axes, min and max are changed,
    // so the other extreme should be stored
    reverse = navigator.reversedExtremes;

    if (index === 0) {
      // Grab the left handle
      navigator.grabbedLeft = true;
      navigator.otherHandlePos = navigator.zoomedMax;
      navigator.fixedExtreme = reverse ? baseXAxis.min : baseXAxis.max;
    } else {
      // Grab the right handle
      navigator.grabbedRight = true;
      navigator.otherHandlePos = navigator.zoomedMin;
      navigator.fixedExtreme = reverse ? baseXAxis.max : baseXAxis.min;
    }

    chart.fixedRange = null;
  },

  /**
   * Mouse move event based on x/y mouse position.
   *
   * @function Highcharts.Navigator#onMouseMove
   *
   * @param  {*} e
   *         Mouse event
   *
   * @return {void}
   */
  onMouseMove: function (e) {
    var navigator = this,
        chart = navigator.chart,
        left = navigator.left,
        navigatorSize = navigator.navigatorSize,
        range = navigator.range,
        dragOffset = navigator.dragOffset,
        inverted = chart.inverted,
        chartX; // In iOS, a mousemove event with e.pageX === 0 is fired when holding
    // the finger down in the center of the scrollbar. This should be
    // ignored.

    if (!e.touches || e.touches[0].pageX !== 0) {
      // #4696
      e = chart.pointer.normalize(e);
      chartX = e.chartX; // Swap some options for inverted chart

      if (inverted) {
        left = navigator.top;
        chartX = e.chartY;
      } // Drag left handle or top handle


      if (navigator.grabbedLeft) {
        navigator.hasDragged = true;
        navigator.render(0, 0, chartX - left, navigator.otherHandlePos); // Drag right handle or bottom handle
      } else if (navigator.grabbedRight) {
        navigator.hasDragged = true;
        navigator.render(0, 0, navigator.otherHandlePos, chartX - left); // Drag scrollbar or open area in navigator
      } else if (navigator.grabbedCenter) {
        navigator.hasDragged = true;

        if (chartX < dragOffset) {
          // outside left
          chartX = dragOffset; // outside right
        } else if (chartX > navigatorSize + dragOffset - range) {
          chartX = navigatorSize + dragOffset - range;
        }

        navigator.render(0, 0, chartX - dragOffset, chartX - dragOffset + range);
      }

      if (navigator.hasDragged && navigator.scrollbar && pick$t(navigator.scrollbar.options.liveRedraw, // By default, don't run live redraw on VML, on touch
      // devices or if the chart is in boost.
      Highcharts.svg && !isTouchDevice$2 && !this.chart.isBoosting)) {
        e.DOMType = e.type; // DOMType is for IE8

        setTimeout(function () {
          navigator.onMouseUp(e);
        }, 0);
      }
    }
  },

  /**
   * Mouse up event based on x/y mouse position.
   *
   * @function Highcharts.Navigator#onMouseUp
   *
   * @param  {*} e
   *         Mouse event
   *
   * @return {void}
   */
  onMouseUp: function (e) {
    var navigator = this,
        chart = navigator.chart,
        xAxis = navigator.xAxis,
        scrollbar = navigator.scrollbar,
        unionExtremes,
        fixedMin,
        fixedMax,
        ext,
        DOMEvent = e.DOMEvent || e;

    if ( // MouseUp is called for both, navigator and scrollbar (that order),
    // which causes calling afterSetExtremes twice. Prevent first call
    // by checking if scrollbar is going to set new extremes (#6334)
    navigator.hasDragged && (!scrollbar || !scrollbar.hasDragged) || e.trigger === 'scrollbar') {
      unionExtremes = navigator.getUnionExtremes(); // When dragging one handle, make sure the other one doesn't change

      if (navigator.zoomedMin === navigator.otherHandlePos) {
        fixedMin = navigator.fixedExtreme;
      } else if (navigator.zoomedMax === navigator.otherHandlePos) {
        fixedMax = navigator.fixedExtreme;
      } // Snap to right edge (#4076)


      if (navigator.zoomedMax === navigator.size) {
        fixedMax = navigator.reversedExtremes ? unionExtremes.dataMin : unionExtremes.dataMax;
      } // Snap to left edge (#7576)


      if (navigator.zoomedMin === 0) {
        fixedMin = navigator.reversedExtremes ? unionExtremes.dataMax : unionExtremes.dataMin;
      }

      ext = xAxis.toFixedRange(navigator.zoomedMin, navigator.zoomedMax, fixedMin, fixedMax);

      if (defined$i(ext.min)) {
        chart.xAxis[0].setExtremes(Math.min(ext.min, ext.max), Math.max(ext.min, ext.max), true, // Run animation when clicking buttons, scrollbar track etc,
        // but not when dragging handles or scrollbar
        navigator.hasDragged ? false : null, {
          trigger: 'navigator',
          triggerOp: 'navigator-drag',
          DOMEvent: DOMEvent // #1838

        });
      }
    }

    if (e.DOMType !== 'mousemove') {
      navigator.grabbedLeft = navigator.grabbedRight = navigator.grabbedCenter = navigator.fixedWidth = navigator.fixedExtreme = navigator.otherHandlePos = navigator.hasDragged = navigator.dragOffset = null;
    }
  },

  /**
   * Removes the event handlers attached previously with addEvents.
   *
   * @function Highcharts.Navigator#removeEvents
   *
   * @return {void}
   */
  removeEvents: function () {
    if (this.eventsToUnbind) {
      each$v(this.eventsToUnbind, function (unbind) {
        unbind();
      });
      this.eventsToUnbind = undefined;
    }

    this.removeBaseSeriesEvents();
  },

  /**
   * Remove data events.
   *
   * @function Highcharts.Navigator#removeBaseSeriesEvents
   *
   * @return {void}
   */
  removeBaseSeriesEvents: function () {
    var baseSeries = this.baseSeries || [];

    if (this.navigatorEnabled && baseSeries[0]) {
      if (this.navigatorOptions.adaptToUpdatedData !== false) {
        each$v(baseSeries, function (series) {
          removeEvent$7(series, 'updatedData', this.updatedDataHandler);
        }, this);
      } // We only listen for extremes-events on the first baseSeries


      if (baseSeries[0].xAxis) {
        removeEvent$7(baseSeries[0].xAxis, 'foundExtremes', this.modifyBaseAxisExtremes);
      }
    }
  },

  /**
   * Initiate the Navigator object
   *
   * @function Highcharts.Navigator#init
   *
   * @param  {Highcharts.Chart} chart
   *
   * @return {void}
   */
  init: function (chart) {
    var chartOptions = chart.options,
        navigatorOptions = chartOptions.navigator,
        navigatorEnabled = navigatorOptions.enabled,
        scrollbarOptions = chartOptions.scrollbar,
        scrollbarEnabled = scrollbarOptions.enabled,
        height = navigatorEnabled ? navigatorOptions.height : 0,
        scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : 0;
    this.handles = [];
    this.shades = [];
    this.chart = chart;
    this.setBaseSeries();
    this.height = height;
    this.scrollbarHeight = scrollbarHeight;
    this.scrollbarEnabled = scrollbarEnabled;
    this.navigatorEnabled = navigatorEnabled;
    this.navigatorOptions = navigatorOptions;
    this.scrollbarOptions = scrollbarOptions;
    this.outlineHeight = height + scrollbarHeight;
    this.opposite = pick$t(navigatorOptions.opposite, !navigatorEnabled && chart.inverted); // #6262

    var navigator = this,
        baseSeries = navigator.baseSeries,
        xAxisIndex = chart.xAxis.length,
        yAxisIndex = chart.yAxis.length,
        baseXaxis = baseSeries && baseSeries[0] && baseSeries[0].xAxis || chart.xAxis[0] || {
      options: {}
    };
    chart.isDirtyBox = true;

    if (navigator.navigatorEnabled) {
      // an x axis is required for scrollbar also
      navigator.xAxis = new Axis$a(chart, merge$j({
        // inherit base xAxis' break and ordinal options
        breaks: baseXaxis.options.breaks,
        ordinal: baseXaxis.options.ordinal
      }, navigatorOptions.xAxis, {
        id: 'navigator-x-axis',
        yAxis: 'navigator-y-axis',
        isX: true,
        type: 'datetime',
        index: xAxisIndex,
        isInternal: true,
        offset: 0,
        keepOrdinalPadding: true,
        // #2436
        startOnTick: false,
        endOnTick: false,
        minPadding: 0,
        maxPadding: 0,
        zoomEnabled: false
      }, chart.inverted ? {
        offsets: [scrollbarHeight, 0, -scrollbarHeight, 0],
        width: height
      } : {
        offsets: [0, -scrollbarHeight, 0, scrollbarHeight],
        height: height
      }));
      navigator.yAxis = new Axis$a(chart, merge$j(navigatorOptions.yAxis, {
        id: 'navigator-y-axis',
        alignTicks: false,
        offset: 0,
        index: yAxisIndex,
        isInternal: true,
        zoomEnabled: false
      }, chart.inverted ? {
        width: height
      } : {
        height: height
      })); // If we have a base series, initialize the navigator series

      if (baseSeries || navigatorOptions.series.data) {
        navigator.updateNavigatorSeries(false); // If not, set up an event to listen for added series
      } else if (chart.series.length === 0) {
        navigator.unbindRedraw = addEvent$i(chart, 'beforeRedraw', function () {
          // We've got one, now add it as base
          if (chart.series.length > 0 && !navigator.series) {
            navigator.setBaseSeries();
            navigator.unbindRedraw(); // reset
          }
        });
      }

      navigator.reversedExtremes = chart.inverted && !navigator.xAxis.reversed || !chart.inverted && navigator.xAxis.reversed; // Render items, so we can bind events to them:

      navigator.renderElements(); // Add mouse events

      navigator.addMouseEvents(); // in case of scrollbar only, fake an x axis to get translation
    } else {
      navigator.xAxis = {
        translate: function (value, reverse) {
          var axis = chart.xAxis[0],
              ext = axis.getExtremes(),
              scrollTrackWidth = axis.len - 2 * scrollbarHeight,
              min = numExt('min', axis.options.min, ext.dataMin),
              valueRange = numExt('max', axis.options.max, ext.dataMax) - min;
          return reverse ? // from pixel to value
          value * valueRange / scrollTrackWidth + min : // from value to pixel
          scrollTrackWidth * (value - min) / valueRange;
        },
        toPixels: function (value) {
          return this.translate(value);
        },
        toValue: function (value) {
          return this.translate(value, true);
        },
        toFixedRange: Axis$a.prototype.toFixedRange,
        fake: true
      };
    } // Initialize the scrollbar


    if (chart.options.scrollbar.enabled) {
      chart.scrollbar = navigator.scrollbar = new Scrollbar$1(chart.renderer, merge$j(chart.options.scrollbar, {
        margin: navigator.navigatorEnabled ? 0 : 10,
        vertical: chart.inverted
      }), chart);
      addEvent$i(navigator.scrollbar, 'changed', function (e) {
        var range = navigator.size,
            to = range * this.to,
            from = range * this.from;
        navigator.hasDragged = navigator.scrollbar.hasDragged;
        navigator.render(0, 0, from, to);

        if (chart.options.scrollbar.liveRedraw || e.DOMType !== 'mousemove' && e.DOMType !== 'touchmove') {
          setTimeout(function () {
            navigator.onMouseUp(e);
          });
        }
      });
    } // Add data events


    navigator.addBaseSeriesEvents(); // Add redraw events

    navigator.addChartEvents();
  },

  /**
   * Get the union data extremes of the chart - the outer data extremes of the
   * base X axis and the navigator axis.
   *
   * @function Highcharts.Navigator#getUnionExtremes
   *
   * @param  {boolean} returnFalseOnNoBaseSeries
   *         as the param says.
   *
   * @return {*}
   */
  getUnionExtremes: function (returnFalseOnNoBaseSeries) {
    var baseAxis = this.chart.xAxis[0],
        navAxis = this.xAxis,
        navAxisOptions = navAxis.options,
        baseAxisOptions = baseAxis.options,
        ret;

    if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {
      ret = {
        dataMin: pick$t( // #4053
        navAxisOptions && navAxisOptions.min, numExt('min', baseAxisOptions.min, baseAxis.dataMin, navAxis.dataMin, navAxis.min)),
        dataMax: pick$t(navAxisOptions && navAxisOptions.max, numExt('max', baseAxisOptions.max, baseAxis.dataMax, navAxis.dataMax, navAxis.max))
      };
    }

    return ret;
  },

  /**
   * Set the base series and update the navigator series from this. With a bit
   * of modification we should be able to make this an API method to be called
   * from the outside
   *
   * @function Highcharts.Navigator#setBaseSeries
   *
   * @param  {*} baseSeriesOptions
   *         Additional series options for a navigator
   *
   * @param  {boolean} [redraw]
   *         Whether to redraw after update.
   *
   * @return {void}
   */
  setBaseSeries: function (baseSeriesOptions, redraw) {
    var chart = this.chart,
        baseSeries = this.baseSeries = [];
    baseSeriesOptions = baseSeriesOptions || chart.options && chart.options.navigator.baseSeries || 0; // Iterate through series and add the ones that should be shown in
    // navigator.

    each$v(chart.series || [], function (series, i) {
      if ( // Don't include existing nav series
      !series.options.isInternal && (series.options.showInNavigator || (i === baseSeriesOptions || series.options.id === baseSeriesOptions) && series.options.showInNavigator !== false)) {
        baseSeries.push(series);
      }
    }); // When run after render, this.xAxis already exists

    if (this.xAxis && !this.xAxis.fake) {
      this.updateNavigatorSeries(true, redraw);
    }
  },

  /**
   * Update series in the navigator from baseSeries, adding new if does not
   * exist.
   *
   * @function Highcharts.Navigator.updateNavigatorSeries
   *
   * @param  {boolean} addEvents
   *
   * @param  {boolean} redraw
   *
   * @return {void}
   */
  updateNavigatorSeries: function (addEvents, redraw) {
    var navigator = this,
        chart = navigator.chart,
        baseSeries = navigator.baseSeries,
        baseOptions,
        mergedNavSeriesOptions,
        chartNavigatorSeriesOptions = navigator.navigatorOptions.series,
        baseNavigatorOptions,
        navSeriesMixin = {
      enableMouseTracking: false,
      index: null,
      // #6162
      linkedTo: null,
      // #6734
      group: 'nav',
      // for columns
      padXAxis: false,
      xAxis: 'navigator-x-axis',
      yAxis: 'navigator-y-axis',
      showInLegend: false,
      stacking: false,
      // #4823
      isInternal: true
    },
        // Remove navigator series that are no longer in the baseSeries
    navigatorSeries = navigator.series = Highcharts.grep(navigator.series || [], function (navSeries) {
      var base = navSeries.baseSeries;

      if (Highcharts.inArray(base, baseSeries) < 0) {
        // Not in array
        // If there is still a base series connected to this
        // series, remove event handler and reference.
        if (base) {
          removeEvent$7(base, 'updatedData', navigator.updatedDataHandler);
          delete base.navigatorSeries;
        } // Kill the nav series. It may already have been
        // destroyed (#8715).


        if (navSeries.chart) {
          navSeries.destroy();
        }

        return false;
      }

      return true;
    }); // Go through each base series and merge the options to create new
    // series

    if (baseSeries && baseSeries.length) {
      each$v(baseSeries, function eachBaseSeries(base) {
        var linkedNavSeries = base.navigatorSeries,
            userNavOptions = extend$j( // Grab color and visibility from base as default
        {
          color: base.color,
          visible: base.visible
        }, !isArray$7(chartNavigatorSeriesOptions) ? chartNavigatorSeriesOptions : defaultOptions$5.navigator.series); // Don't update if the series exists in nav and we have disabled
        // adaptToUpdatedData.

        if (linkedNavSeries && navigator.navigatorOptions.adaptToUpdatedData === false) {
          return;
        }

        navSeriesMixin.name = 'Navigator ' + baseSeries.length;
        baseOptions = base.options || {};
        baseNavigatorOptions = baseOptions.navigatorOptions || {};
        mergedNavSeriesOptions = merge$j(baseOptions, navSeriesMixin, userNavOptions, baseNavigatorOptions); // Merge data separately. Do a slice to avoid mutating the
        // navigator options from base series (#4923).

        var navigatorSeriesData = baseNavigatorOptions.data || userNavOptions.data;
        navigator.hasNavigatorData = navigator.hasNavigatorData || !!navigatorSeriesData;
        mergedNavSeriesOptions.data = navigatorSeriesData || baseOptions.data && baseOptions.data.slice(0); // Update or add the series

        if (linkedNavSeries && linkedNavSeries.options) {
          linkedNavSeries.update(mergedNavSeriesOptions, redraw);
        } else {
          base.navigatorSeries = chart.initSeries(mergedNavSeriesOptions);
          base.navigatorSeries.baseSeries = base; // Store ref

          navigatorSeries.push(base.navigatorSeries);
        }
      });
    } // If user has defined data (and no base series) or explicitly defined
    // navigator.series as an array, we create these series on top of any
    // base series.


    if (chartNavigatorSeriesOptions.data && !(baseSeries && baseSeries.length) || isArray$7(chartNavigatorSeriesOptions)) {
      navigator.hasNavigatorData = false; // Allow navigator.series to be an array

      chartNavigatorSeriesOptions = Highcharts.splat(chartNavigatorSeriesOptions);
      each$v(chartNavigatorSeriesOptions, function (userSeriesOptions, i) {
        navSeriesMixin.name = 'Navigator ' + (navigatorSeries.length + 1);
        mergedNavSeriesOptions = merge$j(defaultOptions$5.navigator.series, {
          // Since we don't have a base series to pull color from,
          // try to fake it by using color from series with same
          // index. Otherwise pull from the colors array. We need
          // an explicit color as otherwise updates will increment
          // color counter and we'll get a new color for each
          // update of the nav series.
          color: chart.series[i] && !chart.series[i].options.isInternal && chart.series[i].color || chart.options.colors[i] || chart.options.colors[0]
        }, navSeriesMixin, userSeriesOptions);
        mergedNavSeriesOptions.data = userSeriesOptions.data;

        if (mergedNavSeriesOptions.data) {
          navigator.hasNavigatorData = true;
          navigatorSeries.push(chart.initSeries(mergedNavSeriesOptions));
        }
      });
    }

    if (addEvents) {
      this.addBaseSeriesEvents();
    }
  },

  /**
   * Add data events.
   * For example when main series is updated we need to recalculate extremes
   *
   * @function Highcharts.Navigator#addBaseSeriesEvent
   *
   * @return {void}
   */
  addBaseSeriesEvents: function () {
    var navigator = this,
        baseSeries = navigator.baseSeries || []; // Bind modified extremes event to first base's xAxis only.
    // In event of > 1 base-xAxes, the navigator will ignore those.
    // Adding this multiple times to the same axis is no problem, as
    // duplicates should be discarded by the browser.

    if (baseSeries[0] && baseSeries[0].xAxis) {
      addEvent$i(baseSeries[0].xAxis, 'foundExtremes', this.modifyBaseAxisExtremes);
    }

    each$v(baseSeries, function (base) {
      // Link base series show/hide to navigator series visibility
      addEvent$i(base, 'show', function () {
        if (this.navigatorSeries) {
          this.navigatorSeries.setVisible(true, false);
        }
      });
      addEvent$i(base, 'hide', function () {
        if (this.navigatorSeries) {
          this.navigatorSeries.setVisible(false, false);
        }
      }); // Respond to updated data in the base series, unless explicitily
      // not adapting to data changes.

      if (this.navigatorOptions.adaptToUpdatedData !== false) {
        if (base.xAxis) {
          addEvent$i(base, 'updatedData', this.updatedDataHandler);
        }
      } // Handle series removal


      addEvent$i(base, 'remove', function () {
        if (this.navigatorSeries) {
          erase$5(navigator.series, this.navigatorSeries);

          if (defined$i(this.navigatorSeries.options)) {
            this.navigatorSeries.remove(false);
          }

          delete this.navigatorSeries;
        }
      });
    }, this);
  },

  /**
   * Set the navigator x axis extremes to reflect the total. The navigator
   * extremes should always be the extremes of the union of all series in the
   * chart as well as the navigator series.
   *
   * @function Highcharts.Navigator#modifyNavigatorAxisExtremes
   *
   * @return {void}
   */
  modifyNavigatorAxisExtremes: function () {
    var xAxis = this.xAxis,
        unionExtremes;

    if (xAxis.getExtremes) {
      unionExtremes = this.getUnionExtremes(true);

      if (unionExtremes && (unionExtremes.dataMin !== xAxis.min || unionExtremes.dataMax !== xAxis.max)) {
        xAxis.min = unionExtremes.dataMin;
        xAxis.max = unionExtremes.dataMax;
      }
    }
  },

  /**
   * Hook to modify the base axis extremes with information from the Navigator
   *
   * @function Highcharts.Navigator#modifyBaseAxisExtremes
   *
   * @return {void}
   */
  modifyBaseAxisExtremes: function () {
    var baseXAxis = this,
        navigator = baseXAxis.chart.navigator,
        baseExtremes = baseXAxis.getExtremes(),
        baseMin = baseExtremes.min,
        baseMax = baseExtremes.max,
        baseDataMin = baseExtremes.dataMin,
        baseDataMax = baseExtremes.dataMax,
        range = baseMax - baseMin,
        stickToMin = navigator.stickToMin,
        stickToMax = navigator.stickToMax,
        overscroll = pick$t(baseXAxis.options.overscroll, 0),
        newMax,
        newMin,
        navigatorSeries = navigator.series && navigator.series[0],
        hasSetExtremes = !!baseXAxis.setExtremes,
        // When the extremes have been set by range selector button, don't
    // stick to min or max. The range selector buttons will handle the
    // extremes. (#5489)
    unmutable = baseXAxis.eventArgs && baseXAxis.eventArgs.trigger === 'rangeSelectorButton';

    if (!unmutable) {
      // If the zoomed range is already at the min, move it to the right
      // as new data comes in
      if (stickToMin) {
        newMin = baseDataMin;
        newMax = newMin + range;
      } // If the zoomed range is already at the max, move it to the right
      // as new data comes in


      if (stickToMax) {
        newMax = baseDataMax + overscroll; // if stickToMin is true, the new min value is set above

        if (!stickToMin) {
          newMin = Math.max(newMax - range, navigatorSeries && navigatorSeries.xData ? navigatorSeries.xData[0] : -Number.MAX_VALUE);
        }
      } // Update the extremes


      if (hasSetExtremes && (stickToMin || stickToMax)) {
        if (isNumber$c(newMin)) {
          baseXAxis.min = baseXAxis.userMin = newMin;
          baseXAxis.max = baseXAxis.userMax = newMax;
        }
      }
    } // Reset


    navigator.stickToMin = navigator.stickToMax = null;
  },

  /**
   * Handler for updated data on the base series. When data is modified, the
   * navigator series must reflect it. This is called from the Chart.redraw
   * function before axis and series extremes are computed.
   *
   * @function Highcharts.Navigator#updateDataHandler
   *
   * @return {void}
   */
  updatedDataHandler: function () {
    var navigator = this.chart.navigator,
        baseSeries = this,
        navigatorSeries = this.navigatorSeries; // If the scrollbar is scrolled all the way to the right, keep right as
    // new data  comes in.

    navigator.stickToMax = navigator.reversedExtremes ? Math.round(navigator.zoomedMin) === 0 : Math.round(navigator.zoomedMax) >= Math.round(navigator.size); // Detect whether the zoomed area should stick to the minimum or
    // maximum. If the current axis minimum falls outside the new updated
    // dataset, we must adjust.

    navigator.stickToMin = isNumber$c(baseSeries.xAxis.min) && baseSeries.xAxis.min <= baseSeries.xData[0] && (!this.chart.fixedRange || !navigator.stickToMax); // Set the navigator series data to the new data of the base series

    if (navigatorSeries && !navigator.hasNavigatorData) {
      navigatorSeries.options.pointStart = baseSeries.xData[0];
      navigatorSeries.setData(baseSeries.options.data, false, null, false); // #5414
    }
  },

  /**
   * Add chart events, like redrawing navigator, when chart requires that.
   *
   * @function Highcharts.Navigator#addChartEvents
   *
   * @return {void}
   */
  addChartEvents: function () {
    if (!this.eventsToUnbind) {
      this.eventsToUnbind = [];
    }

    this.eventsToUnbind.push( // Move the scrollbar after redraw, like after data updata even if
    // axes don't redraw
    addEvent$i(this.chart, 'redraw', function () {
      var navigator = this.navigator,
          xAxis = navigator && (navigator.baseSeries && navigator.baseSeries[0] && navigator.baseSeries[0].xAxis || navigator.scrollbar && this.xAxis[0]); // #5709

      if (xAxis) {
        navigator.render(xAxis.min, xAxis.max);
      }
    }), // Make room for the navigator, can be placed around the chart:
    addEvent$i(this.chart, 'getMargins', function () {
      var chart = this,
          navigator = chart.navigator,
          marginName = navigator.opposite ? 'plotTop' : 'marginBottom';

      if (chart.inverted) {
        marginName = navigator.opposite ? 'marginRight' : 'plotLeft';
      }

      chart[marginName] = (chart[marginName] || 0) + (navigator.navigatorEnabled || !chart.inverted ? navigator.outlineHeight : 0) + navigator.navigatorOptions.margin;
    }));
  },

  /**
   * Destroys allocated elements.
   *
   * @function Highcharts.Navigator#destroy
   *
   * @return {void}
   */
  destroy: function () {
    // Disconnect events added in addEvents
    this.removeEvents();

    if (this.xAxis) {
      erase$5(this.chart.xAxis, this.xAxis);
      erase$5(this.chart.axes, this.xAxis);
    }

    if (this.yAxis) {
      erase$5(this.chart.yAxis, this.yAxis);
      erase$5(this.chart.axes, this.yAxis);
    } // Destroy series


    each$v(this.series || [], function (s) {
      if (s.destroy) {
        s.destroy();
      }
    }); // Destroy properties

    each$v(['series', 'xAxis', 'yAxis', 'shades', 'outline', 'scrollbarTrack', 'scrollbarRifles', 'scrollbarGroup', 'scrollbar', 'navigatorGroup', 'rendered'], function (prop) {
      if (this[prop] && this[prop].destroy) {
        this[prop].destroy();
      }

      this[prop] = null;
    }, this); // Destroy elements in collection

    each$v([this.handles], function (coll) {
      destroyObjectProperties$6(coll);
    }, this);
  }
};
Highcharts.Navigator = Navigator;
/**
 * For Stock charts, override selection zooming with some special features
 * because X axis zooming is already allowed by the Navigator and Range
 * selector.
 */

wrap$8(Axis$a.prototype, 'zoom', function (proceed, newMin, newMax) {
  var chart = this.chart,
      chartOptions = chart.options,
      zoomType = chartOptions.chart.zoomType,
      pinchType = chartOptions.chart.pinchType,
      previousZoom,
      navigator = chartOptions.navigator,
      rangeSelector = chartOptions.rangeSelector,
      ret;

  if (this.isXAxis && (navigator && navigator.enabled || rangeSelector && rangeSelector.enabled)) {
    // For x only zooming, fool the chart.zoom method not to create the zoom
    // button because the property already exists
    if (!isTouchDevice$2 && zoomType === 'x' || isTouchDevice$2 && pinchType === 'x') {
      chart.resetZoomButton = 'blocked'; // For y only zooming, ignore the X axis completely
    } else if (zoomType === 'y') {
      ret = false; // For xy zooming, record the state of the zoom before zoom selection,
      // then when the reset button is pressed, revert to this state. This
      // should apply only if the chart is initialized with a range (#6612),
      // otherwise zoom all the way out.
    } else if ((!isTouchDevice$2 && zoomType === 'xy' || isTouchDevice$2 && pinchType === 'xy') && this.options.range) {
      previousZoom = this.previousZoom;

      if (defined$i(newMin)) {
        this.previousZoom = [this.min, this.max];
      } else if (previousZoom) {
        newMin = previousZoom[0];
        newMax = previousZoom[1];
        delete this.previousZoom;
      }
    }
  }

  return ret !== undefined ? ret : proceed.call(this, newMin, newMax);
}); // Initialize navigator for stock charts

addEvent$i(Chart$8, 'beforeRender', function () {
  var options = this.options;

  if (options.navigator.enabled || options.scrollbar.enabled) {
    this.scroller = this.navigator = new Navigator(this);
  }
});
/**
 * For stock charts, extend the Chart.setChartSize method so that we can set the
 * final top position of the navigator once the height of the chart, including
 * the legend, is determined. #367. We can't use Chart.getMargins, because
 * labels offsets are not calculated yet.
 */

addEvent$i(Chart$8, 'afterSetChartSize', function () {
  var legend = this.legend,
      navigator = this.navigator,
      scrollbarHeight,
      legendOptions,
      xAxis,
      yAxis;

  if (navigator) {
    legendOptions = legend && legend.options;
    xAxis = navigator.xAxis;
    yAxis = navigator.yAxis;
    scrollbarHeight = navigator.scrollbarHeight; // Compute the top position

    if (this.inverted) {
      navigator.left = navigator.opposite ? this.chartWidth - scrollbarHeight - navigator.height : this.spacing[3] + scrollbarHeight;
      navigator.top = this.plotTop + scrollbarHeight;
    } else {
      navigator.left = this.plotLeft + scrollbarHeight;
      navigator.top = navigator.navigatorOptions.top || this.chartHeight - navigator.height - scrollbarHeight - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (legendOptions && legendOptions.verticalAlign === 'bottom' && legendOptions.enabled && !legendOptions.floating ? legend.legendHeight + pick$t(legendOptions.margin, 10) : 0);
    }

    if (xAxis && yAxis) {
      // false if navigator is disabled (#904)
      if (this.inverted) {
        xAxis.options.left = yAxis.options.left = navigator.left;
      } else {
        xAxis.options.top = yAxis.options.top = navigator.top;
      }

      xAxis.setAxisSize();
      yAxis.setAxisSize();
    }
  }
}); // Merge options, if no scrolling exists yet

addEvent$i(Chart$8, 'update', function (e) {
  var navigatorOptions = e.options.navigator || {},
      scrollbarOptions = e.options.scrollbar || {};

  if (!this.navigator && !this.scroller && (navigatorOptions.enabled || scrollbarOptions.enabled)) {
    merge$j(true, this.options.navigator, navigatorOptions);
    merge$j(true, this.options.scrollbar, scrollbarOptions);
    delete e.options.navigator;
    delete e.options.scrollbar;
  }
}); // Initiate navigator, if no scrolling exists yet

addEvent$i(Chart$8, 'afterUpdate', function () {
  if (!this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled)) {
    this.scroller = this.navigator = new Navigator(this);
  }
}); // Pick up badly formatted point options to addPoint

wrap$8(Series$c.prototype, 'addPoint', function (proceed, options, redraw, shift, animation) {
  var turboThreshold = this.options.turboThreshold;

  if (turboThreshold && this.xData.length > turboThreshold && isObject$7(options, true) && this.chart.navigator) {
    error(20, true);
  }

  proceed.call(this, options, redraw, shift, animation);
}); // Handle adding new series

addEvent$i(Chart$8, 'afterAddSeries', function () {
  if (this.navigator) {
    // Recompute which series should be shown in navigator, and add them
    this.navigator.setBaseSeries(null, false);
  }
}); // Handle updating series

addEvent$i(Series$c, 'afterUpdate', function () {
  if (this.chart.navigator && !this.options.isInternal) {
    this.chart.navigator.setBaseSeries(null, false);
  }
});
Chart$8.prototype.callbacks.push(function (chart) {
  var extremes,
      navigator = chart.navigator; // Initiate the navigator

  if (navigator && chart.xAxis[0]) {
    extremes = chart.xAxis[0].getExtremes();
    navigator.render(extremes.min, extremes.max);
  }
});

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$j = Highcharts.addEvent,
    Axis$b = Highcharts.Axis,
    Chart$9 = Highcharts.Chart,
    css$9 = Highcharts.css,
    createElement$5 = Highcharts.createElement,
    defaultOptions$6 = Highcharts.defaultOptions,
    defined$j = Highcharts.defined,
    destroyObjectProperties$7 = Highcharts.destroyObjectProperties,
    discardElement$2 = Highcharts.discardElement,
    each$w = Highcharts.each,
    extend$k = Highcharts.extend,
    fireEvent$b = Highcharts.fireEvent,
    isNumber$d = Highcharts.isNumber,
    merge$k = Highcharts.merge,
    pick$u = Highcharts.pick,
    pInt$4 = Highcharts.pInt,
    splat$8 = Highcharts.splat,
    wrap$9 = Highcharts.wrap;
/* ****************************************************************************
 * Start Range Selector code                                                  *
 *****************************************************************************/

extend$k(defaultOptions$6, {
  /**
   * The range selector is a tool for selecting ranges to display within
   * the chart. It provides buttons to select preconfigured ranges in
   * the chart, like 1 day, 1 week, 1 month etc. It also provides input
   * boxes where min and max dates can be manually input.
   *
   * @product highstock
   * @optionparent rangeSelector
   */
  rangeSelector: {
    /**
     * Whether to enable all buttons from the start. By default buttons are
     * only enabled if the corresponding time range exists on the X axis,
     * but enabling all buttons allows for dynamically loading different
     * time ranges.
     *
     * @sample {highstock} stock/rangeselector/allbuttonsenabled-true/
     *         All buttons enabled
     *
     * @type       {boolean}
     * @default    false
     * @since      2.0.3
     * @product    highstock
     * @apioption  rangeSelector.allButtonsEnabled
     */

    /**
     * An array of configuration objects for the buttons.
     *
     * Defaults to
     *
     * <pre>buttons: [{
     *     type: 'month',
     *     count: 1,
     *     text: '1m'
     * }, {
     *     type: 'month',
     *     count: 3,
     *     text: '3m'
     * }, {
     *     type: 'month',
     *     count: 6,
     *     text: '6m'
     * }, {
     *     type: 'ytd',
     *     text: 'YTD'
     * }, {
     *     type: 'year',
     *     count: 1,
     *     text: '1y'
     * }, {
     *     type: 'all',
     *     text: 'All'
     * }]</pre>
     *
     * @sample {highstock} stock/rangeselector/datagrouping/
     *         Data grouping by buttons
     *
     * @type       {Array<*>}
     * @product    highstock
     * @apioption  rangeSelector.buttons
     */

    /**
     * How many units of the defined type the button should span. If `type`
     * is "month" and `count` is 3, the button spans three months.
     *
     * @type       {number}
     * @default    1
     * @product    highstock
     * @apioption  rangeSelector.buttons.count
     */

    /**
     * Fires when clicking on the rangeSelector button. One parameter,
     * event, is passed to the function, containing common event
     * information.
     *
     * <pre>
     * click: function(e) {
     *   console.log(this);
     * }
     * </pre>
     *
     * Return false to stop default button's click action.
     *
     * @sample {highstock} stock/rangeselector/button-click/
     *         Click event on the button
     *
     * @type       {Function}
     * @product    highstock
     * @apioption  rangeSelector.buttons.events.click
     */

    /**
     * Additional range (in milliseconds) added to the end of the calculated
     * time span.
     *
     * @sample {highstock} stock/rangeselector/min-max-offsets/
     *         Button offsets
     *
     * @type       {number}
     * @default    0
     * @since      6.0.0
     * @product    highstock
     * @apioption  rangeSelector.buttons.offsetMax
     */

    /**
     * Additional range (in milliseconds) added to the start of the
     * calculated time span.
     *
     * @sample {highstock} stock/rangeselector/min-max-offsets/
     *         Button offsets
     *
     * @type       {number}
     * @default    0
     * @since      6.0.0
     * @product    highstock
     * @apioption  rangeSelector.buttons.offsetMin
     */

    /**
     * When buttons apply dataGrouping on a series, by default zooming
     * in/out will deselect buttons and unset dataGrouping. Enable this
     * option to keep buttons selected when extremes change.
     *
     * @sample {highstock} stock/rangeselector/preserve-datagrouping/
     *         Different preserveDataGrouping settings
     *
     * @type       {boolean}
     * @since      6.1.2
     * @default    false
     * @product    highstock
     * @apioption  rangeSelector.buttons.preserveDataGrouping
     */

    /**
     * A custom data grouping object for each button.
     *
     * @see [series.dataGrouping](#plotOptions.series.dataGrouping)
     *
     * @sample {highstock} stock/rangeselector/datagrouping/
     *         Data grouping by range selector buttons
     *
     * @type       {*}
     * @extends    plotOptions.series.dataGrouping
     * @product    highstock
     * @apioption  rangeSelector.buttons.dataGrouping
     */

    /**
     * The text for the button itself.
     *
     * @type       {string}
     * @product    highstock
     * @apioption  rangeSelector.buttons.text
     */

    /**
     * Defined the time span for the button. Can be one of `millisecond`,
     * `second`, `minute`, `hour`, `day`, `week`, `month`, `ytd`, `all`.
     *
     * @type       {string}
     * @product    highstock
     * @validvalue ["millisecond", "second", "minute", "day", "week", "month", "ytd", "all"]
     * @apioption  rangeSelector.buttons.type
     */

    /**
     * The space in pixels between the buttons in the range selector.
     *
     * @type       {number}
     * @default    0
     * @product    highstock
     * @apioption  rangeSelector.buttonSpacing
     */

    /**
     * Enable or disable the range selector.
     *
     * @sample {highstock} stock/rangeselector/enabled/
     *         Disable the range selector
     *
     * @type       {boolean}
     * @default    true
     * @product    highstock
     * @apioption  rangeSelector.enabled
     */

    /**
     * The vertical alignment of the rangeselector box. Allowed properties
     * are `top`, `middle`, `bottom`.
     *
     * @sample {highstock} stock/rangeselector/vertical-align-middle/
     *         Middle
     * @sample {highstock} stock/rangeselector/vertical-align-bottom/
     *         Bottom
     *
     * @type       {string}
     * @default    top
     * @since      6.0.0
     * @validvalue ["top", "middle", "bottom"]
     * @apioption  rangeSelector.verticalAlign
     */
    verticalAlign: 'top',

    /**
     * A collection of attributes for the buttons. The object takes SVG
     * attributes like `fill`, `stroke`, `stroke-width`, as well as `style`,
     * a collection of CSS properties for the text.
     *
     * The object can also be extended with states, so you can set
     * presentational options for `hover`, `select` or `disabled` button
     * states.
     *
     * CSS styles for the text label.
     *
     * In styled mode, the buttons are styled by the
     * `.highcharts-range-selector-buttons .highcharts-button` rule with its
     * different states.
     *
     * @sample {highstock} stock/rangeselector/styling/
     *         Styling the buttons and inputs
     *
     * @type       {Highcharts.CSSObject}
     * @product    highstock
     * @apioption  rangeSelector.buttonTheme
     */
    buttonTheme: {
      width: 28,
      height: 18,
      padding: 2,
      zIndex: 7 // #484, #852

    },

    /**
     * When the rangeselector is floating, the plot area does not reserve
     * space for it. This opens for positioning anywhere on the chart.
     *
     * @sample {highstock} stock/rangeselector/floating/
     *         Placing the range selector between the plot area and the
     *         navigator
     *
     * @type       {boolean}
     * @default    false
     * @since      6.0.0
     * @product    highstock
     * @apioption  rangeSelector.floating
     */
    floating: false,

    /**
     * The x offset of the range selector relative to its horizontal
     * alignment within `chart.spacingLeft` and `chart.spacingRight`.
     *
     * @type       {number}
     * @default    0
     * @since      6.0.0
     * @product    highstock
     * @apioption  rangeSelector.x
     */
    x: 0,

    /**
     * The y offset of the range selector relative to its horizontal
     * alignment within `chart.spacingLeft` and `chart.spacingRight`.
     *
     * @type       {number}
     * @default    0
     * @since      6.0.0
     * @product    highstock
     * @apioption  rangeSelector.y
     */
    y: 0,

    /**
     * Deprecated. The height of the range selector. Currently it is
     * calculated dynamically.
     *
     * @deprecated
     * @type       {number}
     * @default    undefined
     * @since      2.1.9
     * @product    highstock
     * @apioption  rangeSelector.height
     */
    height: undefined,
    // reserved space for buttons and input

    /**
     * The border color of the date input boxes.
     *
     * @sample {highstock} stock/rangeselector/styling/
     *         Styling the buttons and inputs
     *
     * @type       {Highcharts.ColorString}
     * @default    #cccccc
     * @since      1.3.7
     * @product    highstock
     * @apioption  rangeSelector.inputBoxBorderColor
     */

    /**
     * The pixel height of the date input boxes.
     *
     * @sample {highstock} stock/rangeselector/styling/
     *         Styling the buttons and inputs
     *
     * @type       {number}
     * @default    17
     * @since      1.3.7
     * @product    highstock
     * @apioption  rangeSelector.inputBoxHeight
     */

    /**
     * CSS for the container DIV holding the input boxes. Deprecated as
     * of 1.2.5\. Use [inputPosition](#rangeSelector.inputPosition) instead.
     *
     * @sample {highstock} stock/rangeselector/styling/
     *         Styling the buttons and inputs
     *
     * @deprecated
     * @type       {Highcharts.CSSObject}
     * @product    highstock
     * @apioption  rangeSelector.inputBoxStyle
     */

    /**
     * The pixel width of the date input boxes.
     *
     * @sample {highstock} stock/rangeselector/styling/
     *         Styling the buttons and inputs
     *
     * @type       {number}
     * @default    90
     * @since      1.3.7
     * @product    highstock
     * @apioption  rangeSelector.inputBoxWidth
     */

    /**
     * The date format in the input boxes when not selected for editing.
     * Defaults to `%b %e, %Y`.
     *
     * @sample {highstock} stock/rangeselector/input-format/
     *         Milliseconds in the range selector
     *
     * @type       {string}
     * @default    %b %e %Y,
     * @product    highstock
     * @apioption  rangeSelector.inputDateFormat
     */

    /**
     * A custom callback function to parse values entered in the input boxes
     * and return a valid JavaScript time as milliseconds since 1970.
     *
     * @sample {highstock} stock/rangeselector/input-format/
     *         Milliseconds in the range selector
     *
     * @type       {Function}
     * @since      1.3.3
     * @product    highstock
     * @apioption  rangeSelector.inputDateParser
     */

    /**
     * The date format in the input boxes when they are selected for
     * editing. This must be a format that is recognized by JavaScript
     * Date.parse.
     *
     * @sample {highstock} stock/rangeselector/input-format/
     *         Milliseconds in the range selector
     *
     * @type       {string}
     * @default    %Y-%m-%d
     * @product    highstock
     * @apioption  rangeSelector.inputEditDateFormat
     */

    /**
     * Enable or disable the date input boxes. Defaults to enabled when
     * there is enough space, disabled if not (typically mobile).
     *
     * @sample {highstock} stock/rangeselector/input-datepicker/
     *         Extending the input with a jQuery UI datepicker
     *
     * @type       {boolean}
     * @default    true
     * @product    highstock
     * @apioption  rangeSelector.inputEnabled
     */

    /**
     * Positioning for the input boxes. Allowed properties are `align`,
     *  `x` and `y`.
     *
     * @type       {*}
     * @since      1.2.4
     * @product    highstock
     * @apioption  rangeSelector.inputPosition
     */
    inputPosition: {
      /**
       * The alignment of the input box. Allowed properties are `left`,
       * `center`, `right`.
       *
       * @sample {highstock} stock/rangeselector/input-button-position/
       *         Alignment
       *
       * @type       {string}
       * @default    right
       * @since      6.0.0
       * @validvalue ["left", "center", "right"]
       * @apioption  rangeSelector.inputPosition.align
       */
      align: 'right',

      /**
       * X offset of the input row.
       *
       * @type       {number}
       * @default    0
       * @apioption  rangeSelector.inputPosition.x
       */
      x: 0,

      /**
       * Y offset of the input row.
       *
       * @type       {number}
       * @default    0
       * @apioption  rangeSelector.inputPosition.y
       */
      y: 0
    },

    /**
     * The index of the button to appear pre-selected.
     *
     * @type       {number}
     * @product    highstock
     * @apioption  rangeSelector.selected
     */

    /**
     * Positioning for the button row.
     *
     * @type       {*}
     * @since      1.2.4
     * @product    highstock
     * @apioption  rangeSelector.buttonPosition
     */
    buttonPosition: {
      /**
       * The alignment of the input box. Allowed properties are `left`,
       * `center`, `right`.
       *
       * @sample {highstock} stock/rangeselector/input-button-position/
       *         Alignment
       *
       * @type       {string}
       * @default    left
       * @since      6.0.0
       * @validvalue ["left", "center", "right"]
       * @apioption  rangeSelector.buttonPosition.align
       */
      align: 'left',

      /**
       * X offset of the button row.
       *
       * @type       {number}
       * @default    0
       * @apioption  rangeSelector.buttonPosition.x
       */
      x: 0,

      /**
       * Y offset of the button row.
       *
       * @type       {number}
       * @default    0
       * @apioption  rangeSelector.buttonPosition.y
       */
      y: 0
    }
  }
});
defaultOptions$6.lang = merge$k(defaultOptions$6.lang,
/**
 * Language object. The language object is global and it can't be set
 * on each chart initiation. Instead, use `Highcharts.setOptions` to
 * set it before any chart is initialized.
 *
 * <pre>Highcharts.setOptions({
 *     lang: {
 *         months: [
 *             'Janvier', 'Février', 'Mars', 'Avril',
 *             'Mai', 'Juin', 'Juillet', 'Août',
 *             'Septembre', 'Octobre', 'Novembre', 'Décembre'
 *         ],
 *         weekdays: [
 *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',
 *             'Jeudi', 'Vendredi', 'Samedi'
 *         ]
 *     }
 * });</pre>
 *
 * @optionparent lang
 * @product highstock
 */
{
  /**
   * The text for the label for the range selector buttons.
   *
   * @type       {string}
   * @default    Zoom
   * @product    highstock
   * @apioption  lang.rangeSelectorZoom
   */
  rangeSelectorZoom: 'Zoom',

  /**
   * The text for the label for the "from" input box in the range
   * selector.
   *
   * @type       {string}
   * @default    From
   * @product    highstock
   * @apioption  lang.rangeSelectorFrom
   */
  rangeSelectorFrom: 'From',

  /**
   * The text for the label for the "to" input box in the range selector.
   *
   * @type       {string}
   * @default    To
   * @product    highstock
   * @apioption  lang.rangeSelectorTo
   */
  rangeSelectorTo: 'To'
});
/**
 * The range selector.
 *
 * @class Highcharts.RangeSelector
 *
 * @param {Highcharts.Chart} chart
 */

function RangeSelector(chart) {
  // Run RangeSelector
  this.init(chart);
}

RangeSelector.prototype = {
  /**
   * The method to run when one of the buttons in the range selectors is
   * clicked
   *
   * @function Highcharts.RangeSelector#clickButton
   *
   * @param  {number} i
   *         The index of the button
   *
   * @param  {boolean} redraw
   *
   * @return {void}
   */
  clickButton: function (i, redraw) {
    var rangeSelector = this,
        chart = rangeSelector.chart,
        rangeOptions = rangeSelector.buttonOptions[i],
        baseAxis = chart.xAxis[0],
        unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || baseAxis || {},
        dataMin = unionExtremes.dataMin,
        dataMax = unionExtremes.dataMax,
        newMin,
        newMax = baseAxis && Math.round(Math.min(baseAxis.max, pick$u(dataMax, baseAxis.max))),
        // #1568
    type = rangeOptions.type,
        baseXAxisOptions,
        range = rangeOptions._range,
        rangeMin,
        minSetting,
        rangeSetting,
        ctx,
        ytdExtremes,
        dataGrouping = rangeOptions.dataGrouping; // chart has no data, base series is removed

    if (dataMin === null || dataMax === null) {
      return;
    } // Set the fixed range before range is altered


    chart.fixedRange = range; // Apply dataGrouping associated to button

    if (dataGrouping) {
      this.forcedDataGrouping = true;
      Axis$b.prototype.setDataGrouping.call(baseAxis || {
        chart: this.chart
      }, dataGrouping, false);
      this.frozenStates = rangeOptions.preserveDataGrouping;
    } // Apply range


    if (type === 'month' || type === 'year') {
      if (!baseAxis) {
        // This is set to the user options and picked up later when the
        // axis is instantiated so that we know the min and max.
        range = rangeOptions;
      } else {
        ctx = {
          range: rangeOptions,
          max: newMax,
          chart: chart,
          dataMin: dataMin,
          dataMax: dataMax
        };
        newMin = baseAxis.minFromRange.call(ctx);

        if (isNumber$d(ctx.newMax)) {
          newMax = ctx.newMax;
        }
      } // Fixed times like minutes, hours, days

    } else if (range) {
      newMin = Math.max(newMax - range, dataMin);
      newMax = Math.min(newMin + range, dataMax);
    } else if (type === 'ytd') {
      // On user clicks on the buttons, or a delayed action running from
      // the beforeRender event (below), the baseAxis is defined.
      if (baseAxis) {
        // When "ytd" is the pre-selected button for the initial view,
        // its calculation is delayed and rerun in the beforeRender
        // event (below). When the series are initialized, but before
        // the chart is rendered, we have access to the xData array
        // (#942).
        if (dataMax === undefined) {
          dataMin = Number.MAX_VALUE;
          dataMax = Number.MIN_VALUE;
          each$w(chart.series, function (series) {
            // reassign it to the last item
            var xData = series.xData;
            dataMin = Math.min(xData[0], dataMin);
            dataMax = Math.max(xData[xData.length - 1], dataMax);
          });
          redraw = false;
        }

        ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC);
        newMin = rangeMin = ytdExtremes.min;
        newMax = ytdExtremes.max; // "ytd" is pre-selected. We don't yet have access to processed
        // point and extremes data (things like pointStart and pointInterval
        // are missing), so we delay the process (#942)
      } else {
        addEvent$j(chart, 'beforeRender', function () {
          rangeSelector.clickButton(i);
        });
        return;
      }
    } else if (type === 'all' && baseAxis) {
      newMin = dataMin;
      newMax = dataMax;
    }

    newMin += rangeOptions._offsetMin;
    newMax += rangeOptions._offsetMax;
    rangeSelector.setSelected(i); // Update the chart

    if (!baseAxis) {
      // Axis not yet instanciated. Temporarily set min and range
      // options and remove them on chart load (#4317).
      baseXAxisOptions = splat$8(chart.options.xAxis)[0];
      rangeSetting = baseXAxisOptions.range;
      baseXAxisOptions.range = range;
      minSetting = baseXAxisOptions.min;
      baseXAxisOptions.min = rangeMin;
      addEvent$j(chart, 'load', function resetMinAndRange() {
        baseXAxisOptions.range = rangeSetting;
        baseXAxisOptions.min = minSetting;
      });
    } else {
      // Existing axis object. Set extremes after render time.
      baseAxis.setExtremes(newMin, newMax, pick$u(redraw, 1), null, // auto animation
      {
        trigger: 'rangeSelectorButton',
        rangeSelectorButton: rangeOptions
      });
    }
  },

  /**
   * Set the selected option. This method only sets the internal flag, it
   * doesn't update the buttons or the actual zoomed range.
   *
   * @function Highcharts.RangeSelector#setSelected
   *
   * @param  {boolean} selected
   *
   * @return {void}
   */
  setSelected: function (selected) {
    this.selected = this.options.selected = selected;
  },

  /**
   * The default buttons for pre-selecting time frames
   */
  defaultButtons: [{
    type: 'month',
    count: 1,
    text: '1m'
  }, {
    type: 'month',
    count: 3,
    text: '3m'
  }, {
    type: 'month',
    count: 6,
    text: '6m'
  }, {
    type: 'ytd',
    text: 'YTD'
  }, {
    type: 'year',
    count: 1,
    text: '1y'
  }, {
    type: 'all',
    text: 'All'
  }],

  /**
   * Initialize the range selector
   *
   * @function Highcharts.RangeSelector#init
   *
   * @param  {Highcharts.Chart} chart
   *
   * @return {void}
   */
  init: function (chart) {
    var rangeSelector = this,
        options = chart.options.rangeSelector,
        buttonOptions = options.buttons || [].concat(rangeSelector.defaultButtons),
        selectedOption = options.selected,
        blurInputs = function () {
      var minInput = rangeSelector.minInput,
          maxInput = rangeSelector.maxInput; // #3274 in some case blur is not defined

      if (minInput && minInput.blur) {
        fireEvent$b(minInput, 'blur');
      }

      if (maxInput && maxInput.blur) {
        fireEvent$b(maxInput, 'blur');
      }
    };

    rangeSelector.chart = chart;
    rangeSelector.options = options;
    rangeSelector.buttons = [];
    chart.extraTopMargin = options.height;
    rangeSelector.buttonOptions = buttonOptions;
    this.unMouseDown = addEvent$j(chart.container, 'mousedown', blurInputs);
    this.unResize = addEvent$j(chart, 'resize', blurInputs); // Extend the buttonOptions with actual range

    each$w(buttonOptions, rangeSelector.computeButtonRange); // zoomed range based on a pre-selected button index

    if (selectedOption !== undefined && buttonOptions[selectedOption]) {
      this.clickButton(selectedOption, false);
    }

    addEvent$j(chart, 'load', function () {
      // If a data grouping is applied to the current button, release it
      // when extremes change
      if (chart.xAxis && chart.xAxis[0]) {
        addEvent$j(chart.xAxis[0], 'setExtremes', function (e) {
          if (this.max - this.min !== chart.fixedRange && e.trigger !== 'rangeSelectorButton' && e.trigger !== 'updatedData' && rangeSelector.forcedDataGrouping && !rangeSelector.frozenStates) {
            this.setDataGrouping(false, false);
          }
        });
      }
    });
  },

  /**
   * Dynamically update the range selector buttons after a new range has been
   * set
   *
   * @function Highcharts.RangeSelector#updateButtonStates
   *
   * @return {void}
   */
  updateButtonStates: function () {
    var rangeSelector = this,
        chart = this.chart,
        baseAxis = chart.xAxis[0],
        actualRange = Math.round(baseAxis.max - baseAxis.min),
        hasNoData = !baseAxis.hasVisibleSeries,
        day = 24 * 36e5,
        // A single day in milliseconds
    unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || baseAxis,
        dataMin = unionExtremes.dataMin,
        dataMax = unionExtremes.dataMax,
        ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC),
        ytdMin = ytdExtremes.min,
        ytdMax = ytdExtremes.max,
        selected = rangeSelector.selected,
        selectedExists = isNumber$d(selected),
        allButtonsEnabled = rangeSelector.options.allButtonsEnabled,
        buttons = rangeSelector.buttons;
    each$w(rangeSelector.buttonOptions, function (rangeOptions, i) {
      var range = rangeOptions._range,
          type = rangeOptions.type,
          count = rangeOptions.count || 1,
          button = buttons[i],
          state = 0,
          disable,
          select,
          offsetRange = rangeOptions._offsetMax - rangeOptions._offsetMin,
          isSelected = i === selected,
          // Disable buttons where the range exceeds what is allowed in
      // the current view
      isTooGreatRange = range > dataMax - dataMin,
          // Disable buttons where the range is smaller than the minimum
      // range
      isTooSmallRange = range < baseAxis.minRange,
          // Do not select the YTD button if not explicitly told so
      isYTDButNotSelected = false,
          // Disable the All button if we're already showing all
      isAllButAlreadyShowingAll = false,
          isSameRange = range === actualRange; // Months and years have a variable range so we check the extremes

      if ((type === 'month' || type === 'year') && actualRange + 36e5 >= {
        month: 28,
        year: 365
      }[type] * day * count - offsetRange && actualRange - 36e5 <= {
        month: 31,
        year: 366
      }[type] * day * count + offsetRange) {
        isSameRange = true;
      } else if (type === 'ytd') {
        isSameRange = ytdMax - ytdMin + offsetRange === actualRange;
        isYTDButNotSelected = !isSelected;
      } else if (type === 'all') {
        isSameRange = baseAxis.max - baseAxis.min >= dataMax - dataMin;
        isAllButAlreadyShowingAll = !isSelected && selectedExists && isSameRange;
      } // The new zoom area happens to match the range for a button - mark
      // it selected. This happens when scrolling across an ordinal gap.
      // It can be seen in the intraday demos when selecting 1h and scroll
      // across the night gap.


      disable = !allButtonsEnabled && (isTooGreatRange || isTooSmallRange || isAllButAlreadyShowingAll || hasNoData);
      select = isSelected && isSameRange || isSameRange && !selectedExists && !isYTDButNotSelected || isSelected && rangeSelector.frozenStates;

      if (disable) {
        state = 3;
      } else if (select) {
        selectedExists = true; // Only one button can be selected

        state = 2;
      } // If state has changed, update the button


      if (button.state !== state) {
        button.setState(state);
      }
    });
  },

  /**
   * Compute and cache the range for an individual button
   *
   * @function Highcharts.RangeSelector#computeButtonRange
   *
   * @param  {Highcharts.RangeSelectorOptions} rangeOptions
   *
   * @return {void}
   */
  computeButtonRange: function (rangeOptions) {
    var type = rangeOptions.type,
        count = rangeOptions.count || 1,
        // these time intervals have a fixed number of milliseconds, as
    // opposed to month, ytd and year
    fixedTimes = {
      millisecond: 1,
      second: 1000,
      minute: 60 * 1000,
      hour: 3600 * 1000,
      day: 24 * 3600 * 1000,
      week: 7 * 24 * 3600 * 1000
    }; // Store the range on the button object

    if (fixedTimes[type]) {
      rangeOptions._range = fixedTimes[type] * count;
    } else if (type === 'month' || type === 'year') {
      rangeOptions._range = {
        month: 30,
        year: 365
      }[type] * 24 * 36e5 * count;
    }

    rangeOptions._offsetMin = pick$u(rangeOptions.offsetMin, 0);
    rangeOptions._offsetMax = pick$u(rangeOptions.offsetMax, 0);
    rangeOptions._range += rangeOptions._offsetMax - rangeOptions._offsetMin;
  },

  /**
   * Set the internal and displayed value of a HTML input for the dates
   *
   * @function Highcharts.RangeSelector#setInputValue
   *
   * @param  {string} name
   *
   * @param  {number} inputTime
   *
   * @return {void}
   */
  setInputValue: function (name, inputTime) {
    var options = this.chart.options.rangeSelector,
        time = this.chart.time,
        input = this[name + 'Input'];

    if (defined$j(inputTime)) {
      input.previousValue = input.HCTime;
      input.HCTime = inputTime;
    }

    input.value = time.dateFormat(options.inputEditDateFormat || '%Y-%m-%d', input.HCTime);
    this[name + 'DateBox'].attr({
      text: time.dateFormat(options.inputDateFormat || '%b %e, %Y', input.HCTime)
    });
  },

  /**
   * @function Highcharts.RangeSelector#showInput
   *
   * @param  {string} name
   *
   * @return {void}
   */
  showInput: function (name) {
    var inputGroup = this.inputGroup,
        dateBox = this[name + 'DateBox'];
    css$9(this[name + 'Input'], {
      left: inputGroup.translateX + dateBox.x + 'px',
      top: inputGroup.translateY + 'px',
      width: dateBox.width - 2 + 'px',
      height: dateBox.height - 2 + 'px',
      border: '2px solid silver'
    });
  },

  /**
   * @function Highcharts.RangeSelector#hideInput
   *
   * @param  {string} name
   *
   * @return {void}
   */
  hideInput: function (name) {
    css$9(this[name + 'Input'], {
      border: 0,
      width: '1px',
      height: '1px'
    });
    this.setInputValue(name);
  },

  /**
   * Draw either the 'from' or the 'to' HTML input box of the range selector
   *
   * @function Highcharts.RangeSelector#drawInput
   *
   * @param  {string} name
   *
   * @return {void}
   */
  drawInput: function (name) {
    var rangeSelector = this,
        chart = rangeSelector.chart,
        chartStyle = chart.renderer.style || {},
        renderer = chart.renderer,
        options = chart.options.rangeSelector,
        lang = defaultOptions$6.lang,
        div = rangeSelector.div,
        isMin = name === 'min',
        input,
        label,
        dateBox,
        inputGroup = this.inputGroup;

    function updateExtremes() {
      var inputValue = input.value,
          value = (options.inputDateParser || Date.parse)(inputValue),
          chartAxis = chart.xAxis[0],
          dataAxis = chart.scroller && chart.scroller.xAxis ? chart.scroller.xAxis : chartAxis,
          dataMin = dataAxis.dataMin,
          dataMax = dataAxis.dataMax;

      if (value !== input.previousValue) {
        input.previousValue = value; // If the value isn't parsed directly to a value by the
        // browser's Date.parse method, like YYYY-MM-DD in IE, try
        // parsing it a different way

        if (!isNumber$d(value)) {
          value = inputValue.split('-');
          value = Date.UTC(pInt$4(value[0]), pInt$4(value[1]) - 1, pInt$4(value[2]));
        }

        if (isNumber$d(value)) {
          // Correct for timezone offset (#433)
          if (!chart.time.useUTC) {
            value = value + new Date().getTimezoneOffset() * 60 * 1000;
          } // Validate the extremes. If it goes beyound the data min or
          // max, use the actual data extreme (#2438).


          if (isMin) {
            if (value > rangeSelector.maxInput.HCTime) {
              value = undefined;
            } else if (value < dataMin) {
              value = dataMin;
            }
          } else {
            if (value < rangeSelector.minInput.HCTime) {
              value = undefined;
            } else if (value > dataMax) {
              value = dataMax;
            }
          } // Set the extremes


          if (value !== undefined) {
            chartAxis.setExtremes(isMin ? value : chartAxis.min, isMin ? chartAxis.max : value, undefined, undefined, {
              trigger: 'rangeSelectorInput'
            });
          }
        }
      }
    } // Create the text label


    this[name + 'Label'] = label = renderer.label(lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo'], this.inputGroup.offset).addClass('highcharts-range-label').attr({
      padding: 2
    }).add(inputGroup);
    inputGroup.offset += label.width + 5; // Create an SVG label that shows updated date ranges and and records
    // click events that bring in the HTML input.

    this[name + 'DateBox'] = dateBox = renderer.label('', inputGroup.offset).addClass('highcharts-range-input').attr({
      padding: 2,
      width: options.inputBoxWidth || 90,
      height: options.inputBoxHeight || 17,
      'text-align': 'center'
    }).on('click', function () {
      // If it is already focused, the onfocus event doesn't fire
      // (#3713)
      rangeSelector.showInput(name);
      rangeSelector[name + 'Input'].focus();
    }).add(inputGroup);
    inputGroup.offset += dateBox.width + (isMin ? 10 : 0); // Create the HTML input element. This is rendered as 1x1 pixel then set
    // to the right size when focused.

    this[name + 'Input'] = input = createElement$5('input', {
      name: name,
      className: 'highcharts-range-selector',
      type: 'text'
    }, {
      top: chart.plotTop + 'px' // prevent jump on focus in Firefox

    }, div); // Blow up the input box

    input.onfocus = function () {
      rangeSelector.showInput(name);
    }; // Hide away the input box


    input.onblur = function () {
      rangeSelector.hideInput(name);
    }; // handle changes in the input boxes


    input.onchange = updateExtremes;

    input.onkeypress = function (event) {
      // IE does not fire onchange on enter
      if (event.keyCode === 13) {
        updateExtremes();
      }
    };
  },

  /**
   * Get the position of the range selector buttons and inputs. This can be
   * overridden from outside for custom positioning.
   *
   * @function Highcharts.RangeSelector#getPosition
   *
   * @return {Highcharts.Dictionary<number>}
   */
  getPosition: function () {
    var chart = this.chart,
        options = chart.options.rangeSelector,
        top = options.verticalAlign === 'top' ? chart.plotTop - chart.axisOffset[0] : 0; // set offset only for varticalAlign top

    return {
      buttonTop: top + options.buttonPosition.y,
      inputTop: top + options.inputPosition.y - 10
    };
  },

  /**
   * Get the extremes of YTD. Will choose dataMax if its value is lower than
   * the current timestamp. Will choose dataMin if its value is higher than
   * the timestamp for the start of current year.
   *
   * @function Highcharts.RangeSelector#getYTDExtremes
   *
   * @param  {number} dataMax
   *
   * @param  {number} dataMin
   *
   * @return {*}
   *         Returns min and max for the YTD
   */
  getYTDExtremes: function (dataMax, dataMin, useUTC) {
    var time = this.chart.time,
        min,
        now = new time.Date(dataMax),
        year = time.get('FullYear', now),
        startOfYear = useUTC ? time.Date.UTC(year, 0, 1) : // eslint-disable-line new-cap
    +new time.Date(year, 0, 1);
    min = Math.max(dataMin || 0, startOfYear);
    now = now.getTime();
    return {
      max: Math.min(dataMax || now, now),
      min: min
    };
  },

  /**
   * Render the range selector including the buttons and the inputs. The first
   * time render is called, the elements are created and positioned. On
   * subsequent calls, they are moved and updated.
   *
   * @function Highcharts.RangeSelector#render
   *
   * @param  {number} min
   *         X axis minimum
   *
   * @param  {number} max
   *         X axis maximum
   *
   * @return {void}
   */
  render: function (min, max) {
    var rangeSelector = this,
        chart = rangeSelector.chart,
        renderer = chart.renderer,
        container = chart.container,
        chartOptions = chart.options,
        navButtonOptions = chartOptions.exporting && chartOptions.exporting.enabled !== false && chartOptions.navigation && chartOptions.navigation.buttonOptions,
        lang = defaultOptions$6.lang,
        div = rangeSelector.div,
        options = chartOptions.rangeSelector,
        // Place inputs above the container
    inputsZIndex = pick$u(chartOptions.chart.style && chartOptions.chart.style.zIndex, 0) + 1,
        floating = options.floating,
        buttons = rangeSelector.buttons,
        inputGroup = rangeSelector.inputGroup,
        buttonTheme = options.buttonTheme,
        buttonPosition = options.buttonPosition,
        inputPosition = options.inputPosition,
        inputEnabled = options.inputEnabled,
        states = buttonTheme && buttonTheme.states,
        plotLeft = chart.plotLeft,
        buttonLeft,
        buttonGroup = rangeSelector.buttonGroup,
        group,
        groupHeight,
        rendered = rangeSelector.rendered,
        verticalAlign = rangeSelector.options.verticalAlign,
        legend = chart.legend,
        legendOptions = legend && legend.options,
        buttonPositionY = buttonPosition.y,
        inputPositionY = inputPosition.y,
        animate = rendered || false,
        verb = animate ? 'animate' : 'attr',
        exportingX = 0,
        alignTranslateY,
        legendHeight,
        minPosition,
        translateY = 0,
        translateX;

    if (options.enabled === false) {
      return;
    } // create the elements


    if (!rendered) {
      rangeSelector.group = group = renderer.g('range-selector-group').attr({
        zIndex: 7
      }).add();
      rangeSelector.buttonGroup = buttonGroup = renderer.g('range-selector-buttons').add(group);
      rangeSelector.zoomText = renderer.text(lang.rangeSelectorZoom, 0, 15).css(options.labelStyle).add(buttonGroup);
      each$w(rangeSelector.buttonOptions, function (rangeOptions, i) {
        buttons[i] = renderer.button(rangeOptions.text, 0, 0, function () {
          // extract events from button object and call
          var buttonEvents = rangeOptions.events && rangeOptions.events.click,
              callDefaultEvent;

          if (buttonEvents) {
            callDefaultEvent = buttonEvents.call(rangeOptions);
          }

          if (callDefaultEvent !== false) {
            rangeSelector.clickButton(i);
          }

          rangeSelector.isActive = true;
        }, buttonTheme, states && states.hover, states && states.select, states && states.disabled).attr({
          'text-align': 'center'
        }).add(buttonGroup);
      }); // first create a wrapper outside the container in order to make
      // the inputs work and make export correct

      if (inputEnabled !== false) {
        rangeSelector.div = div = createElement$5('div', null, {
          position: 'relative',
          height: 0,
          zIndex: inputsZIndex
        });
        container.parentNode.insertBefore(div, container); // Create the group to keep the inputs

        rangeSelector.inputGroup = inputGroup = renderer.g('input-group').add(group);
        inputGroup.offset = 0;
        rangeSelector.drawInput('min');
        rangeSelector.drawInput('max');
      }
    } // #8769, allow dynamically updating margins


    rangeSelector.zoomText[verb]({
      x: pick$u(plotLeft + buttonPosition.x, plotLeft)
    }); // button start position

    buttonLeft = pick$u(plotLeft + buttonPosition.x, plotLeft) + rangeSelector.zoomText.getBBox().width + 5;
    each$w(rangeSelector.buttonOptions, function (rangeOptions, i) {
      buttons[i][verb]({
        x: buttonLeft
      }); // increase button position for the next button

      buttonLeft += buttons[i].width + pick$u(options.buttonSpacing, 5);
    });
    plotLeft = chart.plotLeft - chart.spacing[3];
    rangeSelector.updateButtonStates(); // detect collisiton with exporting

    if (navButtonOptions && this.titleCollision(chart) && verticalAlign === 'top' && buttonPosition.align === 'right' && buttonPosition.y + buttonGroup.getBBox().height - 12 < (navButtonOptions.y || 0) + navButtonOptions.height) {
      exportingX = -40;
    }

    if (buttonPosition.align === 'left') {
      translateX = buttonPosition.x - chart.spacing[3];
    } else if (buttonPosition.align === 'right') {
      translateX = buttonPosition.x + exportingX - chart.spacing[1];
    } // align button group


    buttonGroup.align({
      y: buttonPosition.y,
      width: buttonGroup.getBBox().width,
      align: buttonPosition.align,
      x: translateX
    }, true, chart.spacingBox); // skip animation

    rangeSelector.group.placed = animate;
    rangeSelector.buttonGroup.placed = animate;

    if (inputEnabled !== false) {
      var inputGroupX, inputGroupWidth, buttonGroupX, buttonGroupWidth; // detect collision with exporting

      if (navButtonOptions && this.titleCollision(chart) && verticalAlign === 'top' && inputPosition.align === 'right' && inputPosition.y - inputGroup.getBBox().height - 12 < (navButtonOptions.y || 0) + navButtonOptions.height + chart.spacing[0]) {
        exportingX = -40;
      } else {
        exportingX = 0;
      }

      if (inputPosition.align === 'left') {
        translateX = plotLeft;
      } else if (inputPosition.align === 'right') {
        translateX = -Math.max(chart.axisOffset[1], -exportingX);
      } // Update the alignment to the updated spacing box


      inputGroup.align({
        y: inputPosition.y,
        width: inputGroup.getBBox().width,
        align: inputPosition.align,
        // fix wrong getBBox() value on right align
        x: inputPosition.x + translateX - 2
      }, true, chart.spacingBox); // detect collision

      inputGroupX = inputGroup.alignAttr.translateX + inputGroup.alignOptions.x - exportingX + // getBBox for detecing left margin
      inputGroup.getBBox().x + // 2px padding to not overlap input and label
      2;
      inputGroupWidth = inputGroup.alignOptions.width;
      buttonGroupX = buttonGroup.alignAttr.translateX + buttonGroup.getBBox().x; // 20 is minimal spacing between elements

      buttonGroupWidth = buttonGroup.getBBox().width + 20;

      if (inputPosition.align === buttonPosition.align || buttonGroupX + buttonGroupWidth > inputGroupX && inputGroupX + inputGroupWidth > buttonGroupX && buttonPositionY < inputPositionY + inputGroup.getBBox().height) {
        inputGroup.attr({
          translateX: inputGroup.alignAttr.translateX + (chart.axisOffset[1] >= -exportingX ? 0 : -exportingX),
          translateY: inputGroup.alignAttr.translateY + buttonGroup.getBBox().height + 10
        });
      } // Set or reset the input values


      rangeSelector.setInputValue('min', min);
      rangeSelector.setInputValue('max', max); // skip animation

      rangeSelector.inputGroup.placed = animate;
    } // vertical align


    rangeSelector.group.align({
      verticalAlign: verticalAlign
    }, true, chart.spacingBox); // set position

    groupHeight = rangeSelector.group.getBBox().height + 20; // # 20 padding

    alignTranslateY = rangeSelector.group.alignAttr.translateY; // calculate bottom position

    if (verticalAlign === 'bottom') {
      legendHeight = legendOptions && legendOptions.verticalAlign === 'bottom' && legendOptions.enabled && !legendOptions.floating ? legend.legendHeight + pick$u(legendOptions.margin, 10) : 0;
      groupHeight = groupHeight + legendHeight - 20;
      translateY = alignTranslateY - groupHeight - (floating ? 0 : options.y) - 10 // 10 spacing
      ;
    }

    if (verticalAlign === 'top') {
      if (floating) {
        translateY = 0;
      }

      if (chart.titleOffset) {
        translateY = chart.titleOffset + chart.options.title.margin;
      }

      translateY += chart.margin[0] - chart.spacing[0] || 0;
    } else if (verticalAlign === 'middle') {
      if (inputPositionY === buttonPositionY) {
        if (inputPositionY < 0) {
          translateY = alignTranslateY + minPosition;
        } else {
          translateY = alignTranslateY;
        }
      } else if (inputPositionY || buttonPositionY) {
        if (inputPositionY < 0 || buttonPositionY < 0) {
          translateY -= Math.min(inputPositionY, buttonPositionY);
        } else {
          translateY = alignTranslateY - groupHeight + minPosition;
        }
      }
    }

    rangeSelector.group.translate(options.x, options.y + Math.floor(translateY)); // translate HTML inputs

    if (inputEnabled !== false) {
      rangeSelector.minInput.style.marginTop = rangeSelector.group.translateY + 'px';
      rangeSelector.maxInput.style.marginTop = rangeSelector.group.translateY + 'px';
    }

    rangeSelector.rendered = true;
  },

  /**
   * Extracts height of range selector
   *
   * @function Highcharts.RangeSelector#getHeight
   *
   * @return {number}
   *         Returns rangeSelector height
   */
  getHeight: function () {
    var rangeSelector = this,
        options = rangeSelector.options,
        rangeSelectorGroup = rangeSelector.group,
        inputPosition = options.inputPosition,
        buttonPosition = options.buttonPosition,
        yPosition = options.y,
        buttonPositionY = buttonPosition.y,
        inputPositionY = inputPosition.y,
        rangeSelectorHeight = 0,
        minPosition;
    rangeSelectorHeight = rangeSelectorGroup ? // 13px to keep back compatibility
    rangeSelectorGroup.getBBox(true).height + 13 + yPosition : 0;
    minPosition = Math.min(inputPositionY, buttonPositionY);

    if (inputPositionY < 0 && buttonPositionY < 0 || inputPositionY > 0 && buttonPositionY > 0) {
      rangeSelectorHeight += Math.abs(minPosition);
    }

    return rangeSelectorHeight;
  },

  /**
   * Detect collision with title or subtitle
   *
   * @function Highcharts.RangeSelector#titleCollision
   *
   * @param  {Highcharts.Chart} chart
   *
   * @return {boolean}
   *         Returns collision status
   */
  titleCollision: function (chart) {
    return !(chart.options.title.text || chart.options.subtitle.text);
  },

  /**
   * Update the range selector with new options
   *
   * @function Highcharts.RangeSelector#update
   *
   * @param  {Highcharts.RangeSelectorOptions} options
   *
   * @return {void}
   */
  update: function (options) {
    var chart = this.chart;
    merge$k(true, chart.options.rangeSelector, options);
    this.destroy();
    this.init(chart);
    chart.rangeSelector.render();
  },

  /**
   * Destroys allocated elements.
   *
   * @function Highcharts.RangeSelector#destroy
   *
   * @return {void}
   */
  destroy: function () {
    var rSelector = this,
        minInput = rSelector.minInput,
        maxInput = rSelector.maxInput;
    rSelector.unMouseDown();
    rSelector.unResize(); // Destroy elements in collections

    destroyObjectProperties$7(rSelector.buttons); // Clear input element events

    if (minInput) {
      minInput.onfocus = minInput.onblur = minInput.onchange = null;
    }

    if (maxInput) {
      maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;
    } // Destroy HTML and SVG elements


    Highcharts.objectEach(rSelector, function (val, key) {
      if (val && key !== 'chart') {
        if (val.destroy) {
          // SVGElement
          val.destroy();
        } else if (val.nodeType) {
          // HTML element
          discardElement$2(this[key]);
        }
      }

      if (val !== RangeSelector.prototype[key]) {
        rSelector[key] = null;
      }
    }, this);
  }
};
/**
 * Add logic to normalize the zoomed range in order to preserve the pressed
 * state of range selector buttons
 *
 * @function Highcharts.Axis#toFixedRange
 *
 * @param  {number} pxMin
 *
 * @param  {number} pxMax
 *
 * @param  {number} fixedMin
 *
 * @param  {number} fixedMax
 *
 * @return {*}
 */

Axis$b.prototype.toFixedRange = function (pxMin, pxMax, fixedMin, fixedMax) {
  var fixedRange = this.chart && this.chart.fixedRange,
      newMin = pick$u(fixedMin, this.translate(pxMin, true, !this.horiz)),
      newMax = pick$u(fixedMax, this.translate(pxMax, true, !this.horiz)),
      changeRatio = fixedRange && (newMax - newMin) / fixedRange; // If the difference between the fixed range and the actual requested range
  // is too great, the user is dragging across an ordinal gap, and we need to
  // release the range selector button.

  if (changeRatio > 0.7 && changeRatio < 1.3) {
    if (fixedMax) {
      newMin = newMax - fixedRange;
    } else {
      newMax = newMin + fixedRange;
    }
  }

  if (!isNumber$d(newMin) || !isNumber$d(newMax)) {
    // #1195, #7411
    newMin = newMax = undefined;
  }

  return {
    min: newMin,
    max: newMax
  };
};
/**
 * Get the axis min value based on the range option and the current max. For
 * stock charts this is extended via the {@link RangeSelector} so that if the
 * selected range is a multiple of months or years, it is compensated for
 * various month lengths.
 *
 * @function Highcharts.Axis#minFromRange
 *
 * @return {number}
 *         The new minimum value.
 */


Axis$b.prototype.minFromRange = function () {
  var rangeOptions = this.range,
      type = rangeOptions.type,
      timeName = {
    month: 'Month',
    year: 'FullYear'
  }[type],
      min,
      max = this.max,
      dataMin,
      range,
      // Get the true range from a start date
  getTrueRange = function (base, count) {
    var date = new Date(base),
        basePeriod = date['get' + timeName]();
    date['set' + timeName](basePeriod + count);

    if (basePeriod === date['get' + timeName]()) {
      date.setDate(0); // #6537
    }

    return date.getTime() - base;
  };

  if (isNumber$d(rangeOptions)) {
    min = max - rangeOptions;
    range = rangeOptions;
  } else {
    min = max + getTrueRange(max, -rangeOptions.count); // Let the fixedRange reflect initial settings (#5930)

    if (this.chart) {
      this.chart.fixedRange = max - min;
    }
  }

  dataMin = pick$u(this.dataMin, Number.MIN_VALUE);

  if (!isNumber$d(min)) {
    min = dataMin;
  }

  if (min <= dataMin) {
    min = dataMin;

    if (range === undefined) {
      // #4501
      range = getTrueRange(min, rangeOptions.count);
    }

    this.newMax = Math.min(min + range, this.dataMax);
  }

  if (!isNumber$d(max)) {
    min = undefined;
  }

  return min;
}; // Initialize rangeselector for stock charts


addEvent$j(Chart$9, 'afterGetContainer', function () {
  if (this.options.rangeSelector.enabled) {
    this.rangeSelector = new RangeSelector(this);
  }
});
wrap$9(Chart$9.prototype, 'render', function (proceed, options, callback) {
  var chart = this,
      axes = chart.axes,
      rangeSelector = chart.rangeSelector,
      verticalAlign;

  if (rangeSelector) {
    each$w(axes, function (axis) {
      axis.updateNames();
      axis.setScale();
    });
    chart.getAxisMargins();
    rangeSelector.render();
    verticalAlign = rangeSelector.options.verticalAlign;

    if (!rangeSelector.options.floating) {
      if (verticalAlign === 'bottom') {
        this.extraBottomMargin = true;
      } else if (verticalAlign !== 'middle') {
        this.extraTopMargin = true;
      }
    }
  }

  proceed.call(this, options, callback);
});
addEvent$j(Chart$9, 'update', function (e) {
  var chart = this,
      options = e.options,
      optionsRangeSelector = options.rangeSelector,
      rangeSelector = chart.rangeSelector,
      verticalAlign,
      extraBottomMarginWas = this.extraBottomMargin,
      extraTopMarginWas = this.extraTopMargin;

  if (optionsRangeSelector && optionsRangeSelector.enabled && !defined$j(rangeSelector)) {
    this.options.rangeSelector.enabled = true;
    this.rangeSelector = new RangeSelector(this);
  }

  this.extraBottomMargin = false;
  this.extraTopMargin = false;

  if (rangeSelector) {
    rangeSelector.render();
    verticalAlign = optionsRangeSelector && optionsRangeSelector.verticalAlign || rangeSelector.options && rangeSelector.options.verticalAlign;

    if (!rangeSelector.options.floating) {
      if (verticalAlign === 'bottom') {
        this.extraBottomMargin = true;
      } else if (verticalAlign !== 'middle') {
        this.extraTopMargin = true;
      }
    }

    if (this.extraBottomMargin !== extraBottomMarginWas || this.extraTopMargin !== extraTopMarginWas) {
      this.isDirtyBox = true;
    }
  }
});
wrap$9(Chart$9.prototype, 'redraw', function (proceed, options, callback) {
  var chart = this,
      rangeSelector = chart.rangeSelector,
      verticalAlign;

  if (rangeSelector && !rangeSelector.options.floating) {
    rangeSelector.render();
    verticalAlign = rangeSelector.options.verticalAlign;

    if (verticalAlign === 'bottom') {
      this.extraBottomMargin = true;
    } else if (verticalAlign !== 'middle') {
      this.extraTopMargin = true;
    }
  }

  proceed.call(this, options, callback);
});
addEvent$j(Chart$9, 'getMargins', function () {
  var rangeSelector = this.rangeSelector,
      rangeSelectorHeight;

  if (rangeSelector) {
    rangeSelectorHeight = rangeSelector.getHeight();

    if (this.extraTopMargin) {
      this.plotTop += rangeSelectorHeight;
    }

    if (this.extraBottomMargin) {
      this.marginBottom += rangeSelectorHeight;
    }
  }
});
Chart$9.prototype.callbacks.push(function (chart) {
  var extremes,
      rangeSelector = chart.rangeSelector,
      unbindRender,
      unbindSetExtremes;

  function renderRangeSelector() {
    extremes = chart.xAxis[0].getExtremes();

    if (isNumber$d(extremes.min)) {
      rangeSelector.render(extremes.min, extremes.max);
    }
  }

  if (rangeSelector) {
    // redraw the scroller on setExtremes
    unbindSetExtremes = addEvent$j(chart.xAxis[0], 'afterSetExtremes', function (e) {
      rangeSelector.render(e.min, e.max);
    }); // redraw the scroller chart resize

    unbindRender = addEvent$j(chart, 'redraw', renderRangeSelector); // do it now

    renderRangeSelector();
  } // Remove resize/afterSetExtremes at chart destroy


  addEvent$j(chart, 'destroy', function destroyEvents() {
    if (rangeSelector) {
      unbindRender();
      unbindSetExtremes();
    }
  });
});
Highcharts.RangeSelector = RangeSelector;
/* ****************************************************************************
 * End Range Selector code                                                     *
 *****************************************************************************/

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$k = Highcharts.addEvent,
    arrayMax$5 = Highcharts.arrayMax,
    arrayMin$4 = Highcharts.arrayMin,
    Axis$c = Highcharts.Axis,
    Chart$a = Highcharts.Chart,
    defined$k = Highcharts.defined,
    each$x = Highcharts.each,
    extend$l = Highcharts.extend,
    format$6 = Highcharts.format,
    grep$5 = Highcharts.grep,
    inArray$6 = Highcharts.inArray,
    isNumber$e = Highcharts.isNumber,
    isString$5 = Highcharts.isString,
    map$6 = Highcharts.map,
    merge$l = Highcharts.merge,
    pick$v = Highcharts.pick,
    Point$7 = Highcharts.Point,
    Renderer$1 = Highcharts.Renderer,
    Series$d = Highcharts.Series,
    splat$9 = Highcharts.splat,
    SVGRenderer$3 = Highcharts.SVGRenderer,
    VMLRenderer$1 = Highcharts.VMLRenderer,
    wrap$a = Highcharts.wrap,
    seriesProto$1 = Series$d.prototype,
    seriesInit = seriesProto$1.init,
    seriesProcessData = seriesProto$1.processData,
    pointTooltipFormatter = Point$7.prototype.tooltipFormatter;
/**
 * Compare the values of the series against the first non-null, non-
 * zero value in the visible range. The y axis will show percentage
 * or absolute change depending on whether `compare` is set to `"percent"`
 * or `"value"`. When this is applied to multiple series, it allows
 * comparing the development of the series against each other. Adds
 * a `change` field to every point object.
 *
 * @type {String}
 * @see [compareBase](#plotOptions.series.compareBase),
 *      [Axis.setCompare()](/class-reference/Highcharts.Axis#setCompare)
 * @sample {highstock} stock/plotoptions/series-compare-percent/ Percent
 * @sample {highstock} stock/plotoptions/series-compare-value/ Value
 * @default undefined
 * @since 1.0.1
 * @product highstock
 * @apioption plotOptions.series.compare
 */

/**
 * Defines if comparison should start from the first point within the visible
 * range or should start from the first point <b>before</b> the range.
 * In other words, this flag determines if first point within the visible range
 * will have 0% (`compareStart=true`) or should have been already calculated
 * according to the previous point (`compareStart=false`).
 *
 * @type {Boolean}
 * @sample {highstock} stock/plotoptions/series-comparestart/
 *         Calculate compare within visible range
 * @default false
 * @since 6.0.0
 * @product highstock
 * @apioption plotOptions.series.compareStart
 */

/**
 * When [compare](#plotOptions.series.compare) is `percent`, this option
 * dictates whether to use 0 or 100 as the base of comparison.
 *
 * @validvalue [0, 100]
 * @type {Number}
 * @sample {highstock} / Compare base is 100
 * @default 0
 * @since 5.0.6
 * @product highstock
 * @apioption plotOptions.series.compareBase
 */

/**
 * Factory function for creating new stock charts. Creates a new {@link Chart|
 * Chart} object with different default options than the basic Chart.
 *
 * @function #stockChart
 * @memberof Highcharts
 *
 * @param  {String|HTMLDOMElement} renderTo
 *         The DOM element to render to, or its id.
 * @param  {Options} options
 *         The chart options structure as described in the {@link
 *         https://api.highcharts.com/highstock|options reference}.
 * @param  {Function} callback
 *         A function to execute when the chart object is finished loading and
 *         rendering. In most cases the chart is built in one thread, but in
 *         Internet Explorer version 8 or less the chart is sometimes
 *         initialized before the document is ready, and in these cases the
 *         chart object will not be finished synchronously. As a consequence,
 *         code that relies on the newly built Chart object should always run in
 *         the callback. Defining a {@link https://api.highcharts.com/highstock/chart.events.load|
 *         chart.event.load} handler is equivalent.
 *
 * @return {Chart}
 *         The chart object.
 *
 * @example
 * var chart = Highcharts.stockChart('container', {
 *     series: [{
 *         data: [1, 2, 3, 4, 5, 6, 7, 8, 9],
 *         pointInterval: 24 * 60 * 60 * 1000
 *     }]
 * });
 */

Highcharts.StockChart = Highcharts.stockChart = function (a, b, c) {
  var hasRenderToArg = isString$5(a) || a.nodeName,
      options = arguments[hasRenderToArg ? 1 : 0],
      // to increase performance, don't merge the data
  seriesOptions = options.series,
      defaultOptions = Highcharts.getOptions(),
      opposite,
      // Always disable startOnTick:true on the main axis when the navigator
  // is enabled (#1090)
  navigatorEnabled = pick$v(options.navigator && options.navigator.enabled, defaultOptions.navigator.enabled, true),
      disableStartOnTick = navigatorEnabled ? {
    startOnTick: false,
    endOnTick: false
  } : null,
      lineOptions = {
    marker: {
      enabled: false,
      radius: 2 // gapSize: 0

    }
  },
      columnOptions = {
    shadow: false,
    borderWidth: 0
  }; // apply X axis options to both single and multi y axes

  options.xAxis = map$6(splat$9(options.xAxis || {}), function (xAxisOptions, i) {
    return merge$l({
      // defaults
      minPadding: 0,
      maxPadding: 0,
      overscroll: 0,
      ordinal: true,
      title: {
        text: null
      },
      labels: {
        overflow: 'justify'
      },
      showLastLabel: true
    }, defaultOptions.xAxis, // #3802
    defaultOptions.xAxis && defaultOptions.xAxis[i], // #7690
    xAxisOptions, // user options
    {
      // forced options
      type: 'datetime',
      categories: null
    }, disableStartOnTick);
  }); // apply Y axis options to both single and multi y axes

  options.yAxis = map$6(splat$9(options.yAxis || {}), function (yAxisOptions, i) {
    opposite = pick$v(yAxisOptions.opposite, true);
    return merge$l({
      // defaults
      labels: {
        y: -2
      },
      opposite: opposite,

      /**
       * @default {highcharts} true
       * @default {highstock} false
       * @apioption yAxis.showLastLabel
       */
      showLastLabel: !!( // #6104, show last label by default for category axes
      yAxisOptions.categories || yAxisOptions.type === 'category'),
      title: {
        text: null
      }
    }, defaultOptions.yAxis, // #3802
    defaultOptions.yAxis && defaultOptions.yAxis[i], // #7690
    yAxisOptions // user options
    );
  });
  options.series = null;
  options = merge$l({
    chart: {
      panning: true,
      pinchType: 'x'
    },
    navigator: {
      enabled: navigatorEnabled
    },
    scrollbar: {
      // #4988 - check if setOptions was called
      enabled: pick$v(defaultOptions.scrollbar.enabled, true)
    },
    rangeSelector: {
      // #4988 - check if setOptions was called
      enabled: pick$v(defaultOptions.rangeSelector.enabled, true)
    },
    title: {
      text: null
    },
    tooltip: {
      split: pick$v(defaultOptions.tooltip.split, true),
      crosshairs: true
    },
    legend: {
      enabled: false
    },
    plotOptions: {
      line: lineOptions,
      spline: lineOptions,
      area: lineOptions,
      areaspline: lineOptions,
      arearange: lineOptions,
      areasplinerange: lineOptions,
      column: columnOptions,
      columnrange: columnOptions,
      candlestick: columnOptions,
      ohlc: columnOptions
    }
  }, options, // user's options
  {
    // forced options
    isStock: true // internal flag

  });
  options.series = seriesOptions;
  return hasRenderToArg ? new Chart$a(a, options, c) : new Chart$a(options, b);
}; // Override the automatic label alignment so that the first Y axis' labels
// are drawn on top of the grid line, and subsequent axes are drawn outside


wrap$a(Axis$c.prototype, 'autoLabelAlign', function (proceed) {
  var chart = this.chart,
      options = this.options,
      panes = chart._labelPanes = chart._labelPanes || {},
      key,
      labelOptions = this.options.labels;

  if (this.chart.options.isStock && this.coll === 'yAxis') {
    key = options.top + ',' + options.height; // do it only for the first Y axis of each pane

    if (!panes[key] && labelOptions.enabled) {
      if (labelOptions.x === 15) {
        // default
        labelOptions.x = 0;
      }

      if (labelOptions.align === undefined) {
        labelOptions.align = 'right';
      }

      panes[key] = this;
      return 'right';
    }
  }

  return proceed.apply(this, [].slice.call(arguments, 1));
}); // Clear axis from label panes (#6071)

addEvent$k(Axis$c, 'destroy', function () {
  var chart = this.chart,
      key = this.options && this.options.top + ',' + this.options.height;

  if (key && chart._labelPanes && chart._labelPanes[key] === this) {
    delete chart._labelPanes[key];
  }
}); // Override getPlotLinePath to allow for multipane charts

wrap$a(Axis$c.prototype, 'getPlotLinePath', function (proceed, value, lineWidth, old, force, translatedValue) {
  var axis = this,
      series = this.isLinked && !this.series ? this.linkedParent.series : this.series,
      chart = axis.chart,
      renderer = chart.renderer,
      axisLeft = axis.left,
      axisTop = axis.top,
      x1,
      y1,
      x2,
      y2,
      result = [],
      axes = [],
      // #3416 need a default array
  axes2,
      uniqueAxes,
      transVal;
  /**
   * Return the other axis based on either the axis option or on related
   * series.
   */

  function getAxis(coll) {
    var otherColl = coll === 'xAxis' ? 'yAxis' : 'xAxis',
        opt = axis.options[otherColl]; // Other axis indexed by number

    if (isNumber$e(opt)) {
      return [chart[otherColl][opt]];
    } // Other axis indexed by id (like navigator)


    if (isString$5(opt)) {
      return [chart.get(opt)];
    } // Auto detect based on existing series


    return map$6(series, function (s) {
      return s[otherColl];
    });
  } // Ignore in case of colorAxis or zAxis. #3360, #3524, #6720


  if (axis.coll !== 'xAxis' && axis.coll !== 'yAxis') {
    return proceed.apply(this, [].slice.call(arguments, 1));
  } // Get the related axes based on series


  axes = getAxis(axis.coll); // Get the related axes based options.*Axis setting #2810

  axes2 = axis.isXAxis ? chart.yAxis : chart.xAxis;
  each$x(axes2, function (A) {
    if (defined$k(A.options.id) ? A.options.id.indexOf('navigator') === -1 : true) {
      var a = A.isXAxis ? 'yAxis' : 'xAxis',
          rax = defined$k(A.options[a]) ? chart[a][A.options[a]] : chart[a][0];

      if (axis === rax) {
        axes.push(A);
      }
    }
  }); // Remove duplicates in the axes array. If there are no axes in the axes
  // array, we are adding an axis without data, so we need to populate this
  // with grid lines (#2796).

  uniqueAxes = axes.length ? [] : [axis.isXAxis ? chart.yAxis[0] : chart.xAxis[0]]; // #3742

  each$x(axes, function (axis2) {
    if (inArray$6(axis2, uniqueAxes) === -1 && // Do not draw on axis which overlap completely. #5424
    !Highcharts.find(uniqueAxes, function (unique) {
      return unique.pos === axis2.pos && unique.len === axis2.len;
    })) {
      uniqueAxes.push(axis2);
    }
  });
  transVal = pick$v(translatedValue, axis.translate(value, null, null, old));

  if (isNumber$e(transVal)) {
    if (axis.horiz) {
      each$x(uniqueAxes, function (axis2) {
        var skip;
        y1 = axis2.pos;
        y2 = y1 + axis2.len;
        x1 = x2 = Math.round(transVal + axis.transB); // outside plot area

        if (x1 < axisLeft || x1 > axisLeft + axis.width) {
          if (force) {
            x1 = x2 = Math.min(Math.max(axisLeft, x1), axisLeft + axis.width);
          } else {
            skip = true;
          }
        }

        if (!skip) {
          result.push('M', x1, y1, 'L', x2, y2);
        }
      });
    } else {
      each$x(uniqueAxes, function (axis2) {
        var skip;
        x1 = axis2.pos;
        x2 = x1 + axis2.len;
        y1 = y2 = Math.round(axisTop + axis.height - transVal); // outside plot area

        if (y1 < axisTop || y1 > axisTop + axis.height) {
          if (force) {
            y1 = y2 = Math.min(Math.max(axisTop, y1), axis.top + axis.height);
          } else {
            skip = true;
          }
        }

        if (!skip) {
          result.push('M', x1, y1, 'L', x2, y2);
        }
      });
    }
  }

  return result.length > 0 ? renderer.crispPolyLine(result, lineWidth || 1) : null; // #3557 getPlotLinePath in regular Highcharts also returns null
}); // Function to crisp a line with multiple segments

SVGRenderer$3.prototype.crispPolyLine = function (points, width) {
  // points format: ['M', 0, 0, 'L', 100, 0]
  // normalize to a crisp line
  var i;

  for (i = 0; i < points.length; i = i + 6) {
    if (points[i + 1] === points[i + 4]) {
      // Substract due to #1129. Now bottom and left axis gridlines behave
      // the same.
      points[i + 1] = points[i + 4] = Math.round(points[i + 1]) - width % 2 / 2;
    }

    if (points[i + 2] === points[i + 5]) {
      points[i + 2] = points[i + 5] = Math.round(points[i + 2]) + width % 2 / 2;
    }
  }

  return points;
}; // Wrapper to hide the label


wrap$a(Axis$c.prototype, 'hideCrosshair', function (proceed, i) {
  proceed.call(this, i);

  if (this.crossLabel) {
    this.crossLabel = this.crossLabel.hide();
  }
}); // Extend crosshairs to also draw the label

addEvent$k(Axis$c, 'afterDrawCrosshair', function (event) {
  // Check if the label has to be drawn
  if (!defined$k(this.crosshair.label) || !this.crosshair.label.enabled || !this.cross) {
    return;
  }

  var chart = this.chart,
      options = this.options.crosshair.label,
      // the label's options
  horiz = this.horiz,
      // axis orientation
  opposite = this.opposite,
      // axis position
  left = this.left,
      // left position
  top = this.top,
      // top position
  crossLabel = this.crossLabel,
      // the svgElement
  posx,
      posy,
      crossBox,
      formatOption = options.format,
      formatFormat = '',
      limit,
      align,
      tickInside = this.options.tickPosition === 'inside',
      snap = this.crosshair.snap !== false,
      value,
      offset = 0,
      // Use last available event (#5287)
  e = event.e || this.cross && this.cross.e,
      point = event.point,
      lin2log = this.lin2log,
      min,
      max;

  if (this.isLog) {
    min = lin2log(this.min);
    max = lin2log(this.max);
  } else {
    min = this.min;
    max = this.max;
  }

  align = horiz ? 'center' : opposite ? this.labelAlign === 'right' ? 'right' : 'left' : this.labelAlign === 'left' ? 'left' : 'center'; // If the label does not exist yet, create it.

  if (!crossLabel) {
    crossLabel = this.crossLabel = chart.renderer.label(null, null, null, options.shape || 'callout').addClass('highcharts-crosshair-label' + (this.series[0] && ' highcharts-color-' + this.series[0].colorIndex)).attr({
      align: options.align || align,
      padding: pick$v(options.padding, 8),
      r: pick$v(options.borderRadius, 3),
      zIndex: 2
    }).add(this.labelGroup);
  }

  if (horiz) {
    posx = snap ? point.plotX + left : e.chartX;
    posy = top + (opposite ? 0 : this.height);
  } else {
    posx = opposite ? this.width + left : 0;
    posy = snap ? point.plotY + top : e.chartY;
  }

  if (!formatOption && !options.formatter) {
    if (this.isDatetimeAxis) {
      formatFormat = '%b %d, %Y';
    }

    formatOption = '{value' + (formatFormat ? ':' + formatFormat : '') + '}';
  } // Show the label


  value = snap ? point[this.isXAxis ? 'x' : 'y'] : this.toValue(horiz ? e.chartX : e.chartY);
  crossLabel.attr({
    text: formatOption ? format$6(formatOption, {
      value: value
    }, chart.time) : options.formatter.call(this, value),
    x: posx,
    y: posy,
    // Crosshair should be rendered within Axis range (#7219)
    visibility: value < min || value > max ? 'hidden' : 'visible'
  });
  crossBox = crossLabel.getBBox(); // now it is placed we can correct its position

  if (horiz) {
    if (tickInside && !opposite || !tickInside && opposite) {
      posy = crossLabel.y - crossBox.height;
    }
  } else {
    posy = crossLabel.y - crossBox.height / 2;
  } // check the edges


  if (horiz) {
    limit = {
      left: left - crossBox.x,
      right: left + this.width - crossBox.x
    };
  } else {
    limit = {
      left: this.labelAlign === 'left' ? left : 0,
      right: this.labelAlign === 'right' ? left + this.width : chart.chartWidth
    };
  } // left edge


  if (crossLabel.translateX < limit.left) {
    offset = limit.left - crossLabel.translateX;
  } // right edge


  if (crossLabel.translateX + crossBox.width >= limit.right) {
    offset = -(crossLabel.translateX + crossBox.width - limit.right);
  } // show the crosslabel


  crossLabel.attr({
    x: posx + offset,
    y: posy,
    // First set x and y, then anchorX and anchorY, when box is actually
    // calculated, #5702
    anchorX: horiz ? posx : this.opposite ? 0 : chart.chartWidth,
    anchorY: horiz ? this.opposite ? chart.chartHeight : 0 : posy + crossBox.height / 2
  });
});
/* ****************************************************************************
 * Start value compare logic                                                  *
 *****************************************************************************/

/**
 * Extend series.init by adding a method to modify the y value used for plotting
 * on the y axis. This method is called both from the axis when finding dataMin
 * and dataMax, and from the series.translate method.
 */

seriesProto$1.init = function () {
  // Call base method
  seriesInit.apply(this, arguments); // Set comparison mode

  this.setCompare(this.options.compare);
};
/**
 * Highstock only. Set the {@link
 * http://api.highcharts.com/highstock/plotOptions.series.compare|
 * compare} mode of the series after render time. In most cases it is more
 * useful running {@link Axis#setCompare} on the X axis to update all its
 * series.
 *
 * @function setCompare
 * @memberof Series.prototype
 *
 * @param  {String} compare
 *         Can be one of `null`, `"percent"` or `"value"`.
 */


seriesProto$1.setCompare = function (compare) {
  // Set or unset the modifyValue method
  this.modifyValue = compare === 'value' || compare === 'percent' ? function (value, point) {
    var compareValue = this.compareValue;

    if (value !== undefined && compareValue !== undefined) {
      // #2601, #5814
      // Get the modified value
      if (compare === 'value') {
        value -= compareValue; // Compare percent
      } else {
        value = 100 * (value / compareValue) - (this.options.compareBase === 100 ? 0 : 100);
      } // record for tooltip etc.


      if (point) {
        point.change = value;
      }

      return value;
    }
  } : null; // Survive to export, #5485

  this.userOptions.compare = compare; // Mark dirty

  if (this.chart.hasRendered) {
    this.isDirty = true;
  }
};
/**
 * Extend series.processData by finding the first y value in the plot area,
 * used for comparing the following values
 */


seriesProto$1.processData = function () {
  var series = this,
      i,
      keyIndex = -1,
      processedXData,
      processedYData,
      compareStart = series.options.compareStart === true ? 0 : 1,
      length,
      compareValue; // call base method

  seriesProcessData.apply(this, arguments);

  if (series.xAxis && series.processedYData) {
    // not pies
    // local variables
    processedXData = series.processedXData;
    processedYData = series.processedYData;
    length = processedYData.length; // For series with more than one value (range, OHLC etc), compare
    // against close or the pointValKey (#4922, #3112)

    if (series.pointArrayMap) {
      // Use close if present (#3112)
      keyIndex = inArray$6('close', series.pointArrayMap);

      if (keyIndex === -1) {
        keyIndex = inArray$6(series.pointValKey || 'y', series.pointArrayMap);
      }
    } // find the first value for comparison


    for (i = 0; i < length - compareStart; i++) {
      compareValue = processedYData[i] && keyIndex > -1 ? processedYData[i][keyIndex] : processedYData[i];

      if (isNumber$e(compareValue) && processedXData[i + compareStart] >= series.xAxis.min && compareValue !== 0) {
        series.compareValue = compareValue;
        break;
      }
    }
  }
};
/**
 * Modify series extremes
 */


wrap$a(seriesProto$1, 'getExtremes', function (proceed) {
  var extremes;
  proceed.apply(this, [].slice.call(arguments, 1));

  if (this.modifyValue) {
    extremes = [this.modifyValue(this.dataMin), this.modifyValue(this.dataMax)];
    this.dataMin = arrayMin$4(extremes);
    this.dataMax = arrayMax$5(extremes);
  }
});
/**
 * Highstock only. Set the compare mode on all series belonging to an Y axis
 * after render time.
 *
 * @param  {String} compare
 *         The compare mode. Can be one of `null`, `"value"` or `"percent"`.
 * @param  {Boolean} [redraw=true]
 *         Whether to redraw the chart or to wait for a later call to {@link
 *         Chart#redraw},
 *
 * @function setCompare
 * @memberof Axis.prototype
 *
 * @see    {@link https://api.highcharts.com/highstock/series.plotOptions.compare|
 *         series.plotOptions.compare}
 *
 * @sample stock/members/axis-setcompare/
 *         Set compoare
 */

Axis$c.prototype.setCompare = function (compare, redraw) {
  if (!this.isXAxis) {
    each$x(this.series, function (series) {
      series.setCompare(compare);
    });

    if (pick$v(redraw, true)) {
      this.chart.redraw();
    }
  }
};
/**
 * Extend the tooltip formatter by adding support for the point.change variable
 * as well as the changeDecimals option
 */


Point$7.prototype.tooltipFormatter = function (pointFormat) {
  var point = this;
  pointFormat = pointFormat.replace('{point.change}', (point.change > 0 ? '+' : '') + Highcharts.numberFormat(point.change, pick$v(point.series.tooltipOptions.changeDecimals, 2)));
  return pointTooltipFormatter.apply(this, [pointFormat]);
};
/* ****************************************************************************
 * End value compare logic                                                    *
 *****************************************************************************/

/**
 * Extend the Series prototype to create a separate series clip box. This is
 * related to using multiple panes, and a future pane logic should incorporate
 * this feature (#2754).
 */


wrap$a(Series$d.prototype, 'render', function (proceed) {
  var clipHeight; // Only do this on not 3d (#2939, #5904) nor polar (#6057) charts, and only
  // if the series type handles clipping in the animate method (#2975).

  if (!(this.chart.is3d && this.chart.is3d()) && !this.chart.polar && this.xAxis && !this.xAxis.isRadial // Gauge, #6192
  ) {
      // Include xAxis line width, #8031
      clipHeight = this.yAxis.len - (this.xAxis.axisLine ? Math.floor(this.xAxis.axisLine.strokeWidth() / 2) : 0); // First render, initial clip box

      if (!this.clipBox && this.animate) {
        this.clipBox = merge$l(this.chart.clipBox);
        this.clipBox.width = this.xAxis.len;
        this.clipBox.height = clipHeight; // On redrawing, resizing etc, update the clip rectangle
      } else if (this.chart[this.sharedClipKey]) {
        this.chart[this.sharedClipKey].attr({
          width: this.xAxis.len,
          height: clipHeight
        }); // #3111
      } else if (this.clipBox) {
        this.clipBox.width = this.xAxis.len;
        this.clipBox.height = clipHeight;
      }
    }

  proceed.call(this);
});
wrap$a(Chart$a.prototype, 'getSelectedPoints', function (proceed) {
  var points = proceed.call(this);
  each$x(this.series, function (serie) {
    // series.points - for grouped points (#6445)
    if (serie.hasGroupedData) {
      points = points.concat(grep$5(serie.points || [], function (point) {
        return point.selected;
      }));
    }
  });
  return points;
});
addEvent$k(Chart$a, 'update', function (e) {
  var options = e.options; // Use case: enabling scrollbar from a disabled state.
  // Scrollbar needs to be initialized from a controller, Navigator in this
  // case (#6615)

  if ('scrollbar' in options && this.navigator) {
    merge$l(true, this.options.scrollbar, options.scrollbar);
    this.navigator.update({}, false);
    delete options.scrollbar;
  }
});

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 * Highstock as a plugin for Highcharts
 *
 * (c) 2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 *
 * (c) 2009-2016 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

/**
 * Accessibility module - internationalization support
 *
 * (c) 2010-2018 Highsoft AS
 * Author: Øystein Moseng
 *
 * License: www.highcharts.com/license
 */
var each$y = Highcharts.each,
    pick$w = Highcharts.pick;
/**
 * String trim that works for IE6-8 as well.
 * @param  {string} str The input string
 * @return {string} The trimmed string
 */

function stringTrim(str) {
  return str.trim && str.trim() || str.replace(/^\s+|\s+$/g, '');
}
/**
 * i18n utility function. Format a single array or plural statement in a format
 * string. If the statement is not an array or plural statement, returns the
 * statement within brackets. Invalid array statements return an empty string.
 */


function formatExtendedStatement(statement, ctx) {
  var eachStart = statement.indexOf('#each('),
      pluralStart = statement.indexOf('#plural('),
      indexStart = statement.indexOf('['),
      indexEnd = statement.indexOf(']'),
      arr,
      result; // Dealing with an each-function?

  if (eachStart > -1) {
    var eachEnd = statement.slice(eachStart).indexOf(')') + eachStart,
        preEach = statement.substring(0, eachStart),
        postEach = statement.substring(eachEnd + 1),
        eachStatement = statement.substring(eachStart + 6, eachEnd),
        eachArguments = eachStatement.split(','),
        lenArg = Number(eachArguments[1]),
        len;
    result = '';
    arr = ctx[eachArguments[0]];

    if (arr) {
      lenArg = isNaN(lenArg) ? arr.length : lenArg;
      len = lenArg < 0 ? arr.length + lenArg : Math.min(lenArg, arr.length); // Overshoot
      // Run through the array for the specified length

      for (var i = 0; i < len; ++i) {
        result += preEach + arr[i] + postEach;
      }
    }

    return result.length ? result : '';
  } // Dealing with a plural-function?


  if (pluralStart > -1) {
    var pluralEnd = statement.slice(pluralStart).indexOf(')') + pluralStart,
        pluralStatement = statement.substring(pluralStart + 8, pluralEnd),
        pluralArguments = pluralStatement.split(','),
        num = Number(ctx[pluralArguments[0]]);

    switch (num) {
      case 0:
        result = pick$w(pluralArguments[4], pluralArguments[1]);
        break;

      case 1:
        result = pick$w(pluralArguments[2], pluralArguments[1]);
        break;

      case 2:
        result = pick$w(pluralArguments[3], pluralArguments[1]);
        break;

      default:
        result = pluralArguments[1];
    }

    return result ? stringTrim(result) : '';
  } // Array index


  if (indexStart > -1) {
    var arrayName = statement.substring(0, indexStart),
        ix = Number(statement.substring(indexStart + 1, indexEnd)),
        val;
    arr = ctx[arrayName];

    if (!isNaN(ix) && arr) {
      if (ix < 0) {
        val = arr[arr.length + ix]; // Handle negative overshoot

        if (val === undefined) {
          val = arr[0];
        }
      } else {
        val = arr[ix]; // Handle positive overshoot

        if (val === undefined) {
          val = arr[arr.length - 1];
        }
      }
    }

    return val !== undefined ? val : '';
  } // Standard substitution, delegate to H.format or similar


  return '{' + statement + '}';
}
/**
 * i18n formatting function. Extends H.format() functionality by also handling
 * arrays and plural conditionals. Arrays can be indexed as follows:
 *
 *  Format: 'This is the first index: {myArray[0]}. The last: {myArray[-1]}.'
 *  Context: { myArray: [0, 1, 2, 3, 4, 5] }
 *  Result: 'This is the first index: 0. The last: 5.'
 *
 * They can also be iterated using the #each() function. This will repeat the
 * contents of the bracket expression for each element. Example:
 *
 *  Format: 'List contains: {#each(myArray)cm }'
 *  Context: { myArray: [0, 1, 2] }
 *  Result: 'List contains: 0cm 1cm 2cm '
 *
 * The #each() function optionally takes a length parameter. If positive, this
 * parameter specifies the max number of elements to iterate through. If
 * negative, the function will subtract the number from the length of the array.
 * Use this to stop iterating before the array ends. Example:
 *
 *  Format: 'List contains: {#each(myArray, -1) }and {myArray[-1]}.'
 *  Context: { myArray: [0, 1, 2, 3] }
 *  Result: 'List contains: 0, 1, 2, and 3.'
 *
 * Use the #plural() function to pick a string depending on whether or not a
 * context object is 1. Arguments are #plural(obj, plural, singular). Example:
 *
 *  Format: 'Has {numPoints} {#plural(numPoints, points, point}.'
 *  Context: { numPoints: 5 }
 *  Result: 'Has 5 points.'
 *
 * Optionally there are additional parameters for dual and none:
 *  #plural(obj,plural,singular,dual,none)
 * Example:
 *
 *  Format: 'Has {#plural(numPoints, many points, one point, two points, none}.'
 *  Context: { numPoints: 2 }
 *  Result: 'Has two points.'
 *
 * The dual or none parameters will take precedence if they are supplied.
 *
 * @param   {string} formatString The string to format.
 * @param   {object} context Context to apply to the format string.
 * @param   {Time} time A `Time` instance for date formatting, passed on to
 *                 H.format().
 * @return  {string} The formatted string.
 */


Highcharts.i18nFormat = function (formatString, context, time) {
  var getFirstBracketStatement = function (sourceStr, offset) {
    var str = sourceStr.slice(offset || 0),
        startBracket = str.indexOf('{'),
        endBracket = str.indexOf('}');

    if (startBracket > -1 && endBracket > startBracket) {
      return {
        statement: str.substring(startBracket + 1, endBracket),
        begin: offset + startBracket + 1,
        end: offset + endBracket
      };
    }
  },
      tokens = [],
      bracketRes,
      constRes,
      cursor = 0; // Tokenize format string into bracket statements and constants


  do {
    bracketRes = getFirstBracketStatement(formatString, cursor);
    constRes = formatString.substring(cursor, bracketRes && bracketRes.begin - 1); // If we have constant content before this bracket statement, add it

    if (constRes.length) {
      tokens.push({
        value: constRes,
        type: 'constant'
      });
    } // Add the bracket statement


    if (bracketRes) {
      tokens.push({
        value: bracketRes.statement,
        type: 'statement'
      });
    }

    cursor = bracketRes && bracketRes.end + 1;
  } while (bracketRes); // Perform the formatting. The formatArrayStatement function returns the
  // statement in brackets if it is not an array statement, which means it
  // gets picked up by H.format below.


  each$y(tokens, function (token) {
    if (token.type === 'statement') {
      token.value = formatExtendedStatement(token.value, context);
    }
  }); // Join string back together and pass to H.format to pick up non-array
  // statements.

  return Highcharts.format(Highcharts.reduce(tokens, function (acc, cur) {
    return acc + cur.value;
  }, ''), context, time);
};
/**
 * Apply context to a format string from lang options of the chart.
 * @param  {string} langKey Key (using dot notation) into lang option structure
 * @param  {object} context Context to apply to the format string
 * @return {string} The formatted string
 */


Highcharts.Chart.prototype.langFormat = function (langKey, context, time) {
  var keys = langKey.split('.'),
      formatString = this.options.lang,
      i = 0;

  for (; i < keys.length; ++i) {
    formatString = formatString && formatString[keys[i]];
  }

  return typeof formatString === 'string' && Highcharts.i18nFormat(formatString, context, time);
};

Highcharts.setOptions({
  lang: {
    /**
     * Configure the accessibility strings in the chart. Requires the
     * [accessibility module](//code.highcharts.com/modules/accessibility.
     * js) to be loaded. For a description of the module and information
     * on its features, see [Highcharts Accessibility](http://www.highcharts.
     * com/docs/chart-concepts/accessibility).
     *
     * For more dynamic control over the accessibility functionality, see
     * [accessibility.pointDescriptionFormatter](
     * accessibility.pointDescriptionFormatter),
     * [accessibility.seriesDescriptionFormatter](
     * accessibility.seriesDescriptionFormatter), and
     * [accessibility.screenReaderSectionFormatter](
     * accessibility.screenReaderSectionFormatter).
     *
     * @since 6.0.6
     * @type {Object}
     * @optionparent lang.accessibility
     */
    accessibility: {
      /* eslint-disable max-len */
      screenReaderRegionLabel: 'Chart screen reader information.',
      navigationHint: 'Use regions/landmarks to skip ahead to chart {#plural(numSeries, and navigate between data series,)}',
      defaultChartTitle: 'Chart',
      longDescriptionHeading: 'Long description.',
      noDescription: 'No description available.',
      structureHeading: 'Structure.',
      viewAsDataTable: 'View as data table.',
      chartHeading: 'Chart graphic.',
      chartContainerLabel: 'Interactive chart. {title}. Use up and down arrows to navigate with most screen readers.',
      rangeSelectorMinInput: 'Select start date.',
      rangeSelectorMaxInput: 'Select end date.',
      tableSummary: 'Table representation of chart.',
      mapZoomIn: 'Zoom chart',
      mapZoomOut: 'Zoom out chart',
      rangeSelectorButton: 'Select range {buttonText}',
      legendItem: 'Toggle visibility of series {itemName}',

      /**
       * Title element text for the chart SVG element. Leave this
       * empty to disable adding the title element. Browsers will display
       * this content when hovering over elements in the chart. Assistive
       * technology may use this element to label the chart.
       *
       * @since 6.0.8
       */
      svgContainerTitle: '{chartTitle}',

      /**
       * Descriptions of lesser known series types. The relevant
       * description is added to the screen reader information region
       * when these series types are used.
       *
       * @since 6.0.6
       * @type {Object}
       * @optionparent lang.accessibility.seriesTypeDescriptions
       */
      seriesTypeDescriptions: {
        boxplot: 'Box plot charts are typically used to display ' + 'groups of statistical data. Each data point in the ' + 'chart can have up to 5 values: minimum, lower quartile, ' + 'median, upper quartile, and maximum.',
        arearange: 'Arearange charts are line charts displaying a ' + 'range between a lower and higher value for each point.',
        areasplinerange: 'These charts are line charts displaying a ' + 'range between a lower and higher value for each point.',
        bubble: 'Bubble charts are scatter charts where each data ' + 'point also has a size value.',
        columnrange: 'Columnrange charts are column charts ' + 'displaying a range between a lower and higher value for ' + 'each point.',
        errorbar: 'Errorbar series are used to display the ' + 'variability of the data.',
        funnel: 'Funnel charts are used to display reduction of data ' + 'in stages.',
        pyramid: 'Pyramid charts consist of a single pyramid with ' + 'item heights corresponding to each point value.',
        waterfall: 'A waterfall chart is a column chart where each ' + 'column contributes towards a total end value.'
      },

      /**
       * Chart type description strings. This is added to the chart
       * information region.
       *
       * If there is only a single series type used in the chart, we use
       * the format string for the series type, or default if missing.
       * There is one format string for cases where there is only a single
       * series in the chart, and one for multiple series of the same
       * type.
       *
       * @since 6.0.6
       * @type {Object}
       * @optionparent lang.accessibility.chartTypes
       */
      chartTypes: {
        emptyChart: 'Empty chart',
        mapTypeDescription: 'Map of {mapTitle} with {numSeries} data series.',
        unknownMap: 'Map of unspecified region with {numSeries} data series.',
        combinationChart: 'Combination chart with {numSeries} data series.',
        defaultSingle: 'Chart with {numPoints} data {#plural(numPoints, points, point)}.',
        defaultMultiple: 'Chart with {numSeries} data series.',
        splineSingle: 'Line chart with {numPoints} data {#plural(numPoints, points, point)}.',
        splineMultiple: 'Line chart with {numSeries} lines.',
        lineSingle: 'Line chart with {numPoints} data {#plural(numPoints, points, point)}.',
        lineMultiple: 'Line chart with {numSeries} lines.',
        columnSingle: 'Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.',
        columnMultiple: 'Bar chart with {numSeries} data series.',
        barSingle: 'Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.',
        barMultiple: 'Bar chart with {numSeries} data series.',
        pieSingle: 'Pie chart with {numPoints} {#plural(numPoints, slices, slice)}.',
        pieMultiple: 'Pie chart with {numSeries} pies.',
        scatterSingle: 'Scatter chart with {numPoints} {#plural(numPoints, points, point)}.',
        scatterMultiple: 'Scatter chart with {numSeries} data series.',
        boxplotSingle: 'Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.',
        boxplotMultiple: 'Boxplot with {numSeries} data series.',
        bubbleSingle: 'Bubble chart with {numPoints} {#plural(numPoints, bubbles, bubble)}.',
        bubbleMultiple: 'Bubble chart with {numSeries} data series.'
      },

      /**
       * Axis description format strings.
       *
       * @since 6.0.6
       * @type {Object}
       * @optionparent lang.accessibility.axis
       */
      axis: {
        xAxisDescriptionSingular: 'The chart has 1 X axis displaying {names[0]}.',
        xAxisDescriptionPlural: 'The chart has {numAxes} X axes displaying {#each(names, -1) }and {names[-1]}',
        yAxisDescriptionSingular: 'The chart has 1 Y axis displaying {names[0]}.',
        yAxisDescriptionPlural: 'The chart has {numAxes} Y axes displaying {#each(names, -1) }and {names[-1]}'
      },

      /**
       * Exporting menu format strings for accessibility module.
       *
       * @since 6.0.6
       * @type {Object}
       * @optionparent lang.accessibility.exporting
       */
      exporting: {
        chartMenuLabel: 'Chart export',
        menuButtonLabel: 'View export menu',
        exportRegionLabel: 'Chart export menu'
      },

      /**
       * Lang configuration for different series types. For more dynamic
       * control over the series element descriptions, see
       * [accessibility.seriesDescriptionFormatter](
       * accessibility.seriesDescriptionFormatter).
       *
       * @since 6.0.6
       * @type {Object}
       * @optionparent lang.accessibility.series
       */
      series: {
        /**
         * Lang configuration for the series main summary. Each series
         * type has two modes:
         *     1. This series type is the only series type used in the
         *        chart
         *    2. This is a combination chart with multiple series types
         *
         * If a definition does not exist for the specific series type
         * and mode, the 'default' lang definitions are used.
         *
         * @since 6.0.6
         * @type {Object}
         * @optionparent lang.accessibility.series.summary
         */
        summary: {
          default: '{name}, series {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.',
          defaultCombination: '{name}, series {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.',
          line: '{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.',
          lineCombination: '{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.',
          spline: '{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.',
          splineCombination: '{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.',
          column: '{name}, bar series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bars, bar)}.',
          columnCombination: '{name}, series {ix} of {numSeries}. Bar series with {numPoints} {#plural(numPoints, bars, bar)}.',
          bar: '{name}, bar series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bars, bar)}.',
          barCombination: '{name}, series {ix} of {numSeries}. Bar series with {numPoints} {#plural(numPoints, bars, bar)}.',
          pie: '{name}, pie {ix} of {numSeries} with {numPoints} {#plural(numPoints, slices, slice)}.',
          pieCombination: '{name}, series {ix} of {numSeries}. Pie with {numPoints} {#plural(numPoints, slices, slice)}.',
          scatter: '{name}, scatter plot {ix} of {numSeries} with {numPoints} {#plural(numPoints, points, point)}.',
          scatterCombination: '{name}, series {ix} of {numSeries}, scatter plot with {numPoints} {#plural(numPoints, points, point)}.',
          boxplot: '{name}, boxplot {ix} of {numSeries} with {numPoints} {#plural(numPoints, boxes, box)}.',
          boxplotCombination: '{name}, series {ix} of {numSeries}. Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.',
          bubble: '{name}, bubble series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bubbles, bubble)}.',
          bubbleCombination: '{name}, series {ix} of {numSeries}. Bubble series with {numPoints} {#plural(numPoints, bubbles, bubble)}.',
          map: '{name}, map {ix} of {numSeries} with {numPoints} {#plural(numPoints, areas, area)}.',
          mapCombination: '{name}, series {ix} of {numSeries}. Map with {numPoints} {#plural(numPoints, areas, area)}.',
          mapline: '{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.',
          maplineCombination: '{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.',
          mapbubble: '{name}, bubble series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bubbles, bubble)}.',
          mapbubbleCombination: '{name}, series {ix} of {numSeries}. Bubble series with {numPoints} {#plural(numPoints, bubbles, bubble)}.'
        },

        /* eslint-enable max-len */

        /**
         * User supplied description text. This is added after the main
         * summary if present.
         *
         * @type {String}
         * @since 6.0.6
         */
        description: '{description}',

        /**
         * xAxis description for series if there are multiple xAxes in
         * the chart.
         *
         * @type {String}
         * @since 6.0.6
         */
        xAxisDescription: 'X axis, {name}',

        /**
         * yAxis description for series if there are multiple yAxes in
         * the chart.
         *
         * @type {String}
         * @since 6.0.6
         */
        yAxisDescription: 'Y axis, {name}'
      }
    }
  }
});

/**
 * Accessibility module - Screen Reader support
 *
 * (c) 2010-2017 Highsoft AS
 * Author: Oystein Moseng
 *
 * License: www.highcharts.com/license
 */
var win$9 = Highcharts.win,
    doc$6 = win$9.document,
    each$z = Highcharts.each,
    map$7 = Highcharts.map,
    erase$6 = Highcharts.erase,
    addEvent$l = Highcharts.addEvent,
    merge$m = Highcharts.merge,
    // CSS style to hide element from visual users while still exposing it to
// screen readers
hiddenStyle = {
  position: 'absolute',
  left: '-9999px',
  top: 'auto',
  width: '1px',
  height: '1px',
  overflow: 'hidden'
}; // If a point has one of the special keys defined, we expose all keys to the
// screen reader.

Highcharts.Series.prototype.commonKeys = ['name', 'id', 'category', 'x', 'value', 'y'];
Highcharts.Series.prototype.specialKeys = ['z', 'open', 'high', 'q3', 'median', 'q1', 'low', 'close'];

if (Highcharts.seriesTypes.pie) {
  // A pie is always simple. Don't quote me on that.
  Highcharts.seriesTypes.pie.prototype.specialKeys = [];
}
/**
 * HTML encode some characters vulnerable for XSS.
 * @param  {string} html The input string
 * @return {string} The excaped string
 */


function htmlencode(html) {
  return html.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;');
}
/**
 * Strip HTML tags away from a string. Used for aria-label attributes, painting
 * on a canvas will fail if the text contains tags.
 * @param  {String} s The input string
 * @return {String}   The filtered string
 */


function stripTags(s) {
  return typeof s === 'string' ? s.replace(/<\/?[^>]+(>|$)/g, '') : s;
}
/**
 * Accessibility options
 */


Highcharts.setOptions({
  /**
   * Options for configuring accessibility for the chart. Requires the
   * [accessibility module](//code.highcharts.com/modules/accessibility.
   * js) to be loaded. For a description of the module and information
   * on its features, see [Highcharts Accessibility](http://www.highcharts.
   * com/docs/chart-concepts/accessibility).
   *
   * @since 5.0.0
   * @type {Object}
   * @optionparent accessibility
   */
  accessibility: {
    /**
     * Whether or not to add series descriptions to charts with a single
     * series.
     *
     * @type {Boolean}
     * @default false
     * @since 5.0.0
     * @apioption accessibility.describeSingleSeries
     */

    /**
     * Function to run upon clicking the "View as Data Table" link in the
     * screen reader region.
     *
     * By default Highcharts will insert and set focus to a data table
     * representation of the chart.
     *
     * @type {Function}
     * @since 5.0.0
     * @apioption accessibility.onTableAnchorClick
     */

    /**
     * Date format to use for points on datetime axes when describing them
     * to screen reader users.
     *
     * Defaults to the same format as in tooltip.
     *
     * For an overview of the replacement codes, see
     * [dateFormat](/class-reference/Highcharts#dateFormat).
     *
     * @type {String}
     * @see [pointDateFormatter](#accessibility.pointDateFormatter)
     * @since 5.0.0
     * @apioption accessibility.pointDateFormat
     */

    /**
     * Formatter function to determine the date/time format used with
     * points on datetime axes when describing them to screen reader users.
     * Receives one argument, `point`, referring to the point to describe.
     * Should return a date format string compatible with
     * [dateFormat](/class-reference/Highcharts#dateFormat).
     *
     * @type {Function}
     * @see [pointDateFormat](#accessibility.pointDateFormat)
     * @since 5.0.0
     * @apioption accessibility.pointDateFormatter
     */

    /**
     * Formatter function to use instead of the default for point
     * descriptions.
     * Receives one argument, `point`, referring to the point to describe.
     * Should return a String with the description of the point for a screen
     * reader user.
     *
     * @type {Function}
     * @see [point.description](#series.line.data.description)
     * @since 5.0.0
     * @apioption accessibility.pointDescriptionFormatter
     */

    /**
     * Formatter function to use instead of the default for series
     * descriptions. Receives one argument, `series`, referring to the
     * series to describe. Should return a String with the description of
     * the series for a screen reader user.
     *
     * @type {Function}
     * @see [series.description](#plotOptions.series.description)
     * @since 5.0.0
     * @apioption accessibility.seriesDescriptionFormatter
     */

    /**
     * Enable accessibility features for the chart.
     *
     * @type {Boolean}
     * @default true
     * @since 5.0.0
     */
    enabled: true,

    /**
     * When a series contains more points than this, we no longer expose
     * information about individual points to screen readers.
     *
     * Set to `false` to disable.
     *
     * @type {Number|Boolean}
     * @since 5.0.0
     */
    pointDescriptionThreshold: false,
    // set to false to disable

    /**
     * A formatter function to create the HTML contents of the hidden screen
     * reader information region. Receives one argument, `chart`, referring
     * to the chart object. Should return a String with the HTML content
     * of the region.
     *
     * The link to view the chart as a data table will be added
     * automatically after the custom HTML content.
     *
     * @type {Function}
     * @default undefined
     * @since 5.0.0
     */
    screenReaderSectionFormatter: function (chart) {
      var options = chart.options,
          chartTypes = chart.types || [],
          formatContext = {
        chart: chart,
        numSeries: chart.series && chart.series.length
      },
          // Build axis info - but not for pies and maps. Consider not
      // adding for certain other types as well (funnel, pyramid?)
      axesDesc = (chartTypes.length === 1 && chartTypes[0] === 'pie' || chartTypes[0] === 'map') && {} || chart.getAxesDescription();
      return '<div>' + chart.langFormat('accessibility.navigationHint', formatContext) + '</div><h3>' + (options.title.text ? htmlencode(options.title.text) : chart.langFormat('accessibility.defaultChartTitle', formatContext)) + (options.subtitle && options.subtitle.text ? '. ' + htmlencode(options.subtitle.text) : '') + '</h3><h4>' + chart.langFormat('accessibility.longDescriptionHeading', formatContext) + '</h4><div>' + (options.chart.description || chart.langFormat('accessibility.noDescription', formatContext)) + '</div><h4>' + chart.langFormat('accessibility.structureHeading', formatContext) + '</h4><div>' + (options.chart.typeDescription || chart.getTypeDescription()) + '</div>' + (axesDesc.xAxis ? '<div>' + axesDesc.xAxis + '</div>' : '') + (axesDesc.yAxis ? '<div>' + axesDesc.yAxis + '</div>' : '');
    }
  }
});
/**
 * A text description of the chart.
 *
 * If the Accessibility module is loaded, this is included by default
 * as a long description of the chart and its contents in the hidden
 * screen reader information region.
 *
 * @type {String}
 * @see [typeDescription](#chart.typeDescription)
 * @default undefined
 * @since 5.0.0
 * @apioption chart.description
 */

/**
* A text description of the chart type.
*
* If the Accessibility module is loaded, this will be included in the
* description of the chart in the screen reader information region.
*
*
* Highcharts will by default attempt to guess the chart type, but for
* more complex charts it is recommended to specify this property for
* clarity.
*
* @type {String}
* @default undefined
* @since 5.0.0
* @apioption chart.typeDescription
*/
// Utility function. Reverses child nodes of a DOM element

function reverseChildNodes(node) {
  var i = node.childNodes.length;

  while (i--) {
    node.appendChild(node.childNodes[i]);
  }
} // Whenever drawing series, put info on DOM elements


Highcharts.addEvent(Highcharts.Series, 'afterRender', function () {
  if (this.chart.options.accessibility.enabled) {
    this.setA11yDescription();
  }
}); // Put accessible info on series and points of a series

Highcharts.Series.prototype.setA11yDescription = function () {
  var a11yOptions = this.chart.options.accessibility,
      firstPointEl = this.points && this.points.length && this.points[0].graphic && this.points[0].graphic.element,
      seriesEl = firstPointEl && firstPointEl.parentNode || this.graph && this.graph.element || this.group && this.group.element; // Could be tracker series depending on series type

  if (seriesEl) {
    // For some series types the order of elements do not match the order of
    // points in series. In that case we have to reverse them in order for
    // AT to read them out in an understandable order
    if (seriesEl.lastChild === firstPointEl) {
      reverseChildNodes(seriesEl);
    } // Make individual point elements accessible if possible. Note: If
    // markers are disabled there might not be any elements there to make
    // accessible.


    if (this.points && (this.points.length < a11yOptions.pointDescriptionThreshold || a11yOptions.pointDescriptionThreshold === false)) {
      each$z(this.points, function (point) {
        if (point.graphic) {
          point.graphic.element.setAttribute('role', 'img');
          point.graphic.element.setAttribute('tabindex', '-1');
          point.graphic.element.setAttribute('aria-label', stripTags(point.series.options.pointDescriptionFormatter && point.series.options.pointDescriptionFormatter(point) || a11yOptions.pointDescriptionFormatter && a11yOptions.pointDescriptionFormatter(point) || point.buildPointInfoString()));
        }
      });
    } // Make series element accessible


    if (this.chart.series.length > 1 || a11yOptions.describeSingleSeries) {
      seriesEl.setAttribute('role', this.options.exposeElementToA11y ? 'img' : 'region');
      seriesEl.setAttribute('tabindex', '-1');
      seriesEl.setAttribute('aria-label', stripTags(a11yOptions.seriesDescriptionFormatter && a11yOptions.seriesDescriptionFormatter(this) || this.buildSeriesInfoString()));
    }
  }
}; // Return string with information about series


Highcharts.Series.prototype.buildSeriesInfoString = function () {
  var chart = this.chart,
      desc = this.description || this.options.description,
      description = desc && chart.langFormat('accessibility.series.description', {
    description: desc,
    series: this
  }),
      xAxisInfo = chart.langFormat('accessibility.series.xAxisDescription', {
    name: this.xAxis && this.xAxis.getDescription(),
    series: this
  }),
      yAxisInfo = chart.langFormat('accessibility.series.yAxisDescription', {
    name: this.yAxis && this.yAxis.getDescription(),
    series: this
  }),
      summaryContext = {
    name: this.name || '',
    ix: this.index + 1,
    numSeries: chart.series.length,
    numPoints: this.points.length,
    series: this
  },
      combination = chart.types.length === 1 ? '' : 'Combination',
      summary = chart.langFormat('accessibility.series.summary.' + this.type + combination, summaryContext) || chart.langFormat('accessibility.series.summary.default' + combination, summaryContext);
  return summary + (description ? ' ' + description : '') + (chart.yAxis.length > 1 && this.yAxis ? ' ' + yAxisInfo : '') + (chart.xAxis.length > 1 && this.xAxis ? ' ' + xAxisInfo : '');
}; // Return string with information about point


Highcharts.Point.prototype.buildPointInfoString = function () {
  var point = this,
      series = point.series,
      a11yOptions = series.chart.options.accessibility,
      infoString = '',
      dateTimePoint = series.xAxis && series.xAxis.isDatetimeAxis,
      timeDesc = dateTimePoint && series.chart.time.dateFormat(a11yOptions.pointDateFormatter && a11yOptions.pointDateFormatter(point) || a11yOptions.pointDateFormat || Highcharts.Tooltip.prototype.getXDateFormat.call({
    getDateFormat: Highcharts.Tooltip.prototype.getDateFormat,
    chart: series.chart
  }, point, series.chart.options.tooltip, series.xAxis), point.x),
      hasSpecialKey = Highcharts.find(series.specialKeys, function (key) {
    return point[key] !== undefined;
  }); // If the point has one of the less common properties defined, display all
  // that are defined

  if (hasSpecialKey) {
    if (dateTimePoint) {
      infoString = timeDesc;
    }

    each$z(series.commonKeys.concat(series.specialKeys), function (key) {
      if (point[key] !== undefined && !(dateTimePoint && key === 'x')) {
        infoString += (infoString ? '. ' : '') + key + ', ' + point[key];
      }
    });
  } else {
    // Pick and choose properties for a succint label
    infoString = (this.name || timeDesc || this.category || this.id || 'x, ' + this.x) + ', ' + (this.value !== undefined ? this.value : this.y);
  }

  return this.index + 1 + '. ' + infoString + '.' + (this.description ? ' ' + this.description : '');
}; // Get descriptive label for axis


Highcharts.Axis.prototype.getDescription = function () {
  return this.userOptions && this.userOptions.description || this.axisTitle && this.axisTitle.textStr || this.options.id || this.categories && 'categories' || this.isDatetimeAxis && 'Time' || 'values';
}; // Whenever adding or removing series, keep track of types present in chart


addEvent$l(Highcharts.Series, 'afterInit', function () {
  var chart = this.chart;

  if (chart.options.accessibility.enabled) {
    chart.types = chart.types || []; // Add type to list if does not exist

    if (chart.types.indexOf(this.type) < 0) {
      chart.types.push(this.type);
    }
  }
});
addEvent$l(Highcharts.Series, 'remove', function () {
  var chart = this.chart,
      removedSeries = this,
      hasType = false; // Check if any of the other series have the same type as this one.
  // Otherwise remove it from the list.

  each$z(chart.series, function (s) {
    if (s !== removedSeries && chart.types.indexOf(removedSeries.type) < 0) {
      hasType = true;
    }
  });

  if (!hasType) {
    erase$6(chart.types, removedSeries.type);
  }
}); // Return simplified description of chart type. Some types will not be familiar
// to most screen reader users, but in those cases we try to add a description
// of the type.

Highcharts.Chart.prototype.getTypeDescription = function () {
  var firstType = this.types && this.types[0],
      firstSeries = this.series && this.series[0] || {},
      mapTitle = firstSeries.mapTitle,
      typeDesc = this.langFormat('accessibility.seriesTypeDescriptions.' + firstType, {
    chart: this
  }),
      formatContext = {
    numSeries: this.series.length,
    numPoints: firstSeries.points && firstSeries.points.length,
    chart: this,
    mapTitle: mapTitle
  },
      multi = this.series && this.series.length === 1 ? 'Single' : 'Multiple';

  if (!firstType) {
    return this.langFormat('accessibility.chartTypes.emptyChart', formatContext);
  } else if (firstType === 'map') {
    return mapTitle ? this.langFormat('accessibility.chartTypes.mapTypeDescription', formatContext) : this.langFormat('accessibility.chartTypes.unknownMap', formatContext);
  } else if (this.types.length > 1) {
    return this.langFormat('accessibility.chartTypes.combinationChart', formatContext);
  }

  return (this.langFormat('accessibility.chartTypes.' + firstType + multi, formatContext) || this.langFormat('accessibility.chartTypes.default' + multi, formatContext)) + (typeDesc ? ' ' + typeDesc : '');
}; // Return object with text description of each of the chart's axes


Highcharts.Chart.prototype.getAxesDescription = function () {
  var numXAxes = this.xAxis.length,
      numYAxes = this.yAxis.length,
      desc = {};

  if (numXAxes) {
    desc.xAxis = this.langFormat('accessibility.axis.xAxisDescription' + (numXAxes > 1 ? 'Plural' : 'Singular'), {
      chart: this,
      names: map$7(this.xAxis, function (axis) {
        return axis.getDescription();
      }),
      numAxes: numXAxes
    });
  }

  if (numYAxes) {
    desc.yAxis = this.langFormat('accessibility.axis.yAxisDescription' + (numYAxes > 1 ? 'Plural' : 'Singular'), {
      chart: this,
      names: map$7(this.yAxis, function (axis) {
        return axis.getDescription();
      }),
      numAxes: numYAxes
    });
  }

  return desc;
}; // Set a11y attribs on exporting menu


Highcharts.Chart.prototype.addAccessibleContextMenuAttribs = function () {
  var exportList = this.exportDivElements;

  if (exportList) {
    // Set tabindex on the menu items to allow focusing by script
    // Set role to give screen readers a chance to pick up the contents
    each$z(exportList, function (item) {
      if (item.tagName === 'DIV' && !(item.children && item.children.length)) {
        item.setAttribute('role', 'menuitem');
        item.setAttribute('tabindex', -1);
      }
    }); // Set accessibility properties on parent div

    exportList[0].parentNode.setAttribute('role', 'menu');
    exportList[0].parentNode.setAttribute('aria-label', this.langFormat('accessibility.exporting.chartMenuLabel', {
      chart: this
    }));
  }
}; // Add screen reader region to chart.
// tableId is the HTML id of the table to focus when clicking the table anchor
// in the screen reader region.


Highcharts.Chart.prototype.addScreenReaderRegion = function (id, tableId) {
  var chart = this,
      hiddenSection = chart.screenReaderRegion = doc$6.createElement('div'),
      tableShortcut = doc$6.createElement('h4'),
      tableShortcutAnchor = doc$6.createElement('a'),
      chartHeading = doc$6.createElement('h4');
  hiddenSection.setAttribute('id', id);
  hiddenSection.setAttribute('role', 'region');
  hiddenSection.setAttribute('aria-label', chart.langFormat('accessibility.screenReaderRegionLabel', {
    chart: this
  }));
  hiddenSection.innerHTML = chart.options.accessibility.screenReaderSectionFormatter(chart); // Add shortcut to data table if export-data is loaded

  if (chart.getCSV) {
    tableShortcutAnchor.innerHTML = chart.langFormat('accessibility.viewAsDataTable', {
      chart: chart
    });
    tableShortcutAnchor.href = '#' + tableId; // Make this unreachable by user tabbing

    tableShortcutAnchor.setAttribute('tabindex', '-1');

    tableShortcutAnchor.onclick = chart.options.accessibility.onTableAnchorClick || function () {
      chart.viewData();
      doc$6.getElementById(tableId).focus();
    };

    tableShortcut.appendChild(tableShortcutAnchor);
    hiddenSection.appendChild(tableShortcut);
  } // Note: JAWS seems to refuse to read aria-label on the container, so add an
  // h4 element as title for the chart.


  chartHeading.innerHTML = chart.langFormat('accessibility.chartHeading', {
    chart: chart
  });
  chart.renderTo.insertBefore(chartHeading, chart.renderTo.firstChild);
  chart.renderTo.insertBefore(hiddenSection, chart.renderTo.firstChild); // Hide the section and the chart heading

  merge$m(true, chartHeading.style, hiddenStyle);
  merge$m(true, hiddenSection.style, hiddenStyle);
}; // Make chart container accessible, and wrap table functionality


Highcharts.Chart.prototype.callbacks.push(function (chart) {
  var options = chart.options,
      a11yOptions = options.accessibility;

  if (!a11yOptions.enabled) {
    return;
  }

  var titleElement,
      descElement = chart.container.getElementsByTagName('desc')[0],
      textElements = chart.container.getElementsByTagName('text'),
      titleId = 'highcharts-title-' + chart.index,
      tableId = 'highcharts-data-table-' + chart.index,
      hiddenSectionId = 'highcharts-information-region-' + chart.index,
      chartTitle = options.title.text || chart.langFormat('accessibility.defaultChartTitle', {
    chart: chart
  }),
      svgContainerTitle = stripTags(chart.langFormat('accessibility.svgContainerTitle', {
    chartTitle: chartTitle
  })); // Add SVG title tag if it is set

  if (svgContainerTitle.length) {
    titleElement = doc$6.createElementNS('http://www.w3.org/2000/svg', 'title');
    titleElement.textContent = svgContainerTitle;
    titleElement.id = titleId;
    descElement.parentNode.insertBefore(titleElement, descElement);
  }

  chart.renderTo.setAttribute('role', 'region');
  chart.renderTo.setAttribute('aria-label', chart.langFormat('accessibility.chartContainerLabel', {
    title: stripTags(chartTitle),
    chart: chart
  })); // Set screen reader properties on export menu

  if (chart.exportSVGElements && chart.exportSVGElements[0] && chart.exportSVGElements[0].element) {
    // Set event handler on button
    var button = chart.exportSVGElements[0].element,
        oldExportCallback = button.onclick;

    button.onclick = function () {
      oldExportCallback.apply(this, Array.prototype.slice.call(arguments));
      chart.addAccessibleContextMenuAttribs();
      chart.highlightExportItem(0);
    }; // Set props on button


    button.setAttribute('role', 'button');
    button.setAttribute('aria-label', chart.langFormat('accessibility.exporting.menuButtonLabel', {
      chart: chart
    })); // Set props on group

    chart.exportingGroup.element.setAttribute('role', 'region');
    chart.exportingGroup.element.setAttribute('aria-label', chart.langFormat('accessibility.exporting.exportRegionLabel', {
      chart: chart
    }));
  } // Set screen reader properties on input boxes for range selector. We need
  // to do this regardless of whether or not these are visible, as they are
  // by default part of the page's tabindex unless we set them to -1.


  if (chart.rangeSelector) {
    each$z(['minInput', 'maxInput'], function (key, i) {
      if (chart.rangeSelector[key]) {
        chart.rangeSelector[key].setAttribute('tabindex', '-1');
        chart.rangeSelector[key].setAttribute('role', 'textbox');
        chart.rangeSelector[key].setAttribute('aria-label', chart.langFormat('accessibility.rangeSelector' + (i ? 'MaxInput' : 'MinInput'), {
          chart: chart
        }));
      }
    });
  } // Hide text elements from screen readers


  each$z(textElements, function (el) {
    el.setAttribute('aria-hidden', 'true');
  }); // Add top-secret screen reader region

  chart.addScreenReaderRegion(hiddenSectionId, tableId); // Add ID and summary attr to table HTML

  Highcharts.wrap(chart, 'getTable', function (proceed) {
    return proceed.apply(this, Array.prototype.slice.call(arguments, 1)).replace('<table>', '<table id="' + tableId + '" summary="' + chart.langFormat('accessibility.tableSummary', {
      chart: chart
    }) + '">');
  });
});

/**
 * Accessibility module - Keyboard navigation
 *
 * (c) 2010-2017 Highsoft AS
 * Author: Oystein Moseng
 *
 * License: www.highcharts.com/license
 */
var win$a = Highcharts.win,
    doc$7 = win$a.document,
    each$A = Highcharts.each,
    addEvent$m = Highcharts.addEvent,
    fireEvent$c = Highcharts.fireEvent,
    merge$n = Highcharts.merge,
    pick$x = Highcharts.pick,
    hasSVGFocusSupport; // Add focus border functionality to SVGElements.
// Draws a new rect on top of element around its bounding box.

Highcharts.extend(Highcharts.SVGElement.prototype, {
  addFocusBorder: function (margin, style) {
    // Allow updating by just adding new border
    if (this.focusBorder) {
      this.removeFocusBorder();
    } // Add the border rect


    var bb = this.getBBox(),
        pad = pick$x(margin, 3);
    this.focusBorder = this.renderer.rect(bb.x - pad, bb.y - pad, bb.width + 2 * pad, bb.height + 2 * pad, style && style.borderRadius).addClass('highcharts-focus-border').attr({
      zIndex: 99
    }).add(this.parentGroup);
  },
  removeFocusBorder: function () {
    if (this.focusBorder) {
      this.focusBorder.destroy();
      delete this.focusBorder;
    }
  }
}); // Set for which series types it makes sense to move to the closest point with
// up/down arrows, and which series types should just move to next series.

Highcharts.Series.prototype.keyboardMoveVertical = true;
each$A(['column', 'pie'], function (type) {
  if (Highcharts.seriesTypes[type]) {
    Highcharts.seriesTypes[type].prototype.keyboardMoveVertical = false;
  }
});
/**
 * Strip HTML tags away from a string. Used for aria-label attributes, painting
 * on a canvas will fail if the text contains tags.
 * @param  {String} s The input string
 * @return {String}   The filtered string
 */

function stripTags$1(s) {
  return typeof s === 'string' ? s.replace(/<\/?[^>]+(>|$)/g, '') : s;
}
/**
 * Get the index of a point in a series. This is needed when using e.g. data
 * grouping.
 *
 * @param {Point} point The point to find index of.
 * @return {number} The index in the series.points array of the point.
 */


function getPointIndex(point) {
  var index = point.index,
      points = point.series.points,
      i = points.length;

  if (points[index] !== point) {
    while (i--) {
      if (points[i] === point) {
        return i;
      }
    }
  } else {
    return index;
  }
}
/**
 * Set default keyboard navigation options
 */


Highcharts.setOptions({
  accessibility: {
    /**
     * Options for keyboard navigation.
     *
     * @type      {Object}
     * @since     5.0.0
     * @apioption accessibility.keyboardNavigation
     */
    keyboardNavigation: {
      /**
       * Enable keyboard navigation for the chart.
       *
       * @type      {Boolean}
       * @default   true
       * @since     5.0.0
       * @apioption accessibility.keyboardNavigation.enabled
       */
      enabled: true,

      /**
       * Options for the focus border drawn around elements while
       * navigating through them.
       *
       * @type      {Object}
       * @sample    highcharts/accessibility/custom-focus
       *            Custom focus ring
       * @since     6.0.3
       * @apioption accessibility.keyboardNavigation.focusBorder
       */
      focusBorder: {
        /**
         * Enable/disable focus border for chart.
         *
         * @type      {Boolean}
         * @default   true
         * @since     6.0.3
         * @apioption accessibility.keyboardNavigation.focusBorder.enabled
         */
        enabled: true,

        /**
         * Hide the browser's default focus indicator.
         *
         * @type      {Boolean}
         * @default   true
         * @since     6.0.4
         * @apioption accessibility.keyboardNavigation.focusBorder.hideBrowserFocusOutline
         */
        hideBrowserFocusOutline: true,

        /**
         * Style options for the focus border drawn around elements
         * while navigating through them. Note that some browsers in
         * addition draw their own borders for focused elements. These
         * automatic borders can not be styled by Highcharts.
         *
         * In styled mode, the border is given the
         * `.highcharts-focus-border` class.
         *
         * @type      {Object}
         * @since     6.0.3
         * @apioption accessibility.keyboardNavigation.focusBorder.style
         */
        style: {
          /**
           * Color of the focus border.
           *
           * @type      {Color}
           * @default   #000000
           * @since     6.0.3
           * @apioption accessibility.keyboardNavigation.focusBorder.style.color
          */
          color: '#335cad',

          /**
           * Line width of the focus border.
           *
           * @type      {Number}
           * @default   2
           * @since     6.0.3
           * @apioption accessibility.keyboardNavigation.focusBorder.style.lineWidth
          */
          lineWidth: 2,

          /**
           * Border radius of the focus border.
           *
           * @type      {Number}
           * @default   3
           * @since     6.0.3
           * @apioption accessibility.keyboardNavigation.focusBorder.style.borderRadius
          */
          borderRadius: 3
        },

        /**
         * Focus border margin around the elements.
         *
         * @type      {Number}
         * @default   2
         * @since     6.0.3
         * @apioption accessibility.keyboardNavigation.focusBorder.margin
         */
        margin: 2
      },

      /**
       * Set the keyboard navigation mode for the chart. Can be "normal"
       * or "serialize". In normal mode, left/right arrow keys move
       * between points in a series, while up/down arrow keys move between
       * series. Up/down navigation acts intelligently to figure out which
       * series makes sense to move to from any given point.
       *
       * In "serialize" mode, points are instead navigated as a single
       * list. Left/right behaves as in "normal" mode. Up/down arrow keys
       * will behave like left/right. This is useful for unifying
       * navigation behavior with/without screen readers enabled.
       *
       * @type      {String}
       * @validvalue ["normal", "serialize"]
       * @default   normal
       * @since     6.0.4
       * @apioption accessibility.keyboardNavigation.mode
       */

      /**
       * Skip null points when navigating through points with the
       * keyboard.
       *
       * @type      {Boolean}
       * @default   true
       * @since     5.0.0
       * @apioption accessibility.keyboardNavigation.skipNullPoints
       */
      skipNullPoints: true
    }
  }
});
/**
 * Keyboard navigation for the legend. Requires the Accessibility module.
 * @since 5.0.14
 * @apioption legend.keyboardNavigation
 */

/**
 * Enable/disable keyboard navigation for the legend. Requires the Accessibility
 * module.
 *
 * @type {Boolean}
 * @see [accessibility.keyboardNavigation](
 *      #accessibility.keyboardNavigation.enabled)
 * @default true
 * @since 5.0.13
 * @apioption legend.keyboardNavigation.enabled
 */
// Abstraction layer for keyboard navigation. Keep a map of keyCodes to
// handler functions, and a next/prev move handler for tab order. The
// module's keyCode handlers determine when to move to another module.
// Validate holds a function to determine if there are prerequisites for
// this module to run that are not met. Init holds a function to run once
// before any keyCodes are interpreted. Terminate holds a function to run
// once before moving to next/prev module.
// The chart object keeps track of a list of KeyboardNavigationModules.

function KeyboardNavigationModule(chart, options) {
  this.chart = chart;
  this.id = options.id;
  this.keyCodeMap = options.keyCodeMap;
  this.validate = options.validate;
  this.init = options.init;
  this.terminate = options.terminate;
}

KeyboardNavigationModule.prototype = {
  // Find handler function(s) for key code in the keyCodeMap and run it.
  run: function (e) {
    var navModule = this,
        keyCode = e.which || e.keyCode,
        found = false,
        handled = false;
    each$A(this.keyCodeMap, function (codeSet) {
      if (codeSet[0].indexOf(keyCode) > -1) {
        found = true;
        handled = codeSet[1].call(navModule, keyCode, e) === false ? // If explicitly returning false, we haven't handled it
        false : true;
      }
    }); // Default tab handler, move to next/prev module

    if (!found && keyCode === 9) {
      handled = this.move(e.shiftKey ? -1 : 1);
    }

    return handled;
  },
  // Move to next/prev valid module, or undefined if none, and init
  // it. Returns true on success and false if there is no valid module
  // to move to.
  move: function (direction) {
    var chart = this.chart;

    if (this.terminate) {
      this.terminate(direction);
    }

    chart.keyboardNavigationModuleIndex += direction;
    var newModule = chart.keyboardNavigationModules[chart.keyboardNavigationModuleIndex]; // Remove existing focus border if any

    if (chart.focusElement) {
      chart.focusElement.removeFocusBorder();
    } // Verify new module


    if (newModule) {
      if (newModule.validate && !newModule.validate()) {
        return this.move(direction); // Invalid module, recurse
      }

      if (newModule.init) {
        newModule.init(direction); // Valid module, init it

        return true;
      }
    } // No module


    chart.keyboardNavigationModuleIndex = 0; // Reset counter
    // Set focus to chart or exit anchor depending on direction

    if (direction > 0) {
      this.chart.exiting = true;
      this.chart.tabExitAnchor.focus();
    } else {
      this.chart.renderTo.focus();
    }

    return false;
  }
}; // Utility function to attempt to fake a click event on an element

function fakeClickEvent(element) {
  var fakeEvent;

  if (element && element.onclick && doc$7.createEvent) {
    fakeEvent = doc$7.createEvent('Events');
    fakeEvent.initEvent('click', true, false);
    element.onclick(fakeEvent);
  }
} // Determine if a series should be skipped


function isSkipSeries(series) {
  var a11yOptions = series.chart.options.accessibility;
  return series.options.skipKeyboardNavigation || series.options.enableMouseTracking === false || // #8440
  !series.visible || // Skip all points in a series where pointDescriptionThreshold is
  // reached
  a11yOptions.pointDescriptionThreshold && a11yOptions.pointDescriptionThreshold <= series.points.length;
} // Determine if a point should be skipped


function isSkipPoint(point) {
  var a11yOptions = point.series.chart.options.accessibility;
  return point.isNull && a11yOptions.keyboardNavigation.skipNullPoints || point.visible === false || isSkipSeries(point.series);
} // Get the point in a series that is closest (in distance) to a reference point
// Optionally supply weight factors for x and y directions


function getClosestPoint(point, series, xWeight, yWeight) {
  var minDistance = Infinity,
      dPoint,
      minIx,
      distance,
      i = series.points.length;

  if (point.plotX === undefined || point.plotY === undefined) {
    return;
  }

  while (i--) {
    dPoint = series.points[i];

    if (dPoint.plotX === undefined || dPoint.plotY === undefined) {
      continue;
    }

    distance = (point.plotX - dPoint.plotX) * (point.plotX - dPoint.plotX) * (xWeight || 1) + (point.plotY - dPoint.plotY) * (point.plotY - dPoint.plotY) * (yWeight || 1);

    if (distance < minDistance) {
      minDistance = distance;
      minIx = i;
    }
  }

  return minIx !== undefined && series.points[minIx];
} // Pan along axis in a direction (1 or -1), optionally with a defined
// granularity (number of steps it takes to walk across current view)


Highcharts.Axis.prototype.panStep = function (direction, granularity) {
  var gran = granularity || 3,
      extremes = this.getExtremes(),
      step = (extremes.max - extremes.min) / gran * direction,
      newMax = extremes.max + step,
      newMin = extremes.min + step,
      size = newMax - newMin;

  if (direction < 0 && newMin < extremes.dataMin) {
    newMin = extremes.dataMin;
    newMax = newMin + size;
  } else if (direction > 0 && newMax > extremes.dataMax) {
    newMax = extremes.dataMax;
    newMin = newMax - size;
  }

  this.setExtremes(newMin, newMax);
}; // Set chart's focus to an SVGElement. Calls focus() on it, and draws the focus
// border. If the focusElement argument is supplied, it draws the border around
// svgElement and sets the focus to focusElement.


Highcharts.Chart.prototype.setFocusToElement = function (svgElement, focusElement) {
  var focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder,
      browserFocusElement = focusElement || svgElement; // Set browser focus if possible

  if (browserFocusElement.element && browserFocusElement.element.focus) {
    browserFocusElement.element.focus(); // Hide default focus ring

    if (focusBorderOptions.hideBrowserFocusOutline) {
      browserFocusElement.css({
        outline: 'none'
      });
    }
  }

  if (focusBorderOptions.enabled) {
    // Remove old focus border
    if (this.focusElement) {
      this.focusElement.removeFocusBorder();
    } // Draw focus border (since some browsers don't do it automatically)


    svgElement.addFocusBorder(focusBorderOptions.margin, {
      stroke: focusBorderOptions.style.color,
      strokeWidth: focusBorderOptions.style.lineWidth,
      borderRadius: focusBorderOptions.style.borderRadius
    });
    this.focusElement = svgElement;
  }
}; // Highlight a point (show tooltip and display hover state). Returns the
// highlighted point.


Highcharts.Point.prototype.highlight = function () {
  var chart = this.series.chart;

  if (!this.isNull) {
    this.onMouseOver(); // Show the hover marker and tooltip
  } else {
    if (chart.tooltip) {
      chart.tooltip.hide(0);
    } // Don't call blur on the element, as it messes up the chart div's focus

  } // We focus only after calling onMouseOver because the state change can
  // change z-index and mess up the element.


  if (this.graphic) {
    chart.setFocusToElement(this.graphic);
  }

  chart.highlightedPoint = this;
  return this;
}; // Function to highlight next/previous point in chart
// Returns highlighted point on success, false on failure (no adjacent point to
// highlight in chosen direction)


Highcharts.Chart.prototype.highlightAdjacentPoint = function (next) {
  var chart = this,
      series = chart.series,
      curPoint = chart.highlightedPoint,
      curPointIndex = curPoint && getPointIndex(curPoint) || 0,
      curPoints = curPoint && curPoint.series.points,
      lastSeries = chart.series && chart.series[chart.series.length - 1],
      lastPoint = lastSeries && lastSeries.points && lastSeries.points[lastSeries.points.length - 1],
      newSeries,
      newPoint; // If no points, return false

  if (!series[0] || !series[0].points) {
    return false;
  }

  if (!curPoint) {
    // No point is highlighted yet. Try first/last point depending on move
    // direction
    newPoint = next ? series[0].points[0] : lastPoint;
  } else {
    // We have a highlighted point.
    // Grab next/prev point & series
    newSeries = series[curPoint.series.index + (next ? 1 : -1)];
    newPoint = curPoints[curPointIndex + (next ? 1 : -1)];

    if (!newPoint && newSeries) {
      // Done with this series, try next one
      newPoint = newSeries.points[next ? 0 : newSeries.points.length - 1];
    } // If there is no adjacent point, we return false


    if (!newPoint) {
      return false;
    }
  } // Recursively skip points


  if (isSkipPoint(newPoint)) {
    // If we skip this whole series, move to the end of the series before we
    // recurse, just to optimize
    newSeries = newPoint.series;

    if (isSkipSeries(newSeries)) {
      chart.highlightedPoint = next ? newSeries.points[newSeries.points.length - 1] : newSeries.points[0];
    } else {
      // Otherwise, just move one point
      chart.highlightedPoint = newPoint;
    } // Retry


    return chart.highlightAdjacentPoint(next);
  } // There is an adjacent point, highlight it


  return newPoint.highlight();
}; // Highlight first valid point in a series. Returns the point if successfully
// highlighted, otherwise false. If there is a highlighted point in the series,
// use that as starting point.


Highcharts.Series.prototype.highlightFirstValidPoint = function () {
  var curPoint = this.chart.highlightedPoint,
      start = (curPoint && curPoint.series) === this ? getPointIndex(curPoint) : 0,
      points = this.points;

  if (points) {
    for (var i = start, len = points.length; i < len; ++i) {
      if (!isSkipPoint(points[i])) {
        return points[i].highlight();
      }
    }

    for (var j = start; j >= 0; --j) {
      if (!isSkipPoint(points[j])) {
        return points[j].highlight();
      }
    }
  }

  return false;
}; // Highlight next/previous series in chart. Returns false if no adjacent series
// in the direction, otherwise returns new highlighted point.


Highcharts.Chart.prototype.highlightAdjacentSeries = function (down) {
  var chart = this,
      newSeries,
      newPoint,
      adjacentNewPoint,
      curPoint = chart.highlightedPoint,
      lastSeries = chart.series && chart.series[chart.series.length - 1],
      lastPoint = lastSeries && lastSeries.points && lastSeries.points[lastSeries.points.length - 1]; // If no point is highlighted, highlight the first/last point

  if (!chart.highlightedPoint) {
    newSeries = down ? chart.series && chart.series[0] : lastSeries;
    newPoint = down ? newSeries && newSeries.points && newSeries.points[0] : lastPoint;
    return newPoint ? newPoint.highlight() : false;
  }

  newSeries = chart.series[curPoint.series.index + (down ? -1 : 1)];

  if (!newSeries) {
    return false;
  } // We have a new series in this direction, find the right point
  // Weigh xDistance as counting much higher than Y distance


  newPoint = getClosestPoint(curPoint, newSeries, 4);

  if (!newPoint) {
    return false;
  } // New series and point exists, but we might want to skip it


  if (isSkipSeries(newSeries)) {
    // Skip the series
    newPoint.highlight();
    adjacentNewPoint = chart.highlightAdjacentSeries(down); // Try recurse

    if (!adjacentNewPoint) {
      // Recurse failed
      curPoint.highlight();
      return false;
    } // Recurse succeeded


    return adjacentNewPoint;
  } // Highlight the new point or any first valid point back or forwards from it


  newPoint.highlight();
  return newPoint.series.highlightFirstValidPoint();
}; // Highlight the closest point vertically


Highcharts.Chart.prototype.highlightAdjacentPointVertical = function (down) {
  var curPoint = this.highlightedPoint,
      minDistance = Infinity,
      bestPoint;

  if (curPoint.plotX === undefined || curPoint.plotY === undefined) {
    return false;
  }

  each$A(this.series, function (series) {
    if (isSkipSeries(series)) {
      return;
    }

    each$A(series.points, function (point) {
      if (point.plotY === undefined || point.plotX === undefined || point === curPoint) {
        return;
      }

      var yDistance = point.plotY - curPoint.plotY,
          width = Math.abs(point.plotX - curPoint.plotX),
          distance = Math.abs(yDistance) * Math.abs(yDistance) + width * width * 4; // Weigh horizontal distance highly
      // Reverse distance number if axis is reversed

      if (series.yAxis.reversed) {
        yDistance *= -1;
      }

      if (yDistance < 0 && down || yDistance > 0 && !down || // Wrong dir
      distance < 5 || // Points in same spot => infinite loop
      isSkipPoint(point)) {
        return;
      }

      if (distance < minDistance) {
        minDistance = distance;
        bestPoint = point;
      }
    });
  });
  return bestPoint ? bestPoint.highlight() : false;
}; // Show the export menu and focus the first item (if exists)


Highcharts.Chart.prototype.showExportMenu = function () {
  if (this.exportSVGElements && this.exportSVGElements[0]) {
    this.exportSVGElements[0].element.onclick();
    this.highlightExportItem(0);
  }
}; // Hide export menu


Highcharts.Chart.prototype.hideExportMenu = function () {
  var chart = this,
      exportList = chart.exportDivElements;

  if (exportList && chart.exportContextMenu) {
    // Reset hover states etc.
    each$A(exportList, function (el) {
      if (el.className === 'highcharts-menu-item' && el.onmouseout) {
        el.onmouseout();
      }
    });
    chart.highlightedExportItem = 0; // Hide the menu div

    chart.exportContextMenu.hideMenu(); // Make sure the chart has focus and can capture keyboard events

    chart.container.focus();
  }
}; // Highlight export menu item by index


Highcharts.Chart.prototype.highlightExportItem = function (ix) {
  var listItem = this.exportDivElements && this.exportDivElements[ix],
      curHighlighted = this.exportDivElements && this.exportDivElements[this.highlightedExportItem];

  if (listItem && listItem.tagName === 'DIV' && !(listItem.children && listItem.children.length)) {
    if (listItem.focus && hasSVGFocusSupport) {
      // Only focus if we can set focus back to the elements after
      // destroying the menu (#7422)
      listItem.focus();
    }

    if (curHighlighted && curHighlighted.onmouseout) {
      curHighlighted.onmouseout();
    }

    if (listItem.onmouseover) {
      listItem.onmouseover();
    }

    this.highlightedExportItem = ix;
    return true;
  }
}; // Try to highlight the last valid export menu item


Highcharts.Chart.prototype.highlightLastExportItem = function () {
  var chart = this,
      i;

  if (chart.exportDivElements) {
    i = chart.exportDivElements.length;

    while (i--) {
      if (chart.highlightExportItem(i)) {
        break;
      }
    }
  }
}; // Highlight range selector button by index


Highcharts.Chart.prototype.highlightRangeSelectorButton = function (ix) {
  var buttons = this.rangeSelector.buttons; // Deselect old

  if (buttons[this.highlightedRangeSelectorItemIx]) {
    buttons[this.highlightedRangeSelectorItemIx].setState(this.oldRangeSelectorItemState || 0);
  } // Select new


  this.highlightedRangeSelectorItemIx = ix;

  if (buttons[ix]) {
    this.setFocusToElement(buttons[ix].box, buttons[ix]);
    this.oldRangeSelectorItemState = buttons[ix].state;
    buttons[ix].setState(2);
    return true;
  }

  return false;
}; // Highlight legend item by index


Highcharts.Chart.prototype.highlightLegendItem = function (ix) {
  var items = this.legend.allItems,
      oldIx = this.highlightedLegendItemIx;

  if (items[ix]) {
    if (items[oldIx]) {
      fireEvent$c(items[oldIx].legendGroup.element, 'mouseout');
    } // Scroll if we have to


    if (items[ix].pageIx !== undefined && items[ix].pageIx + 1 !== this.legend.currentPage) {
      this.legend.scroll(1 + items[ix].pageIx - this.legend.currentPage);
    } // Focus


    this.highlightedLegendItemIx = ix;
    this.setFocusToElement(items[ix].legendItem, items[ix].legendGroup);
    fireEvent$c(items[ix].legendGroup.element, 'mouseover');
    return true;
  }

  return false;
}; // Add keyboard navigation handling modules to chart


Highcharts.Chart.prototype.addKeyboardNavigationModules = function () {
  var chart = this;

  function navModuleFactory(id, keyMap, options) {
    return new KeyboardNavigationModule(chart, merge$n({
      keyCodeMap: keyMap
    }, {
      id: id
    }, options));
  } // List of the different keyboard handling modes we use depending on where
  // we are in the chart. Each mode has a set of handling functions mapped to
  // key codes. Each mode determines when to move to the next/prev mode.


  chart.keyboardNavigationModules = [// Entry point catching the first tab, allowing users to tab into points
  // more intuitively.
  navModuleFactory('entry', []), // Points
  navModuleFactory('points', [// Left/Right
  [[37, 39], function (keyCode) {
    var right = keyCode === 39;

    if (!chart.highlightAdjacentPoint(right)) {
      // Failed to highlight next, wrap to last/first
      return this.init(right ? 1 : -1);
    }

    return true;
  }], // Up/Down
  [[38, 40], function (keyCode) {
    var down = keyCode !== 38,
        navOptions = chart.options.accessibility.keyboardNavigation;

    if (navOptions.mode && navOptions.mode === 'serialize') {
      // Act like left/right
      if (!chart.highlightAdjacentPoint(down)) {
        return this.init(down ? 1 : -1);
      }

      return true;
    } // Normal mode, move between series


    var highlightMethod = chart.highlightedPoint && chart.highlightedPoint.series.keyboardMoveVertical ? 'highlightAdjacentPointVertical' : 'highlightAdjacentSeries';
    chart[highlightMethod](down);
    return true;
  }], // Enter/Spacebar
  [[13, 32], function () {
    if (chart.highlightedPoint) {
      chart.highlightedPoint.firePointEvent('click');
    }
  }]], {
    // Always start highlighting from scratch when entering this module
    init: function (dir) {
      var numSeries = chart.series.length,
          i = dir > 0 ? 0 : numSeries,
          res;

      if (dir > 0) {
        delete chart.highlightedPoint; // Find first valid point to highlight

        while (i < numSeries) {
          res = chart.series[i].highlightFirstValidPoint();

          if (res) {
            return res;
          }

          ++i;
        }
      } else {
        // Find last valid point to highlight
        while (i--) {
          chart.highlightedPoint = chart.series[i].points[chart.series[i].points.length - 1]; // Highlight first valid point in the series will also
          // look backwards. It always starts from currently
          // highlighted point.

          res = chart.series[i].highlightFirstValidPoint();

          if (res) {
            return res;
          }
        }
      }
    },
    // If leaving points, don't show tooltip anymore
    terminate: function () {
      if (chart.tooltip) {
        chart.tooltip.hide(0);
      }

      delete chart.highlightedPoint;
    }
  }), // Exporting
  navModuleFactory('exporting', [// Left/Up
  [[37, 38], function () {
    var i = chart.highlightedExportItem || 0,
        reachedEnd = true; // Try to highlight prev item in list. Highlighting e.g.
    // separators will fail.

    while (i--) {
      if (chart.highlightExportItem(i)) {
        reachedEnd = false;
        break;
      }
    }

    if (reachedEnd) {
      chart.highlightLastExportItem();
      return true;
    }
  }], // Right/Down
  [[39, 40], function () {
    var highlightedExportItem = chart.highlightedExportItem || 0,
        reachedEnd = true; // Try to highlight next item in list. Highlighting e.g.
    // separators will fail.

    for (var i = highlightedExportItem + 1; i < chart.exportDivElements.length; ++i) {
      if (chart.highlightExportItem(i)) {
        reachedEnd = false;
        break;
      }
    }

    if (reachedEnd) {
      chart.highlightExportItem(0);
      return true;
    }
  }], // Enter/Spacebar
  [[13, 32], function () {
    fakeClickEvent(chart.exportDivElements[chart.highlightedExportItem]);
  }]], {
    // Only run exporting navigation if exporting support exists and is
    // enabled on chart
    validate: function () {
      return chart.exportChart && !(chart.options.exporting && chart.options.exporting.enabled === false);
    },
    // Show export menu
    init: function (direction) {
      chart.highlightedPoint = null;
      chart.showExportMenu(); // If coming back to export menu from other module, try to
      // highlight last item in menu

      if (direction < 0) {
        chart.highlightLastExportItem();
      }
    },
    // Hide the menu
    terminate: function () {
      chart.hideExportMenu();
    }
  }), // Map zoom
  navModuleFactory('mapZoom', [// Up/down/left/right
  [[38, 40, 37, 39], function (keyCode) {
    chart[keyCode === 38 || keyCode === 40 ? 'yAxis' : 'xAxis'][0].panStep(keyCode < 39 ? -1 : 1);
  }], // Tabs
  [[9], function (keyCode, e) {
    var button; // Deselect old

    chart.mapNavButtons[chart.focusedMapNavButtonIx].setState(0);

    if (e.shiftKey && !chart.focusedMapNavButtonIx || !e.shiftKey && chart.focusedMapNavButtonIx) {
      // trying to go somewhere we can't?
      chart.mapZoom(); // Reset zoom
      // Nowhere to go, go to prev/next module

      return this.move(e.shiftKey ? -1 : 1);
    }

    chart.focusedMapNavButtonIx += e.shiftKey ? -1 : 1;
    button = chart.mapNavButtons[chart.focusedMapNavButtonIx];
    chart.setFocusToElement(button.box, button);
    button.setState(2);
  }], // Enter/Spacebar
  [[13, 32], function () {
    fakeClickEvent(chart.mapNavButtons[chart.focusedMapNavButtonIx].element);
  }]], {
    // Only run this module if we have map zoom on the chart
    validate: function () {
      return chart.mapZoom && chart.mapNavButtons && chart.mapNavButtons.length === 2;
    },
    // Make zoom buttons do their magic
    init: function (direction) {
      var zoomIn = chart.mapNavButtons[0],
          zoomOut = chart.mapNavButtons[1],
          initialButton = direction > 0 ? zoomIn : zoomOut;
      each$A(chart.mapNavButtons, function (button, i) {
        button.element.setAttribute('tabindex', -1);
        button.element.setAttribute('role', 'button');
        button.element.setAttribute('aria-label', chart.langFormat('accessibility.mapZoom' + (i ? 'Out' : 'In'), {
          chart: chart
        }));
      });
      chart.setFocusToElement(initialButton.box, initialButton);
      initialButton.setState(2);
      chart.focusedMapNavButtonIx = direction > 0 ? 0 : 1;
    }
  }), // Highstock range selector (minus input boxes)
  navModuleFactory('rangeSelector', [// Left/Right/Up/Down
  [[37, 39, 38, 40], function (keyCode) {
    var direction = keyCode === 37 || keyCode === 38 ? -1 : 1; // Try to highlight next/prev button

    if (!chart.highlightRangeSelectorButton(chart.highlightedRangeSelectorItemIx + direction)) {
      return this.move(direction);
    }
  }], // Enter/Spacebar
  [[13, 32], function () {
    // Don't allow click if button used to be disabled
    if (chart.oldRangeSelectorItemState !== 3) {
      fakeClickEvent(chart.rangeSelector.buttons[chart.highlightedRangeSelectorItemIx].element);
    }
  }]], {
    // Only run this module if we have range selector
    validate: function () {
      return chart.rangeSelector && chart.rangeSelector.buttons && chart.rangeSelector.buttons.length;
    },
    // Make elements focusable and accessible
    init: function (direction) {
      each$A(chart.rangeSelector.buttons, function (button) {
        button.element.setAttribute('tabindex', '-1');
        button.element.setAttribute('role', 'button');
        button.element.setAttribute('aria-label', chart.langFormat('accessibility.rangeSelectorButton', {
          chart: chart,
          buttonText: button.text && button.text.textStr
        }));
      }); // Focus first/last button

      chart.highlightRangeSelectorButton(direction > 0 ? 0 : chart.rangeSelector.buttons.length - 1);
    }
  }), // Highstock range selector, input boxes
  navModuleFactory('rangeSelectorInput', [// Tab/Up/Down
  [[9, 38, 40], function (keyCode, e) {
    var direction = keyCode === 9 && e.shiftKey || keyCode === 38 ? -1 : 1,
        newIx = chart.highlightedInputRangeIx = chart.highlightedInputRangeIx + direction; // Try to highlight next/prev item in list.

    if (newIx > 1 || newIx < 0) {
      // Out of range
      return this.move(direction);
    }

    chart.rangeSelector[newIx ? 'maxInput' : 'minInput'].focus();
  }]], {
    // Only run if we have range selector with input boxes
    validate: function () {
      var inputVisible = chart.rangeSelector && chart.rangeSelector.inputGroup && chart.rangeSelector.inputGroup.element.getAttribute('visibility') !== 'hidden';
      return inputVisible && chart.options.rangeSelector.inputEnabled !== false && chart.rangeSelector.minInput && chart.rangeSelector.maxInput;
    },
    // Highlight first/last input box
    init: function (direction) {
      chart.highlightedInputRangeIx = direction > 0 ? 0 : 1;
      chart.rangeSelector[chart.highlightedInputRangeIx ? 'maxInput' : 'minInput'].focus();
    }
  }), // Legend navigation
  navModuleFactory('legend', [// Left/Right/Up/Down
  [[37, 39, 38, 40], function (keyCode) {
    var direction = keyCode === 37 || keyCode === 38 ? -1 : 1; // Try to highlight next/prev legend item

    if (!chart.highlightLegendItem(chart.highlightedLegendItemIx + direction) && chart.legend.allItems.length > 1) {
      // Wrap around if more than 1 item
      this.init(direction);
    }
  }], // Enter/Spacebar
  [[13, 32], function () {
    var legendElement = chart.legend.allItems[chart.highlightedLegendItemIx].legendItem.element;
    fakeClickEvent(!chart.legend.options.useHTML ? // #8561
    legendElement.parentNode : legendElement);
  }]], {
    // Only run this module if we have at least one legend - wait for
    // it - item. Don't run if the legend is populated by a colorAxis.
    // Don't run if legend navigation is disabled.
    validate: function () {
      return chart.legend && chart.legend.allItems && chart.legend.display && !(chart.colorAxis && chart.colorAxis.length) && (chart.options.legend && chart.options.legend.keyboardNavigation && chart.options.legend.keyboardNavigation.enabled) !== false;
    },
    // Make elements focusable and accessible
    init: function (direction) {
      each$A(chart.legend.allItems, function (item) {
        item.legendGroup.element.setAttribute('tabindex', '-1');
        item.legendGroup.element.setAttribute('role', 'button');
        item.legendGroup.element.setAttribute('aria-label', chart.langFormat('accessibility.legendItem', {
          chart: chart,
          itemName: stripTags$1(item.name)
        }));
      }); // Focus first/last item

      chart.highlightLegendItem(direction > 0 ? 0 : chart.legend.allItems.length - 1);
    }
  })];
}; // Add exit anchor to the chart
// We use this to move focus out of chart whenever we want, by setting focus
// to this div and not preventing the default tab action.
// We also use this when users come back into the chart by tabbing back, in
// order to navigate from the end of the chart.
// Function returns the unbind function for the exit anchor's event handler.


Highcharts.Chart.prototype.addExitAnchor = function () {
  var chart = this;
  chart.tabExitAnchor = doc$7.createElement('div');
  chart.tabExitAnchor.setAttribute('tabindex', '0'); // Hide exit anchor

  merge$n(true, chart.tabExitAnchor.style, {
    position: 'absolute',
    left: '-9999px',
    top: 'auto',
    width: '1px',
    height: '1px',
    overflow: 'hidden'
  });
  chart.renderTo.appendChild(chart.tabExitAnchor);
  return addEvent$m(chart.tabExitAnchor, 'focus', function (ev) {
    var e = ev || win$a.event,
        curModule; // If focusing and we are exiting, do nothing once.

    if (!chart.exiting) {
      // Not exiting, means we are coming in backwards
      chart.renderTo.focus();
      e.preventDefault(); // Move to last valid keyboard nav module
      // Note the we don't run it, just set the index

      chart.keyboardNavigationModuleIndex = chart.keyboardNavigationModules.length - 1;
      curModule = chart.keyboardNavigationModules[chart.keyboardNavigationModuleIndex]; // Validate the module

      if (curModule.validate && !curModule.validate()) {
        // Invalid.
        // Move inits next valid module in direction
        curModule.move(-1);
      } else {
        // We have a valid module, init it
        curModule.init(-1);
      }
    } else {
      // Don't skip the next focus, we only skip once.
      chart.exiting = false;
    }
  });
}; // Clear the chart and reset the navigation state


Highcharts.Chart.prototype.resetKeyboardNavigation = function () {
  var chart = this,
      curMod = chart.keyboardNavigationModules && chart.keyboardNavigationModules[chart.keyboardNavigationModuleIndex || 0];

  if (curMod && curMod.terminate) {
    curMod.terminate();
  }

  if (chart.focusElement) {
    chart.focusElement.removeFocusBorder();
  }

  chart.keyboardNavigationModuleIndex = 0;
  chart.keyboardReset = true;
};
/**
 * On destroy, we need to clean up the focus border and the state
 */


Highcharts.addEvent(Highcharts.Series, 'destroy', function () {
  var chart = this.chart;

  if (chart.highlightedPoint && chart.highlightedPoint.series === this) {
    delete chart.highlightedPoint;

    if (chart.focusElement) {
      chart.focusElement.removeFocusBorder();
    }
  }
}); // Add keyboard navigation events on chart load

Highcharts.Chart.prototype.callbacks.push(function (chart) {
  var a11yOptions = chart.options.accessibility;

  if (a11yOptions.enabled && a11yOptions.keyboardNavigation.enabled) {
    // Test if we have focus support for SVG elements
    hasSVGFocusSupport = !!chart.renderTo.getElementsByTagName('g')[0].focus; // Init nav modules. We start at the first module, and as the user
    // navigates through the chart the index will increase to use different
    // handler modules.

    chart.addKeyboardNavigationModules();
    chart.keyboardNavigationModuleIndex = 0; // Make chart container reachable by tab

    if (chart.container.hasAttribute && !chart.container.hasAttribute('tabIndex')) {
      chart.container.setAttribute('tabindex', '0');
    } // Add tab exit anchor


    if (!chart.tabExitAnchor) {
      chart.unbindExitAnchorFocus = chart.addExitAnchor();
    } // Handle keyboard events by routing them to active keyboard nav module


    chart.unbindKeydownHandler = addEvent$m(chart.renderTo, 'keydown', function (ev) {
      var e = ev || win$a.event,
          curNavModule = chart.keyboardNavigationModules[chart.keyboardNavigationModuleIndex];
      chart.keyboardReset = false; // If there is a nav module for the current index, run it.
      // Otherwise, we are outside of the chart in some direction.

      if (curNavModule) {
        if (curNavModule.run(e)) {
          // Successfully handled this key event, stop default
          e.preventDefault();
        }
      }
    }); // Reset chart navigation state if we click outside the chart and it's
    // not already reset

    chart.unbindBlurHandler = addEvent$m(doc$7, 'mouseup', function () {
      if (!chart.keyboardReset && !(chart.pointer && chart.pointer.chartPosition)) {
        chart.resetKeyboardNavigation();
      }
    }); // Add cleanup handlers

    addEvent$m(chart, 'destroy', function () {
      chart.resetKeyboardNavigation();

      if (chart.unbindExitAnchorFocus && chart.tabExitAnchor) {
        chart.unbindExitAnchorFocus();
      }

      if (chart.unbindKeydownHandler && chart.renderTo) {
        chart.unbindKeydownHandler();
      }

      if (chart.unbindBlurHandler) {
        chart.unbindBlurHandler();
      }
    });
  }
});

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 * Accessibility module
 *
 * (c) 2010-2017 Highsoft AS
 * Author: Oystein Moseng
 *
 * License: www.highcharts.com/license
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var CenteredSeriesMixin$1 = Highcharts.CenteredSeriesMixin,
    each$B = Highcharts.each,
    extend$m = Highcharts.extend,
    merge$o = Highcharts.merge,
    splat$a = Highcharts.splat;
/**
 * The Pane object allows options that are common to a set of X and Y axes.
 *
 * In the future, this can be extended to basic Highcharts and Highstock.
 *
 */

function Pane(options, chart) {
  this.init(options, chart);
} // Extend the Pane prototype


extend$m(Pane.prototype, {
  coll: 'pane',
  // Member of chart.pane

  /**
   * Initiate the Pane object
   */
  init: function (options, chart) {
    this.chart = chart;
    this.background = [];
    chart.pane.push(this);
    this.setOptions(options);
  },
  setOptions: function (options) {
    // Set options. Angular charts have a default background (#3318)
    this.options = options = merge$o(this.defaultOptions, this.chart.angular ? {
      background: {}
    } : undefined, options);
  },

  /**
   * Render the pane with its backgrounds.
   */
  render: function () {
    var options = this.options,
        backgroundOption = this.options.background,
        renderer = this.chart.renderer,
        len,
        i;

    if (!this.group) {
      this.group = renderer.g('pane-group').attr({
        zIndex: options.zIndex || 0
      }).add();
    }

    this.updateCenter(); // Render the backgrounds

    if (backgroundOption) {
      backgroundOption = splat$a(backgroundOption);
      len = Math.max(backgroundOption.length, this.background.length || 0);

      for (i = 0; i < len; i++) {
        // #6641 - if axis exists, chart is circular and apply
        // background
        if (backgroundOption[i] && this.axis) {
          this.renderBackground(merge$o(this.defaultBackgroundOptions, backgroundOption[i]), i);
        } else if (this.background[i]) {
          this.background[i] = this.background[i].destroy();
          this.background.splice(i, 1);
        }
      }
    }
  },

  /**
   * Render an individual pane background.
   * @param  {Object} backgroundOptions Background options
   * @param  {number} i The index of the background in this.backgrounds
   */
  renderBackground: function (backgroundOptions, i) {
    var method = 'animate';

    if (!this.background[i]) {
      this.background[i] = this.chart.renderer.path().add(this.group);
      method = 'attr';
    }

    this.background[i][method]({
      'd': this.axis.getPlotBandPath(backgroundOptions.from, backgroundOptions.to, backgroundOptions)
    }).attr({
      'class': 'highcharts-pane ' + (backgroundOptions.className || '')
    });
  },

  /**
   * The pane serves as a container for axes and backgrounds for circular
   * gauges and polar charts.
   * @since 2.3.0
   * @optionparent pane
   */
  defaultOptions: {
    /**
     * The end angle of the polar X axis or gauge value axis, given in
     * degrees where 0 is north. Defaults to [startAngle](#pane.startAngle)
     * + 360.
     *
     * @type {Number}
     * @sample {highcharts} highcharts/demo/gauge-vu-meter/
     *         VU-meter with custom start and end angle
     * @since 2.3.0
     * @product highcharts
     * @apioption pane.endAngle
     */

    /**
     * The center of a polar chart or angular gauge, given as an array
     * of [x, y] positions. Positions can be given as integers that
     * transform to pixels, or as percentages of the plot area size.
     *
     * @type {Array<String|Number>}
     * @sample {highcharts} highcharts/demo/gauge-vu-meter/
     *         Two gauges with different center
     * @default ["50%", "50%"]
     * @since 2.3.0
     * @product highcharts
     */
    center: ['50%', '50%'],

    /**
     * The size of the pane, either as a number defining pixels, or a
     * percentage defining a percentage of the plot are.
     *
     * @type {Number|String}
     * @sample {highcharts} highcharts/demo/gauge-vu-meter/ Smaller size
     * @default 85%
     * @product highcharts
     */
    size: '85%',

    /**
     * The start angle of the polar X axis or gauge axis, given in degrees
     * where 0 is north. Defaults to 0.
     *
     * @type {Number}
     * @sample {highcharts} highcharts/demo/gauge-vu-meter/
     *         VU-meter with custom start and end angle
     * @since 2.3.0
     * @product highcharts
     */
    startAngle: 0
  },

  /**
   * An array of background items for the pane.
   * @type {Array<Object>}
   * @sample {highcharts} highcharts/demo/gauge-speedometer/
   *         Speedometer gauge with multiple backgrounds
   * @optionparent pane.background
   */
  defaultBackgroundOptions: {
    /**
     * The class name for this background.
     *
     * @type {String}
     * @sample {highcharts} highcharts/css/pane/ Panes styled by CSS
     * @sample {highstock} highcharts/css/pane/ Panes styled by CSS
     * @sample {highmaps} highcharts/css/pane/ Panes styled by CSS
     * @default highcharts-pane
     * @since 5.0.0
     * @apioption pane.background.className
     */

    /**
     * The shape of the pane background. When `solid`, the background
     * is circular. When `arc`, the background extends only from the min
     * to the max of the value axis.
     *
     * @validvalue ["solid", "arc"]
     * @type {String}
     * @default solid
     * @since 2.3.0
     * @product highcharts
     */
    shape: 'circle',

    /** @ignore-option */
    from: -Number.MAX_VALUE,
    // corrected to axis min

    /**
     * The inner radius of the pane background. Can be either numeric
     * (pixels) or a percentage string.
     *
     * @type {Number|String}
     * @default 0
     * @since 2.3.0
     * @product highcharts
     */
    innerRadius: 0,

    /** @ignore-option */
    to: Number.MAX_VALUE,
    // corrected to axis max

    /**
     * The outer radius of the circular pane background. Can be either
     * numeric (pixels) or a percentage string.
     *
     * @type {Number|String}
     * @default 105%
     * @since 2.3.0
     * @product highcharts
     */
    outerRadius: '105%'
  },

  /**
   * Gets the center for the pane and its axis.
   */
  updateCenter: function (axis) {
    this.center = (axis || this.axis || {}).center = CenteredSeriesMixin$1.getCenter.call(this);
  },

  /**
   * Destroy the pane item
   * /
  destroy: function () {
      H.erase(this.chart.pane, this);
      each(this.background, function (background) {
          background.destroy();
      });
      this.background.length = 0;
      this.group = this.group.destroy();
  },
  */

  /**
   * Update the pane item with new options
   * @param  {Object} options New pane options
   */
  update: function (options, redraw) {
    merge$o(true, this.options, options);
    this.setOptions(this.options);
    this.render();
    each$B(this.chart.axes, function (axis) {
      if (axis.pane === this) {
        axis.pane = null;
        axis.update({}, redraw);
      }
    }, this);
  }
});
Highcharts.Pane = Pane;

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$n = Highcharts.addEvent,
    Axis$d = Highcharts.Axis,
    each$C = Highcharts.each,
    extend$n = Highcharts.extend,
    map$8 = Highcharts.map,
    merge$p = Highcharts.merge,
    noop$8 = Highcharts.noop,
    pick$y = Highcharts.pick,
    pInt$5 = Highcharts.pInt,
    Tick$1 = Highcharts.Tick,
    wrap$b = Highcharts.wrap,
    correctFloat$5 = Highcharts.correctFloat,
    hiddenAxisMixin,
    // @todo Extract this to a new file
radialAxisMixin,
    // @todo Extract this to a new file
axisProto = Axis$d.prototype,
    tickProto = Tick$1.prototype;

if (!Highcharts.radialAxisExtended) {
  Highcharts.radialAxisExtended = true;
  /**
   * Augmented methods for the x axis in order to hide it completely, used for
   * the X axis in gauges
   */

  hiddenAxisMixin = {
    getOffset: noop$8,
    redraw: function () {
      this.isDirty = false; // prevent setting Y axis dirty
    },
    render: function () {
      this.isDirty = false; // prevent setting Y axis dirty
    },
    setScale: noop$8,
    setCategories: noop$8,
    setTitle: noop$8
  };
  /**
   * Augmented methods for the value axis
   */

  radialAxisMixin = {
    /**
     * The default options extend defaultYAxisOptions
     */
    defaultRadialGaugeOptions: {
      labels: {
        align: 'center',
        x: 0,
        y: null // auto

      },
      minorGridLineWidth: 0,
      minorTickInterval: 'auto',
      minorTickLength: 10,
      minorTickPosition: 'inside',
      minorTickWidth: 1,
      tickLength: 10,
      tickPosition: 'inside',
      tickWidth: 2,
      title: {
        rotation: 0
      },
      zIndex: 2 // behind dials, points in the series group

    },
    // Circular axis around the perimeter of a polar chart
    defaultRadialXOptions: {
      gridLineWidth: 1,
      // spokes
      labels: {
        align: null,
        // auto
        distance: 15,
        x: 0,
        y: null,
        // auto
        style: {
          textOverflow: 'none' // wrap lines by default (#7248)

        }
      },
      maxPadding: 0,
      minPadding: 0,
      showLastLabel: false,
      tickLength: 0
    },
    // Radial axis, like a spoke in a polar chart
    defaultRadialYOptions: {
      gridLineInterpolation: 'circle',
      labels: {
        align: 'right',
        x: -3,
        y: -2
      },
      showLastLabel: false,
      title: {
        x: 4,
        text: null,
        rotation: 90
      }
    },

    /**
     * Merge and set options
     */
    setOptions: function (userOptions) {
      var options = this.options = merge$p(this.defaultOptions, this.defaultRadialOptions, userOptions); // Make sure the plotBands array is instanciated for each Axis
      // (#2649)

      if (!options.plotBands) {
        options.plotBands = [];
      }

      Highcharts.fireEvent(this, 'afterSetOptions');
    },

    /**
     * Wrap the getOffset method to return zero offset for title or labels
     * in a radial axis
     */
    getOffset: function () {
      // Call the Axis prototype method (the method we're in now is on the
      // instance)
      axisProto.getOffset.call(this); // Title or label offsets are not counted

      this.chart.axisOffset[this.side] = 0;
    },

    /**
     * Get the path for the axis line. This method is also referenced in the
     * getPlotLinePath method.
     */
    getLinePath: function (lineWidth, radius) {
      var center = this.center,
          end,
          chart = this.chart,
          r = pick$y(radius, center[2] / 2 - this.offset),
          path;

      if (this.isCircular || radius !== undefined) {
        path = this.chart.renderer.symbols.arc(this.left + center[0], this.top + center[1], r, r, {
          start: this.startAngleRad,
          end: this.endAngleRad,
          open: true,
          innerR: 0
        }); // Bounds used to position the plotLine label next to the line
        // (#7117)

        path.xBounds = [this.left + center[0]];
        path.yBounds = [this.top + center[1] - r];
      } else {
        end = this.postTranslate(this.angleRad, r);
        path = ['M', center[0] + chart.plotLeft, center[1] + chart.plotTop, 'L', end.x, end.y];
      }

      return path;
    },

    /**
     * Override setAxisTranslation by setting the translation to the
     * difference in rotation. This allows the translate method to return
     * angle for any given value.
     */
    setAxisTranslation: function () {
      // Call uber method
      axisProto.setAxisTranslation.call(this); // Set transA and minPixelPadding

      if (this.center) {
        // it's not defined the first time
        if (this.isCircular) {
          this.transA = (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1);
        } else {
          this.transA = this.center[2] / 2 / (this.max - this.min || 1);
        }

        if (this.isXAxis) {
          this.minPixelPadding = this.transA * this.minPointOffset;
        } else {
          // This is a workaround for regression #2593, but categories
          // still don't position correctly.
          this.minPixelPadding = 0;
        }
      }
    },

    /**
     * In case of auto connect, add one closestPointRange to the max value
     * right before tickPositions are computed, so that ticks will extend
     * passed the real max.
     */
    beforeSetTickPositions: function () {
      // If autoConnect is true, polygonal grid lines are connected, and
      // one closestPointRange is added to the X axis to prevent the last
      // point from overlapping the first.
      this.autoConnect = this.isCircular && pick$y(this.userMax, this.options.max) === undefined && correctFloat$5(this.endAngleRad - this.startAngleRad) === correctFloat$5(2 * Math.PI);

      if (this.autoConnect) {
        this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0; // #1197, #2260
      }
    },

    /**
     * Override the setAxisSize method to use the arc's circumference as
     * length. This allows tickPixelInterval to apply to pixel lengths along
     * the perimeter
     */
    setAxisSize: function () {
      axisProto.setAxisSize.call(this);

      if (this.isRadial) {
        // Set the center array
        this.pane.updateCenter(this); // The sector is used in Axis.translate to compute the
        // translation of reversed axis points (#2570)

        if (this.isCircular) {
          this.sector = this.endAngleRad - this.startAngleRad;
        } // Axis len is used to lay out the ticks


        this.len = this.width = this.height = this.center[2] * pick$y(this.sector, 1) / 2;
      }
    },

    /**
     * Returns the x, y coordinate of a point given by a value and a pixel
     * distance from center
     */
    getPosition: function (value, length) {
      return this.postTranslate(this.isCircular ? this.translate(value) : this.angleRad, // #2848
      pick$y(this.isCircular ? length : this.translate(value), this.center[2] / 2) - this.offset);
    },

    /**
     * Translate from intermediate plotX (angle), plotY (axis.len - radius)
     * to final chart coordinates.
     */
    postTranslate: function (angle, radius) {
      var chart = this.chart,
          center = this.center;
      angle = this.startAngleRad + angle;
      return {
        x: chart.plotLeft + center[0] + Math.cos(angle) * radius,
        y: chart.plotTop + center[1] + Math.sin(angle) * radius
      };
    },

    /**
     * Find the path for plot bands along the radial axis
     */
    getPlotBandPath: function (from, to, options) {
      var center = this.center,
          startAngleRad = this.startAngleRad,
          fullRadius = center[2] / 2,
          radii = [pick$y(options.outerRadius, '100%'), options.innerRadius, pick$y(options.thickness, 10)],
          offset = Math.min(this.offset, 0),
          percentRegex = /%$/,
          start,
          end,
          open,
          isCircular = this.isCircular,
          // X axis in a polar chart
      ret; // Polygonal plot bands

      if (this.options.gridLineInterpolation === 'polygon') {
        ret = this.getPlotLinePath(from).concat(this.getPlotLinePath(to, true)); // Circular grid bands
      } else {
        // Keep within bounds
        from = Math.max(from, this.min);
        to = Math.min(to, this.max); // Plot bands on Y axis (radial axis) - inner and outer radius
        // depend on to and from

        if (!isCircular) {
          radii[0] = this.translate(from);
          radii[1] = this.translate(to);
        } // Convert percentages to pixel values


        radii = map$8(radii, function (radius) {
          if (percentRegex.test(radius)) {
            radius = pInt$5(radius, 10) * fullRadius / 100;
          }

          return radius;
        }); // Handle full circle

        if (options.shape === 'circle' || !isCircular) {
          start = -Math.PI / 2;
          end = Math.PI * 1.5;
          open = true;
        } else {
          start = startAngleRad + this.translate(from);
          end = startAngleRad + this.translate(to);
        }

        radii[0] -= offset; // #5283

        radii[2] -= offset; // #5283

        ret = this.chart.renderer.symbols.arc(this.left + center[0], this.top + center[1], radii[0], radii[0], {
          // Math is for reversed yAxis (#3606)
          start: Math.min(start, end),
          end: Math.max(start, end),
          innerR: pick$y(radii[1], radii[0] - radii[2]),
          open: open
        });
      }

      return ret;
    },

    /**
     * Find the path for plot lines perpendicular to the radial axis.
     */
    getPlotLinePath: function (value, reverse) {
      var axis = this,
          center = axis.center,
          chart = axis.chart,
          end = axis.getPosition(value),
          xAxis,
          xy,
          tickPositions,
          ret; // Spokes

      if (axis.isCircular) {
        ret = ['M', center[0] + chart.plotLeft, center[1] + chart.plotTop, 'L', end.x, end.y]; // Concentric circles
      } else if (axis.options.gridLineInterpolation === 'circle') {
        value = axis.translate(value);

        if (value) {
          // a value of 0 is in the center
          ret = axis.getLinePath(0, value);
        } // Concentric polygons

      } else {
        // Find the X axis in the same pane
        each$C(chart.xAxis, function (a) {
          if (a.pane === axis.pane) {
            xAxis = a;
          }
        });
        ret = [];
        value = axis.translate(value);
        tickPositions = xAxis.tickPositions;

        if (xAxis.autoConnect) {
          tickPositions = tickPositions.concat([tickPositions[0]]);
        } // Reverse the positions for concatenation of polygonal plot
        // bands


        if (reverse) {
          tickPositions = [].concat(tickPositions).reverse();
        }

        each$C(tickPositions, function (pos, i) {
          xy = xAxis.getPosition(pos, value);
          ret.push(i ? 'L' : 'M', xy.x, xy.y);
        });
      }

      return ret;
    },

    /**
     * Find the position for the axis title, by default inside the gauge
     */
    getTitlePosition: function () {
      var center = this.center,
          chart = this.chart,
          titleOptions = this.options.title;
      return {
        x: chart.plotLeft + center[0] + (titleOptions.x || 0),
        y: chart.plotTop + center[1] - {
          high: 0.5,
          middle: 0.25,
          low: 0
        }[titleOptions.align] * center[2] + (titleOptions.y || 0)
      };
    }
  };
  /**
   * Actions before axis init.
   */

  addEvent$n(Axis$d, 'init', function (e) {
    var chart = this.chart,
        angular = chart.angular,
        polar = chart.polar,
        isX = this.isXAxis,
        isHidden = angular && isX,
        isCircular,
        chartOptions = chart.options,
        paneIndex = e.userOptions.pane || 0,
        pane = this.pane = chart.pane && chart.pane[paneIndex]; // Before prototype.init

    if (angular) {
      extend$n(this, isHidden ? hiddenAxisMixin : radialAxisMixin);
      isCircular = !isX;

      if (isCircular) {
        this.defaultRadialOptions = this.defaultRadialGaugeOptions;
      }
    } else if (polar) {
      extend$n(this, radialAxisMixin);
      isCircular = isX;
      this.defaultRadialOptions = isX ? this.defaultRadialXOptions : merge$p(this.defaultYAxisOptions, this.defaultRadialYOptions);
    } // Disable certain features on angular and polar axes


    if (angular || polar) {
      this.isRadial = true;
      chart.inverted = false;
      chartOptions.chart.zoomType = null;
    } else {
      this.isRadial = false;
    } // A pointer back to this axis to borrow geometry


    if (pane && isCircular) {
      pane.axis = this;
    }

    this.isCircular = isCircular;
  });
  addEvent$n(Axis$d, 'afterInit', function () {
    var chart = this.chart,
        options = this.options,
        isHidden = chart.angular && this.isXAxis,
        pane = this.pane,
        paneOptions = pane && pane.options;

    if (!isHidden && pane && (chart.angular || chart.polar)) {
      // Start and end angle options are
      // given in degrees relative to top, while internal computations are
      // in radians relative to right (like SVG).
      // Y axis in polar charts
      this.angleRad = (options.angle || 0) * Math.PI / 180; // Gauges

      this.startAngleRad = (paneOptions.startAngle - 90) * Math.PI / 180;
      this.endAngleRad = (pick$y(paneOptions.endAngle, paneOptions.startAngle + 360) - 90) * Math.PI / 180; // Gauges

      this.offset = options.offset || 0;
    }
  });
  /**
   * Wrap auto label align to avoid setting axis-wide rotation on radial axes
   * (#4920)
   * @param   {Function} proceed
   * @returns {String} Alignment
   */

  wrap$b(axisProto, 'autoLabelAlign', function (proceed) {
    if (!this.isRadial) {
      return proceed.apply(this, [].slice.call(arguments, 1));
    } // else return undefined

  });
  /**
   * Add special cases within the Tick class' methods for radial axes.
   */

  addEvent$n(Tick$1, 'afterGetPosition', function (e) {
    if (this.axis.getPosition) {
      extend$n(e.pos, this.axis.getPosition(this.pos));
    }
  });
  /**
   * Find the center position of the label based on the distance option.
   */

  addEvent$n(Tick$1, 'afterGetLabelPosition', function (e) {
    var axis = this.axis,
        label = this.label,
        labelOptions = axis.options.labels,
        optionsY = labelOptions.y,
        ret,
        centerSlot = 20,
        // 20 degrees to each side at the top and bottom
    align = labelOptions.align,
        angle = (axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360;

    if (axis.isRadial) {
      // Both X and Y axes in a polar chart
      ret = axis.getPosition(this.pos, axis.center[2] / 2 + pick$y(labelOptions.distance, -25)); // Automatically rotated

      if (labelOptions.rotation === 'auto') {
        label.attr({
          rotation: angle
        }); // Vertically centered
      } else if (optionsY === null) {
        optionsY = axis.chart.renderer.fontMetrics(label.styles && label.styles.fontSize).b - label.getBBox().height / 2;
      } // Automatic alignment


      if (align === null) {
        if (axis.isCircular) {
          // Y axis
          if (this.label.getBBox().width > axis.len * axis.tickInterval / (axis.max - axis.min)) {
            // #3506
            centerSlot = 0;
          }

          if (angle > centerSlot && angle < 180 - centerSlot) {
            align = 'left'; // right hemisphere
          } else if (angle > 180 + centerSlot && angle < 360 - centerSlot) {
            align = 'right'; // left hemisphere
          } else {
            align = 'center'; // top or bottom
          }
        } else {
          align = 'center';
        }

        label.attr({
          align: align
        });
      }

      e.pos.x = ret.x + labelOptions.x;
      e.pos.y = ret.y + optionsY;
    }
  });
  /**
   * Wrap the getMarkPath function to return the path of the radial marker
   */

  wrap$b(tickProto, 'getMarkPath', function (proceed, x, y, tickLength, tickWidth, horiz, renderer) {
    var axis = this.axis,
        endPoint,
        ret;

    if (axis.isRadial) {
      endPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);
      ret = ['M', x, y, 'L', endPoint.x, endPoint.y];
    } else {
      ret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer);
    }

    return ret;
  });
}

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var each$D = Highcharts.each,
    noop$9 = Highcharts.noop,
    pick$z = Highcharts.pick,
    defined$l = Highcharts.defined,
    Series$e = Highcharts.Series,
    seriesType$a = Highcharts.seriesType,
    seriesTypes$9 = Highcharts.seriesTypes,
    seriesProto$2 = Series$e.prototype,
    pointProto = Highcharts.Point.prototype;
/**
 * The area range series is a carteseian series with higher and lower values
 * for each point along an X axis, where the area between the values is shaded.
 * Requires `highcharts-more.js`.
 *
 * @extends      plotOptions.area
 * @product      highcharts highstock
 * @sample       {highcharts} highcharts/demo/arearange/
 *               Area range chart
 * @sample       {highstock} stock/demo/arearange/
 *               Area range chart
 * @excluding    stack,stacking
 * @optionparent plotOptions.arearange
 */

seriesType$a('arearange', 'area', {
  threshold: null,
  tooltip: {
    pointFormat: '<span class="highcharts-color-{series.colorIndex}">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
  },

  /**
   * Whether the whole area or just the line should respond to mouseover
   * tooltips and other mouse or touch events.
   *
   * @since   2.3.0
   * @product highcharts highstock
   */
  trackByArea: true,

  /**
   * Extended data labels for range series types. Range series data labels
   * have no `x` and `y` options. Instead, they have `xLow`, `xHigh`,
   * `yLow` and `yHigh` options to allow the higher and lower data label
   * sets individually.
   *
   * @type      {Object}
   * @extends   plotOptions.series.dataLabels
   * @excluding x,y
   * @since     2.3.0
   * @product   highcharts highstock
   */
  dataLabels: {
    align: null,
    verticalAlign: null,

    /**
     * X offset of the lower data labels relative to the point value.
     *
     * @sample  {highcharts} highcharts/plotoptions/arearange-datalabels/
     *          Data labels on range series
     * @sample  {highstock} highcharts/plotoptions/arearange-datalabels/
     *          Data labels on range series
     * @since   2.3.0
     * @product highcharts highstock
     */
    xLow: 0,

    /**
     * X offset of the higher data labels relative to the point value.
     *
     * @sample  {highcharts|highstock}
     *          highcharts/plotoptions/arearange-datalabels/
     *          Data labels on range series
     * @since   2.3.0
     * @product highcharts highstock
     */
    xHigh: 0,

    /**
     * Y offset of the lower data labels relative to the point value.
     *
     * @sample  {highcharts|highstock}
     *          highcharts/plotoptions/arearange-datalabels/
     *          Data labels on range series
     * @default 16
     * @since   2.3.0
     * @product highcharts highstock
     */
    yLow: 0,

    /**
     * Y offset of the higher data labels relative to the point value.
     *
     * @sample  {highcharts|highstock}
     *          highcharts/plotoptions/arearange-datalabels/
     *          Data labels on range series
     * @default -6
     * @since   2.3.0
     * @product highcharts highstock
     */
    yHigh: 0 // Prototype members

  }
}, {
  pointArrayMap: ['low', 'high'],
  dataLabelCollections: ['dataLabel', 'dataLabelUpper'],
  toYData: function (point) {
    return [point.low, point.high];
  },
  pointValKey: 'low',
  deferTranslatePolar: true,

  /**
   * Translate a point's plotHigh from the internal angle and radius
   * measures to true plotHigh coordinates. This is an addition of the
   * toXY method found in Polar.js, because it runs too early for
   * arearanges to be considered (#3419).
   */
  highToXY: function (point) {
    // Find the polar plotX and plotY
    var chart = this.chart,
        xy = this.xAxis.postTranslate(point.rectPlotX, this.yAxis.len - point.plotHigh);
    point.plotHighX = xy.x - chart.plotLeft;
    point.plotHigh = xy.y - chart.plotTop;
    point.plotLowX = point.plotX;
  },

  /**
   * Translate data points from raw values x and y to plotX and plotY
   */
  translate: function () {
    var series = this,
        yAxis = series.yAxis,
        hasModifyValue = !!series.modifyValue;
    seriesTypes$9.area.prototype.translate.apply(series); // Set plotLow and plotHigh

    each$D(series.points, function (point) {
      var low = point.low,
          high = point.high,
          plotY = point.plotY;

      if (high === null || low === null) {
        point.isNull = true;
        point.plotY = null;
      } else {
        point.plotLow = plotY;
        point.plotHigh = yAxis.translate(hasModifyValue ? series.modifyValue(high, point) : high, 0, 1, 0, 1);

        if (hasModifyValue) {
          point.yBottom = point.plotHigh;
        }
      }
    }); // Postprocess plotHigh

    if (this.chart.polar) {
      each$D(this.points, function (point) {
        series.highToXY(point);
        point.tooltipPos = [(point.plotHighX + point.plotLowX) / 2, (point.plotHigh + point.plotLow) / 2];
      });
    }
  },

  /**
   * Extend the line series' getSegmentPath method by applying the segment
   * path to both lower and higher values of the range
   */
  getGraphPath: function (points) {
    var highPoints = [],
        highAreaPoints = [],
        i,
        getGraphPath = seriesTypes$9.area.prototype.getGraphPath,
        point,
        pointShim,
        linePath,
        lowerPath,
        options = this.options,
        connectEnds = this.chart.polar && options.connectEnds !== false,
        connectNulls = options.connectNulls,
        step = options.step,
        higherPath,
        higherAreaPath;
    points = points || this.points;
    i = points.length;
    /**
     * Create the top line and the top part of the area fill. The area
     * fill compensates for null points by drawing down to the lower graph,
     * moving across the null gap and starting again at the lower graph.
     */

    i = points.length;

    while (i--) {
      point = points[i];

      if (!point.isNull && !connectEnds && !connectNulls && (!points[i + 1] || points[i + 1].isNull)) {
        highAreaPoints.push({
          plotX: point.plotX,
          plotY: point.plotY,
          doCurve: false // #5186, gaps in areasplinerange fill

        });
      }

      pointShim = {
        polarPlotY: point.polarPlotY,
        rectPlotX: point.rectPlotX,
        yBottom: point.yBottom,
        // plotHighX is for polar charts
        plotX: pick$z(point.plotHighX, point.plotX),
        plotY: point.plotHigh,
        isNull: point.isNull
      };
      highAreaPoints.push(pointShim);
      highPoints.push(pointShim);

      if (!point.isNull && !connectEnds && !connectNulls && (!points[i - 1] || points[i - 1].isNull)) {
        highAreaPoints.push({
          plotX: point.plotX,
          plotY: point.plotY,
          doCurve: false // #5186, gaps in areasplinerange fill

        });
      }
    } // Get the paths


    lowerPath = getGraphPath.call(this, points);

    if (step) {
      if (step === true) {
        step = 'left';
      }

      options.step = {
        left: 'right',
        center: 'center',
        right: 'left'
      }[step]; // swap for reading in getGraphPath
    }

    higherPath = getGraphPath.call(this, highPoints);
    higherAreaPath = getGraphPath.call(this, highAreaPoints);
    options.step = step; // Create a line on both top and bottom of the range

    linePath = [].concat(lowerPath, higherPath); // For the area path, we need to change the 'move' statement
    // into 'lineTo' or 'curveTo'

    if (!this.chart.polar && higherAreaPath[0] === 'M') {
      higherAreaPath[0] = 'L'; // this probably doesn't work for spline
    }

    this.graphPath = linePath;
    this.areaPath = lowerPath.concat(higherAreaPath); // Prepare for sideways animation

    linePath.isArea = true;
    linePath.xMap = lowerPath.xMap;
    this.areaPath.xMap = lowerPath.xMap;
    return linePath;
  },

  /**
   * Extend the basic drawDataLabels method by running it for both lower
   * and higher values.
   */
  drawDataLabels: function () {
    var data = this.data,
        length = data.length,
        i,
        originalDataLabels = [],
        dataLabelOptions = this.options.dataLabels,
        align = dataLabelOptions.align,
        verticalAlign = dataLabelOptions.verticalAlign,
        inside = dataLabelOptions.inside,
        point,
        up,
        inverted = this.chart.inverted;

    if (dataLabelOptions.enabled || this._hasPointLabels) {
      // Step 1: set preliminary values for plotY and dataLabel
      // and draw the upper labels
      i = length;

      while (i--) {
        point = data[i];

        if (point) {
          up = inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow; // Set preliminary values

          point.y = point.high;
          point._plotY = point.plotY;
          point.plotY = point.plotHigh; // Store original data labels and set preliminary label
          // objects to be picked up in the uber method

          originalDataLabels[i] = point.dataLabel;
          point.dataLabel = point.dataLabelUpper; // Set the default offset

          point.below = up;

          if (inverted) {
            if (!align) {
              dataLabelOptions.align = up ? 'right' : 'left';
            }
          } else {
            if (!verticalAlign) {
              dataLabelOptions.verticalAlign = up ? 'top' : 'bottom';
            }
          }

          dataLabelOptions.x = dataLabelOptions.xHigh;
          dataLabelOptions.y = dataLabelOptions.yHigh;
        }
      }

      if (seriesProto$2.drawDataLabels) {
        seriesProto$2.drawDataLabels.apply(this, arguments); // #1209
      } // Step 2: reorganize and handle data labels for the lower values


      i = length;

      while (i--) {
        point = data[i];

        if (point) {
          up = inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow; // Move the generated labels from step 1, and reassign
          // the original data labels

          point.dataLabelUpper = point.dataLabel;
          point.dataLabel = originalDataLabels[i]; // Reset values

          point.y = point.low;
          point.plotY = point._plotY; // Set the default offset

          point.below = !up;

          if (inverted) {
            if (!align) {
              dataLabelOptions.align = up ? 'left' : 'right';
            }
          } else {
            if (!verticalAlign) {
              dataLabelOptions.verticalAlign = up ? 'bottom' : 'top';
            }
          }

          dataLabelOptions.x = dataLabelOptions.xLow;
          dataLabelOptions.y = dataLabelOptions.yLow;
        }
      }

      if (seriesProto$2.drawDataLabels) {
        seriesProto$2.drawDataLabels.apply(this, arguments);
      }
    }

    dataLabelOptions.align = align;
    dataLabelOptions.verticalAlign = verticalAlign;
  },
  alignDataLabel: function () {
    seriesTypes$9.column.prototype.alignDataLabel.apply(this, arguments);
  },
  drawPoints: function () {
    var series = this,
        pointLength = series.points.length,
        point,
        i; // Draw bottom points

    seriesProto$2.drawPoints.apply(series, arguments); // Prepare drawing top points

    i = 0;

    while (i < pointLength) {
      point = series.points[i]; // Save original props to be overridden by temporary props for top
      // points

      point.origProps = {
        plotY: point.plotY,
        plotX: point.plotX,
        isInside: point.isInside,
        negative: point.negative,
        zone: point.zone,
        y: point.y
      };
      point.lowerGraphic = point.graphic;
      point.graphic = point.upperGraphic;
      point.plotY = point.plotHigh;

      if (defined$l(point.plotHighX)) {
        point.plotX = point.plotHighX;
      }

      point.y = point.high;
      point.negative = point.high < (series.options.threshold || 0);
      point.zone = series.zones.length && point.getZone();

      if (!series.chart.polar) {
        point.isInside = point.isTopInside = point.plotY !== undefined && point.plotY >= 0 && point.plotY <= series.yAxis.len && // #3519
        point.plotX >= 0 && point.plotX <= series.xAxis.len;
      }

      i++;
    } // Draw top points


    seriesProto$2.drawPoints.apply(series, arguments); // Reset top points preliminary modifications

    i = 0;

    while (i < pointLength) {
      point = series.points[i];
      point.upperGraphic = point.graphic;
      point.graphic = point.lowerGraphic;
      Highcharts.extend(point, point.origProps);
      delete point.origProps;
      i++;
    }
  },
  setStackedPoints: noop$9
}, {
  setState: function () {
    var prevState = this.state,
        series = this.series,
        isPolar = series.chart.polar;

    if (!defined$l(this.plotHigh)) {
      // Boost doesn't calculate plotHigh
      this.plotHigh = series.yAxis.toPixels(this.high, true);
    }

    if (!defined$l(this.plotLow)) {
      // Boost doesn't calculate plotLow
      this.plotLow = this.plotY = series.yAxis.toPixels(this.low, true);
    }

    if (series.stateMarkerGraphic) {
      series.lowerStateMarkerGraphic = series.stateMarkerGraphic;
      series.stateMarkerGraphic = series.upperStateMarkerGraphic;
    } // Change state also for the top marker


    this.graphic = this.upperGraphic;
    this.plotY = this.plotHigh;

    if (isPolar) {
      this.plotX = this.plotHighX;
    } // Top state:


    pointProto.setState.apply(this, arguments);
    this.state = prevState; // Now restore defaults

    this.plotY = this.plotLow;
    this.graphic = this.lowerGraphic;

    if (isPolar) {
      this.plotX = this.plotLowX;
    }

    if (series.stateMarkerGraphic) {
      series.upperStateMarkerGraphic = series.stateMarkerGraphic;
      series.stateMarkerGraphic = series.lowerStateMarkerGraphic; // Lower marker is stored at stateMarkerGraphic
      // to avoid reference duplication (#7021)

      series.lowerStateMarkerGraphic = undefined;
    }

    pointProto.setState.apply(this, arguments);
  },
  haloPath: function () {
    var isPolar = this.series.chart.polar,
        path = []; // Bottom halo

    this.plotY = this.plotLow;

    if (isPolar) {
      this.plotX = this.plotLowX;
    }

    if (this.isInside) {
      path = pointProto.haloPath.apply(this, arguments);
    } // Top halo


    this.plotY = this.plotHigh;

    if (isPolar) {
      this.plotX = this.plotHighX;
    }

    if (this.isTopInside) {
      path = path.concat(pointProto.haloPath.apply(this, arguments));
    }

    return path;
  },
  destroyElements: function () {
    var graphics = ['lowerGraphic', 'upperGraphic'];
    each$D(graphics, function (graphicName) {
      if (this[graphicName]) {
        this[graphicName] = this[graphicName].destroy();
      }
    }, this); // Clear graphic for states, removed in the above each:

    this.graphic = null;
    return pointProto.destroyElements.apply(this, arguments);
  }
});
/**
 * A `arearange` series. If the [type](#series.arearange.type) option
 * is not specified, it is inherited from [chart.type](#chart.type).
 *
 *
 * @type      {Object}
 * @extends   series,plotOptions.arearange
 * @excluding dataParser,dataURL,stack,stacking
 * @product   highcharts highstock
 * @apioption series.arearange
 */

/**
 * An array of data points for the series. For the `arearange` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of arrays with 3 or 2 values. In this case, the values
 * correspond to `x,low,high`. If the first value is a string, it is
 * applied as the name of the point, and the `x` value is inferred.
 * The `x` value can also be omitted, in which case the inner arrays
 * should be of length 2\. Then the `x` value is automatically calculated,
 * either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options.
 *
 *  ```js
 *     data: [
 *         [0, 8, 3],
 *         [1, 1, 1],
 *         [2, 6, 8]
 *     ]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series'
 * [turboThreshold](#series.arearange.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         low: 9,
 *         high: 0,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         low: 3,
 *         high: 4,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Array>}
 * @extends   series.line.data
 * @excluding marker,y
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts highstock
 * @apioption series.arearange.data
 */

/**
 * The high or maximum value for each data point.
 *
 * @type      {Number}
 * @product   highcharts highstock
 * @apioption series.arearange.data.high
 */

/**
 * The low or minimum value for each data point.
 *
 * @type      {Number}
 * @product   highcharts highstock
 * @apioption series.arearange.data.low
 */

/**
* @excluding x,y
* @product   highcharts highstock
* @apioption series.arearange.dataLabels
*/

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var seriesType$b = Highcharts.seriesType,
    seriesTypes$a = Highcharts.seriesTypes;
/**
 * The area spline range is a cartesian series type with higher and
 * lower Y values along an X axis. The area inside the range is colored, and
 * the graph outlining the area is a smoothed spline. Requires
 * `highcharts-more.js`.
 *
 * @extends   plotOptions.arearange
 * @excluding step
 * @since     2.3.0
 * @sample    {highstock|highstock} stock/demo/areasplinerange/
 *            Area spline range
 * @product   highcharts highstock
 * @apioption plotOptions.areasplinerange
 */

seriesType$b('areasplinerange', 'arearange', null, {
  getPointSpline: seriesTypes$a.spline.prototype.getPointSpline
});
/**
 * A `areasplinerange` series. If the [type](#series.areasplinerange.type)
 * option is not specified, it is inherited from [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.areasplinerange
 * @excluding dataParser,dataURL,stack
 * @product   highcharts highstock
 * @apioption series.areasplinerange
 */

/**
 * An array of data points for the series. For the `areasplinerange`
 * series type, points can be given in the following ways:
 *
 * 1.  An array of arrays with 3 or 2 values. In this case, the values
 * correspond to `x,low,high`. If the first value is a string, it is
 * applied as the name of the point, and the `x` value is inferred.
 * The `x` value can also be omitted, in which case the inner arrays
 * should be of length 2\. Then the `x` value is automatically calculated,
 * either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options.
 *
 *  ```js
 *     data: [
 *         [0, 0, 5],
 *         [1, 9, 1],
 *         [2, 5, 2]
 *     ]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](
 * #series.areasplinerange.turboThreshold), this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         low: 5,
 *         high: 0,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         low: 4,
 *         high: 1,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Array>}
 * @extends   series.arearange.data
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts highstock
 * @apioption series.areasplinerange.data
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var defaultPlotOptions$5 = Highcharts.defaultPlotOptions,
    each$E = Highcharts.each,
    merge$q = Highcharts.merge,
    noop$a = Highcharts.noop,
    pick$A = Highcharts.pick,
    seriesType$c = Highcharts.seriesType,
    seriesTypes$b = Highcharts.seriesTypes;
var colProto = seriesTypes$b.column.prototype;
/**
 * The column range is a cartesian series type with higher and lower
 * Y values along an X axis. Requires `highcharts-more.js`. To display
 * horizontal bars, set [chart.inverted](#chart.inverted) to `true`.
 *
 * @type         {Object}
 * @extends      plotOptions.column
 * @excluding    negativeColor,stacking,softThreshold,threshold
 * @sample       {highcharts|highstock} highcharts/demo/columnrange/
 *               Inverted column range
 * @since        2.3.0
 * @product      highcharts highstock
 * @optionparent plotOptions.columnrange
 */

var columnRangeOptions = {
  /**
   * Extended data labels for range series types. Range series data labels
   * have no `x` and `y` options. Instead, they have `xLow`, `xHigh`,
   * `yLow` and `yHigh` options to allow the higher and lower data label
   * sets individually.
   *
   * @type      {Object}
   * @extends   plotOptions.arearange.dataLabels
   * @excluding x,y
   * @since     2.3.0
   * @product   highcharts highstock
   * @apioption plotOptions.columnrange.dataLabels
   */
  pointRange: null,

  /** @ignore-option */
  marker: null,
  states: {
    hover: {
      /** @ignore-option */
      halo: false
    }
  }
};
/**
 * The ColumnRangeSeries class
 */

seriesType$c('columnrange', 'arearange', merge$q(defaultPlotOptions$5.column, defaultPlotOptions$5.arearange, columnRangeOptions), {
  /**
   * Translate data points from raw values x and y to plotX and plotY
   */
  translate: function () {
    var series = this,
        yAxis = series.yAxis,
        xAxis = series.xAxis,
        startAngleRad = xAxis.startAngleRad,
        start,
        chart = series.chart,
        isRadial = series.xAxis.isRadial,
        safeDistance = Math.max(chart.chartWidth, chart.chartHeight) + 999,
        plotHigh; // Don't draw too far outside plot area (#6835)

    function safeBounds(pixelPos) {
      return Math.min(Math.max(-safeDistance, pixelPos), safeDistance);
    }

    colProto.translate.apply(series); // Set plotLow and plotHigh

    each$E(series.points, function (point) {
      var shapeArgs = point.shapeArgs,
          minPointLength = series.options.minPointLength,
          heightDifference,
          height,
          y;
      point.plotHigh = plotHigh = safeBounds(yAxis.translate(point.high, 0, 1, 0, 1));
      point.plotLow = safeBounds(point.plotY); // adjust shape

      y = plotHigh;
      height = pick$A(point.rectPlotY, point.plotY) - plotHigh; // Adjust for minPointLength

      if (Math.abs(height) < minPointLength) {
        heightDifference = minPointLength - height;
        height += heightDifference;
        y -= heightDifference / 2; // Adjust for negative ranges or reversed Y axis (#1457)
      } else if (height < 0) {
        height *= -1;
        y -= height;
      }

      if (isRadial) {
        start = point.barX + startAngleRad;
        point.shapeType = 'path';
        point.shapeArgs = {
          d: series.polarArc(y + height, y, start, start + point.pointWidth)
        };
      } else {
        shapeArgs.height = height;
        shapeArgs.y = y;
        point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - y - height / 2, xAxis.len + xAxis.pos - chart.plotTop - shapeArgs.x - shapeArgs.width / 2, height] : [xAxis.left - chart.plotLeft + shapeArgs.x + shapeArgs.width / 2, yAxis.pos - chart.plotTop + y + height / 2, height]; // don't inherit from column tooltip position - #3372
      }
    });
  },
  directTouch: true,
  trackerGroups: ['group', 'dataLabelsGroup'],
  drawGraph: noop$a,
  getSymbol: noop$a,
  crispCol: colProto.crispCol,
  drawPoints: colProto.drawPoints,
  drawTracker: colProto.drawTracker,
  getColumnMetrics: colProto.getColumnMetrics,
  pointAttribs: colProto.pointAttribs,
  // Overrides from modules that may be loaded after this module
  animate: function () {
    return colProto.animate.apply(this, arguments);
  },
  polarArc: function () {
    return colProto.polarArc.apply(this, arguments);
  },
  translate3dPoints: function () {
    return colProto.translate3dPoints.apply(this, arguments);
  },
  translate3dShapes: function () {
    return colProto.translate3dShapes.apply(this, arguments);
  }
}, {
  setState: colProto.pointClass.prototype.setState
});
/**
 * A `columnrange` series. If the [type](#series.columnrange.type)
 * option is not specified, it is inherited from
 * [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.columnrange
 * @excluding dataParser,dataURL,stack,stacking
 * @product   highcharts highstock
 * @apioption series.columnrange
 */

/**
 * An array of data points for the series. For the `columnrange` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of arrays with 3 or 2 values. In this case, the values
 * correspond to `x,low,high`. If the first value is a string, it is
 * applied as the name of the point, and the `x` value is inferred.
 * The `x` value can also be omitted, in which case the inner arrays
 * should be of length 2\. Then the `x` value is automatically calculated,
 * either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options.
 *
 *  ```js
 *     data: [
 *         [0, 4, 2],
 *         [1, 2, 1],
 *         [2, 9, 10]
 *     ]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](
 * #series.columnrange.turboThreshold), this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         low: 0,
 *         high: 4,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         low: 5,
 *         high: 3,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Array>}
 * @extends   series.arearange.data
 * @excluding marker
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts highstock
 * @apioption series.columnrange.data
 */

/**
 * @excluding halo,lineWidth,lineWidthPlus,marker
 * @product   highcharts highstock
 * @apioption series.columnrange.states.hover
 */

/**
 * @excluding halo,lineWidth,lineWidthPlus,marker
 * @product   highcharts highstock
 * @apioption series.columnrange.states.select
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var each$F = Highcharts.each,
    isNumber$f = Highcharts.isNumber,
    merge$r = Highcharts.merge,
    noop$b = Highcharts.noop,
    pick$B = Highcharts.pick,
    pInt$6 = Highcharts.pInt,
    Series$f = Highcharts.Series,
    seriesType$d = Highcharts.seriesType,
    TrackerMixin$2 = Highcharts.TrackerMixin;
/**
 * Gauges are circular plots displaying one or more values with a dial pointing
 * to values along the perimeter.
 *
 * @sample       highcharts/demo/gauge-speedometer/ Gauge chart
 * @extends      {plotOptions.line}
 * @excluding    animationLimit,boostThreshold,connectEnds,connectNulls,
 *               cropThreshold,dashStyle,findNearestPointBy,getExtremesFromAll,
 *               marker,negativeColor,pointPlacement,shadow,softThreshold,
 *               stacking,states,step,threshold,turboThreshold,xAxis,zoneAxis,
 *               zones
 * @product      highcharts
 * @optionparent plotOptions.gauge
 */

seriesType$d('gauge', 'line', {
  /**
   * When this option is `true`, the dial will wrap around the axes. For
   * instance, in a full-range gauge going from 0 to 360, a value of 400
   * will point to 40\. When `wrap` is `false`, the dial stops at 360.
   *
   * @type      {Boolean}
   * @see       [overshoot](#plotOptions.gauge.overshoot)
   * @default   true
   * @since     3.0
   * @product   highcharts
   * @apioption plotOptions.gauge.wrap
   */

  /**
   * Data labels for the gauge. For gauges, the data labels are enabled
   * by default and shown in a bordered box below the point.
   *
   * @type    {Object}
   * @extends plotOptions.series.dataLabels
   * @since   2.3.0
   * @product highcharts
   */
  dataLabels: {
    /**
     * Enable or disable the data labels.
     *
     * @since   2.3.0
     * @product highcharts highmaps
     */
    enabled: true,
    defer: false,

    /**
     * The y position offset of the label relative to the center of the
     * gauge.
     *
     * @since   2.3.0
     * @product highcharts highmaps
     */
    y: 15,

    /**
     * The border radius in pixels for the gauge's data label.
     *
     * @since   2.3.0
     * @product highcharts highmaps
     */
    borderRadius: 3,
    crop: false,

    /**
     * The vertical alignment of the data label.
     *
     * @product highcharts highmaps
     */
    verticalAlign: 'top',

    /**
     * The Z index of the data labels. A value of 2 display them behind
     * the dial.
     *
     * @since   2.1.5
     * @product highcharts highmaps
     */
    zIndex: 2
  },

  /**
   * Options for the dial or arrow pointer of the gauge.
   *
   * In styled mode, the dial is styled with the
   * `.highcharts-gauge-series .highcharts-dial` rule.
   *
   * @type    {Object}
   * @sample  {highcharts} highcharts/css/gauge/ Styled mode
   * @since   2.3.0
   * @product highcharts
   */
  dial: {},

  /**
   * The length of the dial's base part, relative to the total radius
   * or length of the dial.
   *
   * @type      {String}
   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/
   *            Dial options demonstrated
   * @default   70%
   * @since     2.3.0
   * @product   highcharts
   * @apioption plotOptions.gauge.dial.baseLength
   */

  /**
   * The pixel width of the base of the gauge dial. The base is the part
   * closest to the pivot, defined by baseLength.
   *
   * @type      {Number}
   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/
   *            Dial options demonstrated
   * @default   3
   * @since     2.3.0
   * @product   highcharts
   * @apioption plotOptions.gauge.dial.baseWidth
   */

  /**
   * The radius or length of the dial, in percentages relative to the
   * radius of the gauge itself.
   *
   * @type      {String}
   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/
   *            Dial options demonstrated
   * @default   80%
   * @since     2.3.0
   * @product   highcharts
   * @apioption plotOptions.gauge.dial.radius
   */

  /**
   * The length of the dial's rear end, the part that extends out on the
   * other side of the pivot. Relative to the dial's length.
   *
   * @type      {String}
   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/
   *            Dial options demonstrated
   * @default   10%
   * @since     2.3.0
   * @product   highcharts
   * @apioption plotOptions.gauge.dial.rearLength
   */

  /**
   * The width of the top of the dial, closest to the perimeter. The pivot
   * narrows in from the base to the top.
   *
   * @type      {Number}
   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/
   *            Dial options demonstrated
   * @default   1
   * @since     2.3.0
   * @product   highcharts
   * @apioption plotOptions.gauge.dial.topWidth
   */

  /**
   * Allow the dial to overshoot the end of the perimeter axis by this
   * many degrees. Say if the gauge axis goes from 0 to 60, a value of
   * 100, or 1000, will show 5 degrees beyond the end of the axis when this
   * option is set to 5.
   *
   * @type      {Number}
   * @see       [wrap](#plotOptions.gauge.wrap)
   * @sample    {highcharts} highcharts/plotoptions/gauge-overshoot/
   *            Allow 5 degrees overshoot
   * @default   0
   * @since     3.0.10
   * @product   highcharts
   * @apioption plotOptions.gauge.overshoot
   */

  /**
   * Options for the pivot or the center point of the gauge.
   *
   * In styled mode, the pivot is styled with the
   * `.highcharts-gauge-series .highcharts-pivot` rule.
   *
   * @type    {Object}
   * @sample  {highcharts} highcharts/css/gauge/ Styled mode
   * @since   2.3.0
   * @product highcharts
   */
  pivot: {},

  /**
   * The pixel radius of the pivot.
   *
   * @type      {Number}
   * @sample    {highcharts} highcharts/plotoptions/gauge-pivot/
   *            Pivot options demonstrated
   * @default   5
   * @since     2.3.0
   * @product   highcharts
   * @apioption plotOptions.gauge.pivot.radius
   */
  tooltip: {
    headerFormat: ''
  },

  /**
   * Whether to display this particular series or series type in the
   * legend. Defaults to false for gauge series.
   *
   * @since   2.3.0
   * @product highcharts
   */
  showInLegend: false // Prototype members

}, {
  // chart.angular will be set to true when a gauge series is present,
  // and this will be used on the axes
  angular: true,
  directTouch: true,
  // #5063
  drawGraph: noop$b,
  fixedBox: true,
  forceDL: true,
  noSharedTooltip: true,
  trackerGroups: ['group', 'dataLabelsGroup'],

  /**
   * Calculate paths etc
   */
  translate: function () {
    var series = this,
        yAxis = series.yAxis,
        options = series.options,
        center = yAxis.center;
    series.generatePoints();
    each$F(series.points, function (point) {
      var dialOptions = merge$r(options.dial, point.dial),
          radius = pInt$6(pick$B(dialOptions.radius, 80)) * center[2] / 200,
          baseLength = pInt$6(pick$B(dialOptions.baseLength, 70)) * radius / 100,
          rearLength = pInt$6(pick$B(dialOptions.rearLength, 10)) * radius / 100,
          baseWidth = dialOptions.baseWidth || 3,
          topWidth = dialOptions.topWidth || 1,
          overshoot = options.overshoot,
          rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true); // Handle the wrap and overshoot options

      if (isNumber$f(overshoot)) {
        overshoot = overshoot / 180 * Math.PI;
        rotation = Math.max(yAxis.startAngleRad - overshoot, Math.min(yAxis.endAngleRad + overshoot, rotation));
      } else if (options.wrap === false) {
        rotation = Math.max(yAxis.startAngleRad, Math.min(yAxis.endAngleRad, rotation));
      }

      rotation = rotation * 180 / Math.PI;
      point.shapeType = 'path';
      point.shapeArgs = {
        d: dialOptions.path || ['M', -rearLength, -baseWidth / 2, 'L', baseLength, -baseWidth / 2, radius, -topWidth / 2, radius, topWidth / 2, baseLength, baseWidth / 2, -rearLength, baseWidth / 2, 'z'],
        translateX: center[0],
        translateY: center[1],
        rotation: rotation
      }; // Positions for data label

      point.plotX = center[0];
      point.plotY = center[1];
    });
  },

  /**
   * Draw the points where each point is one needle
   */
  drawPoints: function () {
    var series = this,
        center = series.yAxis.center,
        pivot = series.pivot,
        options = series.options,
        pivotOptions = options.pivot,
        renderer = series.chart.renderer;
    each$F(series.points, function (point) {
      var graphic = point.graphic,
          shapeArgs = point.shapeArgs,
          d = shapeArgs.d,
          dialOptions = merge$r(options.dial, point.dial); // #1233

      if (graphic) {
        graphic.animate(shapeArgs);
        shapeArgs.d = d; // animate alters it
      } else {
        point.graphic = renderer[point.shapeType](shapeArgs).attr({
          // required by VML when animation is false
          rotation: shapeArgs.rotation,
          zIndex: 1
        }).addClass('highcharts-dial').add(series.group);
      }
    }); // Add or move the pivot

    if (pivot) {
      pivot.animate({
        // #1235
        translateX: center[0],
        translateY: center[1]
      });
    } else {
      series.pivot = renderer.circle(0, 0, pick$B(pivotOptions.radius, 5)).attr({
        zIndex: 2
      }).addClass('highcharts-pivot').translate(center[0], center[1]).add(series.group);
    }
  },

  /**
   * Animate the arrow up from startAngle
   */
  animate: function (init) {
    var series = this;

    if (!init) {
      each$F(series.points, function (point) {
        var graphic = point.graphic;

        if (graphic) {
          // start value
          graphic.attr({
            rotation: series.yAxis.startAngleRad * 180 / Math.PI
          }); // animate

          graphic.animate({
            rotation: point.shapeArgs.rotation
          }, series.options.animation);
        }
      }); // delete this function to allow it only once

      series.animate = null;
    }
  },
  render: function () {
    this.group = this.plotGroup('group', 'series', this.visible ? 'visible' : 'hidden', this.options.zIndex, this.chart.seriesGroup);
    Series$f.prototype.render.call(this);
    this.group.clip(this.chart.clipRect);
  },

  /**
   * Extend the basic setData method by running processData and generatePoints
   * immediately, in order to access the points from the legend.
   */
  setData: function (data, redraw) {
    Series$f.prototype.setData.call(this, data, false);
    this.processData();
    this.generatePoints();

    if (pick$B(redraw, true)) {
      this.chart.redraw();
    }
  },

  /**
   * If the tracking module is loaded, add the point tracker
   */
  drawTracker: TrackerMixin$2 && TrackerMixin$2.drawTrackerPoint // Point members

}, {
  /**
   * Don't do any hover colors or anything
   */
  setState: function (state) {
    this.state = state;
  }
});
/**
 * A `gauge` series. If the [type](#series.gauge.type) option is not
 * specified, it is inherited from [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.gauge
 * @excluding animationLimit,boostThreshold,connectEnds,connectNulls,
 *            cropThreshold,dashStyle,dataParser,dataURL,findNearestPointBy,
 *            getExtremesFromAll,marker,negativeColor,pointPlacement,shadow,
 *            softThreshold,stack,stacking,states,step,threshold,
 *            turboThreshold,zoneAxis,zones
 * @product   highcharts
 * @apioption series.gauge
 */

/**
 * An array of data points for the series. For the `gauge` series type,
 * points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.gauge.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *     y: 6,
 *     name: "Point2",
 *     color: "#00FF00"
 * }, {
 *     y: 8,
 *     name: "Point1",
 *     color: "#FF00FF"
 * }]</pre>
 *
 * The typical gauge only contains a single data value.
 *
 * @type      {Array<Object|Number>}
 * @extends   series.line.data
 * @excluding drilldown,marker,x
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts
 * @apioption series.gauge.data
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var each$G = Highcharts.each,
    noop$c = Highcharts.noop,
    pick$C = Highcharts.pick,
    seriesType$e = Highcharts.seriesType,
    seriesTypes$c = Highcharts.seriesTypes;
/**
 * The boxplot series type.
 *
 * @constructor seriesTypes.boxplot
 * @augments    seriesTypes.column
 */

/**
 * A box plot is a convenient way of depicting groups of data through their
 * five-number summaries: the smallest observation (sample minimum), lower
 * quartile (Q1), median (Q2), upper quartile (Q3), and largest observation
 * (sample maximum).
 *
 * @sample       highcharts/demo/box-plot/ Box plot
 * @extends      {plotOptions.column}
 * @product      highcharts
 * @excluding    borderColor,borderRadius,borderWidth,groupZPadding,states
 * @optionparent plotOptions.boxplot
 */

seriesType$e('boxplot', 'column', {
  threshold: null,
  tooltip: {
    pointFormat: '<span class="highcharts-color-{point.colorIndex}">' + '\u25CF</span> <b> {series.name}</b><br/>' + 'Maximum: {point.high}<br/>' + 'Upper quartile: {point.q3}<br/>' + 'Median: {point.median}<br/>' + 'Lower quartile: {point.q1}<br/>' + 'Minimum: {point.low}<br/>'
  },

  /**
   * The length of the whiskers, the horizontal lines marking low and
   * high values. It can be a numerical pixel value, or a percentage
   * value of the box width. Set `0` to disable whiskers.
   *
   * @type    {Number|String}
   * @sample  {highcharts} highcharts/plotoptions/box-plot-styling/
   *          True by default
   * @since   3.0
   * @product highcharts
   */
  whiskerLength: '50%'
},
/** @lends seriesTypes.boxplot */
{
  // array point configs are mapped to this
  pointArrayMap: ['low', 'q1', 'median', 'q3', 'high'],
  toYData: function (point) {
    // return a plain array for speedy calculation
    return [point.low, point.q1, point.median, point.q3, point.high];
  },
  // defines the top of the tracker
  pointValKey: 'high',

  /**
   * Disable data labels for box plot
   */
  drawDataLabels: noop$c,

  /**
   * Translate data points from raw values x and y to plotX and plotY
   */
  translate: function () {
    var series = this,
        yAxis = series.yAxis,
        pointArrayMap = series.pointArrayMap;
    seriesTypes$c.column.prototype.translate.apply(series); // do the translation on each point dimension

    each$G(series.points, function (point) {
      each$G(pointArrayMap, function (key) {
        if (point[key] !== null) {
          point[key + 'Plot'] = yAxis.translate(point[key], 0, 1, 0, 1);
        }
      });
    });
  },

  /**
   * Draw the data points
   */
  drawPoints: function () {
    var series = this,
        points = series.points,
        options = series.options,
        chart = series.chart,
        renderer = chart.renderer,
        q1Plot,
        q3Plot,
        highPlot,
        lowPlot,
        medianPlot,
        medianPath,
        crispCorr,
        crispX = 0,
        boxPath,
        width,
        left,
        right,
        halfWidth,
        // error bar inherits this series type but doesn't do quartiles
    doQuartiles = series.doQuartiles !== false,
        pointWiskerLength,
        whiskerLength = series.options.whiskerLength;
    each$G(points, function (point) {
      var graphic = point.graphic,
          verb = graphic ? 'animate' : 'attr',
          shapeArgs = point.shapeArgs; // the box

      if (point.plotY !== undefined) {
        // crisp vector coordinates
        width = shapeArgs.width;
        left = Math.floor(shapeArgs.x);
        right = left + width;
        halfWidth = Math.round(width / 2);
        q1Plot = Math.floor(doQuartiles ? point.q1Plot : point.lowPlot);
        q3Plot = Math.floor(doQuartiles ? point.q3Plot : point.lowPlot);
        highPlot = Math.floor(point.highPlot);
        lowPlot = Math.floor(point.lowPlot);

        if (!graphic) {
          point.graphic = graphic = renderer.g('point').add(series.group);
          point.stem = renderer.path().addClass('highcharts-boxplot-stem').add(graphic);

          if (whiskerLength) {
            point.whiskers = renderer.path().addClass('highcharts-boxplot-whisker').add(graphic);
          }

          if (doQuartiles) {
            point.box = renderer.path(boxPath).addClass('highcharts-boxplot-box').add(graphic);
          }

          point.medianShape = renderer.path(medianPath).addClass('highcharts-boxplot-median').add(graphic);
        } // The stem


        crispCorr = point.stem.strokeWidth() % 2 / 2;
        crispX = left + halfWidth + crispCorr;
        point.stem[verb]({
          d: [// stem up
          'M', crispX, q3Plot, 'L', crispX, highPlot, // stem down
          'M', crispX, q1Plot, 'L', crispX, lowPlot]
        }); // The box

        if (doQuartiles) {
          crispCorr = point.box.strokeWidth() % 2 / 2;
          q1Plot = Math.floor(q1Plot) + crispCorr;
          q3Plot = Math.floor(q3Plot) + crispCorr;
          left += crispCorr;
          right += crispCorr;
          point.box[verb]({
            d: ['M', left, q3Plot, 'L', left, q1Plot, 'L', right, q1Plot, 'L', right, q3Plot, 'L', left, q3Plot, 'z']
          });
        } // The whiskers


        if (whiskerLength) {
          crispCorr = point.whiskers.strokeWidth() % 2 / 2;
          highPlot = highPlot + crispCorr;
          lowPlot = lowPlot + crispCorr;
          pointWiskerLength = /%$/.test(whiskerLength) ? halfWidth * parseFloat(whiskerLength) / 100 : whiskerLength / 2;
          point.whiskers[verb]({
            d: [// High whisker
            'M', crispX - pointWiskerLength, highPlot, 'L', crispX + pointWiskerLength, highPlot, // Low whisker
            'M', crispX - pointWiskerLength, lowPlot, 'L', crispX + pointWiskerLength, lowPlot]
          });
        } // The median


        medianPlot = Math.round(point.medianPlot);
        crispCorr = point.medianShape.strokeWidth() % 2 / 2;
        medianPlot = medianPlot + crispCorr;
        point.medianShape[verb]({
          d: ['M', left, medianPlot, 'L', right, medianPlot]
        });
      }
    });
  },
  setStackedPoints: noop$c // #3890

});
/**
 * A `boxplot` series. If the [type](#series.boxplot.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.boxplot
 * @excluding dataParser,dataURL,marker,stack,stacking,states
 * @product   highcharts
 * @apioption series.boxplot
 */

/**
 * An array of data points for the series. For the `boxplot` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of arrays with 6 or 5 values. In this case, the values
 * correspond to `x,low,q1,median,q3,high`. If the first value is a
 * string, it is applied as the name of the point, and the `x` value
 * is inferred. The `x` value can also be omitted, in which case the
 * inner arrays should be of length 5\. Then the `x` value is automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options.
 *
 *  ```js
 *     data: [
 *         [0, 3, 0, 10, 3, 5],
 *         [1, 7, 8, 7, 2, 9],
 *         [2, 6, 9, 5, 1, 3]
 *     ]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.boxplot.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         low: 4,
 *         q1: 9,
 *         median: 9,
 *         q3: 1,
 *         high: 10,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         low: 5,
 *         q1: 7,
 *         median: 3,
 *         q3: 6,
 *         high: 2,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Array>}
 * @extends   series.line.data
 * @excluding marker
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts
 * @apioption series.boxplot.data
 */

/**
 * The `high` value for each data point, signifying the highest value
 * in the sample set. The top whisker is drawn here.
 *
 * @type      {Number}
 * @product   highcharts
 * @apioption series.boxplot.data.high
 */

/**
 * The `low` value for each data point, signifying the lowest value
 * in the sample set. The bottom whisker is drawn here.
 *
 * @type      {Number}
 * @product   highcharts
 * @apioption series.boxplot.data.low
 */

/**
 * The median for each data point. This is drawn as a line through the
 * middle area of the box.
 *
 * @type      {Number}
 * @product   highcharts
 * @apioption series.boxplot.data.median
 */

/**
 * The lower quartile for each data point. This is the bottom of the
 * box.
 *
 * @type      {Number}
 * @product   highcharts
 * @apioption series.boxplot.data.q1
 */

/**
 * The higher quartile for each data point. This is the top of the box.
 *
 * @type      {Number}
 * @product   highcharts
 * @apioption series.boxplot.data.q3
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var each$H = Highcharts.each,
    noop$d = Highcharts.noop,
    seriesType$f = Highcharts.seriesType,
    seriesTypes$d = Highcharts.seriesTypes;
/**
 * Error bars are a graphical representation of the variability of data and are
 * used on graphs to indicate the error, or uncertainty in a reported
 * measurement.
 *
 * @sample       highcharts/demo/error-bar/
 *               Error bars on a column series
 * @sample       highcharts/series-errorbar/on-scatter/
 *               Error bars on a scatter series
 * @extends      {plotOptions.boxplot}
 * @product      highcharts highstock
 * @optionparent plotOptions.errorbar
 */

seriesType$f('errorbar', 'boxplot', {
  grouping: false,

  /**
   * The parent series of the error bar. The default value links it to
   * the previous series. Otherwise, use the id of the parent series.
   *
   * @since   3.0
   * @product highcharts
   */
  linkedTo: ':previous',
  tooltip: {
    pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
  },

  /**
   * The line width of the whiskers, the horizontal lines marking low
   * and high values. When `null`, the general
   * [lineWidth](#plotOptions.errorbar.lineWidth) applies.
   *
   * @type    {Number}
   * @sample  {highcharts} highcharts/plotoptions/error-bar-styling/
   *          Error bar styling
   * @since   3.0
   * @product highcharts
   */
  whiskerWidth: null // Prototype members

}, {
  type: 'errorbar',
  pointArrayMap: ['low', 'high'],
  // array point configs are mapped to this
  toYData: function (point) {
    // return a plain array for speedy calculation
    return [point.low, point.high];
  },
  pointValKey: 'high',
  // defines the top of the tracker
  doQuartiles: false,
  drawDataLabels: seriesTypes$d.arearange ? function () {
    var valKey = this.pointValKey;
    seriesTypes$d.arearange.prototype.drawDataLabels.call(this); // Arearange drawDataLabels does not reset point.y to high,
    // but to low after drawing (#4133)

    each$H(this.data, function (point) {
      point.y = point[valKey];
    });
  } : noop$d,

  /**
   * Get the width and X offset, either on top of the linked series column
   * or standalone
   */
  getColumnMetrics: function () {
    return this.linkedParent && this.linkedParent.columnMetrics || seriesTypes$d.column.prototype.getColumnMetrics.call(this);
  }
});
/**
 * A `errorbar` series. If the [type](#series.errorbar.type) option
 * is not specified, it is inherited from [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.errorbar
 * @excluding dataParser,dataURL,stack,stacking
 * @product   highcharts
 * @apioption series.errorbar
 */

/**
 * An array of data points for the series. For the `errorbar` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of arrays with 3 or 2 values. In this case, the values
 * correspond to `x,low,high`. If the first value is a string, it is
 * applied as the name of the point, and the `x` value is inferred.
 * The `x` value can also be omitted, in which case the inner arrays
 * should be of length 2\. Then the `x` value is automatically calculated,
 * either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options.
 *
 *  ```js
 *     data: [
 *         [0, 10, 2],
 *         [1, 1, 8],
 *         [2, 4, 5]
 *     ]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.errorbar.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         low: 0,
 *         high: 0,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         low: 5,
 *         high: 5,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Array>}
 * @extends   series.arearange.data
 * @excluding dataLabels,drilldown,marker,states
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts
 * @apioption series.errorbar.data
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var correctFloat$6 = Highcharts.correctFloat,
    isNumber$g = Highcharts.isNumber,
    pick$D = Highcharts.pick,
    Point$8 = Highcharts.Point,
    Series$g = Highcharts.Series,
    seriesType$g = Highcharts.seriesType,
    seriesTypes$e = Highcharts.seriesTypes;
/**
 * A waterfall chart displays sequentially introduced positive or negative
 * values in cumulative columns.
 *
 * @sample       highcharts/demo/waterfall/
 *               Waterfall chart
 * @sample       highcharts/plotoptions/waterfall-inverted/
 *               Horizontal (inverted) waterfall
 * @sample       highcharts/plotoptions/waterfall-stacked/
 *               Stacked waterfall chart
 * @extends      {plotOptions.column}
 * @product      highcharts
 * @optionparent plotOptions.waterfall
 */

seriesType$g('waterfall', 'column', {
  /**
   * The color used specifically for positive point columns. When not
   * specified, the general series color is used.
   *
   * In styled mode, the waterfall colors can be set with the
   * `.highcharts-point-negative`, `.highcharts-sum` and
   * `.highcharts-intermediate-sum` classes.
   *
   * @type      {Color}
   * @sample    {highcharts} highcharts/demo/waterfall/ Waterfall
   * @product   highcharts
   * @apioption plotOptions.waterfall.upColor
   */
  dataLabels: {
    inside: true
  } // Prototype members

}, {
  pointValKey: 'y',

  /**
   * Property needed to prevent lines between the columns from disappearing
   * when negativeColor is used.
   */
  showLine: true,

  /**
   * After generating points, set y-values for all sums.
   */
  generatePoints: function () {
    var previousIntermediate = this.options.threshold,
        point,
        len,
        i,
        y; // Parent call:

    seriesTypes$e.column.prototype.generatePoints.apply(this);

    for (i = 0, len = this.points.length; i < len; i++) {
      point = this.points[i];
      y = this.processedYData[i]; // override point value for sums
      // #3710 Update point does not propagate to sum

      if (point.isSum) {
        point.y = correctFloat$6(y);
      } else if (point.isIntermediateSum) {
        point.y = correctFloat$6(y - previousIntermediate); // #3840

        previousIntermediate = y;
      }
    }
  },

  /**
   * Translate data points from raw values
   */
  translate: function () {
    var series = this,
        options = series.options,
        yAxis = series.yAxis,
        len,
        i,
        points,
        point,
        shapeArgs,
        stack,
        y,
        yValue,
        previousY,
        previousIntermediate,
        range,
        minPointLength = pick$D(options.minPointLength, 5),
        halfMinPointLength = minPointLength / 2,
        threshold = options.threshold,
        stacking = options.stacking,
        stackIndicator,
        tooltipY; // run column series translate

    seriesTypes$e.column.prototype.translate.apply(series);
    previousY = previousIntermediate = threshold;
    points = series.points;

    for (i = 0, len = points.length; i < len; i++) {
      // cache current point object
      point = points[i];
      yValue = series.processedYData[i];
      shapeArgs = point.shapeArgs; // get current stack

      stack = stacking && yAxis.stacks[(series.negStacks && yValue < threshold ? '-' : '') + series.stackKey];
      stackIndicator = series.getStackIndicator(stackIndicator, point.x, series.index);
      range = pick$D(stack && stack[point.x].points[stackIndicator.key], [0, yValue]); // up points

      y = Math.max(previousY, previousY + point.y) + range[0];
      shapeArgs.y = yAxis.translate(y, 0, 1, 0, 1); // sum points

      if (point.isSum) {
        shapeArgs.y = yAxis.translate(range[1], 0, 1, 0, 1);
        shapeArgs.height = Math.min(yAxis.translate(range[0], 0, 1, 0, 1), yAxis.len) - shapeArgs.y; // #4256
      } else if (point.isIntermediateSum) {
        shapeArgs.y = yAxis.translate(range[1], 0, 1, 0, 1);
        shapeArgs.height = Math.min(yAxis.translate(previousIntermediate, 0, 1, 0, 1), yAxis.len) - shapeArgs.y;
        previousIntermediate = range[1]; // If it's not the sum point, update previous stack end position
        // and get shape height (#3886)
      } else {
        shapeArgs.height = yValue > 0 ? yAxis.translate(previousY, 0, 1, 0, 1) - shapeArgs.y : yAxis.translate(previousY, 0, 1, 0, 1) - yAxis.translate(previousY - yValue, 0, 1, 0, 1);
        previousY += stack && stack[point.x] ? stack[point.x].total : yValue;
        point.below = previousY < pick$D(threshold, 0);
      } // #3952 Negative sum or intermediate sum not rendered correctly


      if (shapeArgs.height < 0) {
        shapeArgs.y += shapeArgs.height;
        shapeArgs.height *= -1;
      }

      point.plotY = shapeArgs.y = Math.round(shapeArgs.y) - series.borderWidth % 2 / 2; // #3151

      shapeArgs.height = Math.max(Math.round(shapeArgs.height), 0.001);
      point.yBottom = shapeArgs.y + shapeArgs.height;

      if (shapeArgs.height <= minPointLength && !point.isNull) {
        shapeArgs.height = minPointLength;
        shapeArgs.y -= halfMinPointLength;
        point.plotY = shapeArgs.y;

        if (point.y < 0) {
          point.minPointLengthOffset = -halfMinPointLength;
        } else {
          point.minPointLengthOffset = halfMinPointLength;
        }
      } else {
        if (point.isNull) {
          shapeArgs.width = 0;
        }

        point.minPointLengthOffset = 0;
      } // Correct tooltip placement (#3014)


      tooltipY = point.plotY + (point.negative ? shapeArgs.height : 0);

      if (series.chart.inverted) {
        point.tooltipPos[0] = yAxis.len - tooltipY;
      } else {
        point.tooltipPos[1] = tooltipY;
      }
    }
  },

  /**
   * Call default processData then override yData to reflect
   * waterfall's extremes on yAxis
   */
  processData: function (force) {
    var series = this,
        options = series.options,
        yData = series.yData,
        // #3710 Update point does not propagate to sum
    points = series.options.data,
        point,
        dataLength = yData.length,
        threshold = options.threshold || 0,
        subSum,
        sum,
        dataMin,
        dataMax,
        y,
        i;
    sum = subSum = dataMin = dataMax = threshold;

    for (i = 0; i < dataLength; i++) {
      y = yData[i];
      point = points && points[i] ? points[i] : {};

      if (y === 'sum' || point.isSum) {
        yData[i] = correctFloat$6(sum);
      } else if (y === 'intermediateSum' || point.isIntermediateSum) {
        yData[i] = correctFloat$6(subSum);
      } else {
        sum += y;
        subSum += y;
      }

      dataMin = Math.min(sum, dataMin);
      dataMax = Math.max(sum, dataMax);
    }

    Series$g.prototype.processData.call(this, force); // Record extremes only if stacking was not set:

    if (!series.options.stacking) {
      series.dataMin = dataMin;
      series.dataMax = dataMax;
    }
  },

  /**
   * Return y value or string if point is sum
   */
  toYData: function (pt) {
    if (pt.isSum) {
      // #3245 Error when first element is Sum or Intermediate Sum
      return pt.x === 0 ? null : 'sum';
    }

    if (pt.isIntermediateSum) {
      return pt.x === 0 ? null : 'intermediateSum'; // #3245
    }

    return pt.y;
  },

  /**
   * Return an empty path initially, because we need to know the
   * stroke-width in order to set the final path.
   */
  getGraphPath: function () {
    return ['M', 0, 0];
  },

  /**
   * Draw columns' connector lines
   */
  getCrispPath: function () {
    var data = this.data,
        length = data.length,
        lineWidth = this.graph.strokeWidth() + this.borderWidth,
        normalizer = Math.round(lineWidth) % 2 / 2,
        reversedXAxis = this.xAxis.reversed,
        reversedYAxis = this.yAxis.reversed,
        path = [],
        prevArgs,
        pointArgs,
        i,
        d;

    for (i = 1; i < length; i++) {
      pointArgs = data[i].shapeArgs;
      prevArgs = data[i - 1].shapeArgs;
      d = ['M', prevArgs.x + (reversedXAxis ? 0 : prevArgs.width), prevArgs.y + data[i - 1].minPointLengthOffset + normalizer, 'L', pointArgs.x + (reversedXAxis ? prevArgs.width : 0), prevArgs.y + data[i - 1].minPointLengthOffset + normalizer];

      if (data[i - 1].y < 0 && !reversedYAxis || data[i - 1].y > 0 && reversedYAxis) {
        d[2] += prevArgs.height;
        d[5] += prevArgs.height;
      }

      path = path.concat(d);
    }

    return path;
  },

  /**
   * The graph is initially drawn with an empty definition, then updated with
   * crisp rendering.
   */
  drawGraph: function () {
    Series$g.prototype.drawGraph.call(this);
    this.graph.attr({
      d: this.getCrispPath()
    });
  },

  /**
   * Waterfall has stacking along the x-values too.
   */
  setStackedPoints: function () {
    var series = this,
        options = series.options,
        stackedYLength,
        i;
    Series$g.prototype.setStackedPoints.apply(series, arguments);
    stackedYLength = series.stackedYData ? series.stackedYData.length : 0; // Start from the second point:

    for (i = 1; i < stackedYLength; i++) {
      if (!options.data[i].isSum && !options.data[i].isIntermediateSum) {
        // Sum previous stacked data as waterfall can grow up/down:
        series.stackedYData[i] += series.stackedYData[i - 1];
      }
    }
  },

  /**
   * Extremes for a non-stacked series are recorded in processData.
   * In case of stacking, use Series.stackedYData to calculate extremes.
   */
  getExtremes: function () {
    if (this.options.stacking) {
      return Series$g.prototype.getExtremes.apply(this, arguments);
    }
  } // Point members

}, {
  getClassName: function () {
    var className = Point$8.prototype.getClassName.call(this);

    if (this.isSum) {
      className += ' highcharts-sum';
    } else if (this.isIntermediateSum) {
      className += ' highcharts-intermediate-sum';
    }

    return className;
  },

  /**
   * Pass the null test in ColumnSeries.translate.
   */
  isValid: function () {
    return isNumber$g(this.y, true) || this.isSum || this.isIntermediateSum;
  }
});
/**
 * A `waterfall` series. If the [type](#series.waterfall.type) option
 * is not specified, it is inherited from [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.waterfall
 * @excluding dataParser,dataURL
 * @product   highcharts
 * @apioption series.waterfall
 */

/**
 * An array of data points for the series. For the `waterfall` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 *
 *  ```js
 *     data: [
 *         [0, 7],
 *         [1, 8],
 *         [2, 3]
 *     ]
 *  ```
 *
 * 3.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series'
 * [turboThreshold](#series.waterfall.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 8,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 8,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Array|Number>}
 * @extends   series.line.data
 * @excluding marker
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts
 * @apioption series.waterfall.data
 */

/**
 * When this property is true, the points acts as a summary column for
 * the values added or substracted since the last intermediate sum,
 * or since the start of the series. The `y` value is ignored.
 *
 * @type      {Boolean}
 * @sample    {highcharts} highcharts/demo/waterfall/ Waterfall
 * @default   false
 * @product   highcharts
 * @apioption series.waterfall.data.isIntermediateSum
 */

/**
 * When this property is true, the point display the total sum across
 * the entire series. The `y` value is ignored.
 *
 * @type      {Boolean}
 * @sample    {highcharts} highcharts/demo/waterfall/ Waterfall
 * @default   false
 * @product   highcharts
 * @apioption series.waterfall.data.isSum
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var LegendSymbolMixin$5 = Highcharts.LegendSymbolMixin,
    noop$e = Highcharts.noop,
    Series$h = Highcharts.Series,
    seriesType$h = Highcharts.seriesType,
    seriesTypes$f = Highcharts.seriesTypes;
/**
 * A polygon series can be used to draw any freeform shape in the cartesian
 * coordinate system. A fill is applied with the `color` option, and
 * stroke is applied through `lineWidth` and `lineColor` options. Requires
 * the `highcharts-more.js` file.
 *
 * @type {Object}
 * @extends plotOptions.scatter
 * @excluding softThreshold,threshold
 * @sample {highcharts} highcharts/demo/polygon/ Polygon
 * @sample {highstock} highcharts/demo/polygon/ Polygon
 * @since 4.1.0
 * @product highcharts highstock
 * @optionparent plotOptions.polygon
 */

seriesType$h('polygon', 'scatter', {
  marker: {
    enabled: false,
    states: {
      hover: {
        enabled: false
      }
    }
  },
  stickyTracking: false,
  tooltip: {
    followPointer: true,
    pointFormat: ''
  },
  trackByArea: true // Prototype members

}, {
  type: 'polygon',
  getGraphPath: function () {
    var graphPath = Series$h.prototype.getGraphPath.call(this),
        i = graphPath.length + 1; // Close all segments

    while (i--) {
      if ((i === graphPath.length || graphPath[i] === 'M') && i > 0) {
        graphPath.splice(i, 0, 'z');
      }
    }

    this.areaPath = graphPath;
    return graphPath;
  },
  drawGraph: function () {
    seriesTypes$f.area.prototype.drawGraph.call(this);
  },
  drawLegendSymbol: LegendSymbolMixin$5.drawRectangle,
  drawTracker: Series$h.prototype.drawTracker,
  setStackedPoints: noop$e // No stacking points on polygons (#5310)

});
/**
 * A `polygon` series. If the [type](#series.polygon.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 *
 * @type {Object}
 * @extends series,plotOptions.polygon
 * @excluding dataParser,dataURL,stack
 * @product highcharts highstock
 * @apioption series.polygon
 */

/**
 * An array of data points for the series. For the `polygon` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 *
 *  ```js
 *     data: [
 *         [0, 10],
 *         [1, 3],
 *         [2, 1]
 *     ]
 *  ```
 *
 * 3.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.polygon.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 1,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 8,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type {Array<Object|Array>}
 * @extends series.line.data
 * @sample {highcharts} highcharts/chart/reflow-true/
 *         Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/
 *         Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *         Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/
 *         Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/
 *         Config objects
 * @product highcharts highstock
 * @apioption series.polygon.data
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var arrayMax$6 = Highcharts.arrayMax,
    arrayMin$5 = Highcharts.arrayMin,
    Axis$e = Highcharts.Axis,
    color$7 = Highcharts.color,
    each$I = Highcharts.each,
    isNumber$h = Highcharts.isNumber,
    noop$f = Highcharts.noop,
    pick$E = Highcharts.pick,
    pInt$7 = Highcharts.pInt,
    Point$9 = Highcharts.Point,
    Series$i = Highcharts.Series,
    seriesType$i = Highcharts.seriesType,
    seriesTypes$g = Highcharts.seriesTypes;
/**
 * A bubble series is a three dimensional series type where each point renders
 * an X, Y and Z value. Each points is drawn as a bubble where the position
 * along the X and Y axes mark the X and Y values, and the size of the bubble
 * relates to the Z value. Requires `highcharts-more.js`.
 *
 * @sample       {highcharts} highcharts/demo/bubble/ Bubble chart
 * @extends      plotOptions.scatter
 * @product      highcharts highstock
 * @optionparent plotOptions.bubble
 */

seriesType$i('bubble', 'scatter', {
  dataLabels: {
    formatter: function () {
      // #2945
      return this.point.z;
    },
    inside: true,
    verticalAlign: 'middle'
  },

  /**
   * If there are more points in the series than the `animationLimit`, the
   * animation won't run. Animation affects overall performance and doesn't
   * work well with heavy data series.
   * @since 6.1.0
   */
  animationLimit: 250,

  /**
   * Whether to display negative sized bubbles. The threshold is given
   * by the [zThreshold](#plotOptions.bubble.zThreshold) option, and negative
   * bubbles can be visualized by setting
   * [negativeColor](#plotOptions.bubble.negativeColor).
   *
   * @type      {Boolean}
   * @sample    {highcharts} highcharts/plotoptions/bubble-negative/
   *            Negative bubbles
   * @default   true
   * @since     3.0
   * @apioption plotOptions.bubble.displayNegative
   */

  /**
   * @extends   plotOptions.series.marker
   * @excluding enabled,enabledThreshold,height,radius,width
   */
  marker: {
    /**
     * In bubble charts, the radius is overridden and determined based on
     * the point's data value.
     */

    /**
     * @ignore-option
     */
    radius: null,
    states: {
      hover: {
        radiusPlus: 0
      }
    },

    /**
     * A predefined shape or symbol for the marker. Possible values are
     * "circle", "square", "diamond", "triangle" and "triangle-down".
     *
     * Additionally, the URL to a graphic can be given on the form
     * `url(graphic.png)`. Note that for the image to be applied to exported
     * charts, its URL needs to be accessible by the export server.
     *
     * Custom callbacks for symbol path generation can also be added to
     * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
     * used by its method name, as shown in the demo.
     *
     * @validvalue ["circle", "square", "diamond", "triangle",
     *              "triangle-down"]
     * @sample     {highcharts} highcharts/plotoptions/bubble-symbol/
     *             Bubble chart with various symbols
     * @sample     {highcharts} highcharts/plotoptions/series-marker-symbol/
     *             General chart with predefined, graphic and custom markers
     * @since      5.0.11
     */
    symbol: 'circle'
  },

  /**
   * Minimum bubble size. Bubbles will automatically size between the
   * `minSize` and `maxSize` to reflect the `z` value of each bubble.
   * Can be either pixels (when no unit is given), or a percentage of
   * the smallest one of the plot width and height.
   *
   * @type    {Number|String}
   * @sample  {highcharts} highcharts/plotoptions/bubble-size/ Bubble size
   * @since   3.0
   * @product highcharts highstock
   */
  minSize: 8,

  /**
   * Maximum bubble size. Bubbles will automatically size between the
   * `minSize` and `maxSize` to reflect the `z` value of each bubble.
   * Can be either pixels (when no unit is given), or a percentage of
   * the smallest one of the plot width and height.
   *
   * @type    {Number|String}
   * @sample  {highcharts} highcharts/plotoptions/bubble-size/
   *          Bubble size
   * @since   3.0
   * @product highcharts highstock
   */
  maxSize: '20%',

  /**
   * When a point's Z value is below the
   * [zThreshold](#plotOptions.bubble.zThreshold) setting, this color is used.
   *
   * @type      {Color}
   * @sample    {highcharts} highcharts/plotoptions/bubble-negative/
   *            Negative bubbles
   * @default   null
   * @since     3.0
   * @product   highcharts
   * @apioption plotOptions.bubble.negativeColor
   */

  /**
   * Whether the bubble's value should be represented by the area or the
   * width of the bubble. The default, `area`, corresponds best to the
   * human perception of the size of each bubble.
   *
   * @validvalue ["area", "width"]
   * @type       {String}
   * @sample     {highcharts} highcharts/plotoptions/bubble-sizeby/
   *             Comparison of area and size
   * @default    area
   * @since      3.0.7
   * @apioption  plotOptions.bubble.sizeBy
   */

  /**
   * When this is true, the absolute value of z determines the size of
   * the bubble. This means that with the default `zThreshold` of 0, a
   * bubble of value -1 will have the same size as a bubble of value 1,
   * while a bubble of value 0 will have a smaller size according to
   * `minSize`.
   *
   * @type      {Boolean}
   * @sample    {highcharts}
   *            highcharts/plotoptions/bubble-sizebyabsolutevalue/
   *            Size by absolute value, various thresholds
   * @default   false
   * @since     4.1.9
   * @product   highcharts
   * @apioption plotOptions.bubble.sizeByAbsoluteValue
   */

  /**
   * When this is true, the series will not cause the Y axis to cross
   * the zero plane (or [threshold](#plotOptions.series.threshold) option)
   * unless the data actually crosses the plane.
   *
   * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
   * 3 will make the Y axis show negative values according to the `minPadding`
   * option. If `softThreshold` is `true`, the Y axis starts at 0.
   *
   * @since   4.1.9
   * @product highcharts
   */
  softThreshold: false,
  states: {
    hover: {
      halo: {
        size: 5
      }
    }
  },
  tooltip: {
    pointFormat: '({point.x}, {point.y}), Size: {point.z}'
  },
  turboThreshold: 0,

  /**
   * The minimum for the Z value range. Defaults to the highest Z value
   * in the data.
   *
   * @type      {Number}
   * @see       [zMin](#plotOptions.bubble.zMin)
   * @sample    {highcharts} highcharts/plotoptions/bubble-zmin-zmax/
   *            Z has a possible range of 0-100
   * @default   null
   * @since     4.0.3
   * @product   highcharts
   * @apioption plotOptions.bubble.zMax
   */

  /**
   * The minimum for the Z value range. Defaults to the lowest Z value
   * in the data.
   *
   * @type      {Number}
   * @see       [zMax](#plotOptions.bubble.zMax)
   * @sample    {highcharts} highcharts/plotoptions/bubble-zmin-zmax/
   *            Z has a possible range of 0-100
   * @default   null
   * @since     4.0.3
   * @product   highcharts
   * @apioption plotOptions.bubble.zMin
   */

  /**
   * When [displayNegative](#plotOptions.bubble.displayNegative) is `false`,
   * bubbles with lower Z values are skipped. When `displayNegative`
   * is `true` and a [negativeColor](#plotOptions.bubble.negativeColor)
   * is given, points with lower Z is colored.
   *
   * @type    {Number}
   * @sample  {highcharts} highcharts/plotoptions/bubble-negative/
   *          Negative bubbles
   * @default 0
   * @since   3.0
   * @product highcharts
   */
  zThreshold: 0,
  zoneAxis: 'z' // Prototype members

}, {
  pointArrayMap: ['y', 'z'],
  parallelArrays: ['x', 'y', 'z'],
  trackerGroups: ['group', 'dataLabelsGroup'],
  specialGroup: 'group',
  // To allow clipping (#6296)
  bubblePadding: true,
  zoneAxis: 'z',
  directTouch: true,

  /**
   * Get the radius for each point based on the minSize, maxSize and each
   * point's Z value. This must be done prior to Series.translate because
   * the axis needs to add padding in accordance with the point sizes.
   */
  getRadii: function (zMin, zMax, minSize, maxSize) {
    var len,
        i,
        pos,
        zData = this.zData,
        radii = [],
        options = this.options,
        sizeByArea = options.sizeBy !== 'width',
        zThreshold = options.zThreshold,
        zRange = zMax - zMin,
        value,
        radius; // Set the shape type and arguments to be picked up in drawPoints

    for (i = 0, len = zData.length; i < len; i++) {
      value = zData[i]; // When sizing by threshold, the absolute value of z determines
      // the size of the bubble.

      if (options.sizeByAbsoluteValue && value !== null) {
        value = Math.abs(value - zThreshold);
        zMax = zRange = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));
        zMin = 0;
      }

      if (!isNumber$h(value)) {
        radius = null; // Issue #4419 - if value is less than zMin, push a radius that's
        // always smaller than the minimum size
      } else if (value < zMin) {
        radius = minSize / 2 - 1;
      } else {
        // Relative size, a number between 0 and 1
        pos = zRange > 0 ? (value - zMin) / zRange : 0.5;

        if (sizeByArea && pos >= 0) {
          pos = Math.sqrt(pos);
        }

        radius = Math.ceil(minSize + pos * (maxSize - minSize)) / 2;
      }

      radii.push(radius);
    }

    this.radii = radii;
  },

  /**
   * Perform animation on the bubbles
   */
  animate: function (init) {
    if (!init && this.points.length < this.options.animationLimit // #8099
    ) {
        each$I(this.points, function (point) {
          var graphic = point.graphic,
              animationTarget;

          if (graphic && graphic.width) {
            // URL symbols don't have width
            animationTarget = {
              x: graphic.x,
              y: graphic.y,
              width: graphic.width,
              height: graphic.height
            }; // Start values

            graphic.attr({
              x: point.plotX,
              y: point.plotY,
              width: 1,
              height: 1
            }); // Run animation

            graphic.animate(animationTarget, this.options.animation);
          }
        }, this); // delete this function to allow it only once

        this.animate = null;
      }
  },

  /**
   * Extend the base translate method to handle bubble size
   */
  translate: function () {
    var i,
        data = this.data,
        point,
        radius,
        radii = this.radii; // Run the parent method

    seriesTypes$g.scatter.prototype.translate.call(this); // Set the shape type and arguments to be picked up in drawPoints

    i = data.length;

    while (i--) {
      point = data[i];
      radius = radii ? radii[i] : 0; // #1737

      if (isNumber$h(radius) && radius >= this.minPxSize / 2) {
        // Shape arguments
        point.marker = Highcharts.extend(point.marker, {
          radius: radius,
          width: 2 * radius,
          height: 2 * radius
        }); // Alignment box for the data label

        point.dlBox = {
          x: point.plotX - radius,
          y: point.plotY - radius,
          width: 2 * radius,
          height: 2 * radius
        };
      } else {
        // below zThreshold
        // #1691
        point.shapeArgs = point.plotY = point.dlBox = undefined;
      }
    }
  },
  alignDataLabel: seriesTypes$g.column.prototype.alignDataLabel,
  buildKDTree: noop$f,
  applyZones: noop$f // Point class

}, {
  haloPath: function (size) {
    return Point$9.prototype.haloPath.call(this, // #6067
    size === 0 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + size);
  },
  ttBelow: false
});
/**
 * Add logic to pad each axis with the amount of pixels
 * necessary to avoid the bubbles to overflow.
 */

Axis$e.prototype.beforePadding = function () {
  var axis = this,
      axisLength = this.len,
      chart = this.chart,
      pxMin = 0,
      pxMax = axisLength,
      isXAxis = this.isXAxis,
      dataKey = isXAxis ? 'xData' : 'yData',
      min = this.min,
      extremes = {},
      smallestSize = Math.min(chart.plotWidth, chart.plotHeight),
      zMin = Number.MAX_VALUE,
      zMax = -Number.MAX_VALUE,
      range = this.max - min,
      transA = axisLength / range,
      activeSeries = []; // Handle padding on the second pass, or on redraw

  each$I(this.series, function (series) {
    var seriesOptions = series.options,
        zData;

    if (series.bubblePadding && (series.visible || !chart.options.chart.ignoreHiddenSeries)) {
      // Correction for #1673
      axis.allowZoomOutside = true; // Cache it

      activeSeries.push(series);

      if (isXAxis) {
        // because X axis is evaluated first
        // For each series, translate the size extremes to pixel values
        each$I(['minSize', 'maxSize'], function (prop) {
          var length = seriesOptions[prop],
              isPercent = /%$/.test(length);
          length = pInt$7(length);
          extremes[prop] = isPercent ? smallestSize * length / 100 : length;
        });
        series.minPxSize = extremes.minSize; // Prioritize min size if conflict to make sure bubbles are
        // always visible. #5873

        series.maxPxSize = Math.max(extremes.maxSize, extremes.minSize); // Find the min and max Z

        zData = Highcharts.grep(series.zData, Highcharts.isNumber);

        if (zData.length) {
          // #1735
          zMin = pick$E(seriesOptions.zMin, Math.min(zMin, Math.max(arrayMin$5(zData), seriesOptions.displayNegative === false ? seriesOptions.zThreshold : -Number.MAX_VALUE)));
          zMax = pick$E(seriesOptions.zMax, Math.max(zMax, arrayMax$6(zData)));
        }
      }
    }
  });
  each$I(activeSeries, function (series) {
    var data = series[dataKey],
        i = data.length,
        radius;

    if (isXAxis) {
      series.getRadii(zMin, zMax, series.minPxSize, series.maxPxSize);
    }

    if (range > 0) {
      while (i--) {
        if (isNumber$h(data[i]) && axis.dataMin <= data[i] && data[i] <= axis.dataMax) {
          radius = series.radii[i];
          pxMin = Math.min((data[i] - min) * transA - radius, pxMin);
          pxMax = Math.max((data[i] - min) * transA + radius, pxMax);
        }
      }
    }
  }); // Apply the padding to the min and max properties

  if (activeSeries.length && range > 0 && !this.isLog) {
    pxMax -= axisLength;
    transA *= (axisLength + Math.max(0, pxMin) - // #8901
    Math.min(pxMax, axisLength)) / axisLength;
    each$I([['min', 'userMin', pxMin], ['max', 'userMax', pxMax]], function (keys) {
      if (pick$E(axis.options[keys[0]], axis[keys[1]]) === undefined) {
        axis[keys[0]] += keys[2] / transA;
      }
    });
  }
};
/**
 * A `bubble` series. If the [type](#series.bubble.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.bubble
 * @excluding dataParser,dataURL,stack
 * @product   highcharts highstock
 * @apioption series.bubble
 */

/**
 * An array of data points for the series. For the `bubble` series type,
 * points can be given in the following ways:
 *
 * 1.  An array of arrays with 3 or 2 values. In this case, the values
 * correspond to `x,y,z`. If the first value is a string, it is applied
 * as the name of the point, and the `x` value is inferred. The `x`
 * value can also be omitted, in which case the inner arrays should
 * be of length 2\. Then the `x` value is automatically calculated,
 * either starting at 0 and incremented by 1, or from `pointStart` and
 * `pointInterval` given in the series options.
 *
 *  ```js
 *     data: [
 *         [0, 1, 2],
 *         [1, 5, 5],
 *         [2, 0, 2]
 *     ]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.bubble.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 1,
 *         z: 1,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 5,
 *         z: 4,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Array>}
 * @extends   series.line.data
 * @excluding marker
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts
 * @apioption series.bubble.data
 */

/**
 * The size value for each bubble. The bubbles' diameters are computed
 * based on the `z`, and controlled by series options like `minSize`,
 * `maxSize`, `sizeBy`, `zMin` and `zMax`.
 *
 * @type {Number}
 * @product highcharts
 * @apioption series.bubble.data.z
 */

/**
 * @excluding enabled,enabledThreshold,height,radius,width
 * @apioption series.bubble.marker
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * Extensions for polar charts. Additionally, much of the geometry required for
 * polar charts is gathered in RadialAxes.js.
 */

var each$J = Highcharts.each,
    pick$F = Highcharts.pick,
    Pointer$3 = Highcharts.Pointer,
    Series$j = Highcharts.Series,
    seriesTypes$h = Highcharts.seriesTypes,
    wrap$c = Highcharts.wrap,
    seriesProto$3 = Series$j.prototype,
    pointerProto = Pointer$3.prototype,
    colProto$1;

if (!Highcharts.polarExtended) {
  Highcharts.polarExtended = true;
  /**
   * Search a k-d tree by the point angle, used for shared tooltips in polar
   * charts
   */

  seriesProto$3.searchPointByAngle = function (e) {
    var series = this,
        chart = series.chart,
        xAxis = series.xAxis,
        center = xAxis.pane.center,
        plotX = e.chartX - center[0] - chart.plotLeft,
        plotY = e.chartY - center[1] - chart.plotTop;
    return this.searchKDTree({
      clientX: 180 + Math.atan2(plotX, plotY) * (-180 / Math.PI)
    });
  };
  /**
   * #6212 Calculate connectors for spline series in polar chart.
   * @param {Boolean} calculateNeighbours
   *        Check if connectors should be calculated for neighbour points as
   *        well allows short recurence
   */


  seriesProto$3.getConnectors = function (segment, index, calculateNeighbours, connectEnds) {
    var i,
        prevPointInd,
        nextPointInd,
        previousPoint,
        nextPoint,
        previousX,
        previousY,
        nextX,
        nextY,
        plotX,
        plotY,
        ret,
        // 1 means control points midway between points, 2 means 1/3 from
    // the point, 3 is 1/4 etc;
    smoothing = 1.5,
        denom = smoothing + 1,
        leftContX,
        leftContY,
        rightContX,
        rightContY,
        dLControlPoint,
        // distance left control point
    dRControlPoint,
        leftContAngle,
        rightContAngle,
        jointAngle,
        addedNumber = connectEnds ? 1 : 0; // Calculate final index of points depending on the initial index value.
    // Because of calculating neighbours, index may be outisde segment
    // array.

    if (index >= 0 && index <= segment.length - 1) {
      i = index;
    } else if (index < 0) {
      i = segment.length - 1 + index;
    } else {
      i = 0;
    }

    prevPointInd = i - 1 < 0 ? segment.length - (1 + addedNumber) : i - 1;
    nextPointInd = i + 1 > segment.length - 1 ? addedNumber : i + 1;
    previousPoint = segment[prevPointInd];
    nextPoint = segment[nextPointInd];
    previousX = previousPoint.plotX;
    previousY = previousPoint.plotY;
    nextX = nextPoint.plotX;
    nextY = nextPoint.plotY;
    plotX = segment[i].plotX; // actual point

    plotY = segment[i].plotY;
    leftContX = (smoothing * plotX + previousX) / denom;
    leftContY = (smoothing * plotY + previousY) / denom;
    rightContX = (smoothing * plotX + nextX) / denom;
    rightContY = (smoothing * plotY + nextY) / denom;
    dLControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2));
    dRControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2));
    leftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX);
    rightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);
    jointAngle = Math.PI / 2 + (leftContAngle + rightContAngle) / 2; // Ensure the right direction, jointAngle should be in the same quadrant
    // as leftContAngle

    if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {
      jointAngle -= Math.PI;
    } // Find the corrected control points for a spline straight through the
    // point


    leftContX = plotX + Math.cos(jointAngle) * dLControlPoint;
    leftContY = plotY + Math.sin(jointAngle) * dLControlPoint;
    rightContX = plotX + Math.cos(Math.PI + jointAngle) * dRControlPoint;
    rightContY = plotY + Math.sin(Math.PI + jointAngle) * dRControlPoint; // push current point's connectors into returned object

    ret = {
      rightContX: rightContX,
      rightContY: rightContY,
      leftContX: leftContX,
      leftContY: leftContY,
      plotX: plotX,
      plotY: plotY
    }; // calculate connectors for previous and next point and push them inside
    // returned object

    if (calculateNeighbours) {
      ret.prevPointCont = this.getConnectors(segment, prevPointInd, false, connectEnds);
    }

    return ret;
  };
  /**
   * Wrap the buildKDTree function so that it searches by angle (clientX) in
   * case of shared tooltip, and by two dimensional distance in case of
   * non-shared.
   */


  wrap$c(seriesProto$3, 'buildKDTree', function (proceed) {
    if (this.chart.polar) {
      if (this.kdByAngle) {
        this.searchPoint = this.searchPointByAngle;
      } else {
        this.options.findNearestPointBy = 'xy';
      }
    }

    proceed.apply(this);
  });
  /**
   * Translate a point's plotX and plotY from the internal angle and radius
   * measures to true plotX, plotY coordinates
   */

  seriesProto$3.toXY = function (point) {
    var xy,
        chart = this.chart,
        plotX = point.plotX,
        plotY = point.plotY,
        clientX; // Save rectangular plotX, plotY for later computation

    point.rectPlotX = plotX;
    point.rectPlotY = plotY; // Find the polar plotX and plotY

    xy = this.xAxis.postTranslate(point.plotX, this.yAxis.len - plotY);
    point.plotX = point.polarPlotX = xy.x - chart.plotLeft;
    point.plotY = point.polarPlotY = xy.y - chart.plotTop; // If shared tooltip, record the angle in degrees in order to align X
    // points. Otherwise, use a standard k-d tree to get the nearest point
    // in two dimensions.

    if (this.kdByAngle) {
      clientX = (plotX / Math.PI * 180 + this.xAxis.pane.options.startAngle) % 360;

      if (clientX < 0) {
        // #2665
        clientX += 360;
      }

      point.clientX = clientX;
    } else {
      point.clientX = point.plotX;
    }
  };

  if (seriesTypes$h.spline) {
    /**
     * Overridden method for calculating a spline from one point to the next
     */
    wrap$c(seriesTypes$h.spline.prototype, 'getPointSpline', function (proceed, segment, point, i) {
      var ret, connectors;

      if (this.chart.polar) {
        // moveTo or lineTo
        if (!i) {
          ret = ['M', point.plotX, point.plotY];
        } else {
          // curve from last point to this
          connectors = this.getConnectors(segment, i, true, this.connectEnds);
          ret = ['C', connectors.prevPointCont.rightContX, connectors.prevPointCont.rightContY, connectors.leftContX, connectors.leftContY, connectors.plotX, connectors.plotY];
        }
      } else {
        ret = proceed.call(this, segment, point, i);
      }

      return ret;
    }); // #6430 Areasplinerange series use unwrapped getPointSpline method, so
    // we need to set this method again.

    if (seriesTypes$h.areasplinerange) {
      seriesTypes$h.areasplinerange.prototype.getPointSpline = seriesTypes$h.spline.prototype.getPointSpline;
    }
  }
  /**
   * Extend translate. The plotX and plotY values are computed as if the polar
   * chart were a cartesian plane, where plotX denotes the angle in radians
   * and (yAxis.len - plotY) is the pixel distance from center.
   */


  Highcharts.addEvent(Series$j, 'afterTranslate', function () {
    var chart = this.chart,
        points,
        i;

    if (chart.polar) {
      // Postprocess plot coordinates
      this.kdByAngle = chart.tooltip && chart.tooltip.shared;

      if (!this.preventPostTranslate) {
        points = this.points;
        i = points.length;

        while (i--) {
          // Translate plotX, plotY from angle and radius to true plot
          // coordinates
          this.toXY(points[i]);
        }
      } // Perform clip after render


      if (!this.hasClipCircleSetter) {
        this.hasClipCircleSetter = Boolean(Highcharts.addEvent(this, 'afterRender', function () {
          var circ;

          if (chart.polar) {
            circ = this.yAxis.center;
            this.group.clip(chart.renderer.clipCircle(circ[0], circ[1], circ[2] / 2));
            this.setClip = Highcharts.noop;
          }
        }));
      }
    }
  }, {
    order: 2
  }); // Run after translation of ||-coords

  /**
   * Extend getSegmentPath to allow connecting ends across 0 to provide a
   * closed circle in line-like series.
   */

  wrap$c(seriesProto$3, 'getGraphPath', function (proceed, points) {
    var series = this,
        i,
        firstValid,
        popLastPoint; // Connect the path

    if (this.chart.polar) {
      points = points || this.points; // Append first valid point in order to connect the ends

      for (i = 0; i < points.length; i++) {
        if (!points[i].isNull) {
          firstValid = i;
          break;
        }
      }
      /**
       * Polar charts only. Whether to connect the ends of a line series
       * plot across the extremes.
       *
       * @type {Boolean}
       * @sample {highcharts} highcharts/plotoptions/line-connectends-false/
       *         Do not connect
       * @since 2.3.0
       * @product highcharts
       * @apioption plotOptions.series.connectEnds
       */


      if (this.options.connectEnds !== false && firstValid !== undefined) {
        this.connectEnds = true; // re-used in splines

        points.splice(points.length, 0, points[firstValid]);
        popLastPoint = true;
      } // For area charts, pseudo points are added to the graph, now we
      // need to translate these


      each$J(points, function (point) {
        if (point.polarPlotY === undefined) {
          series.toXY(point);
        }
      });
    } // Run uber method


    var ret = proceed.apply(this, [].slice.call(arguments, 1)); // #6212 points.splice method is adding points to an array. In case of
    // areaspline getGraphPath method is used two times and in both times
    // points are added to an array. That is why points.pop is used, to get
    // unmodified points.

    if (popLastPoint) {
      points.pop();
    }

    return ret;
  });

  var polarAnimate = function (proceed, init) {
    var chart = this.chart,
        animation = this.options.animation,
        group = this.group,
        markerGroup = this.markerGroup,
        center = this.xAxis.center,
        plotLeft = chart.plotLeft,
        plotTop = chart.plotTop,
        attribs; // Specific animation for polar charts

    if (chart.polar) {
      // Enable animation on polar charts only in SVG. In VML, the scaling
      // is different, plus animation would be so slow it would't matter.
      if (chart.renderer.isSVG) {
        if (animation === true) {
          animation = {};
        } // Initialize the animation


        if (init) {
          // Scale down the group and place it in the center
          attribs = {
            translateX: center[0] + plotLeft,
            translateY: center[1] + plotTop,
            scaleX: 0.001,
            // #1499
            scaleY: 0.001
          };
          group.attr(attribs);

          if (markerGroup) {
            markerGroup.attr(attribs);
          } // Run the animation

        } else {
          attribs = {
            translateX: plotLeft,
            translateY: plotTop,
            scaleX: 1,
            scaleY: 1
          };
          group.animate(attribs, animation);

          if (markerGroup) {
            markerGroup.animate(attribs, animation);
          } // Delete this function to allow it only once


          this.animate = null;
        }
      } // For non-polar charts, revert to the basic animation

    } else {
      proceed.call(this, init);
    }
  }; // Define the animate method for regular series


  wrap$c(seriesProto$3, 'animate', polarAnimate);

  if (seriesTypes$h.column) {
    colProto$1 = seriesTypes$h.column.prototype;

    colProto$1.polarArc = function (low, high, start, end) {
      var center = this.xAxis.center,
          len = this.yAxis.len;
      return this.chart.renderer.symbols.arc(center[0], center[1], len - high, null, {
        start: start,
        end: end,
        innerR: len - pick$F(low, len)
      });
    };
    /**
    * Define the animate method for columnseries
    */


    wrap$c(colProto$1, 'animate', polarAnimate);
    /**
     * Extend the column prototype's translate method
     */

    wrap$c(colProto$1, 'translate', function (proceed) {
      var xAxis = this.xAxis,
          startAngleRad = xAxis.startAngleRad,
          start,
          points,
          point,
          i;
      this.preventPostTranslate = true; // Run uber method

      proceed.call(this); // Postprocess plot coordinates

      if (xAxis.isRadial) {
        points = this.points;
        i = points.length;

        while (i--) {
          point = points[i];
          start = point.barX + startAngleRad;
          point.shapeType = 'path';
          point.shapeArgs = {
            d: this.polarArc(point.yBottom, point.plotY, start, start + point.pointWidth)
          }; // Provide correct plotX, plotY for tooltip

          this.toXY(point);
          point.tooltipPos = [point.plotX, point.plotY];
          point.ttBelow = point.plotY > xAxis.center[1];
        }
      }
    });
    /**
     * Align column data labels outside the columns. #1199.
     */

    wrap$c(colProto$1, 'alignDataLabel', function (proceed, point, dataLabel, options, alignTo, isNew) {
      if (this.chart.polar) {
        var angle = point.rectPlotX / Math.PI * 180,
            align,
            verticalAlign; // Align nicely outside the perimeter of the columns

        if (options.align === null) {
          if (angle > 20 && angle < 160) {
            align = 'left'; // right hemisphere
          } else if (angle > 200 && angle < 340) {
            align = 'right'; // left hemisphere
          } else {
            align = 'center'; // top or bottom
          }

          options.align = align;
        }

        if (options.verticalAlign === null) {
          if (angle < 45 || angle > 315) {
            verticalAlign = 'bottom'; // top part
          } else if (angle > 135 && angle < 225) {
            verticalAlign = 'top'; // bottom part
          } else {
            verticalAlign = 'middle'; // left or right
          }

          options.verticalAlign = verticalAlign;
        }

        seriesProto$3.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
      } else {
        proceed.call(this, point, dataLabel, options, alignTo, isNew);
      }
    });
  }
  /**
   * Extend getCoordinates to prepare for polar axis values
   */


  wrap$c(pointerProto, 'getCoordinates', function (proceed, e) {
    var chart = this.chart,
        ret = {
      xAxis: [],
      yAxis: []
    };

    if (chart.polar) {
      each$J(chart.axes, function (axis) {
        var isXAxis = axis.isXAxis,
            center = axis.center,
            x = e.chartX - center[0] - chart.plotLeft,
            y = e.chartY - center[1] - chart.plotTop;
        ret[isXAxis ? 'xAxis' : 'yAxis'].push({
          axis: axis,
          value: axis.translate(isXAxis ? Math.PI - Math.atan2(x, y) : // angle
          // distance from center
          Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), true)
        });
      });
    } else {
      ret = proceed.call(this, e);
    }

    return ret;
  });

  Highcharts.SVGRenderer.prototype.clipCircle = function (x, y, r) {
    var wrapper,
        id = Highcharts.uniqueKey(),
        clipPath = this.createElement('clipPath').attr({
      id: id
    }).add(this.defs);
    wrapper = this.circle(x, y, r).add(clipPath);
    wrapper.id = id;
    wrapper.clipPath = clipPath;
    return wrapper;
  };

  Highcharts.addEvent(Highcharts.Chart, 'getAxes', function () {
    if (!this.pane) {
      this.pane = [];
    }

    each$J(Highcharts.splat(this.options.pane), function (paneOptions) {
      new Highcharts.Pane( // eslint-disable-line no-new
      paneOptions, this);
    }, this);
  });
  Highcharts.addEvent(Highcharts.Chart, 'afterDrawChartBox', function () {
    each$J(this.pane, function (pane) {
      pane.render();
    });
  });
  /**
   * Extend chart.get to also search in panes. Used internally in
   * responsiveness and chart.update.
   */

  wrap$c(Highcharts.Chart.prototype, 'get', function (proceed, id) {
    return Highcharts.find(this.pane, function (pane) {
      return pane.options.id === id;
    }) || proceed.call(this, id);
  });
}

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 *
 * (c) 2009-2016 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 *    Mathematical Functionility
 */

var deg2rad$4 = Highcharts.deg2rad,
    pick$G = Highcharts.pick;
/* eslint-disable max-len */

/**
 * Apply 3-D rotation
 * Euler Angles (XYZ):
 *     cosA = cos(Alfa|Roll)
 *     cosB = cos(Beta|Pitch)
 *     cosG = cos(Gamma|Yaw)
 *
 * Composite rotation:
 * |          cosB * cosG             |           cosB * sinG            |    -sinB    |
 * | sinA * sinB * cosG - cosA * sinG | sinA * sinB * sinG + cosA * cosG | sinA * cosB |
 * | cosA * sinB * cosG + sinA * sinG | cosA * sinB * sinG - sinA * cosG | cosA * cosB |
 *
 * Now, Gamma/Yaw is not used (angle=0), so we assume cosG = 1 and sinG = 0, so
 * we get:
 * |     cosB    |   0    |   - sinB    |
 * | sinA * sinB |  cosA  | sinA * cosB |
 * | cosA * sinB | - sinA | cosA * cosB |
 *
 * But in browsers, y is reversed, so we get sinA => -sinA. The general result
 * is:
 * |      cosB     |   0    |    - sinB     |     | x |     | px |
 * | - sinA * sinB |  cosA  | - sinA * cosB |  x  | y |  =  | py |
 * |  cosA * sinB  |  sinA  |  cosA * cosB  |     | z |     | pz |
 */

/* eslint-enable max-len */

function rotate3D(x, y, z, angles) {
  return {
    x: angles.cosB * x - angles.sinB * z,
    y: -angles.sinA * angles.sinB * x + angles.cosA * y - angles.cosB * angles.sinA * z,
    z: angles.cosA * angles.sinB * x + angles.sinA * y + angles.cosA * angles.cosB * z
  };
} // Perspective3D function is available in global Highcharts scope because is
// needed also outside of perspective() function (#8042).


Highcharts.perspective3D = function (coordinate, origin, distance) {
  var projection = distance > 0 && distance < Number.POSITIVE_INFINITY ? distance / (coordinate.z + origin.z + distance) : 1;
  return {
    x: coordinate.x * projection,
    y: coordinate.y * projection
  };
};
/**
 * Transforms a given array of points according to the angles in chart.options.
 * Parameters:
 *        - points: the array of points
 *        - chart: the chart
 *        - insidePlotArea: wether to verifiy the points are inside the plotArea
 * Returns:
 *        - an array of transformed points
 */


Highcharts.perspective = function (points, chart, insidePlotArea) {
  var options3d = chart.options.chart.options3d,
      inverted = insidePlotArea ? chart.inverted : false,
      origin = {
    x: chart.plotWidth / 2,
    y: chart.plotHeight / 2,
    z: options3d.depth / 2,
    vd: pick$G(options3d.depth, 1) * pick$G(options3d.viewDistance, 0)
  },
      scale = chart.scale3d || 1,
      beta = deg2rad$4 * options3d.beta * (inverted ? -1 : 1),
      alpha = deg2rad$4 * options3d.alpha * (inverted ? -1 : 1),
      angles = {
    cosA: Math.cos(alpha),
    cosB: Math.cos(-beta),
    sinA: Math.sin(alpha),
    sinB: Math.sin(-beta)
  };

  if (!insidePlotArea) {
    origin.x += chart.plotLeft;
    origin.y += chart.plotTop;
  } // Transform each point


  return Highcharts.map(points, function (point) {
    var rotated = rotate3D((inverted ? point.y : point.x) - origin.x, (inverted ? point.x : point.y) - origin.y, (point.z || 0) - origin.z, angles),
        // Apply perspective
    coordinate = Highcharts.perspective3D(rotated, origin, origin.vd); // Apply translation

    coordinate.x = coordinate.x * scale + origin.x;
    coordinate.y = coordinate.y * scale + origin.y;
    coordinate.z = rotated.z * scale + origin.z;
    return {
      x: inverted ? coordinate.y : coordinate.x,
      y: inverted ? coordinate.x : coordinate.y,
      z: coordinate.z
    };
  });
};
/**
 * Calculate a distance from camera to points - made for calculating zIndex of
 * scatter points.
 * Parameters:
 *        - coordinates: The coordinates of the specific point
 *        - chart: the chart
 * Returns:
 *        - a distance from camera to point
 */


Highcharts.pointCameraDistance = function (coordinates, chart) {
  var options3d = chart.options.chart.options3d,
      cameraPosition = {
    x: chart.plotWidth / 2,
    y: chart.plotHeight / 2,
    z: pick$G(options3d.depth, 1) * pick$G(options3d.viewDistance, 0) + options3d.depth
  },
      distance = Math.sqrt(Math.pow(cameraPosition.x - coordinates.plotX, 2) + Math.pow(cameraPosition.y - coordinates.plotY, 2) + Math.pow(cameraPosition.z - coordinates.plotZ, 2));
  return distance;
};
/**
 * Calculate area of a 2D polygon using Shoelace algorithm
 * http://en.wikipedia.org/wiki/Shoelace_formula
 */


Highcharts.shapeArea = function (vertexes) {
  var area = 0,
      i,
      j;

  for (i = 0; i < vertexes.length; i++) {
    j = (i + 1) % vertexes.length;
    area += vertexes[i].x * vertexes[j].y - vertexes[j].x * vertexes[i].y;
  }

  return area / 2;
};
/**
 * Calculate area of a 3D polygon after perspective projection
 */


Highcharts.shapeArea3d = function (vertexes, chart, insidePlotArea) {
  return Highcharts.shapeArea(Highcharts.perspective(vertexes, chart, insidePlotArea));
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var cos = Math.cos,
    PI = Math.PI,
    sin = Math.sin;
var animObject$4 = Highcharts.animObject,
    charts$6 = Highcharts.charts,
    color$8 = Highcharts.color,
    defined$m = Highcharts.defined,
    deg2rad$5 = Highcharts.deg2rad,
    each$K = Highcharts.each,
    extend$o = Highcharts.extend,
    inArray$7 = Highcharts.inArray,
    map$9 = Highcharts.map,
    merge$s = Highcharts.merge,
    perspective = Highcharts.perspective,
    pick$H = Highcharts.pick,
    SVGElement$3 = Highcharts.SVGElement,
    SVGRenderer$4 = Highcharts.SVGRenderer,
    wrap$d = Highcharts.wrap;
/*
    EXTENSION TO THE SVG-RENDERER TO ENABLE 3D SHAPES
*/
// HELPER METHODS //

var dFactor = 4 * (Math.sqrt(2) - 1) / 3 / (PI / 2);
/** Method to construct a curved path
  * Can 'wrap' around more then 180 degrees
  */

function curveTo(cx, cy, rx, ry, start, end, dx, dy) {
  var result = [],
      arcAngle = end - start;

  if (end > start && end - start > Math.PI / 2 + 0.0001) {
    result = result.concat(curveTo(cx, cy, rx, ry, start, start + Math.PI / 2, dx, dy));
    result = result.concat(curveTo(cx, cy, rx, ry, start + Math.PI / 2, end, dx, dy));
    return result;
  }

  if (end < start && start - end > Math.PI / 2 + 0.0001) {
    result = result.concat(curveTo(cx, cy, rx, ry, start, start - Math.PI / 2, dx, dy));
    result = result.concat(curveTo(cx, cy, rx, ry, start - Math.PI / 2, end, dx, dy));
    return result;
  }

  return ['C', cx + rx * Math.cos(start) - rx * dFactor * arcAngle * Math.sin(start) + dx, cy + ry * Math.sin(start) + ry * dFactor * arcAngle * Math.cos(start) + dy, cx + rx * Math.cos(end) + rx * dFactor * arcAngle * Math.sin(end) + dx, cy + ry * Math.sin(end) - ry * dFactor * arcAngle * Math.cos(end) + dy, cx + rx * Math.cos(end) + dx, cy + ry * Math.sin(end) + dy];
}
/**
 * Override the SVGRenderer initiator to add definitions used by brighter and
 * darker faces of the cuboids.
 */


wrap$d(SVGRenderer$4.prototype, 'init', function (proceed) {
  proceed.apply(this, [].slice.call(arguments, 1));
  each$K([{
    name: 'darker',
    slope: 0.6
  }, {
    name: 'brighter',
    slope: 1.4
  }], function (cfg) {
    this.definition({
      tagName: 'filter',
      id: 'highcharts-' + cfg.name,
      children: [{
        tagName: 'feComponentTransfer',
        children: [{
          tagName: 'feFuncR',
          type: 'linear',
          slope: cfg.slope
        }, {
          tagName: 'feFuncG',
          type: 'linear',
          slope: cfg.slope
        }, {
          tagName: 'feFuncB',
          type: 'linear',
          slope: cfg.slope
        }]
      }]
    });
  }, this);
});

SVGRenderer$4.prototype.toLinePath = function (points, closed) {
  var result = []; // Put "L x y" for each point

  each$K(points, function (point) {
    result.push('L', point.x, point.y);
  });

  if (points.length) {
    // Set the first element to M
    result[0] = 'M'; // If it is a closed line, add Z

    if (closed) {
      result.push('Z');
    }
  }

  return result;
};

SVGRenderer$4.prototype.toLineSegments = function (points) {
  var result = [];
  var m = true;
  each$K(points, function (point) {
    result.push(m ? 'M' : 'L', point.x, point.y);
    m = !m;
  });
  return result;
};
/**
 * A 3-D Face is defined by it's 3D vertexes, and is only
 * visible if it's vertexes are counter-clockwise (Back-face culling).
 * It is used as a polyhedron Element
 */


SVGRenderer$4.prototype.face3d = function (args) {
  var renderer = this,
      ret = this.createElement('path');
  ret.vertexes = [];
  ret.insidePlotArea = false;
  ret.enabled = true;
  wrap$d(ret, 'attr', function (proceed, hash) {
    if (typeof hash === 'object' && (defined$m(hash.enabled) || defined$m(hash.vertexes) || defined$m(hash.insidePlotArea))) {
      this.enabled = pick$H(hash.enabled, this.enabled);
      this.vertexes = pick$H(hash.vertexes, this.vertexes);
      this.insidePlotArea = pick$H(hash.insidePlotArea, this.insidePlotArea);
      delete hash.enabled;
      delete hash.vertexes;
      delete hash.insidePlotArea;
      var chart = charts$6[renderer.chartIndex],
          vertexes2d = perspective(this.vertexes, chart, this.insidePlotArea),
          path = renderer.toLinePath(vertexes2d, true),
          area = Highcharts.shapeArea(vertexes2d),
          visibility = this.enabled && area > 0 ? 'visible' : 'hidden';
      hash.d = path;
      hash.visibility = visibility;
    }

    return proceed.apply(this, [].slice.call(arguments, 1));
  });
  wrap$d(ret, 'animate', function (proceed, params) {
    if (typeof params === 'object' && (defined$m(params.enabled) || defined$m(params.vertexes) || defined$m(params.insidePlotArea))) {
      this.enabled = pick$H(params.enabled, this.enabled);
      this.vertexes = pick$H(params.vertexes, this.vertexes);
      this.insidePlotArea = pick$H(params.insidePlotArea, this.insidePlotArea);
      delete params.enabled;
      delete params.vertexes;
      delete params.insidePlotArea;
      var chart = charts$6[renderer.chartIndex],
          vertexes2d = perspective(this.vertexes, chart, this.insidePlotArea),
          path = renderer.toLinePath(vertexes2d, true),
          area = Highcharts.shapeArea(vertexes2d),
          visibility = this.enabled && area > 0 ? 'visible' : 'hidden';
      params.d = path;
      this.attr('visibility', visibility);
    }

    return proceed.apply(this, [].slice.call(arguments, 1));
  });
  return ret.attr(args);
};
/**
 * A Polyhedron is a handy way of defining a group of 3-D faces. It's only
 * attribute is `faces`, an array of attributes of each one of it's Face3D
 * instances.
 */


SVGRenderer$4.prototype.polyhedron = function (args) {
  var renderer = this,
      result = this.g(),
      destroy = result.destroy;
  result.faces = []; // destroy all children

  result.destroy = function () {
    for (var i = 0; i < result.faces.length; i++) {
      result.faces[i].destroy();
    }

    return destroy.call(this);
  };

  wrap$d(result, 'attr', function (proceed, hash, val, complete, continueAnimation) {
    if (typeof hash === 'object' && defined$m(hash.faces)) {
      while (result.faces.length > hash.faces.length) {
        result.faces.pop().destroy();
      }

      while (result.faces.length < hash.faces.length) {
        result.faces.push(renderer.face3d().add(result));
      }

      for (var i = 0; i < hash.faces.length; i++) {
        result.faces[i].attr(hash.faces[i], null, complete, continueAnimation);
      }

      delete hash.faces;
    }

    return proceed.apply(this, [].slice.call(arguments, 1));
  });
  wrap$d(result, 'animate', function (proceed, params, duration, complete) {
    if (params && params.faces) {
      while (result.faces.length > params.faces.length) {
        result.faces.pop().destroy();
      }

      while (result.faces.length < params.faces.length) {
        result.faces.push(renderer.face3d().add(result));
      }

      for (var i = 0; i < params.faces.length; i++) {
        result.faces[i].animate(params.faces[i], duration, complete);
      }

      delete params.faces;
    }

    return proceed.apply(this, [].slice.call(arguments, 1));
  });
  return result.attr(args);
}; // CUBOIDS //


SVGRenderer$4.prototype.cuboid = function (shapeArgs) {
  var result = this.g(),
      destroy = result.destroy,
      paths = this.cuboidPath(shapeArgs); // Create the 3 sides. // Front, top and side are never overlapping in our
  // case so it is redundant to set zIndex of every element.

  result.front = this.path(paths[0]).attr({
    'class': 'highcharts-3d-front'
  }).add(result);
  result.top = this.path(paths[1]).attr({
    'class': 'highcharts-3d-top'
  }).add(result);
  result.side = this.path(paths[2]).attr({
    'class': 'highcharts-3d-side'
  }).add(result); // apply the fill everywhere, the top a bit brighter, the side a bit darker

  result.fillSetter = function (fill) {
    this.front.attr({
      fill: fill
    });
    this.top.attr({
      fill: color$8(fill).brighten(0.1).get()
    });
    this.side.attr({
      fill: color$8(fill).brighten(-0.1).get()
    });
    this.color = fill; // for animation getter (#6776)

    result.fill = fill;
    return this;
  }; // apply opacaity everywhere


  result.opacitySetter = function (opacity) {
    this.front.attr({
      opacity: opacity
    });
    this.top.attr({
      opacity: opacity
    });
    this.side.attr({
      opacity: opacity
    });
    return this;
  };

  result.attr = function (args, val, complete, continueAnimation) {
    // Resolve setting attributes by string name
    if (typeof args === 'string' && typeof val !== 'undefined') {
      var key = args;
      args = {};
      args[key] = val;
    }

    if (args.shapeArgs || defined$m(args.x)) {
      var shapeArgs = args.shapeArgs || args;
      var paths = this.renderer.cuboidPath(shapeArgs);
      this.front.attr({
        d: paths[0]
      });
      this.top.attr({
        d: paths[1]
      });
      this.side.attr({
        d: paths[2]
      });
    } else {
      // getter returns value
      return SVGElement$3.prototype.attr.call(this, args, undefined, complete, continueAnimation);
    }

    return this;
  };

  result.animate = function (args, duration, complete) {
    if (defined$m(args.x) && defined$m(args.y)) {
      var paths = this.renderer.cuboidPath(args);
      this.front.animate({
        d: paths[0]
      }, duration, complete);
      this.top.animate({
        d: paths[1]
      }, duration, complete);
      this.side.animate({
        d: paths[2]
      }, duration, complete);
      this.attr({
        zIndex: -paths[3] // #4774

      });
    } else if (args.opacity) {
      this.front.animate(args, duration, complete);
      this.top.animate(args, duration, complete);
      this.side.animate(args, duration, complete);
    } else {
      SVGElement$3.prototype.animate.call(this, args, duration, complete);
    }

    return this;
  }; // destroy all children


  result.destroy = function () {
    this.front.destroy();
    this.top.destroy();
    this.side.destroy();
    return destroy.call(this);
  }; // Apply the Z index to the cuboid group


  result.attr({
    zIndex: -paths[3]
  });
  return result;
};
/**
 *    Generates a cuboid
 */


Highcharts.SVGRenderer.prototype.cuboidPath = function (shapeArgs) {
  var x = shapeArgs.x,
      y = shapeArgs.y,
      z = shapeArgs.z,
      h = shapeArgs.height,
      w = shapeArgs.width,
      d = shapeArgs.depth,
      chart = charts$6[this.chartIndex],
      front,
      back,
      top,
      bottom,
      left,
      right,
      shape,
      path1,
      path2,
      path3,
      isFront,
      isTop,
      isRight,
      options3d = chart.options.chart.options3d,
      alpha = options3d.alpha,
      // Priority for x axis is the biggest,
  // because of x direction has biggest influence on zIndex
  incrementX = 10000,
      // y axis has the smallest priority in case of our charts
  // (needs to be set because of stacking)
  incrementY = 10,
      incrementZ = 100,
      zIndex = 0; // The 8 corners of the cube

  var pArr = [{
    x: x,
    y: y,
    z: z
  }, {
    x: x + w,
    y: y,
    z: z
  }, {
    x: x + w,
    y: y + h,
    z: z
  }, {
    x: x,
    y: y + h,
    z: z
  }, {
    x: x,
    y: y + h,
    z: z + d
  }, {
    x: x + w,
    y: y + h,
    z: z + d
  }, {
    x: x + w,
    y: y,
    z: z + d
  }, {
    x: x,
    y: y,
    z: z + d
  }]; // apply perspective

  pArr = perspective(pArr, chart, shapeArgs.insidePlotArea); // helper method to decide which side is visible

  function mapPath(i) {
    return pArr[i];
  }
  /*
   * First value - path with specific side
   * Second  value - added information about side for later calculations.
   * Possible second values are 0 for path1, 1 for path2 and -1 for no path
   * chosen.
   */


  var pickShape = function (path1, path2) {
    var ret = [[], -1];
    path1 = map$9(path1, mapPath);
    path2 = map$9(path2, mapPath);

    if (Highcharts.shapeArea(path1) < 0) {
      ret = [path1, 0];
    } else if (Highcharts.shapeArea(path2) < 0) {
      ret = [path2, 1];
    }

    return ret;
  }; // front or back


  front = [3, 2, 1, 0];
  back = [7, 6, 5, 4];
  shape = pickShape(front, back);
  path1 = shape[0];
  isFront = shape[1]; // top or bottom

  top = [1, 6, 7, 0];
  bottom = [4, 5, 2, 3];
  shape = pickShape(top, bottom);
  path2 = shape[0];
  isTop = shape[1]; // side

  right = [1, 2, 5, 6];
  left = [0, 7, 4, 3];
  shape = pickShape(right, left);
  path3 = shape[0];
  isRight = shape[1];
  /*
   * New block used for calculating zIndex. It is basing on X, Y and Z
   * position of specific columns. All zIndexes (for X, Y and Z values) are
   * added to the final zIndex, where every value has different priority. The
   * biggest priority is in X and Z directions, the lowest index is for
   * stacked columns (Y direction and the same X and Z positions). Big
   * differences between priorities is made because we need to ensure that
   * even for big changes in Y and Z parameters all columns will be drawn
   * correctly.
   */

  if (isRight === 1) {
    zIndex += incrementX * (1000 - x);
  } else if (!isRight) {
    zIndex += incrementX * x;
  }

  zIndex += incrementY * (!isTop || // Numbers checked empirically
  alpha >= 0 && alpha <= 180 || alpha < 360 && alpha > 357.5 ? chart.plotHeight - y : 10 + y);

  if (isFront === 1) {
    zIndex += incrementZ * z;
  } else if (!isFront) {
    zIndex += incrementZ * (1000 - z);
  }

  zIndex = -Math.round(zIndex);
  return [this.toLinePath(path1, true), this.toLinePath(path2, true), this.toLinePath(path3, true), zIndex]; // #4774
}; // SECTORS //


Highcharts.SVGRenderer.prototype.arc3d = function (attribs) {
  var wrapper = this.g(),
      renderer = wrapper.renderer,
      customAttribs = ['x', 'y', 'r', 'innerR', 'start', 'end'];
  /**
   * Get custom attributes. Don't mutate the original object and return an
   * object with only custom attr.
   */

  function suckOutCustom(params) {
    var hasCA = false,
        ca = {};
    params = merge$s(params); // Don't mutate the original object

    for (var key in params) {
      if (inArray$7(key, customAttribs) !== -1) {
        ca[key] = params[key];
        delete params[key];
        hasCA = true;
      }
    }

    return hasCA ? ca : false;
  }

  attribs = merge$s(attribs);
  attribs.alpha = (attribs.alpha || 0) * deg2rad$5;
  attribs.beta = (attribs.beta || 0) * deg2rad$5; // Create the different sub sections of the shape

  wrapper.top = renderer.path();
  wrapper.side1 = renderer.path();
  wrapper.side2 = renderer.path();
  wrapper.inn = renderer.path();
  wrapper.out = renderer.path();
  /**
   * Add all faces
   */

  wrapper.onAdd = function () {
    var parent = wrapper.parentGroup,
        className = wrapper.attr('class');
    wrapper.top.add(wrapper); // These faces are added outside the wrapper group because the z index
    // relates to neighbour elements as well

    each$K(['out', 'inn', 'side1', 'side2'], function (face) {
      wrapper[face].attr({
        'class': className + ' highcharts-3d-side'
      }).add(parent);
    });
  }; // Cascade to faces


  each$K(['addClass', 'removeClass'], function (fn) {
    wrapper[fn] = function () {
      var args = arguments;
      each$K(['top', 'out', 'inn', 'side1', 'side2'], function (face) {
        wrapper[face][fn].apply(wrapper[face], args);
      });
    };
  });
  /**
   * Compute the transformed paths and set them to the composite shapes
   */

  wrapper.setPaths = function (attribs) {
    var paths = wrapper.renderer.arc3dPath(attribs),
        zIndex = paths.zTop * 100;
    wrapper.attribs = attribs;
    wrapper.top.attr({
      d: paths.top,
      zIndex: paths.zTop
    });
    wrapper.inn.attr({
      d: paths.inn,
      zIndex: paths.zInn
    });
    wrapper.out.attr({
      d: paths.out,
      zIndex: paths.zOut
    });
    wrapper.side1.attr({
      d: paths.side1,
      zIndex: paths.zSide1
    });
    wrapper.side2.attr({
      d: paths.side2,
      zIndex: paths.zSide2
    }); // show all children

    wrapper.zIndex = zIndex;
    wrapper.attr({
      zIndex: zIndex
    }); // Set the radial gradient center the first time

    if (attribs.center) {
      wrapper.top.setRadialReference(attribs.center);
      delete attribs.center;
    }
  };

  wrapper.setPaths(attribs); // Apply the fill to the top and a darker shade to the sides

  wrapper.fillSetter = function (value) {
    var darker = color$8(value).brighten(-0.1).get();
    this.fill = value;
    this.side1.attr({
      fill: darker
    });
    this.side2.attr({
      fill: darker
    });
    this.inn.attr({
      fill: darker
    });
    this.out.attr({
      fill: darker
    });
    this.top.attr({
      fill: value
    });
    return this;
  }; // Apply the same value to all. These properties cascade down to the
  // children when set to the composite arc3d.


  each$K(['opacity', 'translateX', 'translateY', 'visibility'], function (setter) {
    wrapper[setter + 'Setter'] = function (value, key) {
      wrapper[key] = value;
      each$K(['out', 'inn', 'side1', 'side2', 'top'], function (el) {
        wrapper[el].attr(key, value);
      });
    };
  });
  /**
   * Override attr to remove shape attributes and use those to set child paths
   */

  wrap$d(wrapper, 'attr', function (proceed, params) {
    var ca;

    if (typeof params === 'object') {
      ca = suckOutCustom(params);

      if (ca) {
        extend$o(wrapper.attribs, ca);
        wrapper.setPaths(wrapper.attribs);
      }
    }

    return proceed.apply(this, [].slice.call(arguments, 1));
  });
  /**
   * Override the animate function by sucking out custom parameters related to
   * the shapes directly, and update the shapes from the animation step.
   */

  wrap$d(wrapper, 'animate', function (proceed, params, animation, complete) {
    var ca,
        from = this.attribs,
        to,
        anim,
        randomProp = 'data-' + Math.random().toString(26).substring(2, 9); // Attribute-line properties connected to 3D. These shouldn't have been
    // in the attribs collection in the first place.

    delete params.center;
    delete params.z;
    delete params.depth;
    delete params.alpha;
    delete params.beta;
    anim = animObject$4(pick$H(animation, this.renderer.globalAnimation));

    if (anim.duration) {
      ca = suckOutCustom(params); // Params need to have a property in order for the step to run
      // (#5765, #7097, #7437)

      wrapper[randomProp] = 0;
      params[randomProp] = 1;
      wrapper[randomProp + 'Setter'] = Highcharts.noop;

      if (ca) {
        to = ca;

        anim.step = function (a, fx) {
          function interpolate(key) {
            return from[key] + (pick$H(to[key], from[key]) - from[key]) * fx.pos;
          }

          if (fx.prop === randomProp) {
            fx.elem.setPaths(merge$s(from, {
              x: interpolate('x'),
              y: interpolate('y'),
              r: interpolate('r'),
              innerR: interpolate('innerR'),
              start: interpolate('start'),
              end: interpolate('end')
            }));
          }
        };
      }

      animation = anim; // Only when duration (#5572)
    }

    return proceed.call(this, params, animation, complete);
  }); // destroy all children

  wrapper.destroy = function () {
    this.top.destroy();
    this.out.destroy();
    this.inn.destroy();
    this.side1.destroy();
    this.side2.destroy();
    SVGElement$3.prototype.destroy.call(this);
  }; // hide all children


  wrapper.hide = function () {
    this.top.hide();
    this.out.hide();
    this.inn.hide();
    this.side1.hide();
    this.side2.hide();
  };

  wrapper.show = function () {
    this.top.show();
    this.out.show();
    this.inn.show();
    this.side1.show();
    this.side2.show();
  };

  return wrapper;
};
/**
 * Generate the paths required to draw a 3D arc
 */


SVGRenderer$4.prototype.arc3dPath = function (shapeArgs) {
  var cx = shapeArgs.x,
      // x coordinate of the center
  cy = shapeArgs.y,
      // y coordinate of the center
  start = shapeArgs.start,
      // start angle
  end = shapeArgs.end - 0.00001,
      // end angle
  r = shapeArgs.r,
      // radius
  ir = shapeArgs.innerR || 0,
      // inner radius
  d = shapeArgs.depth || 0,
      // depth
  alpha = shapeArgs.alpha,
      // alpha rotation of the chart
  beta = shapeArgs.beta; // beta rotation of the chart
  // Derived Variables

  var cs = Math.cos(start),
      // cosinus of the start angle
  ss = Math.sin(start),
      // sinus of the start angle
  ce = Math.cos(end),
      // cosinus of the end angle
  se = Math.sin(end),
      // sinus of the end angle
  rx = r * Math.cos(beta),
      // x-radius
  ry = r * Math.cos(alpha),
      // y-radius
  irx = ir * Math.cos(beta),
      // x-radius (inner)
  iry = ir * Math.cos(alpha),
      // y-radius (inner)
  dx = d * Math.sin(beta),
      // distance between top and bottom in x
  dy = d * Math.sin(alpha); // distance between top and bottom in y
  // TOP

  var top = ['M', cx + rx * cs, cy + ry * ss];
  top = top.concat(curveTo(cx, cy, rx, ry, start, end, 0, 0));
  top = top.concat(['L', cx + irx * ce, cy + iry * se]);
  top = top.concat(curveTo(cx, cy, irx, iry, end, start, 0, 0));
  top = top.concat(['Z']); // OUTSIDE

  var b = beta > 0 ? Math.PI / 2 : 0,
      a = alpha > 0 ? 0 : Math.PI / 2;
  var start2 = start > -b ? start : end > -b ? -b : start,
      end2 = end < PI - a ? end : start < PI - a ? PI - a : end,
      midEnd = 2 * PI - a; // When slice goes over bottom middle, need to add both, left and right
  // outer side. Additionally, when we cross right hand edge, create sharp
  // edge. Outer shape/wall:
  //
  //            -------
  //          /    ^    \
  //    4)   /   /   \   \  1)
  //        /   /     \   \
  //       /   /       \   \
  // (c)=> ====         ==== <=(d)
  //       \   \       /   /
  //        \   \<=(a)/   /
  //         \   \   /   / <=(b)
  //    3)    \    v    /  2)
  //            -------
  //
  // (a) - inner side
  // (b) - outer side
  // (c) - left edge (sharp)
  // (d) - right edge (sharp)
  // 1..n - rendering order for startAngle = 0, when set to e.g 90, order
  // changes clockwise (1->2, 2->3, n->1) and counterclockwise for negative
  // startAngle

  var out = ['M', cx + rx * cos(start2), cy + ry * sin(start2)];
  out = out.concat(curveTo(cx, cy, rx, ry, start2, end2, 0, 0)); // When shape is wide, it can cross both, (c) and (d) edges, when using
  // startAngle

  if (end > midEnd && start < midEnd) {
    // Go to outer side
    out = out.concat(['L', cx + rx * cos(end2) + dx, cy + ry * sin(end2) + dy]); // Curve to the right edge of the slice (d)

    out = out.concat(curveTo(cx, cy, rx, ry, end2, midEnd, dx, dy)); // Go to the inner side

    out = out.concat(['L', cx + rx * cos(midEnd), cy + ry * sin(midEnd)]); // Curve to the true end of the slice

    out = out.concat(curveTo(cx, cy, rx, ry, midEnd, end, 0, 0)); // Go to the outer side

    out = out.concat(['L', cx + rx * cos(end) + dx, cy + ry * sin(end) + dy]); // Go back to middle (d)

    out = out.concat(curveTo(cx, cy, rx, ry, end, midEnd, dx, dy));
    out = out.concat(['L', cx + rx * cos(midEnd), cy + ry * sin(midEnd)]); // Go back to the left edge

    out = out.concat(curveTo(cx, cy, rx, ry, midEnd, end2, 0, 0)); // But shape can cross also only (c) edge:
  } else if (end > PI - a && start < PI - a) {
    // Go to outer side
    out = out.concat(['L', cx + rx * Math.cos(end2) + dx, cy + ry * Math.sin(end2) + dy]); // Curve to the true end of the slice

    out = out.concat(curveTo(cx, cy, rx, ry, end2, end, dx, dy)); // Go to the inner side

    out = out.concat(['L', cx + rx * Math.cos(end), cy + ry * Math.sin(end)]); // Go back to the artifical end2

    out = out.concat(curveTo(cx, cy, rx, ry, end, end2, 0, 0));
  }

  out = out.concat(['L', cx + rx * Math.cos(end2) + dx, cy + ry * Math.sin(end2) + dy]);
  out = out.concat(curveTo(cx, cy, rx, ry, end2, start2, dx, dy));
  out = out.concat(['Z']); // INSIDE

  var inn = ['M', cx + irx * cs, cy + iry * ss];
  inn = inn.concat(curveTo(cx, cy, irx, iry, start, end, 0, 0));
  inn = inn.concat(['L', cx + irx * Math.cos(end) + dx, cy + iry * Math.sin(end) + dy]);
  inn = inn.concat(curveTo(cx, cy, irx, iry, end, start, dx, dy));
  inn = inn.concat(['Z']); // SIDES

  var side1 = ['M', cx + rx * cs, cy + ry * ss, 'L', cx + rx * cs + dx, cy + ry * ss + dy, 'L', cx + irx * cs + dx, cy + iry * ss + dy, 'L', cx + irx * cs, cy + iry * ss, 'Z'];
  var side2 = ['M', cx + rx * ce, cy + ry * se, 'L', cx + rx * ce + dx, cy + ry * se + dy, 'L', cx + irx * ce + dx, cy + iry * se + dy, 'L', cx + irx * ce, cy + iry * se, 'Z']; // correction for changed position of vanishing point caused by alpha and
  // beta rotations

  var angleCorr = Math.atan2(dy, -dx),
      angleEnd = Math.abs(end + angleCorr),
      angleStart = Math.abs(start + angleCorr),
      angleMid = Math.abs((start + end) / 2 + angleCorr); // set to 0-PI range

  function toZeroPIRange(angle) {
    angle = angle % (2 * Math.PI);

    if (angle > Math.PI) {
      angle = 2 * Math.PI - angle;
    }

    return angle;
  }

  angleEnd = toZeroPIRange(angleEnd);
  angleStart = toZeroPIRange(angleStart);
  angleMid = toZeroPIRange(angleMid); // *1e5 is to compensate pInt in zIndexSetter

  var incPrecision = 1e5,
      a1 = angleMid * incPrecision,
      a2 = angleStart * incPrecision,
      a3 = angleEnd * incPrecision;
  return {
    top: top,
    // max angle is PI, so this is always higher
    zTop: Math.PI * incPrecision + 1,
    out: out,
    zOut: Math.max(a1, a2, a3),
    inn: inn,
    zInn: Math.max(a1, a2, a3),
    side1: side1,
    zSide1: a3 * 0.99,
    // to keep below zOut and zInn in case of same values
    side2: side2,
    zSide2: a2 * 0.99
  };
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * Extension for 3D charts
 *
 * License: www.highcharts.com/license
 */
var addEvent$o = Highcharts.addEvent,
    Chart$b = Highcharts.Chart,
    each$L = Highcharts.each,
    merge$t = Highcharts.merge,
    perspective$1 = Highcharts.perspective,
    pick$I = Highcharts.pick,
    wrap$e = Highcharts.wrap; // Shorthand to check the is3d flag

Chart$b.prototype.is3d = function () {
  return this.options.chart.options3d && this.options.chart.options3d.enabled; // #4280
};

Chart$b.prototype.propsRequireDirtyBox.push('chart.options3d');
Chart$b.prototype.propsRequireUpdateSeries.push('chart.options3d'); // Legacy support for HC < 6 to make 'scatter' series in a 3D chart route to the
// real 'scatter3d' series type.

addEvent$o(Chart$b, 'afterInit', function () {
  var options = this.options;

  if (this.is3d()) {
    each$L(options.series || [], function (s) {
      var type = s.type || options.chart.type || options.chart.defaultSeriesType;

      if (type === 'scatter') {
        s.type = 'scatter3d';
      }
    });
  }
}); // And do it on dynamic add (#8407)

addEvent$o(Chart$b, 'addSeries', function (e) {
  if (this.is3d()) {
    if (e.options.type === 'scatter') {
      e.options.type = 'scatter3d';
    }
  }
});
/**
 * Calculate scale of the 3D view. That is required to
 * fit chart's 3D projection into the actual plotting area. Reported as #4933.
 * @notice This function should ideally take the plot values instead of a chart
 *         object, but since the chart object is needed for perspective it is
 *         not practical. Possible to make both getScale and perspective more
 *         logical and also immutable.
 * @param  {Object} chart Chart object
 * @param  {Number} chart.plotLeft
 * @param  {Number} chart.plotWidth
 * @param  {Number} chart.plotTop
 * @param  {Number} chart.plotHeight
 * @param  {Number} depth The depth of the chart
 * @return {Number} The scale to fit the 3D chart into the plotting area.
 */

function getScale(chart, depth) {
  var plotLeft = chart.plotLeft,
      plotRight = chart.plotWidth + plotLeft,
      plotTop = chart.plotTop,
      plotBottom = chart.plotHeight + plotTop,
      originX = plotLeft + chart.plotWidth / 2,
      originY = plotTop + chart.plotHeight / 2,
      bbox3d = {
    minX: Number.MAX_VALUE,
    maxX: -Number.MAX_VALUE,
    minY: Number.MAX_VALUE,
    maxY: -Number.MAX_VALUE
  },
      corners,
      scale = 1; // Top left corners:

  corners = [{
    x: plotLeft,
    y: plotTop,
    z: 0
  }, {
    x: plotLeft,
    y: plotTop,
    z: depth
  }]; // Top right corners:

  each$L([0, 1], function (i) {
    corners.push({
      x: plotRight,
      y: corners[i].y,
      z: corners[i].z
    });
  }); // All bottom corners:

  each$L([0, 1, 2, 3], function (i) {
    corners.push({
      x: corners[i].x,
      y: plotBottom,
      z: corners[i].z
    });
  }); // Calculate 3D corners:

  corners = perspective$1(corners, chart, false); // Get bounding box of 3D element:

  each$L(corners, function (corner) {
    bbox3d.minX = Math.min(bbox3d.minX, corner.x);
    bbox3d.maxX = Math.max(bbox3d.maxX, corner.x);
    bbox3d.minY = Math.min(bbox3d.minY, corner.y);
    bbox3d.maxY = Math.max(bbox3d.maxY, corner.y);
  }); // Left edge:

  if (plotLeft > bbox3d.minX) {
    scale = Math.min(scale, 1 - Math.abs((plotLeft + originX) / (bbox3d.minX + originX)) % 1);
  } // Right edge:


  if (plotRight < bbox3d.maxX) {
    scale = Math.min(scale, (plotRight - originX) / (bbox3d.maxX - originX));
  } // Top edge:


  if (plotTop > bbox3d.minY) {
    if (bbox3d.minY < 0) {
      scale = Math.min(scale, (plotTop + originY) / (-bbox3d.minY + plotTop + originY));
    } else {
      scale = Math.min(scale, 1 - (plotTop + originY) / (bbox3d.minY + originY) % 1);
    }
  } // Bottom edge:


  if (plotBottom < bbox3d.maxY) {
    scale = Math.min(scale, Math.abs((plotBottom - originY) / (bbox3d.maxY - originY)));
  }

  return scale;
}

Highcharts.wrap(Highcharts.Chart.prototype, 'isInsidePlot', function (proceed) {
  return this.is3d() || proceed.apply(this, [].slice.call(arguments, 1));
});
var defaultOptions$7 = Highcharts.getOptions();
/**
 * @optionparent
 */

var extendedOptions = {
  chart: {
    /**
     * Options to render charts in 3 dimensions. This feature requires
     * `highcharts-3d.js`, found in the download package or online at
     * [code.highcharts.com/highcharts-3d.js](http://code.highcharts.com/highcharts-
     * 3d.js).
     *
     * @since 4.0
     * @product highcharts
     */
    options3d: {
      /**
       * Wether to render the chart using the 3D functionality.
       *
       * @type {Boolean}
       * @default false
       * @since 4.0
       * @product highcharts
       */
      enabled: false,

      /**
       * One of the two rotation angles for the chart.
       *
       * @type {Number}
       * @default 0
       * @since 4.0
       * @product highcharts
       */
      alpha: 0,

      /**
       * One of the two rotation angles for the chart.
       *
       * @type {Number}
       * @default 0
       * @since 4.0
       * @product highcharts
       */
      beta: 0,

      /**
       * The total depth of the chart.
       *
       * @type {Number}
       * @default 100
       * @since 4.0
       * @product highcharts
       */
      depth: 100,

      /**
       * Whether the 3d box should automatically adjust to the chart plot
       * area.
       *
       * @type {Boolean}
       * @default true
       * @since 4.2.4
       * @product highcharts
       */
      fitToPlot: true,

      /**
       * Defines the distance the viewer is standing in front of the
       * chart, this setting is important to calculate the perspective
       * effect in column and scatter charts. It is not used for 3D pie
       * charts.
       *
       * @type {Number}
       * @default 100
       * @since 4.0
       * @product highcharts
       */
      viewDistance: 25,

      /**
       * Set it to `"auto"` to automatically move the labels to the best
       * edge.
       *
       * @validvalue [null, "auto"]
       * @type {String}
       * @since 5.0.12
       * @product highcharts
       */
      axisLabelPosition: null,

      /**
       * Provides the option to draw a frame around the charts by defining
       * a bottom, front and back panel.
       *
       * @since 4.0
       * @product highcharts
       */
      frame: {
        /**
         * Whether the frames are visible.
         */
        visible: 'default',

        /**
         * General pixel thickness for the frame faces.
         */
        size: 1,

        /**
         * The bottom of the frame around a 3D chart.
         *
         * @since 4.0
         * @product highcharts
         */

        /**
         * The color of the panel.
         *
         * @type {Color}
         * @default transparent
         * @since 4.0
         * @product highcharts
         * @apioption chart.options3d.frame.bottom.color
         */

        /**
         * The thickness of the panel.
         *
         * @type {Number}
         * @default 1
         * @since 4.0
         * @product highcharts
         * @apioption chart.options3d.frame.bottom.size
         */

        /**
         * Whether to display the frame. Possible values are `true`,
         * `false`, `"auto"` to display only the frames behind the data,
         * and `"default"` to display faces behind the data based on the
         * axis layout, ignoring the point of view.
         *
         * @validvalue ["default", "auto", true, false]
         * @type {Boolean|String}
         * @sample {highcharts} highcharts/3d/scatter-frame/ Auto frames
         * @default default
         * @since 5.0.12
         * @product highcharts
         * @apioption chart.options3d.frame.bottom.visible
         */

        /**
         * The bottom of the frame around a 3D chart.
         */
        bottom: {},

        /**
         * The top of the frame around a 3D chart.
         *
         * @extends chart.options3d.frame.bottom
         */
        top: {},

        /**
         * The left side of the frame around a 3D chart.
         *
         * @extends chart.options3d.frame.bottom
         */
        left: {},

        /**
         * The right of the frame around a 3D chart.
         *
         * @extends chart.options3d.frame.bottom
         */
        right: {},

        /**
         * The back side of the frame around a 3D chart.
         *
         * @extends chart.options3d.frame.bottom
         */
        back: {},

        /**
         * The front of the frame around a 3D chart.
         *
         * @extends chart.options3d.frame.bottom
         */
        front: {}
      }
    }
  }
};
merge$t(true, defaultOptions$7, extendedOptions);
/**
 * Add the required CSS classes for column sides (#6018)
 */

addEvent$o(Chart$b, 'afterGetContainer', function () {
  this.renderer.definition({
    tagName: 'style',
    textContent: '.highcharts-3d-top{' + 'filter: url(#highcharts-brighter)' + '}\n' + '.highcharts-3d-side{' + 'filter: url(#highcharts-darker)' + '}\n'
  });
});
wrap$e(Chart$b.prototype, 'setClassName', function (proceed) {
  proceed.apply(this, [].slice.call(arguments, 1));

  if (this.is3d()) {
    this.container.className += ' highcharts-3d-chart';
  }
});
addEvent$o(Highcharts.Chart, 'afterSetChartSize', function () {
  var chart = this,
      options3d = chart.options.chart.options3d;

  if (chart.is3d()) {
    var inverted = chart.inverted,
        clipBox = chart.clipBox,
        margin = chart.margin,
        x = inverted ? 'y' : 'x',
        y = inverted ? 'x' : 'y',
        w = inverted ? 'height' : 'width',
        h = inverted ? 'width' : 'height';
    clipBox[x] = -(margin[3] || 0);
    clipBox[y] = -(margin[0] || 0);
    clipBox[w] = chart.chartWidth + (margin[3] || 0) + (margin[1] || 0);
    clipBox[h] = chart.chartHeight + (margin[0] || 0) + (margin[2] || 0); // Set scale, used later in perspective method():
    // getScale uses perspective, so scale3d has to be reset.

    chart.scale3d = 1;

    if (options3d.fitToPlot === true) {
      chart.scale3d = getScale(chart, options3d.depth);
    } // Recalculate the 3d frame with every call of setChartSize,
    // instead of doing it after every redraw(). It avoids ticks
    // and axis title outside of chart.


    chart.frame3d = this.get3dFrame(); // #7942
  }
});
addEvent$o(Chart$b, 'beforeRedraw', function () {
  if (this.is3d()) {
    // Set to force a redraw of all elements
    this.isDirtyBox = true;
  }
});
addEvent$o(Chart$b, 'beforeRender', function () {
  if (this.is3d()) {
    this.frame3d = this.get3dFrame();
  }
}); // Draw the series in the reverse order (#3803, #3917)

wrap$e(Chart$b.prototype, 'renderSeries', function (proceed) {
  var series,
      i = this.series.length;

  if (this.is3d()) {
    while (i--) {
      series = this.series[i];
      series.translate();
      series.render();
    }
  } else {
    proceed.call(this);
  }
});
addEvent$o(Chart$b, 'afterDrawChartBox', function () {
  if (this.is3d()) {
    var chart = this,
        renderer = chart.renderer,
        options3d = this.options.chart.options3d,
        frame = chart.get3dFrame(),
        xm = this.plotLeft,
        xp = this.plotLeft + this.plotWidth,
        ym = this.plotTop,
        yp = this.plotTop + this.plotHeight,
        zm = 0,
        zp = options3d.depth,
        xmm = xm - (frame.left.visible ? frame.left.size : 0),
        xpp = xp + (frame.right.visible ? frame.right.size : 0),
        ymm = ym - (frame.top.visible ? frame.top.size : 0),
        ypp = yp + (frame.bottom.visible ? frame.bottom.size : 0),
        zmm = zm - (frame.front.visible ? frame.front.size : 0),
        zpp = zp + (frame.back.visible ? frame.back.size : 0),
        verb = chart.hasRendered ? 'animate' : 'attr';
    this.frame3d = frame;

    if (!this.frameShapes) {
      this.frameShapes = {
        bottom: renderer.polyhedron().add(),
        top: renderer.polyhedron().add(),
        left: renderer.polyhedron().add(),
        right: renderer.polyhedron().add(),
        back: renderer.polyhedron().add(),
        front: renderer.polyhedron().add()
      };
    }

    this.frameShapes.bottom[verb]({
      'class': 'highcharts-3d-frame highcharts-3d-frame-bottom',
      zIndex: frame.bottom.frontFacing ? -1000 : 1000,
      faces: [{
        // bottom
        fill: Highcharts.color(frame.bottom.color).brighten(0.1).get(),
        vertexes: [{
          x: xmm,
          y: ypp,
          z: zmm
        }, {
          x: xpp,
          y: ypp,
          z: zmm
        }, {
          x: xpp,
          y: ypp,
          z: zpp
        }, {
          x: xmm,
          y: ypp,
          z: zpp
        }],
        enabled: frame.bottom.visible
      }, {
        // top
        fill: Highcharts.color(frame.bottom.color).brighten(0.1).get(),
        vertexes: [{
          x: xm,
          y: yp,
          z: zp
        }, {
          x: xp,
          y: yp,
          z: zp
        }, {
          x: xp,
          y: yp,
          z: zm
        }, {
          x: xm,
          y: yp,
          z: zm
        }],
        enabled: frame.bottom.visible
      }, {
        // left
        fill: Highcharts.color(frame.bottom.color).brighten(-0.1).get(),
        vertexes: [{
          x: xmm,
          y: ypp,
          z: zmm
        }, {
          x: xmm,
          y: ypp,
          z: zpp
        }, {
          x: xm,
          y: yp,
          z: zp
        }, {
          x: xm,
          y: yp,
          z: zm
        }],
        enabled: frame.bottom.visible && !frame.left.visible
      }, {
        // right
        fill: Highcharts.color(frame.bottom.color).brighten(-0.1).get(),
        vertexes: [{
          x: xpp,
          y: ypp,
          z: zpp
        }, {
          x: xpp,
          y: ypp,
          z: zmm
        }, {
          x: xp,
          y: yp,
          z: zm
        }, {
          x: xp,
          y: yp,
          z: zp
        }],
        enabled: frame.bottom.visible && !frame.right.visible
      }, {
        // front
        fill: Highcharts.color(frame.bottom.color).get(),
        vertexes: [{
          x: xpp,
          y: ypp,
          z: zmm
        }, {
          x: xmm,
          y: ypp,
          z: zmm
        }, {
          x: xm,
          y: yp,
          z: zm
        }, {
          x: xp,
          y: yp,
          z: zm
        }],
        enabled: frame.bottom.visible && !frame.front.visible
      }, {
        // back
        fill: Highcharts.color(frame.bottom.color).get(),
        vertexes: [{
          x: xmm,
          y: ypp,
          z: zpp
        }, {
          x: xpp,
          y: ypp,
          z: zpp
        }, {
          x: xp,
          y: yp,
          z: zp
        }, {
          x: xm,
          y: yp,
          z: zp
        }],
        enabled: frame.bottom.visible && !frame.back.visible
      }]
    });
    this.frameShapes.top[verb]({
      'class': 'highcharts-3d-frame highcharts-3d-frame-top',
      zIndex: frame.top.frontFacing ? -1000 : 1000,
      faces: [{
        // bottom
        fill: Highcharts.color(frame.top.color).brighten(0.1).get(),
        vertexes: [{
          x: xmm,
          y: ymm,
          z: zpp
        }, {
          x: xpp,
          y: ymm,
          z: zpp
        }, {
          x: xpp,
          y: ymm,
          z: zmm
        }, {
          x: xmm,
          y: ymm,
          z: zmm
        }],
        enabled: frame.top.visible
      }, {
        // top
        fill: Highcharts.color(frame.top.color).brighten(0.1).get(),
        vertexes: [{
          x: xm,
          y: ym,
          z: zm
        }, {
          x: xp,
          y: ym,
          z: zm
        }, {
          x: xp,
          y: ym,
          z: zp
        }, {
          x: xm,
          y: ym,
          z: zp
        }],
        enabled: frame.top.visible
      }, {
        // left
        fill: Highcharts.color(frame.top.color).brighten(-0.1).get(),
        vertexes: [{
          x: xmm,
          y: ymm,
          z: zpp
        }, {
          x: xmm,
          y: ymm,
          z: zmm
        }, {
          x: xm,
          y: ym,
          z: zm
        }, {
          x: xm,
          y: ym,
          z: zp
        }],
        enabled: frame.top.visible && !frame.left.visible
      }, {
        // right
        fill: Highcharts.color(frame.top.color).brighten(-0.1).get(),
        vertexes: [{
          x: xpp,
          y: ymm,
          z: zmm
        }, {
          x: xpp,
          y: ymm,
          z: zpp
        }, {
          x: xp,
          y: ym,
          z: zp
        }, {
          x: xp,
          y: ym,
          z: zm
        }],
        enabled: frame.top.visible && !frame.right.visible
      }, {
        // front
        fill: Highcharts.color(frame.top.color).get(),
        vertexes: [{
          x: xmm,
          y: ymm,
          z: zmm
        }, {
          x: xpp,
          y: ymm,
          z: zmm
        }, {
          x: xp,
          y: ym,
          z: zm
        }, {
          x: xm,
          y: ym,
          z: zm
        }],
        enabled: frame.top.visible && !frame.front.visible
      }, {
        // back
        fill: Highcharts.color(frame.top.color).get(),
        vertexes: [{
          x: xpp,
          y: ymm,
          z: zpp
        }, {
          x: xmm,
          y: ymm,
          z: zpp
        }, {
          x: xm,
          y: ym,
          z: zp
        }, {
          x: xp,
          y: ym,
          z: zp
        }],
        enabled: frame.top.visible && !frame.back.visible
      }]
    });
    this.frameShapes.left[verb]({
      'class': 'highcharts-3d-frame highcharts-3d-frame-left',
      zIndex: frame.left.frontFacing ? -1000 : 1000,
      faces: [{
        // bottom
        fill: Highcharts.color(frame.left.color).brighten(0.1).get(),
        vertexes: [{
          x: xmm,
          y: ypp,
          z: zmm
        }, {
          x: xm,
          y: yp,
          z: zm
        }, {
          x: xm,
          y: yp,
          z: zp
        }, {
          x: xmm,
          y: ypp,
          z: zpp
        }],
        enabled: frame.left.visible && !frame.bottom.visible
      }, {
        // top
        fill: Highcharts.color(frame.left.color).brighten(0.1).get(),
        vertexes: [{
          x: xmm,
          y: ymm,
          z: zpp
        }, {
          x: xm,
          y: ym,
          z: zp
        }, {
          x: xm,
          y: ym,
          z: zm
        }, {
          x: xmm,
          y: ymm,
          z: zmm
        }],
        enabled: frame.left.visible && !frame.top.visible
      }, {
        // left
        fill: Highcharts.color(frame.left.color).brighten(-0.1).get(),
        vertexes: [{
          x: xmm,
          y: ypp,
          z: zpp
        }, {
          x: xmm,
          y: ymm,
          z: zpp
        }, {
          x: xmm,
          y: ymm,
          z: zmm
        }, {
          x: xmm,
          y: ypp,
          z: zmm
        }],
        enabled: frame.left.visible
      }, {
        // right
        fill: Highcharts.color(frame.left.color).brighten(-0.1).get(),
        vertexes: [{
          x: xm,
          y: ym,
          z: zp
        }, {
          x: xm,
          y: yp,
          z: zp
        }, {
          x: xm,
          y: yp,
          z: zm
        }, {
          x: xm,
          y: ym,
          z: zm
        }],
        enabled: frame.left.visible
      }, {
        // front
        fill: Highcharts.color(frame.left.color).get(),
        vertexes: [{
          x: xmm,
          y: ypp,
          z: zmm
        }, {
          x: xmm,
          y: ymm,
          z: zmm
        }, {
          x: xm,
          y: ym,
          z: zm
        }, {
          x: xm,
          y: yp,
          z: zm
        }],
        enabled: frame.left.visible && !frame.front.visible
      }, {
        // back
        fill: Highcharts.color(frame.left.color).get(),
        vertexes: [{
          x: xmm,
          y: ymm,
          z: zpp
        }, {
          x: xmm,
          y: ypp,
          z: zpp
        }, {
          x: xm,
          y: yp,
          z: zp
        }, {
          x: xm,
          y: ym,
          z: zp
        }],
        enabled: frame.left.visible && !frame.back.visible
      }]
    });
    this.frameShapes.right[verb]({
      'class': 'highcharts-3d-frame highcharts-3d-frame-right',
      zIndex: frame.right.frontFacing ? -1000 : 1000,
      faces: [{
        // bottom
        fill: Highcharts.color(frame.right.color).brighten(0.1).get(),
        vertexes: [{
          x: xpp,
          y: ypp,
          z: zpp
        }, {
          x: xp,
          y: yp,
          z: zp
        }, {
          x: xp,
          y: yp,
          z: zm
        }, {
          x: xpp,
          y: ypp,
          z: zmm
        }],
        enabled: frame.right.visible && !frame.bottom.visible
      }, {
        // top
        fill: Highcharts.color(frame.right.color).brighten(0.1).get(),
        vertexes: [{
          x: xpp,
          y: ymm,
          z: zmm
        }, {
          x: xp,
          y: ym,
          z: zm
        }, {
          x: xp,
          y: ym,
          z: zp
        }, {
          x: xpp,
          y: ymm,
          z: zpp
        }],
        enabled: frame.right.visible && !frame.top.visible
      }, {
        // left
        fill: Highcharts.color(frame.right.color).brighten(-0.1).get(),
        vertexes: [{
          x: xp,
          y: ym,
          z: zm
        }, {
          x: xp,
          y: yp,
          z: zm
        }, {
          x: xp,
          y: yp,
          z: zp
        }, {
          x: xp,
          y: ym,
          z: zp
        }],
        enabled: frame.right.visible
      }, {
        // right
        fill: Highcharts.color(frame.right.color).brighten(-0.1).get(),
        vertexes: [{
          x: xpp,
          y: ypp,
          z: zmm
        }, {
          x: xpp,
          y: ymm,
          z: zmm
        }, {
          x: xpp,
          y: ymm,
          z: zpp
        }, {
          x: xpp,
          y: ypp,
          z: zpp
        }],
        enabled: frame.right.visible
      }, {
        // front
        fill: Highcharts.color(frame.right.color).get(),
        vertexes: [{
          x: xpp,
          y: ymm,
          z: zmm
        }, {
          x: xpp,
          y: ypp,
          z: zmm
        }, {
          x: xp,
          y: yp,
          z: zm
        }, {
          x: xp,
          y: ym,
          z: zm
        }],
        enabled: frame.right.visible && !frame.front.visible
      }, {
        // back
        fill: Highcharts.color(frame.right.color).get(),
        vertexes: [{
          x: xpp,
          y: ypp,
          z: zpp
        }, {
          x: xpp,
          y: ymm,
          z: zpp
        }, {
          x: xp,
          y: ym,
          z: zp
        }, {
          x: xp,
          y: yp,
          z: zp
        }],
        enabled: frame.right.visible && !frame.back.visible
      }]
    });
    this.frameShapes.back[verb]({
      'class': 'highcharts-3d-frame highcharts-3d-frame-back',
      zIndex: frame.back.frontFacing ? -1000 : 1000,
      faces: [{
        // bottom
        fill: Highcharts.color(frame.back.color).brighten(0.1).get(),
        vertexes: [{
          x: xpp,
          y: ypp,
          z: zpp
        }, {
          x: xmm,
          y: ypp,
          z: zpp
        }, {
          x: xm,
          y: yp,
          z: zp
        }, {
          x: xp,
          y: yp,
          z: zp
        }],
        enabled: frame.back.visible && !frame.bottom.visible
      }, {
        // top
        fill: Highcharts.color(frame.back.color).brighten(0.1).get(),
        vertexes: [{
          x: xmm,
          y: ymm,
          z: zpp
        }, {
          x: xpp,
          y: ymm,
          z: zpp
        }, {
          x: xp,
          y: ym,
          z: zp
        }, {
          x: xm,
          y: ym,
          z: zp
        }],
        enabled: frame.back.visible && !frame.top.visible
      }, {
        // left
        fill: Highcharts.color(frame.back.color).brighten(-0.1).get(),
        vertexes: [{
          x: xmm,
          y: ypp,
          z: zpp
        }, {
          x: xmm,
          y: ymm,
          z: zpp
        }, {
          x: xm,
          y: ym,
          z: zp
        }, {
          x: xm,
          y: yp,
          z: zp
        }],
        enabled: frame.back.visible && !frame.left.visible
      }, {
        // right
        fill: Highcharts.color(frame.back.color).brighten(-0.1).get(),
        vertexes: [{
          x: xpp,
          y: ymm,
          z: zpp
        }, {
          x: xpp,
          y: ypp,
          z: zpp
        }, {
          x: xp,
          y: yp,
          z: zp
        }, {
          x: xp,
          y: ym,
          z: zp
        }],
        enabled: frame.back.visible && !frame.right.visible
      }, {
        // front
        fill: Highcharts.color(frame.back.color).get(),
        vertexes: [{
          x: xm,
          y: ym,
          z: zp
        }, {
          x: xp,
          y: ym,
          z: zp
        }, {
          x: xp,
          y: yp,
          z: zp
        }, {
          x: xm,
          y: yp,
          z: zp
        }],
        enabled: frame.back.visible
      }, {
        // back
        fill: Highcharts.color(frame.back.color).get(),
        vertexes: [{
          x: xmm,
          y: ypp,
          z: zpp
        }, {
          x: xpp,
          y: ypp,
          z: zpp
        }, {
          x: xpp,
          y: ymm,
          z: zpp
        }, {
          x: xmm,
          y: ymm,
          z: zpp
        }],
        enabled: frame.back.visible
      }]
    });
    this.frameShapes.front[verb]({
      'class': 'highcharts-3d-frame highcharts-3d-frame-front',
      zIndex: frame.front.frontFacing ? -1000 : 1000,
      faces: [{
        // bottom
        fill: Highcharts.color(frame.front.color).brighten(0.1).get(),
        vertexes: [{
          x: xmm,
          y: ypp,
          z: zmm
        }, {
          x: xpp,
          y: ypp,
          z: zmm
        }, {
          x: xp,
          y: yp,
          z: zm
        }, {
          x: xm,
          y: yp,
          z: zm
        }],
        enabled: frame.front.visible && !frame.bottom.visible
      }, {
        // top
        fill: Highcharts.color(frame.front.color).brighten(0.1).get(),
        vertexes: [{
          x: xpp,
          y: ymm,
          z: zmm
        }, {
          x: xmm,
          y: ymm,
          z: zmm
        }, {
          x: xm,
          y: ym,
          z: zm
        }, {
          x: xp,
          y: ym,
          z: zm
        }],
        enabled: frame.front.visible && !frame.top.visible
      }, {
        // left
        fill: Highcharts.color(frame.front.color).brighten(-0.1).get(),
        vertexes: [{
          x: xmm,
          y: ymm,
          z: zmm
        }, {
          x: xmm,
          y: ypp,
          z: zmm
        }, {
          x: xm,
          y: yp,
          z: zm
        }, {
          x: xm,
          y: ym,
          z: zm
        }],
        enabled: frame.front.visible && !frame.left.visible
      }, {
        // right
        fill: Highcharts.color(frame.front.color).brighten(-0.1).get(),
        vertexes: [{
          x: xpp,
          y: ypp,
          z: zmm
        }, {
          x: xpp,
          y: ymm,
          z: zmm
        }, {
          x: xp,
          y: ym,
          z: zm
        }, {
          x: xp,
          y: yp,
          z: zm
        }],
        enabled: frame.front.visible && !frame.right.visible
      }, {
        // front
        fill: Highcharts.color(frame.front.color).get(),
        vertexes: [{
          x: xp,
          y: ym,
          z: zm
        }, {
          x: xm,
          y: ym,
          z: zm
        }, {
          x: xm,
          y: yp,
          z: zm
        }, {
          x: xp,
          y: yp,
          z: zm
        }],
        enabled: frame.front.visible
      }, {
        // back
        fill: Highcharts.color(frame.front.color).get(),
        vertexes: [{
          x: xpp,
          y: ypp,
          z: zmm
        }, {
          x: xmm,
          y: ypp,
          z: zmm
        }, {
          x: xmm,
          y: ymm,
          z: zmm
        }, {
          x: xpp,
          y: ymm,
          z: zmm
        }],
        enabled: frame.front.visible
      }]
    });
  }
});

Chart$b.prototype.retrieveStacks = function (stacking) {
  var series = this.series,
      stacks = {},
      stackNumber,
      i = 1;
  each$L(this.series, function (s) {
    stackNumber = pick$I(s.options.stack, stacking ? 0 : series.length - 1 - s.index); // #3841, #4532

    if (!stacks[stackNumber]) {
      stacks[stackNumber] = {
        series: [s],
        position: i
      };
      i++;
    } else {
      stacks[stackNumber].series.push(s);
    }
  });
  stacks.totalStacks = i + 1;
  return stacks;
};

Chart$b.prototype.get3dFrame = function () {
  var chart = this,
      options3d = chart.options.chart.options3d,
      frameOptions = options3d.frame,
      xm = chart.plotLeft,
      xp = chart.plotLeft + chart.plotWidth,
      ym = chart.plotTop,
      yp = chart.plotTop + chart.plotHeight,
      zm = 0,
      zp = options3d.depth,
      faceOrientation = function (vertexes) {
    var area = Highcharts.shapeArea3d(vertexes, chart); // Give it 0.5 squared-pixel as a margin for rounding errors.

    if (area > 0.5) {
      return 1;
    }

    if (area < -0.5) {
      return -1;
    }

    return 0;
  },
      bottomOrientation = faceOrientation([{
    x: xm,
    y: yp,
    z: zp
  }, {
    x: xp,
    y: yp,
    z: zp
  }, {
    x: xp,
    y: yp,
    z: zm
  }, {
    x: xm,
    y: yp,
    z: zm
  }]),
      topOrientation = faceOrientation([{
    x: xm,
    y: ym,
    z: zm
  }, {
    x: xp,
    y: ym,
    z: zm
  }, {
    x: xp,
    y: ym,
    z: zp
  }, {
    x: xm,
    y: ym,
    z: zp
  }]),
      leftOrientation = faceOrientation([{
    x: xm,
    y: ym,
    z: zm
  }, {
    x: xm,
    y: ym,
    z: zp
  }, {
    x: xm,
    y: yp,
    z: zp
  }, {
    x: xm,
    y: yp,
    z: zm
  }]),
      rightOrientation = faceOrientation([{
    x: xp,
    y: ym,
    z: zp
  }, {
    x: xp,
    y: ym,
    z: zm
  }, {
    x: xp,
    y: yp,
    z: zm
  }, {
    x: xp,
    y: yp,
    z: zp
  }]),
      frontOrientation = faceOrientation([{
    x: xm,
    y: yp,
    z: zm
  }, {
    x: xp,
    y: yp,
    z: zm
  }, {
    x: xp,
    y: ym,
    z: zm
  }, {
    x: xm,
    y: ym,
    z: zm
  }]),
      backOrientation = faceOrientation([{
    x: xm,
    y: ym,
    z: zp
  }, {
    x: xp,
    y: ym,
    z: zp
  }, {
    x: xp,
    y: yp,
    z: zp
  }, {
    x: xm,
    y: yp,
    z: zp
  }]),
      defaultShowBottom = false,
      defaultShowTop = false,
      defaultShowLeft = false,
      defaultShowRight = false,
      defaultShowFront = false,
      defaultShowBack = true; // The 'default' criteria to visible faces of the frame is looking up every
  // axis to decide whenever the left/right//top/bottom sides of the frame
  // will be shown


  each$L([].concat(chart.xAxis, chart.yAxis, chart.zAxis), function (axis) {
    if (axis) {
      if (axis.horiz) {
        if (axis.opposite) {
          defaultShowTop = true;
        } else {
          defaultShowBottom = true;
        }
      } else {
        if (axis.opposite) {
          defaultShowRight = true;
        } else {
          defaultShowLeft = true;
        }
      }
    }
  });

  var getFaceOptions = function (sources, faceOrientation, defaultVisible) {
    var faceAttrs = ['size', 'color', 'visible'];
    var options = {};

    for (var i = 0; i < faceAttrs.length; i++) {
      var attr = faceAttrs[i];

      for (var j = 0; j < sources.length; j++) {
        if (typeof sources[j] === 'object') {
          var val = sources[j][attr];

          if (val !== undefined && val !== null) {
            options[attr] = val;
            break;
          }
        }
      }
    }

    var isVisible = defaultVisible;

    if (options.visible === true || options.visible === false) {
      isVisible = options.visible;
    } else if (options.visible === 'auto') {
      isVisible = faceOrientation > 0;
    }

    return {
      size: pick$I(options.size, 1),
      color: pick$I(options.color, 'none'),
      frontFacing: faceOrientation > 0,
      visible: isVisible
    };
  }; // docs @TODO: Add all frame options (left, right, top, bottom, front, back)
  // to apioptions JSDoc once the new system is up.


  var ret = {
    // FIXME: Previously, left/right, top/bottom and front/back pairs shared
    // size and color.
    // For compatibility and consistency sake, when one face have
    // size/color/visibility set, the opposite face will default to the same
    // values. Also, left/right used to be called 'side', so that's also
    // added as a fallback
    bottom: getFaceOptions([frameOptions.bottom, frameOptions.top, frameOptions], bottomOrientation, defaultShowBottom),
    top: getFaceOptions([frameOptions.top, frameOptions.bottom, frameOptions], topOrientation, defaultShowTop),
    left: getFaceOptions([frameOptions.left, frameOptions.right, frameOptions.side, frameOptions], leftOrientation, defaultShowLeft),
    right: getFaceOptions([frameOptions.right, frameOptions.left, frameOptions.side, frameOptions], rightOrientation, defaultShowRight),
    back: getFaceOptions([frameOptions.back, frameOptions.front, frameOptions], backOrientation, defaultShowBack),
    front: getFaceOptions([frameOptions.front, frameOptions.back, frameOptions], frontOrientation, defaultShowFront)
  }; // Decide the bast place to put axis title/labels based on the visible
  // faces. Ideally, The labels can only be on the edge between a visible face
  // and an invisble one. Also, the Y label should be one the left-most edge
  // (right-most if opposite),

  if (options3d.axisLabelPosition === 'auto') {
    var isValidEdge = function (face1, face2) {
      return face1.visible !== face2.visible || face1.visible && face2.visible && face1.frontFacing !== face2.frontFacing;
    };

    var yEdges = [];

    if (isValidEdge(ret.left, ret.front)) {
      yEdges.push({
        y: (ym + yp) / 2,
        x: xm,
        z: zm,
        xDir: {
          x: 1,
          y: 0,
          z: 0
        }
      });
    }

    if (isValidEdge(ret.left, ret.back)) {
      yEdges.push({
        y: (ym + yp) / 2,
        x: xm,
        z: zp,
        xDir: {
          x: 0,
          y: 0,
          z: -1
        }
      });
    }

    if (isValidEdge(ret.right, ret.front)) {
      yEdges.push({
        y: (ym + yp) / 2,
        x: xp,
        z: zm,
        xDir: {
          x: 0,
          y: 0,
          z: 1
        }
      });
    }

    if (isValidEdge(ret.right, ret.back)) {
      yEdges.push({
        y: (ym + yp) / 2,
        x: xp,
        z: zp,
        xDir: {
          x: -1,
          y: 0,
          z: 0
        }
      });
    }

    var xBottomEdges = [];

    if (isValidEdge(ret.bottom, ret.front)) {
      xBottomEdges.push({
        x: (xm + xp) / 2,
        y: yp,
        z: zm,
        xDir: {
          x: 1,
          y: 0,
          z: 0
        }
      });
    }

    if (isValidEdge(ret.bottom, ret.back)) {
      xBottomEdges.push({
        x: (xm + xp) / 2,
        y: yp,
        z: zp,
        xDir: {
          x: -1,
          y: 0,
          z: 0
        }
      });
    }

    var xTopEdges = [];

    if (isValidEdge(ret.top, ret.front)) {
      xTopEdges.push({
        x: (xm + xp) / 2,
        y: ym,
        z: zm,
        xDir: {
          x: 1,
          y: 0,
          z: 0
        }
      });
    }

    if (isValidEdge(ret.top, ret.back)) {
      xTopEdges.push({
        x: (xm + xp) / 2,
        y: ym,
        z: zp,
        xDir: {
          x: -1,
          y: 0,
          z: 0
        }
      });
    }

    var zBottomEdges = [];

    if (isValidEdge(ret.bottom, ret.left)) {
      zBottomEdges.push({
        z: (zm + zp) / 2,
        y: yp,
        x: xm,
        xDir: {
          x: 0,
          y: 0,
          z: -1
        }
      });
    }

    if (isValidEdge(ret.bottom, ret.right)) {
      zBottomEdges.push({
        z: (zm + zp) / 2,
        y: yp,
        x: xp,
        xDir: {
          x: 0,
          y: 0,
          z: 1
        }
      });
    }

    var zTopEdges = [];

    if (isValidEdge(ret.top, ret.left)) {
      zTopEdges.push({
        z: (zm + zp) / 2,
        y: ym,
        x: xm,
        xDir: {
          x: 0,
          y: 0,
          z: -1
        }
      });
    }

    if (isValidEdge(ret.top, ret.right)) {
      zTopEdges.push({
        z: (zm + zp) / 2,
        y: ym,
        x: xp,
        xDir: {
          x: 0,
          y: 0,
          z: 1
        }
      });
    }

    var pickEdge = function (edges, axis, mult) {
      if (edges.length === 0) {
        return null;
      } else if (edges.length === 1) {
        return edges[0];
      }

      var best = 0,
          projections = perspective$1(edges, chart, false);

      for (var i = 1; i < projections.length; i++) {
        if (mult * projections[i][axis] > mult * projections[best][axis]) {
          best = i;
        } else if (mult * projections[i][axis] === mult * projections[best][axis] && projections[i].z < projections[best].z) {
          best = i;
        }
      }

      return edges[best];
    };

    ret.axes = {
      y: {
        'left': pickEdge(yEdges, 'x', -1),
        'right': pickEdge(yEdges, 'x', +1)
      },
      x: {
        'top': pickEdge(xTopEdges, 'y', -1),
        'bottom': pickEdge(xBottomEdges, 'y', +1)
      },
      z: {
        'top': pickEdge(zTopEdges, 'y', -1),
        'bottom': pickEdge(zBottomEdges, 'y', +1)
      }
    };
  } else {
    ret.axes = {
      y: {
        'left': {
          x: xm,
          z: zm,
          xDir: {
            x: 1,
            y: 0,
            z: 0
          }
        },
        'right': {
          x: xp,
          z: zm,
          xDir: {
            x: 0,
            y: 0,
            z: 1
          }
        }
      },
      x: {
        'top': {
          y: ym,
          z: zm,
          xDir: {
            x: 1,
            y: 0,
            z: 0
          }
        },
        'bottom': {
          y: yp,
          z: zm,
          xDir: {
            x: 1,
            y: 0,
            z: 0
          }
        }
      },
      z: {
        'top': {
          x: defaultShowLeft ? xp : xm,
          y: ym,
          xDir: defaultShowLeft ? {
            x: 0,
            y: 0,
            z: 1
          } : {
            x: 0,
            y: 0,
            z: -1
          }
        },
        'bottom': {
          x: defaultShowLeft ? xp : xm,
          y: yp,
          xDir: defaultShowLeft ? {
            x: 0,
            y: 0,
            z: 1
          } : {
            x: 0,
            y: 0,
            z: -1
          }
        }
      }
    };
  }

  return ret;
};
/**
 * Animation setter for matrix property.
 */


Highcharts.Fx.prototype.matrixSetter = function () {
  var interpolated;

  if (this.pos < 1 && (Highcharts.isArray(this.start) || Highcharts.isArray(this.end))) {
    var start = this.start || [1, 0, 0, 1, 0, 0];
    var end = this.end || [1, 0, 0, 1, 0, 0];
    interpolated = [];

    for (var i = 0; i < 6; i++) {
      interpolated.push(this.pos * end[i] + (1 - this.pos) * start[i]);
    }
  } else {
    interpolated = this.end;
  }

  this.elem.attr(this.prop, interpolated, null, true);
};
/**
 * Note: As of v5.0.12, `frame.left` or `frame.right` should be used
 * instead.
 *
 * The side for the frame around a 3D chart.
 *
 * @since 4.0
 * @product highcharts
 * @apioption chart.options3d.frame.side
 */

/**
 * The color of the panel.
 *
 * @type {Color}
 * @default transparent
 * @since 4.0
 * @product highcharts
 * @apioption chart.options3d.frame.side.color
 */

/**
 * The thickness of the panel.
 *
 * @type {Number}
 * @default 1
 * @since 4.0
 * @product highcharts
 * @apioption chart.options3d.frame.side.size
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * Extenstion for 3d axes
 *
 * License: www.highcharts.com/license
 */
var ZAxis,
    addEvent$p = Highcharts.addEvent,
    Axis$f = Highcharts.Axis,
    Chart$c = Highcharts.Chart,
    deg2rad$6 = Highcharts.deg2rad,
    each$M = Highcharts.each,
    extend$p = Highcharts.extend,
    merge$u = Highcharts.merge,
    perspective$2 = Highcharts.perspective,
    perspective3D = Highcharts.perspective3D,
    pick$J = Highcharts.pick,
    shapeArea = Highcharts.shapeArea,
    splat$b = Highcharts.splat,
    Tick$2 = Highcharts.Tick,
    wrap$f = Highcharts.wrap;
/**
 * @optionparent xAxis
 */

var extendedOptions$1 = {
  labels: {
    /**
     * Defines how the labels are be repositioned according to the 3D chart
     * orientation.
     * - `'offset'`: Maintain a fixed horizontal/vertical distance from the
     *      tick marks, despite the chart orientation. This is the backwards
     *      compatible behavior, and causes skewing of X and Z axes.
     * - `'chart'`: Preserve 3D position relative to the chart.
     *   This looks nice, but hard to read if the text isn't
     *   forward-facing.
     * - `'flap'`: Rotated text along the axis to compensate for the chart
     *      orientation. This tries to maintain text as legible as possible
     *      on all orientations.
     * - `'ortho'`: Rotated text along the axis direction so that the labels
     *      are orthogonal to the axis. This is very similar to `'flap'`,
     *      but prevents skewing the labels (X and Y scaling are still
     *      present).
     *
     * @validvalue ['offset', 'chart', 'flap', 'ortho']
     * @sample highcharts/3d/skewed-labels/ Skewed labels
     * @since 5.0.15
     * @product highcharts
     */
    position3d: 'offset',

    /**
     * If enabled, the axis labels will skewed to follow the perspective.
     *
     * This will fix overlapping labels and titles, but texts become less
     * legible due to the distortion.
     *
     * The final appearance depends heavily on `labels.position3d`.
     *
     * @since 5.0.15
     * @sample highcharts/3d/skewed-labels/ Skewed labels
     * @product highcharts
     */
    skew3d: false
  },
  title: {
    /**
     * Defines how the title is repositioned according to the 3D chart
     * orientation.
     * - `'offset'`: Maintain a fixed horizontal/vertical distance from the
     *   tick marks, despite the chart orientation. This is the backwards
     *   compatible behavior, and causes skewing of X and Z axes.
     * - `'chart'`: Preserve 3D position relative to the chart.
     *   This looks nice, but hard to read if the text isn't
     *   forward-facing.
     * - `'flap'`: Rotated text along the axis to compensate for the chart
     *   orientation. This tries to maintain text as legible as possible on
     *   all orientations.
     * - `'ortho'`: Rotated text along the axis direction so that the labels
     *   are orthogonal to the axis. This is very similar to `'flap'`, but
     *   prevents skewing the labels (X and Y scaling are still present).
     * - `null`: Will use the config from `labels.position3d`
     *
     * @validvalue ['offset', 'chart', 'flap', 'ortho', null]
     * @type {String}
     * @since 5.0.15
     * @sample highcharts/3d/skewed-labels/ Skewed labels
     * @product highcharts
     */
    position3d: null,

    /**
     * If enabled, the axis title will skewed to follow the perspective.
     *
      * This will fix overlapping labels and titles, but texts become less
      * legible due to the distortion.
     *
     * The final appearance depends heavily on `title.position3d`.
     *
     * A `null` value will use the config from `labels.skew3d`.
     *
     * @validvalue [false, true, null]
     * @type {Boolean}
     * @sample highcharts/3d/skewed-labels/ Skewed labels
     * @since 5.0.15
     * @product highcharts
     */
    skew3d: null
  }
};
merge$u(true, Axis$f.prototype.defaultOptions, extendedOptions$1);
addEvent$p(Axis$f, 'afterSetOptions', function () {
  var options;

  if (this.chart.is3d && this.chart.is3d() && this.coll !== 'colorAxis') {
    options = this.options;
    options.tickWidth = pick$J(options.tickWidth, 0);
    options.gridLineWidth = pick$J(options.gridLineWidth, 1);
  }
});
wrap$f(Axis$f.prototype, 'getPlotLinePath', function (proceed) {
  var path = proceed.apply(this, [].slice.call(arguments, 1)); // Do not do this if the chart is not 3D

  if (!this.chart.is3d() || this.coll === 'colorAxis') {
    return path;
  }

  if (path === null) {
    return path;
  }

  var chart = this.chart,
      options3d = chart.options.chart.options3d,
      d = this.isZAxis ? chart.plotWidth : options3d.depth,
      frame = chart.frame3d;
  var pArr = [this.swapZ({
    x: path[1],
    y: path[2],
    z: 0
  }), this.swapZ({
    x: path[1],
    y: path[2],
    z: d
  }), this.swapZ({
    x: path[4],
    y: path[5],
    z: 0
  }), this.swapZ({
    x: path[4],
    y: path[5],
    z: d
  })];
  var pathSegments = [];

  if (!this.horiz) {
    // Y-Axis
    if (frame.front.visible) {
      pathSegments.push(pArr[0], pArr[2]);
    }

    if (frame.back.visible) {
      pathSegments.push(pArr[1], pArr[3]);
    }

    if (frame.left.visible) {
      pathSegments.push(pArr[0], pArr[1]);
    }

    if (frame.right.visible) {
      pathSegments.push(pArr[2], pArr[3]);
    }
  } else if (this.isZAxis) {
    // Z-Axis
    if (frame.left.visible) {
      pathSegments.push(pArr[0], pArr[2]);
    }

    if (frame.right.visible) {
      pathSegments.push(pArr[1], pArr[3]);
    }

    if (frame.top.visible) {
      pathSegments.push(pArr[0], pArr[1]);
    }

    if (frame.bottom.visible) {
      pathSegments.push(pArr[2], pArr[3]);
    }
  } else {
    // X-Axis
    if (frame.front.visible) {
      pathSegments.push(pArr[0], pArr[2]);
    }

    if (frame.back.visible) {
      pathSegments.push(pArr[1], pArr[3]);
    }

    if (frame.top.visible) {
      pathSegments.push(pArr[0], pArr[1]);
    }

    if (frame.bottom.visible) {
      pathSegments.push(pArr[2], pArr[3]);
    }
  }

  pathSegments = perspective$2(pathSegments, this.chart, false);
  return this.chart.renderer.toLineSegments(pathSegments);
}); // Do not draw axislines in 3D

wrap$f(Axis$f.prototype, 'getLinePath', function (proceed) {
  // Do not do this if the chart is not 3D
  if (!this.chart.is3d() || this.coll === 'colorAxis') {
    return proceed.apply(this, [].slice.call(arguments, 1));
  }

  return [];
});
wrap$f(Axis$f.prototype, 'getPlotBandPath', function (proceed) {
  // Do not do this if the chart is not 3D
  if (!this.chart.is3d() || this.coll === 'colorAxis') {
    return proceed.apply(this, [].slice.call(arguments, 1));
  }

  var args = arguments,
      from = args[1],
      to = args[2],
      path = [],
      fromPath = this.getPlotLinePath(from),
      toPath = this.getPlotLinePath(to);

  if (fromPath && toPath) {
    for (var i = 0; i < fromPath.length; i += 6) {
      path.push('M', fromPath[i + 1], fromPath[i + 2], 'L', fromPath[i + 4], fromPath[i + 5], 'L', toPath[i + 4], toPath[i + 5], 'L', toPath[i + 1], toPath[i + 2], 'Z');
    }
  }

  return path;
});

function fix3dPosition(axis, pos, isTitle) {
  // Do not do this if the chart is not 3D
  if (!axis.chart.is3d() || axis.coll === 'colorAxis') {
    return pos;
  }

  var chart = axis.chart,
      alpha = deg2rad$6 * chart.options.chart.options3d.alpha,
      beta = deg2rad$6 * chart.options.chart.options3d.beta,
      positionMode = pick$J(isTitle && axis.options.title.position3d, axis.options.labels.position3d),
      skew = pick$J(isTitle && axis.options.title.skew3d, axis.options.labels.skew3d),
      frame = chart.frame3d,
      plotLeft = chart.plotLeft,
      plotRight = chart.plotWidth + plotLeft,
      plotTop = chart.plotTop,
      plotBottom = chart.plotHeight + plotTop,
      // Indicates we are labelling an X or Z axis on the "back" of the chart
  reverseFlap = false,
      offsetX = 0,
      offsetY = 0,
      vecX,
      vecY = {
    x: 0,
    y: 1,
    z: 0
  };
  pos = axis.swapZ({
    x: pos.x,
    y: pos.y,
    z: 0
  });

  if (axis.isZAxis) {
    // Z Axis
    if (axis.opposite) {
      if (frame.axes.z.top === null) {
        return {};
      }

      offsetY = pos.y - plotTop;
      pos.x = frame.axes.z.top.x;
      pos.y = frame.axes.z.top.y;
      vecX = frame.axes.z.top.xDir;
      reverseFlap = !frame.top.frontFacing;
    } else {
      if (frame.axes.z.bottom === null) {
        return {};
      }

      offsetY = pos.y - plotBottom;
      pos.x = frame.axes.z.bottom.x;
      pos.y = frame.axes.z.bottom.y;
      vecX = frame.axes.z.bottom.xDir;
      reverseFlap = !frame.bottom.frontFacing;
    }
  } else if (axis.horiz) {
    // X Axis
    if (axis.opposite) {
      if (frame.axes.x.top === null) {
        return {};
      }

      offsetY = pos.y - plotTop;
      pos.y = frame.axes.x.top.y;
      pos.z = frame.axes.x.top.z;
      vecX = frame.axes.x.top.xDir;
      reverseFlap = !frame.top.frontFacing;
    } else {
      if (frame.axes.x.bottom === null) {
        return {};
      }

      offsetY = pos.y - plotBottom;
      pos.y = frame.axes.x.bottom.y;
      pos.z = frame.axes.x.bottom.z;
      vecX = frame.axes.x.bottom.xDir;
      reverseFlap = !frame.bottom.frontFacing;
    }
  } else {
    // Y Axis
    if (axis.opposite) {
      if (frame.axes.y.right === null) {
        return {};
      }

      offsetX = pos.x - plotRight;
      pos.x = frame.axes.y.right.x;
      pos.z = frame.axes.y.right.z;
      vecX = frame.axes.y.right.xDir; // Rotate 90º on opposite edge

      vecX = {
        x: vecX.z,
        y: vecX.y,
        z: -vecX.x
      };
    } else {
      if (frame.axes.y.left === null) {
        return {};
      }

      offsetX = pos.x - plotLeft;
      pos.x = frame.axes.y.left.x;
      pos.z = frame.axes.y.left.z;
      vecX = frame.axes.y.left.xDir;
    }
  }

  if (positionMode === 'chart') ; else if (positionMode === 'flap') {
    // Labels are be rotated around the axis direction to face the screen
    if (!axis.horiz) {
      // Y Axis
      vecX = {
        x: Math.cos(beta),
        y: 0,
        z: Math.sin(beta)
      };
    } else {
      // X and Z Axis
      var sin = Math.sin(alpha);
      var cos = Math.cos(alpha);

      if (axis.opposite) {
        sin = -sin;
      }

      if (reverseFlap) {
        sin = -sin;
      }

      vecY = {
        x: vecX.z * sin,
        y: cos,
        z: -vecX.x * sin
      };
    }
  } else if (positionMode === 'ortho') {
    // Labels will be rotated to be ortogonal to the axis
    if (!axis.horiz) {
      // Y Axis
      vecX = {
        x: Math.cos(beta),
        y: 0,
        z: Math.sin(beta)
      };
    } else {
      // X and Z Axis
      var sina = Math.sin(alpha);
      var cosa = Math.cos(alpha);
      var sinb = Math.sin(beta);
      var cosb = Math.cos(beta);
      var vecZ = {
        x: sinb * cosa,
        y: -sina,
        z: -cosa * cosb
      };
      vecY = {
        x: vecX.y * vecZ.z - vecX.z * vecZ.y,
        y: vecX.z * vecZ.x - vecX.x * vecZ.z,
        z: vecX.x * vecZ.y - vecX.y * vecZ.x
      };
      var scale = 1 / Math.sqrt(vecY.x * vecY.x + vecY.y * vecY.y + vecY.z * vecY.z);

      if (reverseFlap) {
        scale = -scale;
      }

      vecY = {
        x: scale * vecY.x,
        y: scale * vecY.y,
        z: scale * vecY.z
      };
    }
  } else {
    // positionMode  == 'offset'
    // Labels will be skewd to maintain vertical / horizontal offsets from
    // axis
    if (!axis.horiz) {
      // Y Axis
      vecX = {
        x: Math.cos(beta),
        y: 0,
        z: Math.sin(beta)
      };
    } else {
      // X and Z Axis
      vecY = {
        x: Math.sin(beta) * Math.sin(alpha),
        y: Math.cos(alpha),
        z: -Math.cos(beta) * Math.sin(alpha)
      };
    }
  }

  pos.x += offsetX * vecX.x + offsetY * vecY.x;
  pos.y += offsetX * vecX.y + offsetY * vecY.y;
  pos.z += offsetX * vecX.z + offsetY * vecY.z;
  var projected = perspective$2([pos], axis.chart)[0];

  if (skew) {
    // Check if the label text would be mirrored
    var isMirrored = shapeArea(perspective$2([pos, {
      x: pos.x + vecX.x,
      y: pos.y + vecX.y,
      z: pos.z + vecX.z
    }, {
      x: pos.x + vecY.x,
      y: pos.y + vecY.y,
      z: pos.z + vecY.z
    }], axis.chart)) < 0;

    if (isMirrored) {
      vecX = {
        x: -vecX.x,
        y: -vecX.y,
        z: -vecX.z
      };
    }

    var pointsProjected = perspective$2([{
      x: pos.x,
      y: pos.y,
      z: pos.z
    }, {
      x: pos.x + vecX.x,
      y: pos.y + vecX.y,
      z: pos.z + vecX.z
    }, {
      x: pos.x + vecY.x,
      y: pos.y + vecY.y,
      z: pos.z + vecY.z
    }], axis.chart);
    projected.matrix = [pointsProjected[1].x - pointsProjected[0].x, pointsProjected[1].y - pointsProjected[0].y, pointsProjected[2].x - pointsProjected[0].x, pointsProjected[2].y - pointsProjected[0].y, projected.x, projected.y];
    projected.matrix[4] -= projected.x * projected.matrix[0] + projected.y * projected.matrix[2];
    projected.matrix[5] -= projected.x * projected.matrix[1] + projected.y * projected.matrix[3];
  }

  return projected;
}
/*
Tick extensions
 */


wrap$f(Tick$2.prototype, 'getMarkPath', function (proceed) {
  var path = proceed.apply(this, [].slice.call(arguments, 1));
  var pArr = [fix3dPosition(this.axis, {
    x: path[1],
    y: path[2],
    z: 0
  }), fix3dPosition(this.axis, {
    x: path[4],
    y: path[5],
    z: 0
  })];
  return this.axis.chart.renderer.toLineSegments(pArr);
});
addEvent$p(Tick$2, 'afterGetLabelPosition', function (e) {
  extend$p(e.pos, fix3dPosition(this.axis, e.pos));
});
wrap$f(Axis$f.prototype, 'getTitlePosition', function (proceed) {
  var pos = proceed.apply(this, [].slice.call(arguments, 1));
  return fix3dPosition(this, pos, true);
});
addEvent$p(Axis$f, 'drawCrosshair', function (e) {
  if (this.chart.is3d() && this.coll !== 'colorAxis') {
    if (e.point) {
      e.point.crosshairPos = this.isXAxis ? e.point.axisXpos : this.len - e.point.axisYpos;
    }
  }
});
addEvent$p(Axis$f, 'destroy', function () {
  each$M(['backFrame', 'bottomFrame', 'sideFrame'], function (prop) {
    if (this[prop]) {
      this[prop] = this[prop].destroy();
    }
  }, this);
});
/*
Z-AXIS
*/

Axis$f.prototype.swapZ = function (p, insidePlotArea) {
  if (this.isZAxis) {
    var plotLeft = insidePlotArea ? 0 : this.chart.plotLeft;
    return {
      x: plotLeft + p.z,
      y: p.y,
      z: p.x - plotLeft
    };
  }

  return p;
};

ZAxis = Highcharts.ZAxis = function () {
  this.init.apply(this, arguments);
};

extend$p(ZAxis.prototype, Axis$f.prototype);
extend$p(ZAxis.prototype, {
  isZAxis: true,
  setOptions: function (userOptions) {
    userOptions = merge$u({
      offset: 0,
      lineWidth: 0
    }, userOptions);
    Axis$f.prototype.setOptions.call(this, userOptions);
    this.coll = 'zAxis';
  },
  setAxisSize: function () {
    Axis$f.prototype.setAxisSize.call(this);
    this.width = this.len = this.chart.options.chart.options3d.depth;
    this.right = this.chart.chartWidth - this.width - this.left;
  },
  getSeriesExtremes: function () {
    var axis = this,
        chart = axis.chart;
    axis.hasVisibleSeries = false; // Reset properties in case we're redrawing (#3353)

    axis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = null;

    if (axis.buildStacks) {
      axis.buildStacks();
    } // loop through this axis' series


    each$M(axis.series, function (series) {
      if (series.visible || !chart.options.chart.ignoreHiddenSeries) {
        var seriesOptions = series.options,
            zData,
            threshold = seriesOptions.threshold;
        axis.hasVisibleSeries = true; // Validate threshold in logarithmic axes

        if (axis.positiveValuesOnly && threshold <= 0) {
          threshold = null;
        }

        zData = series.zData;

        if (zData.length) {
          axis.dataMin = Math.min(pick$J(axis.dataMin, zData[0]), Math.min.apply(null, zData));
          axis.dataMax = Math.max(pick$J(axis.dataMax, zData[0]), Math.max.apply(null, zData));
        }
      }
    });
  }
});
/**
* Get the Z axis in addition to the default X and Y.
*/

addEvent$p(Chart$c, 'afterGetAxes', function () {
  var chart = this,
      options = this.options,
      zAxisOptions = options.zAxis = splat$b(options.zAxis || {});

  if (!chart.is3d()) {
    return;
  }

  this.zAxis = [];
  each$M(zAxisOptions, function (axisOptions, i) {
    axisOptions.index = i; // Z-Axis is shown horizontally, so it's kind of a X-Axis

    axisOptions.isX = true;
    var zAxis = new ZAxis(chart, axisOptions);
    zAxis.setScale();
  });
});
/**
 * Wrap getSlotWidth function to calculate individual width value
 * for each slot (#8042).
 */

wrap$f(Axis$f.prototype, 'getSlotWidth', function (proceed, tick) {
  if (this.chart.is3d() && tick && tick.label && this.categories && this.chart.frameShapes) {
    var chart = this.chart,
        ticks = this.ticks,
        gridGroup = this.gridGroup.element.childNodes,
        firstGridLine = gridGroup[0].getBBox(),
        frame3DLeft = chart.frameShapes.left.getBBox(),
        options3d = chart.options.chart.options3d,
        origin = {
      x: chart.plotWidth / 2,
      y: chart.plotHeight / 2,
      z: options3d.depth / 2,
      vd: pick$J(options3d.depth, 1) * pick$J(options3d.viewDistance, 0)
    },
        labelPos,
        prevLabelPos,
        nextLabelPos,
        slotWidth,
        tickId = tick.pos,
        prevTick = ticks[tickId - 1],
        nextTick = ticks[tickId + 1]; // Check whether the tick is not the first one and previous tick exists,
    // then calculate position of previous label.

    if (tickId !== 0 && prevTick && prevTick.label.xy) {
      // #8621
      prevLabelPos = perspective3D({
        x: prevTick.label.xy.x,
        y: prevTick.label.xy.y,
        z: null
      }, origin, origin.vd);
    } // If next label position is defined, then recalculate its position
    // basing on the perspective.


    if (nextTick && nextTick.label.xy) {
      nextLabelPos = perspective3D({
        x: nextTick.label.xy.x,
        y: nextTick.label.xy.y,
        z: null
      }, origin, origin.vd);
    }

    labelPos = {
      x: tick.label.xy.x,
      y: tick.label.xy.y,
      z: null
    };
    labelPos = perspective3D(labelPos, origin, origin.vd); // If tick is first one, check whether next label position is already
    // calculated, then return difference between the first and the second
    // label. If there is no next label position calculated, return the
    // difference between the first grid line and left 3d frame.

    slotWidth = Math.abs(prevLabelPos ? labelPos.x - prevLabelPos.x : nextLabelPos ? nextLabelPos.x - labelPos.x : firstGridLine.x - frame3DLeft.x);
    return slotWidth;
  }

  return proceed.apply(this, [].slice.call(arguments, 1));
});

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * Extension to the Series object in 3D charts.
 *
 * License: www.highcharts.com/license
 */
var addEvent$q = Highcharts.addEvent,
    perspective$3 = Highcharts.perspective,
    pick$K = Highcharts.pick; // Wrap the translate method to post-translate points into 3D perspective

addEvent$q(Highcharts.Series, 'afterTranslate', function () {
  if (this.chart.is3d()) {
    this.translate3dPoints();
  }
});
/**
 * Translate the plotX, plotY properties and add plotZ.
 */

Highcharts.Series.prototype.translate3dPoints = function () {
  var series = this,
      chart = series.chart,
      zAxis = pick$K(series.zAxis, chart.options.zAxis[0]),
      rawPoints = [],
      rawPoint,
      projectedPoints,
      projectedPoint,
      zValue,
      i;

  for (i = 0; i < series.data.length; i++) {
    rawPoint = series.data[i];

    if (zAxis && zAxis.translate) {
      zValue = zAxis.isLog && zAxis.val2lin ? zAxis.val2lin(rawPoint.z) : rawPoint.z; // #4562

      rawPoint.plotZ = zAxis.translate(zValue);
      rawPoint.isInside = rawPoint.isInside ? zValue >= zAxis.min && zValue <= zAxis.max : false;
    } else {
      rawPoint.plotZ = 0;
    }

    rawPoint.axisXpos = rawPoint.plotX;
    rawPoint.axisYpos = rawPoint.plotY;
    rawPoint.axisZpos = rawPoint.plotZ;
    rawPoints.push({
      x: rawPoint.plotX,
      y: rawPoint.plotY,
      z: rawPoint.plotZ
    });
  }

  projectedPoints = perspective$3(rawPoints, chart, true);

  for (i = 0; i < series.data.length; i++) {
    rawPoint = series.data[i];
    projectedPoint = projectedPoints[i];
    rawPoint.plotX = projectedPoint.x;
    rawPoint.plotY = projectedPoint.y;
    rawPoint.plotZ = projectedPoint.z;
  }
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$r = Highcharts.addEvent,
    each$N = Highcharts.each,
    perspective$4 = Highcharts.perspective,
    pick$L = Highcharts.pick,
    Series$k = Highcharts.Series,
    seriesTypes$i = Highcharts.seriesTypes,
    inArray$8 = Highcharts.inArray,
    svg$5 = Highcharts.svg,
    wrap$g = Highcharts.wrap;
/**
 * Depth of the columns in a 3D column chart. Requires `highcharts-3d.js`.
 *
 * @type {Number}
 * @default 25
 * @since 4.0
 * @product highcharts
 * @apioption plotOptions.column.depth
 */

/**
 * 3D columns only. The color of the edges. Similar to `borderColor`,
 *  except it defaults to the same color as the column.
 *
 * @type {Color}
 * @product highcharts
 * @apioption plotOptions.column.edgeColor
 */

/**
 * 3D columns only. The width of the colored edges.
 *
 * @type {Number}
 * @default 1
 * @product highcharts
 * @apioption plotOptions.column.edgeWidth
 */

/**
 * The spacing between columns on the Z Axis in a 3D chart. Requires
 * `highcharts-3d.js`.
 *
 * @type {Number}
 * @default 1
 * @since 4.0
 * @product highcharts
 * @apioption plotOptions.column.groupZPadding
 */

wrap$g(seriesTypes$i.column.prototype, 'translate', function (proceed) {
  proceed.apply(this, [].slice.call(arguments, 1)); // Do not do this if the chart is not 3D

  if (this.chart.is3d()) {
    this.translate3dShapes();
  }
}); // In 3D we need to pass point.outsidePlot option to the justifyDataLabel
// method for disabling justifying dataLabels in columns outside plot

wrap$g(Highcharts.Series.prototype, 'alignDataLabel', function (proceed) {
  arguments[3].outside3dPlot = arguments[1].outside3dPlot;
  proceed.apply(this, [].slice.call(arguments, 1));
}); // Don't use justifyDataLabel when point is outsidePlot

wrap$g(Highcharts.Series.prototype, 'justifyDataLabel', function (proceed) {
  return !arguments[2].outside3dPlot ? proceed.apply(this, [].slice.call(arguments, 1)) : false;
});

seriesTypes$i.column.prototype.translate3dPoints = function () {};

seriesTypes$i.column.prototype.translate3dShapes = function () {
  var series = this,
      chart = series.chart,
      seriesOptions = series.options,
      depth = seriesOptions.depth || 25,
      stack = seriesOptions.stacking ? seriesOptions.stack || 0 : series.index,
      // #4743
  z = stack * (depth + (seriesOptions.groupZPadding || 1)),
      borderCrisp = series.borderWidth % 2 ? 0.5 : 0;

  if (chart.inverted && !series.yAxis.reversed) {
    borderCrisp *= -1;
  }

  if (seriesOptions.grouping !== false) {
    z = 0;
  }

  z += seriesOptions.groupZPadding || 1;
  each$N(series.data, function (point) {
    // #7103 Reset outside3dPlot flag
    point.outside3dPlot = null;

    if (point.y !== null) {
      var shapeArgs = point.shapeArgs,
          tooltipPos = point.tooltipPos,
          // Array for final shapeArgs calculation.
      // We are checking two dimensions (x and y).
      dimensions = [['x', 'width'], ['y', 'height']],
          borderlessBase; // Crisped rects can have +/- 0.5 pixels offset.
      // #3131 We need to check if column is inside plotArea.

      each$N(dimensions, function (d) {
        borderlessBase = shapeArgs[d[0]] - borderCrisp;

        if (borderlessBase < 0) {
          // If borderLessBase is smaller than 0, it is needed to set
          // its value to 0 or 0.5 depending on borderWidth
          // borderWidth may be even or odd.
          shapeArgs[d[1]] += shapeArgs[d[0]] + borderCrisp;
          shapeArgs[d[0]] = -borderCrisp;
          borderlessBase = 0;
        }

        if (borderlessBase + shapeArgs[d[1]] > series[d[0] + 'Axis'].len && // Do not change height/width of column if 0 (#6708)
        shapeArgs[d[1]] !== 0) {
          shapeArgs[d[1]] = series[d[0] + 'Axis'].len - shapeArgs[d[0]];
        }

        if ( // Do not remove columns with zero height/width.
        shapeArgs[d[1]] !== 0 && (shapeArgs[d[0]] >= series[d[0] + 'Axis'].len || shapeArgs[d[0]] + shapeArgs[d[1]] <= borderCrisp)) {
          // Set args to 0 if column is outside the chart.
          for (var key in shapeArgs) {
            shapeArgs[key] = 0;
          } // #7103 outside3dPlot flag is set on Points which are
          // currently outside of plot.


          point.outside3dPlot = true;
        }
      });
      point.shapeType = 'cuboid';
      shapeArgs.z = z;
      shapeArgs.depth = depth;
      shapeArgs.insidePlotArea = true; // Translate the tooltip position in 3d space

      tooltipPos = perspective$4([{
        x: tooltipPos[0],
        y: tooltipPos[1],
        z: z
      }], chart, true)[0];
      point.tooltipPos = [tooltipPos.x, tooltipPos.y];
    }
  }); // store for later use #4067

  series.z = z;
};

wrap$g(seriesTypes$i.column.prototype, 'animate', function (proceed) {
  if (!this.chart.is3d()) {
    proceed.apply(this, [].slice.call(arguments, 1));
  } else {
    var args = arguments,
        init = args[1],
        yAxis = this.yAxis,
        series = this,
        reversed = this.yAxis.reversed;

    if (svg$5) {
      // VML is too slow anyway
      if (init) {
        each$N(series.data, function (point) {
          if (point.y !== null) {
            point.height = point.shapeArgs.height;
            point.shapey = point.shapeArgs.y; // #2968

            point.shapeArgs.height = 1;

            if (!reversed) {
              if (point.stackY) {
                point.shapeArgs.y = point.plotY + yAxis.translate(point.stackY);
              } else {
                point.shapeArgs.y = point.plotY + (point.negative ? -point.height : point.height);
              }
            }
          }
        });
      } else {
        // run the animation
        each$N(series.data, function (point) {
          if (point.y !== null) {
            point.shapeArgs.height = point.height;
            point.shapeArgs.y = point.shapey; // #2968
            // null value do not have a graphic

            if (point.graphic) {
              point.graphic.animate(point.shapeArgs, series.options.animation);
            }
          }
        }); // redraw datalabels to the correct position

        this.drawDataLabels(); // delete this function to allow it only once

        series.animate = null;
      }
    }
  }
});
/*
 * In case of 3d columns there is no sense to add this columns
 * to a specific series group - if series is added to a group
 * all columns will have the same zIndex in comparison with different series
 */

wrap$g(seriesTypes$i.column.prototype, 'plotGroup', function (proceed, prop, name, visibility, zIndex, parent) {
  if (this.chart.is3d() && parent && !this[prop]) {
    if (!this.chart.columnGroup) {
      this.chart.columnGroup = this.chart.renderer.g('columnGroup').add(parent);
    }

    this[prop] = this.chart.columnGroup;
    this.chart.columnGroup.attr(this.getPlotBox());
    this[prop].survive = true;
  }

  return proceed.apply(this, Array.prototype.slice.call(arguments, 1));
});
/*
 * When series is not added to group it is needed to change
 * setVisible method to allow correct Legend funcionality
 * This wrap is basing on pie chart series
 */

wrap$g(seriesTypes$i.column.prototype, 'setVisible', function (proceed, vis) {
  var series = this,
      pointVis;

  if (series.chart.is3d()) {
    each$N(series.data, function (point) {
      point.visible = point.options.visible = vis = vis === undefined ? !point.visible : vis;
      pointVis = vis ? 'visible' : 'hidden';
      series.options.data[inArray$8(point, series.data)] = point.options;

      if (point.graphic) {
        point.graphic.attr({
          visibility: pointVis
        });
      }
    });
  }

  proceed.apply(this, Array.prototype.slice.call(arguments, 1));
});
seriesTypes$i.column.prototype.handle3dGrouping = true;
addEvent$r(Series$k, 'afterInit', function () {
  if (this.chart.is3d() && this.handle3dGrouping) {
    var seriesOptions = this.options,
        grouping = seriesOptions.grouping,
        stacking = seriesOptions.stacking,
        reversedStacks = pick$L(this.yAxis.options.reversedStacks, true),
        z = 0;

    if (!(grouping !== undefined && !grouping)) {
      var stacks = this.chart.retrieveStacks(stacking),
          stack = seriesOptions.stack || 0,
          i; // position within the stack

      for (i = 0; i < stacks[stack].series.length; i++) {
        if (stacks[stack].series[i] === this) {
          break;
        }
      }

      z = 10 * (stacks.totalStacks - stacks[stack].position) + (reversedStacks ? i : -i); // #4369
      // In case when axis is reversed, columns are also reversed inside
      // the group (#3737)

      if (!this.xAxis.reversed) {
        z = stacks.totalStacks * 10 - z;
      }
    }

    seriesOptions.zIndex = z;
  }
});
wrap$g(Series$k.prototype, 'alignDataLabel', function (proceed) {
  // Only do this for 3D columns and columnranges
  if (this.chart.is3d() && (this.type === 'column' || this.type === 'columnrange')) {
    var series = this,
        chart = series.chart;
    var args = arguments,
        alignTo = args[4],
        point = args[1];
    var pos = {
      x: alignTo.x,
      y: alignTo.y,
      z: series.z
    };
    pos = perspective$4([pos], chart, true)[0];
    alignTo.x = pos.x; // #7103 If point is outside of plotArea, hide data label.

    alignTo.y = point.outside3dPlot ? -9e9 : pos.y;
  }

  proceed.apply(this, [].slice.call(arguments, 1));
}); // Added stackLabels position calculation for 3D charts.

wrap$g(Highcharts.StackItem.prototype, 'getStackBox', function (proceed, chart) {
  // #3946
  var stackBox = proceed.apply(this, [].slice.call(arguments, 1)); // Only do this for 3D chart.

  if (chart.is3d()) {
    var pos = {
      x: stackBox.x,
      y: stackBox.y,
      z: 0
    };
    pos = Highcharts.perspective([pos], chart, true)[0];
    stackBox.x = pos.x;
    stackBox.y = pos.y;
  }

  return stackBox;
});
/*
    EXTENSION FOR 3D CYLINDRICAL COLUMNS
    Not supported
*/

/*
var defaultOptions = H.getOptions();
defaultOptions.plotOptions.cylinder =
    H.merge(defaultOptions.plotOptions.column);
var CylinderSeries = H.extendClass(seriesTypes.column, {
    type: 'cylinder'
});
seriesTypes.cylinder = CylinderSeries;

wrap(seriesTypes.cylinder.prototype, 'translate', function (proceed) {
    proceed.apply(this, [].slice.call(arguments, 1));

    // Do not do this if the chart is not 3D
    if (!this.chart.is3d()) {
        return;
    }

    var series = this,
        chart = series.chart,
        options = chart.options,
        cylOptions = options.plotOptions.cylinder,
        options3d = options.chart.options3d,
        depth = cylOptions.depth || 0,
        alpha = chart.alpha3d;

    var z = cylOptions.stacking ?
        (this.options.stack || 0) * depth :
        series._i * depth;
    z += depth / 2;

    if (cylOptions.grouping !== false) { z = 0; }

    each(series.data, function (point) {
        var shapeArgs = point.shapeArgs,
            deg2rad = H.deg2rad;
        point.shapeType = 'arc3d';
        shapeArgs.x += depth / 2;
        shapeArgs.z = z;
        shapeArgs.start = 0;
        shapeArgs.end = 2 * PI;
        shapeArgs.r = depth * 0.95;
        shapeArgs.innerR = 0;
        shapeArgs.depth =
            shapeArgs.height * (1 / sin((90 - alpha) * deg2rad)) - z;
        shapeArgs.alpha = 90 - alpha;
        shapeArgs.beta = 0;
    });
});
*/

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * 3D pie series
 *
 * License: www.highcharts.com/license
 */
var deg2rad$7 = Highcharts.deg2rad,
    each$O = Highcharts.each,
    pick$M = Highcharts.pick,
    seriesTypes$j = Highcharts.seriesTypes,
    svg$6 = Highcharts.svg,
    wrap$h = Highcharts.wrap;
/**
 * The thickness of a 3D pie. Requires `highcharts-3d.js`
 *
 * @type {Number}
 * @default 0
 * @since 4.0
 * @product highcharts
 * @apioption plotOptions.pie.depth
 */

wrap$h(seriesTypes$j.pie.prototype, 'translate', function (proceed) {
  proceed.apply(this, [].slice.call(arguments, 1)); // Do not do this if the chart is not 3D

  if (!this.chart.is3d()) {
    return;
  }

  var series = this,
      seriesOptions = series.options,
      depth = seriesOptions.depth || 0,
      options3d = series.chart.options.chart.options3d,
      alpha = options3d.alpha,
      beta = options3d.beta,
      z = seriesOptions.stacking ? (seriesOptions.stack || 0) * depth : series._i * depth;
  z += depth / 2;

  if (seriesOptions.grouping !== false) {
    z = 0;
  }

  each$O(series.data, function (point) {
    var shapeArgs = point.shapeArgs,
        angle;
    point.shapeType = 'arc3d';
    shapeArgs.z = z;
    shapeArgs.depth = depth * 0.75;
    shapeArgs.alpha = alpha;
    shapeArgs.beta = beta;
    shapeArgs.center = series.center;
    angle = (shapeArgs.end + shapeArgs.start) / 2;
    point.slicedTranslation = {
      translateX: Math.round(Math.cos(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad$7)),
      translateY: Math.round(Math.sin(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad$7))
    };
  });
});
wrap$h(seriesTypes$j.pie.prototype.pointClass.prototype, 'haloPath', function (proceed) {
  var args = arguments;
  return this.series.chart.is3d() ? [] : proceed.call(this, args[1]);
});
wrap$h(seriesTypes$j.pie.prototype, 'drawPoints', function (proceed) {
  proceed.apply(this, [].slice.call(arguments, 1));

  if (this.chart.is3d()) {
    each$O(this.points, function (point) {
      var graphic = point.graphic; // #4584 Check if has graphic - null points don't have it

      if (graphic) {
        // Hide null or 0 points (#3006, 3650)
        graphic[point.y && point.visible ? 'show' : 'hide']();
      }
    });
  }
});
wrap$h(seriesTypes$j.pie.prototype, 'drawDataLabels', function (proceed) {
  if (this.chart.is3d()) {
    var series = this,
        chart = series.chart,
        options3d = chart.options.chart.options3d;
    each$O(series.data, function (point) {
      var shapeArgs = point.shapeArgs,
          r = shapeArgs.r,
          // #3240 issue with datalabels for 0 and null values
      a1 = (shapeArgs.alpha || options3d.alpha) * deg2rad$7,
          b1 = (shapeArgs.beta || options3d.beta) * deg2rad$7,
          a2 = (shapeArgs.start + shapeArgs.end) / 2,
          labelPos = point.labelPos,
          labelIndexes = [0, 2, 4],
          // [x1, y1, x2, y2, x3, y3]
      yOffset = -r * (1 - Math.cos(a1)) * Math.sin(a2),
          xOffset = r * (Math.cos(b1) - 1) * Math.cos(a2); // Apply perspective on label positions

      each$O(labelIndexes, function (index) {
        labelPos[index] += xOffset;
        labelPos[index + 1] += yOffset;
      });
    });
  }

  proceed.apply(this, [].slice.call(arguments, 1));
});
wrap$h(seriesTypes$j.pie.prototype, 'addPoint', function (proceed) {
  proceed.apply(this, [].slice.call(arguments, 1));

  if (this.chart.is3d()) {
    // destroy (and rebuild) everything!!!
    this.update(this.userOptions, true); // #3845 pass the old options
  }
});
wrap$h(seriesTypes$j.pie.prototype, 'animate', function (proceed) {
  if (!this.chart.is3d()) {
    proceed.apply(this, [].slice.call(arguments, 1));
  } else {
    var args = arguments,
        init = args[1],
        animation = this.options.animation,
        attribs,
        center = this.center,
        group = this.group,
        markerGroup = this.markerGroup;

    if (svg$6) {
      // VML is too slow anyway
      if (animation === true) {
        animation = {};
      } // Initialize the animation


      if (init) {
        // Scale down the group and place it in the center
        group.oldtranslateX = group.translateX;
        group.oldtranslateY = group.translateY;
        attribs = {
          translateX: center[0],
          translateY: center[1],
          scaleX: 0.001,
          // #1499
          scaleY: 0.001
        };
        group.attr(attribs);

        if (markerGroup) {
          markerGroup.attrSetters = group.attrSetters;
          markerGroup.attr(attribs);
        } // Run the animation

      } else {
        attribs = {
          translateX: group.oldtranslateX,
          translateY: group.oldtranslateY,
          scaleX: 1,
          scaleY: 1
        };
        group.animate(attribs, animation);

        if (markerGroup) {
          markerGroup.animate(attribs, animation);
        } // Delete this function to allow it only once


        this.animate = null;
      }
    }
  }
});

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * Scatter 3D series.
 *
 * License: www.highcharts.com/license
 */
var Point$a = Highcharts.Point,
    seriesType$j = Highcharts.seriesType,
    seriesTypes$k = Highcharts.seriesTypes;
/**
 * A 3D scatter plot uses x, y and z coordinates to display values for three
 * variables for a set of data.
 *
 * @sample {highcharts} highcharts/3d/scatter/
 *         Simple 3D scatter
 * @sample {highcharts} highcharts/demo/3d-scatter-draggable
 *         Draggable 3d scatter
 *
 * @extends plotOptions.scatter
 * @product highcharts
 * @optionparent plotOptions.scatter3d
 */

seriesType$j('scatter3d', 'scatter', {
  tooltip: {
    pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>' // Series class

  }
}, {
  pointAttribs: function (point) {
    var attribs = seriesTypes$k.scatter.prototype.pointAttribs.apply(this, arguments);

    if (this.chart.is3d() && point) {
      attribs.zIndex = Highcharts.pointCameraDistance(point, this.chart);
    }

    return attribs;
  },
  axisTypes: ['xAxis', 'yAxis', 'zAxis'],
  pointArrayMap: ['x', 'y', 'z'],
  parallelArrays: ['x', 'y', 'z'],
  // Require direct touch rather than using the k-d-tree, because the k-d-tree
  // currently doesn't take the xyz coordinate system into account (#4552)
  directTouch: true // Point class

}, {
  applyOptions: function () {
    Point$a.prototype.applyOptions.apply(this, arguments);

    if (this.z === undefined) {
      this.z = 0;
    }

    return this;
  }
});
/**
 * A `scatter3d` series. If the [type](#series.scatter3d.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 *
 * scatter3d](#plotOptions.scatter3d).
 *
 * @type {Object}
 * @extends series,plotOptions.scatter3d
 * @product highcharts
 * @apioption series.scatter3d
 */

/**
 * An array of data points for the series. For the `scatter3d` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of arrays with 3 values. In this case, the values correspond
 * to `x,y,z`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 *
 *  ```js
 *     data: [
 *         [0, 0, 1],
 *         [1, 8, 7],
 *         [2, 9, 2]
 *     ]
 *  ```
 *
 * 3.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series'
 * [turboThreshold](#series.scatter3d.turboThreshold), this option is not
 * available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 2,
 *         z: 24,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 4,
 *         z: 12,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type {Array<Object|Array>}
 * @extends series.scatter.data
 * @sample {highcharts} highcharts/chart/reflow-true/
 *         Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/
 *         Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *         Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/
 *         Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/
 *         Config objects
 * @product highcharts
 * @apioption series.scatter3d.data
 */

/**
 * The z value for each data point.
 *
 * @type {Number}
 * @product highcharts
 * @apioption series.scatter3d.data.z
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 *
 * 3D features for Highcharts JS
 *
 * @license: www.highcharts.com/license
 */

/**
 * (c) 2010-2017 Christer Vasseng, Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @typedef {Object} AjaxSettings
 * @property {String} url - The URL to call
 * @property {('get'|'post'|'update'|'delete')} type - The verb to use
 * @property {('json'|'xml'|'text'|'octet')} dataType - The data type expected
 * @property {Function} success - Function to call on success
 * @property {Function} error - Function to call on error
 * @property {Object} data - The payload to send
 * @property {Object} headers - The headers; keyed on header name
 */

/**
 * Perform an Ajax call.
 *
 * @memberof Highcharts
 * @param {AjaxSettings} - The Ajax settings to use
 *
 */

Highcharts.ajax = function (attr) {
  var options = Highcharts.merge(true, {
    url: false,
    type: 'GET',
    dataType: 'json',
    success: false,
    error: false,
    data: false,
    headers: {}
  }, attr),
      headers = {
    json: 'application/json',
    xml: 'application/xml',
    text: 'text/plain',
    octet: 'application/octet-stream'
  },
      r = new XMLHttpRequest();

  function handleError(xhr, err) {
    if (options.error) {
      options.error(xhr, err);
    }
  }

  if (!options.url) {
    return false;
  }

  r.open(options.type.toUpperCase(), options.url, true);
  r.setRequestHeader('Content-Type', headers[options.dataType] || headers.text);
  Highcharts.objectEach(options.headers, function (val, key) {
    r.setRequestHeader(key, val);
  });

  r.onreadystatechange = function () {
    var res;

    if (r.readyState === 4) {
      if (r.status === 200) {
        res = r.responseText;

        if (options.dataType === 'json') {
          try {
            res = JSON.parse(res);
          } catch (e) {
            return handleError(r, e);
          }
        }

        return options.success && options.success(res);
      }

      handleError(r, r.responseText);
    }
  };

  try {
    options.data = JSON.stringify(options.data);
  } catch (e) {}

  r.send(options.data || true);
};

/**
 * Data module
 *
 * (c) 2012-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

var addEvent$s = Highcharts.addEvent,
    Chart$d = Highcharts.Chart,
    win$b = Highcharts.win,
    doc$8 = win$b.document,
    each$P = Highcharts.each,
    objectEach$7 = Highcharts.objectEach,
    pick$N = Highcharts.pick,
    inArray$9 = Highcharts.inArray,
    isNumber$i = Highcharts.isNumber,
    merge$v = Highcharts.merge,
    splat$c = Highcharts.splat,
    fireEvent$d = Highcharts.fireEvent,
    some$1 = Highcharts.some,
    SeriesBuilder;
/**
 * The Data module provides a simplified interface for adding data to
 * a chart from sources like CVS, HTML tables or grid views. See also
 * the [tutorial article on the Data module](https://www.highcharts.com/docs/working-
 * with-data/data-module).
 *
 * It requires the `modules/data.js` file to be loaded.
 *
 * Please note that the default way of adding data in Highcharts, without
 * the need of a module, is through the [series.data](#series.data)
 * option.
 *
 * @sample {highcharts} highcharts/demo/column-parsed/ HTML table
 * @sample {highcharts} highcharts/data/csv/ CSV
 * @since 4.0
 * @apioption data
 */

/**
 * A callback function to modify the CSV before parsing it. Return the modified
 * string.
 *
 * @type {Function}
 * @sample {highcharts} highcharts/demo/line-ajax/ Modify CSV before parse
 * @since 6.1
 * @apioption data.beforeParse
 */

/**
 * A two-dimensional array representing the input data on tabular form.
 * This input can be used when the data is already parsed, for example
 * from a grid view component. Each cell can be a string or number.
 * If not switchRowsAndColumns is set, the columns are interpreted as
 * series.
 *
 * @type {Array<Array<Mixed>>}
 * @see [data.rows](#data.rows)
 * @sample {highcharts} highcharts/data/columns/ Columns
 * @since 4.0
 * @apioption data.columns
 */

/**
 * The callback that is evaluated when the data is finished loading,
 * optionally from an external source, and parsed. The first argument
 * passed is a finished chart options object, containing the series.
 * These options can be extended with additional options and passed
 * directly to the chart constructor.
 *
 * @type {Function}
 * @see [data.parsed](#data.parsed)
 * @sample {highcharts} highcharts/data/complete/ Modify data on complete
 * @since 4.0
 * @apioption data.complete
 */

/**
 * A comma delimited string to be parsed. Related options are [startRow](
 * #data.startRow), [endRow](#data.endRow), [startColumn](#data.startColumn)
 * and [endColumn](#data.endColumn) to delimit what part of the table
 * is used. The [lineDelimiter](#data.lineDelimiter) and [itemDelimiter](
 * #data.itemDelimiter) options define the CSV delimiter formats.
 *
 * The built-in CSV parser doesn't support all flavours of CSV, so in
 * some cases it may be necessary to use an external CSV parser. See
 * [this example](https://jsfiddle.net/highcharts/u59176h4/) of parsing
 * CSV through the MIT licensed [Papa Parse](http://papaparse.com/)
 * library.
 *
 * @type {String}
 * @sample {highcharts} highcharts/data/csv/ Data from CSV
 * @since 4.0
 * @apioption data.csv
 */

/**
 * Which of the predefined date formats in Date.prototype.dateFormats
 * to use to parse date values. Defaults to a best guess based on what
 * format gives valid and ordered dates.
 *
 * Valid options include:
 *
 * *   `YYYY/mm/dd`
 * *   `dd/mm/YYYY`
 * *   `mm/dd/YYYY`
 * *   `dd/mm/YY`
 * *   `mm/dd/YY`
 *
 * @validvalue [undefined, "YYYY/mm/dd", "dd/mm/YYYY", "mm/dd/YYYY",
 *             "dd/mm/YYYY", "dd/mm/YY", "mm/dd/YY"]
 * @type {String}
 * @see [data.parseDate](#data.parseDate)
 * @sample {highcharts} highcharts/data/dateformat-auto/ Best guess date format
 * @since 4.0
 * @apioption data.dateFormat
 */

/**
 * The decimal point used for parsing numbers in the CSV.
 *
 * If both this and data.delimiter is set to false, the parser will
 * attempt to deduce the decimal point automatically.
 *
 * @type {String}
 * @sample {highcharts} highcharts/data/delimiters/ Comma as decimal point
 * @default .
 * @since 4.1.0
 * @apioption data.decimalPoint
 */

/**
 * In tabular input data, the last column (indexed by 0) to use. Defaults
 * to the last column containing data.
 *
 * @type {Number}
 * @sample {highcharts} highcharts/data/start-end/ Limited data
 * @since 4.0
 * @apioption data.endColumn
 */

/**
 * In tabular input data, the last row (indexed by 0) to use. Defaults
 * to the last row containing data.
 *
 * @type {Number}
 * @sample {highcharts} highcharts/data/start-end/ Limited data
 * @since 4.0.4
 * @apioption data.endRow
 */

/**
 * Whether to use the first row in the data set as series names.
 *
 * @type {Boolean}
 * @sample {highcharts} highcharts/data/start-end/ Don't get series names from the CSV
 * @sample {highstock} highcharts/data/start-end/ Don't get series names from the CSV
 * @default true
 * @since 4.1.0
 * @product highcharts highstock
 * @apioption data.firstRowAsNames
 */

/**
 * The key for a Google Spreadsheet to load. See [general information
 * on GS](https://developers.google.com/gdata/samples/spreadsheet_sample).
 *
 * @type {String}
 * @sample {highcharts} highcharts/data/google-spreadsheet/
 *         Load a Google Spreadsheet
 * @since 4.0
 * @apioption data.googleSpreadsheetKey
 */

/**
 * The Google Spreadsheet worksheet to use in combination with
 * [googleSpreadsheetKey](#data.googleSpreadsheetKey). The available id's from
 * your sheet can be read from `https://spreadsheets.google.com/feeds/worksheets/{key}/public/basic`.
 *
 * @type {String}
 * @sample {highcharts} highcharts/data/google-spreadsheet/ Load a Google Spreadsheet
 * @since 4.0
 * @apioption data.googleSpreadsheetWorksheet
 */

/**
 * Item or cell delimiter for parsing CSV. Defaults to the tab character
 * `\t` if a tab character is found in the CSV string, if not it defaults
 * to `,`.
 *
 * If this is set to false or undefined, the parser will attempt to deduce
 * the delimiter automatically.
 *
 * @type {String}
 * @sample {highcharts} highcharts/data/delimiters/ Delimiters
 * @since 4.0
 * @apioption data.itemDelimiter
 */

/**
 * Line delimiter for parsing CSV.
 *
 * @type {String}
 * @sample {highcharts} highcharts/data/delimiters/ Delimiters
 * @default \n
 * @since 4.0
 * @apioption data.lineDelimiter
 */

/**
 * A callback function to parse string representations of dates into
 * JavaScript timestamps. Should return an integer timestamp on success.
 *
 * @type {Function}
 * @see [dateFormat](#data.dateFormat)
 * @since 4.0
 * @apioption data.parseDate
 */

/**
 * A callback function to access the parsed columns, the two-dimentional
 * input data array directly, before they are interpreted into series
 * data and categories. Return `false` to stop completion, or call
 * `this.complete()` to continue async.
 *
 * @type {Function}
 * @see [data.complete](#data.complete)
 * @sample {highcharts} highcharts/data/parsed/ Modify data after parse
 * @since 4.0
 * @apioption data.parsed
 */

/**
 * The same as the columns input option, but defining rows intead of
 * columns.
 *
 * @type {Array<Array<Mixed>>}
 * @see [data.columns](#data.columns)
 * @sample {highcharts} highcharts/data/rows/ Data in rows
 * @since 4.0
 * @apioption data.rows
 */

/**
 * An array containing object with Point property names along with what
 * column id the property should be taken from.
 *
 * @type {Array<Object>}
 * @sample {highcharts} highcharts/data/seriesmapping-label/ Label from data set
 * @since 4.0.4
 * @apioption data.seriesMapping
 */

/**
 * In tabular input data, the first column (indexed by 0) to use.
 *
 * @type {Number}
 * @sample {highcharts} highcharts/data/start-end/ Limited data
 * @default 0
 * @since 4.0
 * @apioption data.startColumn
 */

/**
 * In tabular input data, the first row (indexed by 0) to use.
 *
 * @type {Number}
 * @sample {highcharts} highcharts/data/start-end/ Limited data
 * @default 0
 * @since 4.0
 * @apioption data.startRow
 */

/**
 * Switch rows and columns of the input data, so that `this.columns`
 * effectively becomes the rows of the data set, and the rows are interpreted
 * as series.
 *
 * @type {Boolean}
 * @sample {highcharts} highcharts/data/switchrowsandcolumns/ Switch rows and columns
 * @default false
 * @since 4.0
 * @apioption data.switchRowsAndColumns
 */

/**
 * An HTML table or the id of such to be parsed as input data. Related
 * options are `startRow`, `endRow`, `startColumn` and `endColumn` to
 * delimit what part of the table is used.
 *
 * @type {String|HTMLElement}
 * @sample {highcharts} highcharts/demo/column-parsed/ Parsed table
 * @since 4.0
 * @apioption data.table
 */

/**
 * A URL to a remote CSV dataset.
 * Will be fetched when the chart is created using Ajax.
 *
 * @type {String}
 * @sample highcharts/data/livedata-columns
 *           Categorized bar chart with CSV and live polling
 * @sample highcharts/data/livedata-csv
 *         Time based line chart with CSV and live polling
 * @apioption data.csvURL
 */

/**
 * A URL to a remote JSON dataset, structured as a row array.
 * Will be fetched when the chart is created using Ajax.
 *
 * @type {String}
 * @sample highcharts/data/livedata-rows
 *         Rows with live polling
 * @apioption data.rowsURL
 */

/**
 * A URL to a remote JSON dataset, structured as a column array.
 * Will be fetched when the chart is created using Ajax.
 *
 * @type {String}
 * @sample highcharts/data/livedata-columns
 *         Columns with live polling
 * @apioption data.columnsURL
 */

/**
 * Sets the refresh rate for data polling when importing remote dataset by
 * setting [data.csvURL](data.csvURL), [data.rowsURL](data.rowsURL),
 * [data.columnsURL](data.columnsURL), or
 * [data.googleSpreadsheetKey](data.googleSpreadsheetKey).
 *
 * Note that polling must be enabled by setting
 * [data.enablePolling](data.enablePolling) to true.
 *
 * The value is the number of seconds between pollings.
 * It cannot be set to less than 1 second.
 *
 * @default 1
 * @type {Number}
 * @sample highcharts/demo/live-data
 *         Live data with user set refresh rate
 * @apioption data.dataRefreshRate
 */

/**
 * Enables automatic refetching of remote datasets every _n_ seconds (defined by
 * setting [data.dataRefreshRate](data.dataRefreshRate)).
 *
 * Only works when either [data.csvURL](data.csvURL),
 * [data.rowsURL](data.rowsURL), [data.columnsURL](data.columnsURL), or
 * [data.googleSpreadsheetKey](data.googleSpreadsheetKey).
 *
 * @sample highcharts/demo/live-data
 *         Live data
 * @sample highcharts/data/livedata-columns
 *           Categorized bar chart with CSV and live polling
 *
 * @type {Boolean}
 * @default false
 * @apioption data.enablePolling
 */
// The Data constructor

var Data = function (dataOptions, chartOptions, chart) {
  this.init(dataOptions, chartOptions, chart);
}; // Set the prototype properties


Highcharts.extend(Data.prototype, {
  /**
   * Initialize the Data object with the given options
   */
  init: function (options, chartOptions, chart) {
    var decimalPoint = options.decimalPoint,
        hasData;

    if (chartOptions) {
      this.chartOptions = chartOptions;
    }

    if (chart) {
      this.chart = chart;
    }

    if (decimalPoint !== '.' && decimalPoint !== ',') {
      decimalPoint = undefined;
    }

    this.options = options;
    this.columns = options.columns || this.rowsToColumns(options.rows) || [];
    this.firstRowAsNames = pick$N(options.firstRowAsNames, this.firstRowAsNames, true);
    this.decimalRegex = decimalPoint && new RegExp('^(-?[0-9]+)' + decimalPoint + '([0-9]+)$') // eslint-disable-line security/detect-non-literal-regexp
    ; // This is a two-dimensional array holding the raw, trimmed string
    // values with the same organisation as the columns array. It makes it
    // possible for example to revert from interpreted timestamps to
    // string-based categories.

    this.rawColumns = []; // No need to parse or interpret anything

    if (this.columns.length) {
      this.dataFound();
      hasData = true;
    }

    if (!hasData) {
      // Fetch live data
      hasData = this.fetchLiveData();
    }

    if (!hasData) {
      // Parse a CSV string if options.csv is given. The parseCSV function
      // returns a columns array, if it has no length, we have no data
      hasData = Boolean(this.parseCSV().length);
    }

    if (!hasData) {
      // Parse a HTML table if options.table is given
      hasData = Boolean(this.parseTable().length);
    }

    if (!hasData) {
      // Parse a Google Spreadsheet
      hasData = this.parseGoogleSpreadsheet();
    }

    if (!hasData && options.afterComplete) {
      options.afterComplete();
    }
  },

  /**
   * Get the column distribution. For example, a line series takes a single
   * column for Y values. A range series takes two columns for low and high
   * values respectively, and an OHLC series takes four columns.
   */
  getColumnDistribution: function () {
    var chartOptions = this.chartOptions,
        options = this.options,
        xColumns = [],
        getValueCount = function (type) {
      return (Highcharts.seriesTypes[type || 'line'].prototype.pointArrayMap || [0]).length;
    },
        getPointArrayMap = function (type) {
      return Highcharts.seriesTypes[type || 'line'].prototype.pointArrayMap;
    },
        globalType = chartOptions && chartOptions.chart && chartOptions.chart.type,
        individualCounts = [],
        seriesBuilders = [],
        seriesIndex = 0,
        // If no series mapping is defined, check if the series array is
    // defined with types.
    seriesMapping = options && options.seriesMapping || chartOptions && chartOptions.series && Highcharts.map(chartOptions.series, function () {
      return {
        x: 0
      };
    }) || [],
        i;

    each$P(chartOptions && chartOptions.series || [], function (series) {
      individualCounts.push(getValueCount(series.type || globalType));
    }); // Collect the x-column indexes from seriesMapping

    each$P(seriesMapping, function (mapping) {
      xColumns.push(mapping.x || 0);
    }); // If there are no defined series with x-columns, use the first column
    // as x column

    if (xColumns.length === 0) {
      xColumns.push(0);
    } // Loop all seriesMappings and constructs SeriesBuilders from
    // the mapping options.


    each$P(seriesMapping, function (mapping) {
      var builder = new SeriesBuilder(),
          numberOfValueColumnsNeeded = individualCounts[seriesIndex] || getValueCount(globalType),
          seriesArr = chartOptions && chartOptions.series || [],
          series = seriesArr[seriesIndex] || {},
          pointArrayMap = getPointArrayMap(series.type || globalType) || ['y']; // Add an x reader from the x property or from an undefined column
      // if the property is not set. It will then be auto populated later.

      builder.addColumnReader(mapping.x, 'x'); // Add all column mappings

      objectEach$7(mapping, function (val, name) {
        if (name !== 'x') {
          builder.addColumnReader(val, name);
        }
      }); // Add missing columns

      for (i = 0; i < numberOfValueColumnsNeeded; i++) {
        if (!builder.hasReader(pointArrayMap[i])) {
          // Create and add a column reader for the next free column
          // index
          builder.addColumnReader(undefined, pointArrayMap[i]);
        }
      }

      seriesBuilders.push(builder);
      seriesIndex++;
    });
    var globalPointArrayMap = getPointArrayMap(globalType);

    if (globalPointArrayMap === undefined) {
      globalPointArrayMap = ['y'];
    }

    this.valueCount = {
      global: getValueCount(globalType),
      xColumns: xColumns,
      individual: individualCounts,
      seriesBuilders: seriesBuilders,
      globalPointArrayMap: globalPointArrayMap
    };
  },

  /**
   * When the data is parsed into columns, either by CSV, table, GS or direct
   * input, continue with other operations.
   */
  dataFound: function () {
    if (this.options.switchRowsAndColumns) {
      this.columns = this.rowsToColumns(this.columns);
    } // Interpret the info about series and columns


    this.getColumnDistribution(); // Interpret the values into right types

    this.parseTypes(); // Handle columns if a handleColumns callback is given

    if (this.parsed() !== false) {
      // Complete if a complete callback is given
      this.complete();
    }
  },

  /**
   * Parse a CSV input string
   */
  parseCSV: function (inOptions) {
    var self = this,
        options = inOptions || this.options,
        csv = options.csv,
        columns,
        startRow = typeof options.startRow !== 'undefined' && options.startRow ? options.startRow : 0,
        endRow = options.endRow || Number.MAX_VALUE,
        startColumn = typeof options.startColumn !== 'undefined' && options.startColumn ? options.startColumn : 0,
        endColumn = options.endColumn || Number.MAX_VALUE,
        itemDelimiter,
        lines,
        rowIt = 0,
        // activeRowNo = 0,
    dataTypes = [],
        // We count potential delimiters in the prepass, and use the
    // result as the basis of half-intelligent guesses.
    potDelimiters = {
      ',': 0,
      ';': 0,
      '\t': 0
    };
    columns = this.columns = [];
    /*
        This implementation is quite verbose. It will be shortened once
        it's stable and passes all the test.
         It's also not written with speed in mind, instead everything is
        very seggregated, and there a several redundant loops.
        This is to make it easier to stabilize the code initially.
         We do a pre-pass on the first 4 rows to make some intelligent
        guesses on the set. Guessed delimiters are in this pass counted.
         Auto detecting delimiters
            - If we meet a quoted string, the next symbol afterwards
              (that's not \s, \t) is the delimiter
            - If we meet a date, the next symbol afterwards is the delimiter
         Date formats
            - If we meet a column with date formats, check all of them to
              see if one of the potential months crossing 12. If it does,
              we now know the format
         It would make things easier to guess the delimiter before
        doing the actual parsing.
         General rules:
            - Quoting is allowed, e.g: "Col 1",123,321
            - Quoting is optional, e.g.: Col1,123,321
            - Doubble quoting is escaping, e.g. "Col ""Hello world""",123
            - Spaces are considered part of the data: Col1 ,123
            - New line is always the row delimiter
            - Potential column delimiters are , ; \t
            - First row may optionally contain headers
            - The last row may or may not have a row delimiter
            - Comments are optionally supported, in which case the comment
              must start at the first column, and the rest of the line will
              be ignored
    */
    // Parse a single row

    function parseRow(columnStr, rowNumber, noAdd, callbacks) {
      var i = 0,
          c = '',
          cl = '',
          cn = '',
          token = '',
          actualColumn = 0,
          column = 0;

      function read(j) {
        c = columnStr[j];
        cl = columnStr[j - 1];
        cn = columnStr[j + 1];
      }

      function pushType(type) {
        if (dataTypes.length < column + 1) {
          dataTypes.push([type]);
        }

        if (dataTypes[column][dataTypes[column].length - 1] !== type) {
          dataTypes[column].push(type);
        }
      }

      function push() {
        if (startColumn > actualColumn || actualColumn > endColumn) {
          // Skip this column, but increment the column count (#7272)
          ++actualColumn;
          token = '';
          return;
        }

        if (!isNaN(parseFloat(token)) && isFinite(token)) {
          token = parseFloat(token);
          pushType('number');
        } else if (!isNaN(Date.parse(token))) {
          token = token.replace(/\//g, '-');
          pushType('date');
        } else {
          pushType('string');
        }

        if (columns.length < column + 1) {
          columns.push([]);
        }

        if (!noAdd) {
          // Don't push - if there's a varrying amount of columns
          // for each row, pushing will skew everything down n slots
          columns[column][rowNumber] = token;
        }

        token = '';
        ++column;
        ++actualColumn;
      }

      if (!columnStr.trim().length) {
        return;
      }

      if (columnStr.trim()[0] === '#') {
        return;
      }

      for (; i < columnStr.length; i++) {
        read(i); // Quoted string

        if (c === '#') {
          // The rest of the row is a comment
          push();
          return;
        } else if (c === '"') {
          read(++i);

          while (i < columnStr.length) {
            if (c === '"' && cl !== '"' && cn !== '"') {
              break;
            }

            if (c !== '"' || c === '"' && cl !== '"') {
              token += c;
            }

            read(++i);
          } // Perform "plugin" handling

        } else if (callbacks && callbacks[c]) {
          if (callbacks[c](c, token)) {
            push();
          } // Delimiter - push current token

        } else if (c === itemDelimiter) {
          push(); // Actual column data
        } else {
          token += c;
        }
      }

      push();
    } // Attempt to guess the delimiter
    // We do a separate parse pass here because we need
    // to count potential delimiters softly without making any assumptions.


    function guessDelimiter(lines) {
      var points = 0,
          commas = 0,
          guessed = false;
      some$1(lines, function (columnStr, i) {
        var inStr = false,
            c,
            cn,
            cl,
            token = ''; // We should be able to detect dateformats within 13 rows

        if (i > 13) {
          return true;
        }

        for (var j = 0; j < columnStr.length; j++) {
          c = columnStr[j];
          cn = columnStr[j + 1];
          cl = columnStr[j - 1];

          if (c === '#') {
            // Skip the rest of the line - it's a comment
            return;
          } else if (c === '"') {
            if (inStr) {
              if (cl !== '"' && cn !== '"') {
                while (cn === ' ' && j < columnStr.length) {
                  cn = columnStr[++j];
                } // After parsing a string, the next non-blank
                // should be a delimiter if the CSV is properly
                // formed.


                if (typeof potDelimiters[cn] !== 'undefined') {
                  potDelimiters[cn]++;
                }

                inStr = false;
              }
            } else {
              inStr = true;
            }
          } else if (typeof potDelimiters[c] !== 'undefined') {
            token = token.trim();

            if (!isNaN(Date.parse(token))) {
              potDelimiters[c]++;
            } else if (isNaN(token) || !isFinite(token)) {
              potDelimiters[c]++;
            }

            token = '';
          } else {
            token += c;
          }

          if (c === ',') {
            commas++;
          }

          if (c === '.') {
            points++;
          }
        }
      }); // Count the potential delimiters.
      // This could be improved by checking if the number of delimiters
      // equals the number of columns - 1

      if (potDelimiters[';'] > potDelimiters[',']) {
        guessed = ';';
      } else if (potDelimiters[','] > potDelimiters[';']) {
        guessed = ',';
      } else {
        // No good guess could be made..
        guessed = ',';
      } // Try to deduce the decimal point if it's not explicitly set.
      // If both commas or points is > 0 there is likely an issue


      if (!options.decimalPoint) {
        if (points > commas) {
          options.decimalPoint = '.';
        } else {
          options.decimalPoint = ',';
        } // Apply a new decimal regex based on the presumed decimal sep.


        self.decimalRegex = new RegExp( // eslint-disable-line security/detect-non-literal-regexp
        '^(-?[0-9]+)' + options.decimalPoint + '([0-9]+)$');
      }

      return guessed;
    }
    /* Tries to guess the date format
     *    - Check if either month candidate exceeds 12
     *  - Check if year is missing (use current year)
     *  - Check if a shortened year format is used (e.g. 1/1/99)
     *  - If no guess can be made, the user must be prompted
     * data is the data to deduce a format based on
     */


    function deduceDateFormat(data, limit) {
      var format = 'YYYY/mm/dd',
          thing,
          guessedFormat,
          calculatedFormat,
          i = 0,
          madeDeduction = false,
          // candidates = {},
      stable = [],
          max = [],
          j;

      if (!limit || limit > data.length) {
        limit = data.length;
      }

      for (; i < limit; i++) {
        if (typeof data[i] !== 'undefined' && data[i] && data[i].length) {
          thing = data[i].trim().replace(/\//g, ' ').replace(/\-/g, ' ').split(' ');
          guessedFormat = ['', '', ''];

          for (j = 0; j < thing.length; j++) {
            if (j < guessedFormat.length) {
              thing[j] = parseInt(thing[j], 10);

              if (thing[j]) {
                max[j] = !max[j] || max[j] < thing[j] ? thing[j] : max[j];

                if (typeof stable[j] !== 'undefined') {
                  if (stable[j] !== thing[j]) {
                    stable[j] = false;
                  }
                } else {
                  stable[j] = thing[j];
                }

                if (thing[j] > 31) {
                  if (thing[j] < 100) {
                    guessedFormat[j] = 'YY';
                  } else {
                    guessedFormat[j] = 'YYYY';
                  } // madeDeduction = true;

                } else if (thing[j] > 12 && thing[j] <= 31) {
                  guessedFormat[j] = 'dd';
                  madeDeduction = true;
                } else if (!guessedFormat[j].length) {
                  guessedFormat[j] = 'mm';
                }
              }
            }
          }
        }
      }

      if (madeDeduction) {
        // This handles a few edge cases with hard to guess dates
        for (j = 0; j < stable.length; j++) {
          if (stable[j] !== false) {
            if (max[j] > 12 && guessedFormat[j] !== 'YY' && guessedFormat[j] !== 'YYYY') {
              guessedFormat[j] = 'YY';
            }
          } else if (max[j] > 12 && guessedFormat[j] === 'mm') {
            guessedFormat[j] = 'dd';
          }
        } // If the middle one is dd, and the last one is dd,
        // the last should likely be year.


        if (guessedFormat.length === 3 && guessedFormat[1] === 'dd' && guessedFormat[2] === 'dd') {
          guessedFormat[2] = 'YY';
        }

        calculatedFormat = guessedFormat.join('/'); // If the caculated format is not valid, we need to present an
        // error.

        if (!(options.dateFormats || self.dateFormats)[calculatedFormat]) {
          // This should emit an event instead
          fireEvent$d('deduceDateFailed');
          return format;
        }

        return calculatedFormat;
      }

      return format;
    }

    if (csv && options.beforeParse) {
      csv = options.beforeParse.call(this, csv);
    }

    if (csv) {
      lines = csv.replace(/\r\n/g, '\n') // Unix
      .replace(/\r/g, '\n') // Mac
      .split(options.lineDelimiter || '\n');

      if (!startRow || startRow < 0) {
        startRow = 0;
      }

      if (!endRow || endRow >= lines.length) {
        endRow = lines.length - 1;
      }

      if (options.itemDelimiter) {
        itemDelimiter = options.itemDelimiter;
      } else {
        itemDelimiter = null;
        itemDelimiter = guessDelimiter(lines);
      }

      var offset = 0;

      for (rowIt = startRow; rowIt <= endRow; rowIt++) {
        if (lines[rowIt][0] === '#') {
          offset++;
        } else {
          parseRow(lines[rowIt], rowIt - startRow - offset);
        }
      } // //Make sure that there's header columns for everything

      if ((!options.columnTypes || options.columnTypes.length === 0) && dataTypes.length && dataTypes[0].length && dataTypes[0][1] === 'date' && !options.dateFormat) {
        options.dateFormat = deduceDateFormat(columns[0]);
      } // each(lines, function (line, rowNo) {
      //    var trimmed = self.trim(line),
      //        isComment = trimmed.indexOf('#') === 0,
      //        isBlank = trimmed === '',
      //        items;
      //    if (
      //        rowNo >= startRow &&
      //        rowNo <= endRow &&
      //        !isComment && !isBlank
      //    ) {
      //        items = line.split(itemDelimiter);
      //        each(items, function (item, colNo) {
      //            if (colNo >= startColumn && colNo <= endColumn) {
      //                if (!columns[colNo - startColumn]) {
      //                    columns[colNo - startColumn] = [];
      //                }
      //                columns[colNo - startColumn][activeRowNo] = item;
      //            }
      //        });
      //        activeRowNo += 1;
      //    }
      // });
      //


      this.dataFound();
    }

    return columns;
  },

  /**
   * Parse a HTML table
   */
  parseTable: function () {
    var options = this.options,
        table = options.table,
        columns = this.columns,
        startRow = options.startRow || 0,
        endRow = options.endRow || Number.MAX_VALUE,
        startColumn = options.startColumn || 0,
        endColumn = options.endColumn || Number.MAX_VALUE;

    if (table) {
      if (typeof table === 'string') {
        table = doc$8.getElementById(table);
      }

      each$P(table.getElementsByTagName('tr'), function (tr, rowNo) {
        if (rowNo >= startRow && rowNo <= endRow) {
          each$P(tr.children, function (item, colNo) {
            if ((item.tagName === 'TD' || item.tagName === 'TH') && colNo >= startColumn && colNo <= endColumn) {
              if (!columns[colNo - startColumn]) {
                columns[colNo - startColumn] = [];
              }

              columns[colNo - startColumn][rowNo - startRow] = item.innerHTML;
            }
          });
        }
      });
      this.dataFound(); // continue
    }

    return columns;
  },

  /**
   * Fetch or refetch live data
   */
  fetchLiveData: function () {
    var chart = this.chart,
        options = this.options,
        maxRetries = 3,
        currentRetries = 0,
        pollingEnabled = options.enablePolling,
        updateIntervalMs = (options.dataRefreshRate || 2) * 1000,
        originalOptions = merge$v(options);

    if (!options || !options.csvURL && !options.rowsURL && !options.columnsURL) {
      return false;
    } // Do not allow polling more than once a second


    if (updateIntervalMs < 1000) {
      updateIntervalMs = 1000;
    }

    delete options.csvURL;
    delete options.rowsURL;
    delete options.columnsURL;

    function performFetch(initialFetch) {
      // Helper function for doing the data fetch + polling
      function request(url, done, tp) {
        if (!url || url.indexOf('http') !== 0) {
          if (url && options.error) {
            options.error('Invalid URL');
          }

          return false;
        }

        if (initialFetch) {
          clearTimeout(chart.liveDataTimeout);
          chart.liveDataURL = url;
        }

        function poll() {
          // Poll
          if (pollingEnabled && chart.liveDataURL === url) {
            // We need to stop doing this if the URL has changed
            chart.liveDataTimeout = setTimeout(performFetch, updateIntervalMs);
          }
        }

        Highcharts.ajax({
          url: url,
          dataType: tp || 'json',
          success: function (res) {
            if (chart && chart.series) {
              done(res);
            }

            poll();
          },
          error: function (xhr, text) {
            if (++currentRetries < maxRetries) {
              poll();
            }

            return options.error && options.error(text, xhr);
          }
        });
        return true;
      }

      if (!request(originalOptions.csvURL, function (res) {
        chart.update({
          data: {
            csv: res
          }
        });
      }, 'text')) {
        if (!request(originalOptions.rowsURL, function (res) {
          chart.update({
            data: {
              rows: res
            }
          });
        })) {
          request(originalOptions.columnsURL, function (res) {
            chart.update({
              data: {
                columns: res
              }
            });
          });
        }
      }
    }

    performFetch(true);
    return options && (options.csvURL || options.rowsURL || options.columnsURL);
  },

  /**
   * Parse a Google spreadsheet.
   */
  parseGoogleSpreadsheet: function () {
    var data = this,
        options = this.options,
        googleSpreadsheetKey = options.googleSpreadsheetKey,
        chart = this.chart,
        // use sheet 1 as the default rather than od6
    // as the latter sometimes cause issues (it looks like it can
    // be renamed in some cases, ref. a fogbugz case).
    worksheet = options.googleSpreadsheetWorksheet || 1,
        startRow = options.startRow || 0,
        endRow = options.endRow || Number.MAX_VALUE,
        startColumn = options.startColumn || 0,
        endColumn = options.endColumn || Number.MAX_VALUE,
        refreshRate = (options.dataRefreshRate || 2) * 1000;

    if (refreshRate < 4000) {
      refreshRate = 4000;
    }
    /*
     * Fetch the actual spreadsheet using XMLHttpRequest
     */


    function fetchSheet(fn) {
      var url = ['https://spreadsheets.google.com/feeds/cells', googleSpreadsheetKey, worksheet, 'public/values?alt=json'].join('/');
      Highcharts.ajax({
        url: url,
        dataType: 'json',
        success: function (json) {
          fn(json);

          if (options.enablePolling) {
            setTimeout(function () {
              fetchSheet(fn);
            }, options.dataRefreshRate);
          }
        },
        error: function (xhr, text) {
          return options.error && options.error(text, xhr);
        }
      });
    }

    if (googleSpreadsheetKey) {
      delete options.googleSpreadsheetKey;
      fetchSheet(function (json) {
        // Prepare the data from the spreadsheat
        var columns = [],
            cells = json.feed.entry,
            cell,
            cellCount = (cells || []).length,
            colCount = 0,
            rowCount = 0,
            val,
            gr,
            gc,
            cellInner,
            i;

        if (!cells || cells.length === 0) {
          return false;
        } // First, find the total number of columns and rows that
        // are actually filled with data


        for (i = 0; i < cellCount; i++) {
          cell = cells[i];
          colCount = Math.max(colCount, cell.gs$cell.col);
          rowCount = Math.max(rowCount, cell.gs$cell.row);
        } // Set up arrays containing the column data


        for (i = 0; i < colCount; i++) {
          if (i >= startColumn && i <= endColumn) {
            // Create new columns with the length of either
            // end-start or rowCount
            columns[i - startColumn] = [];
          }
        } // Loop over the cells and assign the value to the right
        // place in the column arrays


        for (i = 0; i < cellCount; i++) {
          cell = cells[i];
          gr = cell.gs$cell.row - 1; // rows start at 1

          gc = cell.gs$cell.col - 1; // columns start at 1
          // If both row and col falls inside start and end set the
          // transposed cell value in the newly created columns

          if (gc >= startColumn && gc <= endColumn && gr >= startRow && gr <= endRow) {
            cellInner = cell.gs$cell || cell.content;
            val = null;

            if (cellInner.numericValue) {
              if (cellInner.$t.indexOf('/') >= 0 || cellInner.$t.indexOf('-') >= 0) {
                // This is a date - for future reference.
                val = cellInner.$t;
              } else if (cellInner.$t.indexOf('%') > 0) {
                // Percentage
                val = parseFloat(cellInner.numericValue) * 100;
              } else {
                val = parseFloat(cellInner.numericValue);
              }
            } else if (cellInner.$t && cellInner.$t.length) {
              val = cellInner.$t;
            }

            columns[gc - startColumn][gr - startRow] = val;
          }
        } // Insert null for empty spreadsheet cells (#5298)


        each$P(columns, function (column) {
          for (i = 0; i < column.length; i++) {
            if (column[i] === undefined) {
              column[i] = null;
            }
          }
        });

        if (chart && chart.series) {
          chart.update({
            data: {
              columns: columns
            }
          });
        } else {
          // #8245
          data.columns = columns;
          data.dataFound();
        }
      });
    } // This is an intermediate fetch, so always return false.


    return false;
  },

  /**
   * Trim a string from whitespace
   */
  trim: function (str, inside) {
    if (typeof str === 'string') {
      str = str.replace(/^\s+|\s+$/g, ''); // Clear white space insdie the string, like thousands separators

      if (inside && /^[0-9\s]+$/.test(str)) {
        str = str.replace(/\s/g, '');
      }

      if (this.decimalRegex) {
        str = str.replace(this.decimalRegex, '$1.$2');
      }
    }

    return str;
  },

  /**
   * Parse numeric cells in to number types and date types in to true dates.
   */
  parseTypes: function () {
    var columns = this.columns,
        col = columns.length;

    while (col--) {
      this.parseColumn(columns[col], col);
    }
  },

  /**
   * Parse a single column. Set properties like .isDatetime and .isNumeric.
   */
  parseColumn: function (column, col) {
    var rawColumns = this.rawColumns,
        columns = this.columns,
        row = column.length,
        val,
        floatVal,
        trimVal,
        trimInsideVal,
        firstRowAsNames = this.firstRowAsNames,
        isXColumn = inArray$9(col, this.valueCount.xColumns) !== -1,
        dateVal,
        backup = [],
        diff,
        chartOptions = this.chartOptions,
        descending,
        columnTypes = this.options.columnTypes || [],
        columnType = columnTypes[col],
        forceCategory = isXColumn && (chartOptions && chartOptions.xAxis && splat$c(chartOptions.xAxis)[0].type === 'category' || columnType === 'string');

    if (!rawColumns[col]) {
      rawColumns[col] = [];
    }

    while (row--) {
      val = backup[row] || column[row];
      trimVal = this.trim(val);
      trimInsideVal = this.trim(val, true);
      floatVal = parseFloat(trimInsideVal); // Set it the first time

      if (rawColumns[col][row] === undefined) {
        rawColumns[col][row] = trimVal;
      } // Disable number or date parsing by setting the X axis type to
      // category


      if (forceCategory || row === 0 && firstRowAsNames) {
        column[row] = '' + trimVal;
      } else if (+trimInsideVal === floatVal) {
        // is numeric
        column[row] = floatVal; // If the number is greater than milliseconds in a year, assume
        // datetime

        if (floatVal > 365 * 24 * 3600 * 1000 && columnType !== 'float') {
          column.isDatetime = true;
        } else {
          column.isNumeric = true;
        }

        if (column[row + 1] !== undefined) {
          descending = floatVal > column[row + 1];
        } // String, continue to determine if it is a date string or really a
        // string

      } else {
        if (trimVal && trimVal.length) {
          dateVal = this.parseDate(val);
        } // Only allow parsing of dates if this column is an x-column


        if (isXColumn && isNumber$i(dateVal) && columnType !== 'float') {
          backup[row] = val;
          column[row] = dateVal;
          column.isDatetime = true; // Check if the dates are uniformly descending or ascending.
          // If they are not, chances are that they are a different
          // time format, so check for alternative.

          if (column[row + 1] !== undefined) {
            diff = dateVal > column[row + 1];

            if (diff !== descending && descending !== undefined) {
              if (this.alternativeFormat) {
                this.dateFormat = this.alternativeFormat;
                row = column.length;
                this.alternativeFormat = this.dateFormats[this.dateFormat].alternative;
              } else {
                column.unsorted = true;
              }
            }

            descending = diff;
          }
        } else {
          // string
          column[row] = trimVal === '' ? null : trimVal;

          if (row !== 0 && (column.isDatetime || column.isNumeric)) {
            column.mixed = true;
          }
        }
      }
    } // If strings are intermixed with numbers or dates in a parsed column,
    // it is an indication that parsing went wrong or the data was not
    // intended to display as numbers or dates and parsing is too
    // aggressive. Fall back to categories. Demonstrated in the
    // highcharts/demo/column-drilldown sample.


    if (isXColumn && column.mixed) {
      columns[col] = rawColumns[col];
    } // If the 0 column is date or number and descending, reverse all
    // columns.


    if (isXColumn && descending && this.options.sort) {
      for (col = 0; col < columns.length; col++) {
        columns[col].reverse();

        if (firstRowAsNames) {
          columns[col].unshift(columns[col].pop());
        }
      }
    }
  },

  /**
   * A collection of available date formats, extendable from the outside to
   * support custom date formats.
   */
  dateFormats: {
    'YYYY/mm/dd': {
      regex: /^([0-9]{4})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{1,2})$/,
      parser: function (match) {
        return Date.UTC(+match[1], match[2] - 1, +match[3]);
      }
    },
    'dd/mm/YYYY': {
      regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/,
      parser: function (match) {
        return Date.UTC(+match[3], match[2] - 1, +match[1]);
      },
      alternative: 'mm/dd/YYYY' // different format with the same regex

    },
    'mm/dd/YYYY': {
      regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/,
      parser: function (match) {
        return Date.UTC(+match[3], match[1] - 1, +match[2]);
      }
    },
    'dd/mm/YY': {
      regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/,
      parser: function (match) {
        var year = +match[3],
            d = new Date();

        if (year > d.getFullYear() - 2000) {
          year += 1900;
        } else {
          year += 2000;
        }

        return Date.UTC(year, match[2] - 1, +match[1]);
      },
      alternative: 'mm/dd/YY' // different format with the same regex

    },
    'mm/dd/YY': {
      regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/,
      parser: function (match) {
        return Date.UTC(+match[3] + 2000, match[1] - 1, +match[2]);
      }
    }
  },

  /**
   * Parse a date and return it as a number. Overridable through
   * `options.parseDate`.
   */
  parseDate: function (val) {
    var parseDate = this.options.parseDate,
        ret,
        key,
        format,
        dateFormat = this.options.dateFormat || this.dateFormat,
        match;

    if (parseDate) {
      ret = parseDate(val);
    } else if (typeof val === 'string') {
      // Auto-detect the date format the first time
      if (!dateFormat) {
        for (key in this.dateFormats) {
          format = this.dateFormats[key];
          match = val.match(format.regex);

          if (match) {
            this.dateFormat = dateFormat = key;
            this.alternativeFormat = format.alternative;
            ret = format.parser(match);
            break;
          }
        } // Next time, use the one previously found

      } else {
        format = this.dateFormats[dateFormat];

        if (!format) {
          // The selected format is invalid
          format = this.dateFormats['YYYY/mm/dd'];
        }

        match = val.match(format.regex);

        if (match) {
          ret = format.parser(match);
        }
      } // Fall back to Date.parse


      if (!match) {
        match = Date.parse(val); // External tools like Date.js and MooTools extend Date object
        // and returns a date.

        if (typeof match === 'object' && match !== null && match.getTime) {
          ret = match.getTime() - match.getTimezoneOffset() * 60000; // Timestamp
        } else if (isNumber$i(match)) {
          ret = match - new Date(match).getTimezoneOffset() * 60000;
        }
      }
    }

    return ret;
  },

  /**
   * Reorganize rows into columns
   */
  rowsToColumns: function (rows) {
    var row, rowsLength, col, colsLength, columns;

    if (rows) {
      columns = [];
      rowsLength = rows.length;

      for (row = 0; row < rowsLength; row++) {
        colsLength = rows[row].length;

        for (col = 0; col < colsLength; col++) {
          if (!columns[col]) {
            columns[col] = [];
          }

          columns[col][row] = rows[row][col];
        }
      }
    }

    return columns;
  },

  /**
   * A hook for working directly on the parsed columns
   */
  parsed: function () {
    if (this.options.parsed) {
      return this.options.parsed.call(this, this.columns);
    }
  },
  getFreeIndexes: function (numberOfColumns, seriesBuilders) {
    var s,
        i,
        freeIndexes = [],
        freeIndexValues = [],
        referencedIndexes; // Add all columns as free

    for (i = 0; i < numberOfColumns; i = i + 1) {
      freeIndexes.push(true);
    } // Loop all defined builders and remove their referenced columns


    for (s = 0; s < seriesBuilders.length; s = s + 1) {
      referencedIndexes = seriesBuilders[s].getReferencedColumnIndexes();

      for (i = 0; i < referencedIndexes.length; i = i + 1) {
        freeIndexes[referencedIndexes[i]] = false;
      }
    } // Collect the values for the free indexes


    for (i = 0; i < freeIndexes.length; i = i + 1) {
      if (freeIndexes[i]) {
        freeIndexValues.push(i);
      }
    }

    return freeIndexValues;
  },

  /**
   * If a complete callback function is provided in the options, interpret the
   * columns into a Highcharts options object.
   */
  complete: function () {
    var columns = this.columns,
        xColumns = [],
        type,
        options = this.options,
        series,
        data,
        i,
        j,
        r,
        seriesIndex,
        chartOptions,
        allSeriesBuilders = [],
        builder,
        freeIndexes,
        typeCol,
        index;
    xColumns.length = columns.length;

    if (options.complete || options.afterComplete) {
      // Get the names and shift the top row
      if (this.firstRowAsNames) {
        for (i = 0; i < columns.length; i++) {
          columns[i].name = columns[i].shift();
        }
      } // Use the next columns for series


      series = [];
      freeIndexes = this.getFreeIndexes(columns.length, this.valueCount.seriesBuilders); // Populate defined series

      for (seriesIndex = 0; seriesIndex < this.valueCount.seriesBuilders.length; seriesIndex++) {
        builder = this.valueCount.seriesBuilders[seriesIndex]; // If the builder can be populated with remaining columns, then
        // add it to allBuilders

        if (builder.populateColumns(freeIndexes)) {
          allSeriesBuilders.push(builder);
        }
      } // Populate dynamic series


      while (freeIndexes.length > 0) {
        builder = new SeriesBuilder();
        builder.addColumnReader(0, 'x'); // Mark index as used (not free)

        index = inArray$9(0, freeIndexes);

        if (index !== -1) {
          freeIndexes.splice(index, 1);
        }

        for (i = 0; i < this.valueCount.global; i++) {
          // Create and add a column reader for the next free column
          // index
          builder.addColumnReader(undefined, this.valueCount.globalPointArrayMap[i]);
        } // If the builder can be populated with remaining columns, then
        // add it to allBuilders


        if (builder.populateColumns(freeIndexes)) {
          allSeriesBuilders.push(builder);
        }
      } // Get the data-type from the first series x column


      if (allSeriesBuilders.length > 0 && allSeriesBuilders[0].readers.length > 0) {
        typeCol = columns[allSeriesBuilders[0].readers[0].columnIndex];

        if (typeCol !== undefined) {
          if (typeCol.isDatetime) {
            type = 'datetime';
          } else if (!typeCol.isNumeric) {
            type = 'category';
          }
        }
      } // Axis type is category, then the "x" column should be called
      // "name"


      if (type === 'category') {
        for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {
          builder = allSeriesBuilders[seriesIndex];

          for (r = 0; r < builder.readers.length; r++) {
            if (builder.readers[r].configName === 'x') {
              builder.readers[r].configName = 'name';
            }
          }
        }
      } // Read data for all builders


      for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {
        builder = allSeriesBuilders[seriesIndex]; // Iterate down the cells of each column and add data to the
        // series

        data = [];

        for (j = 0; j < columns[0].length; j++) {
          data[j] = builder.read(columns, j);
        } // Add the series


        series[seriesIndex] = {
          data: data
        };

        if (builder.name) {
          series[seriesIndex].name = builder.name;
        }

        if (type === 'category') {
          series[seriesIndex].turboThreshold = 0;
        }
      } // Do the callback


      chartOptions = {
        series: series
      };

      if (type) {
        chartOptions.xAxis = {
          type: type
        };

        if (type === 'category') {
          chartOptions.xAxis.uniqueNames = false;
        }
      }

      if (options.complete) {
        options.complete(chartOptions);
      } // The afterComplete hook is used internally to avoid conflict with
      // the externally available complete option.


      if (options.afterComplete) {
        options.afterComplete(chartOptions);
      }
    }
  },
  update: function (options, redraw) {
    var chart = this.chart;

    if (options) {
      // Set the complete handler
      options.afterComplete = function (dataOptions) {
        // Avoid setting axis options unless the type changes. Running
        // Axis.update will cause the whole structure to be destroyed
        // and rebuilt, and animation is lost.
        if (dataOptions.xAxis && chart.xAxis[0] && dataOptions.xAxis.type === chart.xAxis[0].options.type) {
          delete dataOptions.xAxis;
        }

        chart.update(dataOptions, redraw, true);
      }; // Apply it


      merge$v(true, this.options, options);
      this.init(this.options);
    }
  }
}); // Register the Data prototype and data function on Highcharts

Highcharts.Data = Data;

Highcharts.data = function (options, chartOptions) {
  return new Data(options, chartOptions);
}; // Extend Chart.init so that the Chart constructor accepts a new configuration
// option group, data.


addEvent$s(Chart$d, 'init', function (e) {
  var chart = this,
      userOptions = e.args[0],
      callback = e.args[1];

  if (userOptions && userOptions.data && !chart.hasDataDef) {
    chart.hasDataDef = true;
    chart.data = new Data(Highcharts.extend(userOptions.data, {
      afterComplete: function (dataOptions) {
        var i, series; // Merge series configs

        if (userOptions.hasOwnProperty('series')) {
          if (typeof userOptions.series === 'object') {
            i = Math.max(userOptions.series.length, dataOptions && dataOptions.series ? dataOptions.series.length : 0);

            while (i--) {
              series = userOptions.series[i] || {};
              userOptions.series[i] = merge$v(series, dataOptions && dataOptions.series ? dataOptions.series[i] : {});
            }
          } else {
            // Allow merging in dataOptions.series (#2856)
            delete userOptions.series;
          }
        } // Do the merge


        userOptions = merge$v(dataOptions, userOptions); // Run chart.init again

        chart.init(userOptions, callback);
      }
    }), userOptions, chart);
    e.preventDefault();
  }
});
/**
 * Creates a new SeriesBuilder. A SeriesBuilder consists of a number
 * of ColumnReaders that reads columns and give them a name.
 * Ex: A series builder can be constructed to read column 3 as 'x' and
 * column 7 and 8 as 'y1' and 'y2'.
 * The output would then be points/rows of the form {x: 11, y1: 22, y2: 33}
 *
 * The name of the builder is taken from the second column. In the above
 * example it would be the column with index 7.
 * @constructor
 */

SeriesBuilder = function () {
  this.readers = [];
  this.pointIsArray = true;
};
/**
 * Populates readers with column indexes. A reader can be added without
 * a specific index and for those readers the index is taken sequentially
 * from the free columns (this is handled by the ColumnCursor instance).
 * @returns {boolean}
 */


SeriesBuilder.prototype.populateColumns = function (freeIndexes) {
  var builder = this,
      enoughColumns = true; // Loop each reader and give it an index if its missing.
  // The freeIndexes.shift() will return undefined if there
  // are no more columns.

  each$P(builder.readers, function (reader) {
    if (reader.columnIndex === undefined) {
      reader.columnIndex = freeIndexes.shift();
    }
  }); // Now, all readers should have columns mapped. If not
  // then return false to signal that this series should
  // not be added.

  each$P(builder.readers, function (reader) {
    if (reader.columnIndex === undefined) {
      enoughColumns = false;
    }
  });
  return enoughColumns;
};
/**
 * Reads a row from the dataset and returns a point or array depending
 * on the names of the readers.
 * @param columns
 * @param rowIndex
 * @returns {Array | Object}
 */


SeriesBuilder.prototype.read = function (columns, rowIndex) {
  var builder = this,
      pointIsArray = builder.pointIsArray,
      point = pointIsArray ? [] : {},
      columnIndexes; // Loop each reader and ask it to read its value.
  // Then, build an array or point based on the readers names.

  each$P(builder.readers, function (reader) {
    var value = columns[reader.columnIndex][rowIndex];

    if (pointIsArray) {
      point.push(value);
    } else {
      if (reader.configName.indexOf('.') > 0) {
        // Handle nested property names
        Highcharts.Point.prototype.setNestedProperty(point, value, reader.configName);
      } else {
        point[reader.configName] = value;
      }
    }
  }); // The name comes from the first column (excluding the x column)

  if (this.name === undefined && builder.readers.length >= 2) {
    columnIndexes = builder.getReferencedColumnIndexes();

    if (columnIndexes.length >= 2) {
      // remove the first one (x col)
      columnIndexes.shift(); // Sort the remaining

      columnIndexes.sort(function (a, b) {
        return a - b;
      }); // Now use the lowest index as name column

      this.name = columns[columnIndexes.shift()].name;
    }
  }

  return point;
};
/**
 * Creates and adds ColumnReader from the given columnIndex and configName.
 * ColumnIndex can be undefined and in that case the reader will be given
 * an index when columns are populated.
 * @param columnIndex {Number | undefined}
 * @param configName
 */


SeriesBuilder.prototype.addColumnReader = function (columnIndex, configName) {
  this.readers.push({
    columnIndex: columnIndex,
    configName: configName
  });

  if (!(configName === 'x' || configName === 'y' || configName === undefined)) {
    this.pointIsArray = false;
  }
};
/**
 * Returns an array of column indexes that the builder will use when
 * reading data.
 * @returns {Array}
 */


SeriesBuilder.prototype.getReferencedColumnIndexes = function () {
  var i,
      referencedColumnIndexes = [],
      columnReader;

  for (i = 0; i < this.readers.length; i = i + 1) {
    columnReader = this.readers[i];

    if (columnReader.columnIndex !== undefined) {
      referencedColumnIndexes.push(columnReader.columnIndex);
    }
  }

  return referencedColumnIndexes;
};
/**
 * Returns true if the builder has a reader for the given configName.
 * @param configName
 * @returns {boolean}
 */


SeriesBuilder.prototype.hasReader = function (configName) {
  var i, columnReader;

  for (i = 0; i < this.readers.length; i = i + 1) {
    columnReader = this.readers[i];

    if (columnReader.configName === configName) {
      return true;
    }
  } // Else return undefined

};

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 * Data module
 *
 * (c) 2012-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

/**
 * Highcharts Drilldown module
 *
 * Author: Torstein Honsi
 * License: www.highcharts.com/license
 *
 */
var animObject$5 = Highcharts.animObject,
    noop$g = Highcharts.noop,
    color$9 = Highcharts.color,
    defaultOptions$8 = Highcharts.defaultOptions,
    each$Q = Highcharts.each,
    extend$q = Highcharts.extend,
    format$7 = Highcharts.format,
    objectEach$8 = Highcharts.objectEach,
    pick$O = Highcharts.pick,
    Chart$e = Highcharts.Chart,
    seriesTypes$l = Highcharts.seriesTypes,
    PieSeries = seriesTypes$l.pie,
    ColumnSeries = seriesTypes$l.column,
    Tick$3 = Highcharts.Tick,
    fireEvent$e = Highcharts.fireEvent,
    inArray$a = Highcharts.inArray,
    ddSeriesId = 1; // Add language

extend$q(defaultOptions$8.lang, {
  /**
   * The text for the button that appears when drilling down, linking
   * back to the parent series. The parent series' name is inserted for
   * `{series.name}`.
   *
   * @type {String}
   * @default Back to {series.name}
   * @since 3.0.8
   * @product highcharts highmaps
   * @apioption lang.drillUpText
   */
  drillUpText: '◁ Back to {series.name}'
});
/**
 * Options for drill down, the concept of inspecting increasingly high
 * resolution data through clicking on chart items like columns or pie slices.
 *
 * The drilldown feature requires the drilldown.js file to be loaded,
 * found in the modules directory of the download package, or online at
 * [code.highcharts.com/modules/drilldown.js
 * ](code.highcharts.com/modules/drilldown.js).
 *
 * @type {Object}
 * @optionparent drilldown
 */

defaultOptions$8.drilldown = {
  /**
   * When this option is false, clicking a single point will drill down
   * all points in the same category, equivalent to clicking the X axis
   * label.
   *
   * @type {Boolean}
   * @sample {highcharts} highcharts/drilldown/allowpointdrilldown-false/
   *         Don't allow point drilldown
   * @default true
   * @since 4.1.7
   * @product highcharts
   * @apioption drilldown.allowPointDrilldown
   */

  /**
   * An array of series configurations for the drill down. Each series
   * configuration uses the same syntax as the [series](#series) option
   * set. These drilldown series are hidden by default. The drilldown
   * series is linked to the parent series' point by its `id`.
   *
   * @type {Array<Object>}
   * @since 3.0.8
   * @product highcharts highmaps
   * @apioption drilldown.series
   */

  /**
   * Set the animation for all drilldown animations. Animation of a drilldown
   * occurs when drilling between a column point and a column series,
   * or a pie slice and a full pie series. Drilldown can still be used
   * between series and points of different types, but animation will
   * not occur.
   *
   * The animation can either be set as a boolean or a configuration
   * object. If `true`, it will use the 'swing' jQuery easing and a duration
   * of 500 ms. If used as a configuration object, the following properties
   * are supported:
   *
   * <dl>
   *
   * <dt>duration</dt>
   *
   * <dd>The duration of the animation in milliseconds.</dd>
   *
   * <dt>easing</dt>
   *
   * <dd>A string reference to an easing function set on the `Math` object.
   * See [the easing demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-
   * animation-easing/).</dd>
   *
   * </dl>
   *
   * @type {Boolean|AnimationOptions}
   * @since 3.0.8
   * @product highcharts highmaps
   */
  animation: {
    /**
     * Duration for the drilldown animation.
     * @default 500
     */
    duration: 500
  },

  /**
   * Options for the drill up button that appears when drilling down
   * on a series. The text for the button is defined in
   * [lang.drillUpText](#lang.drillUpText).
   *
   * @type {Object}
   * @sample {highcharts} highcharts/drilldown/drillupbutton/ Drill up button
   * @sample {highmaps} highcharts/drilldown/drillupbutton/ Drill up button
   * @since 3.0.8
   * @product highcharts highmaps
   */
  drillUpButton: {
    /**
     * What box to align the button to. Can be either `plotBox` or
     * `spacingBox`.
     *
     * @type {String}
     * @default plotBox
     * @validvalue ["plotBox", "spacingBox"]
     * @since 3.0.8
     * @product highcharts highmaps
     * @apioption drilldown.drillUpButton.relativeTo
     */

    /**
     * A collection of attributes for the button. The object takes SVG
     * attributes like `fill`, `stroke`, `stroke-width` or `r`, the border
     * radius. The theme also supports `style`, a collection of CSS
     * properties for the text. Equivalent attributes for the hover state
     * are given in `theme.states.hover`.
     *
     * @type {Object}
     * @see    In styled mode, drill-up button styles can be applied with
     *         the `.highcharts-drillup-button` class.
     * @sample {highcharts} highcharts/drilldown/drillupbutton/
     *         Button theming
     * @sample {highmaps} highcharts/drilldown/drillupbutton/
     *         Button theming
     * @since 3.0.8
     * @product highcharts highmaps
     * @apioption drilldown.drillUpButton.theme
     */

    /**
     * Positioning options for the button within the `relativeTo` box.
     * Available properties are `x`, `y`, `align` and `verticalAlign`.
     *
     * @type {Object}
     * @since 3.0.8
     * @product highcharts highmaps
     */
    position: {
      /**
       * Vertical alignment of the button.
       *
       * @type {String}
       * @default top
       * @validvalue ["top", "middle", "bottom"]
       * @product highcharts highmaps
       * @apioption drilldown.drillUpButton.position.verticalAlign
       */

      /**
       * Horizontal alignment.
       * @validvalue ["left", "center", "right"]
       * @type {String}
       */
      align: 'right',

      /**
       * The X offset of the button.
       * @type {Number}
       */
      x: -10,

      /**
       * The Y offset of the button.
       * @type {Number}
       */
      y: 10
    }
  }
};
/**
 * Fires when a drilldown point is clicked, before the new series is
 * added. This event is also utilized for async drilldown, where the
 * seriesOptions are not added by option, but rather loaded async. Note
 * that when clicking a category label to trigger multiple series drilldown,
 * one `drilldown` event is triggered per point in the category.
 *
 * Event arguments:
 *
 * <dl>
 *
 * <dt>`category`</dt>
 *
 * <dd>If a category label was clicked, which index.</dd>
 *
 * <dt>`point`</dt>
 *
 * <dd>The originating point.</dd>
 *
 * <dt>`originalEvent`</dt>
 *
 * <dd>The original browser event (usually click) that triggered the
 * drilldown.</dd>
 *
 * <dt>`points`</dt>
 *
 * <dd>If a category label was clicked, this array holds all points
 * corresponing to the category.</dd>
 *
 * <dt>`seriesOptions`</dt>
 *
 * <dd>Options for the new series</dd>
 *
 * </dl>
 *
 * @type {Function}
 * @context Chart
 * @sample {highcharts} highcharts/drilldown/async/ Async drilldown
 * @since 3.0.8
 * @product highcharts highmaps
 * @apioption chart.events.drilldown
 */

/**
* Fires when drilling up from a drilldown series.
*
* @type {Function}
* @context Chart
* @since 3.0.8
* @product highcharts highmaps
* @apioption chart.events.drillup
*/

/**
 * In a chart with multiple drilldown series, this event fires after
 * all the series have been drilled up.
 *
 * @type {Function}
 * @context Chart
 * @since 4.2.4
 * @product highcharts highmaps
 * @apioption chart.events.drillupall
 */

/**
 * The `id` of a series in the [drilldown.series](#drilldown.series)
 * array to use for a drilldown for this point.
 *
 * @type {String}
 * @sample {highcharts} highcharts/drilldown/basic/ Basic drilldown
 * @since 3.0.8
 * @product highcharts
 * @apioption series.line.data.drilldown
 */

/**
 * A general fadeIn method
 */

Highcharts.SVGRenderer.prototype.Element.prototype.fadeIn = function (animation) {
  this.attr({
    opacity: 0.1,
    visibility: 'inherit'
  }).animate({
    opacity: pick$O(this.newOpacity, 1) // newOpacity used in maps

  }, animation || {
    duration: 250
  });
};
/**
 * Add a series to the chart as drilldown from a specific point in the parent
 * series. This method is used for async drilldown, when clicking a point in a
 * series should result in loading and displaying a more high-resolution series.
 * When not async, the setup is simpler using the {@link
 * https://api.highcharts.com/highcharts/drilldown.series|drilldown.series}
 * options structure.
 *
 * @memberof Highcharts.Chart
 * @function #addSeriesAsDrilldown
 *
 * @param  {Highcharts.Point} point
 *         The point from which the drilldown will start.
 * @param  {SeriesOptions} options
 *         The series options for the new, detailed series.
 *
 * @sample highcharts/drilldown/async/ Async drilldown
 */


Chart$e.prototype.addSeriesAsDrilldown = function (point, options) {
  this.addSingleSeriesAsDrilldown(point, options);
  this.applyDrilldown();
};

Chart$e.prototype.addSingleSeriesAsDrilldown = function (point, ddOptions) {
  var oldSeries = point.series,
      xAxis = oldSeries.xAxis,
      yAxis = oldSeries.yAxis,
      newSeries,
      pointIndex,
      levelSeries = [],
      levelSeriesOptions = [],
      level,
      levelNumber,
      last,
      colorProp;
  colorProp = {
    colorIndex: pick$O(point.colorIndex, oldSeries.colorIndex)
  };

  if (!this.drilldownLevels) {
    this.drilldownLevels = [];
  }

  levelNumber = oldSeries.options._levelNumber || 0; // See if we can reuse the registered series from last run

  last = this.drilldownLevels[this.drilldownLevels.length - 1];

  if (last && last.levelNumber !== levelNumber) {
    last = undefined;
  }

  ddOptions = extend$q(extend$q({
    _ddSeriesId: ddSeriesId++
  }, colorProp), ddOptions);
  pointIndex = inArray$a(point, oldSeries.points); // Record options for all current series

  each$Q(oldSeries.chart.series, function (series) {
    if (series.xAxis === xAxis && !series.isDrilling) {
      series.options._ddSeriesId = series.options._ddSeriesId || ddSeriesId++;
      series.options._colorIndex = series.userOptions._colorIndex;
      series.options._levelNumber = series.options._levelNumber || levelNumber; // #3182

      if (last) {
        levelSeries = last.levelSeries;
        levelSeriesOptions = last.levelSeriesOptions;
      } else {
        levelSeries.push(series);
        levelSeriesOptions.push(series.options);
      }
    }
  }); // Add a record of properties for each drilldown level

  level = extend$q({
    levelNumber: levelNumber,
    seriesOptions: oldSeries.options,
    levelSeriesOptions: levelSeriesOptions,
    levelSeries: levelSeries,
    shapeArgs: point.shapeArgs,
    // no graphic in line series with markers disabled
    bBox: point.graphic ? point.graphic.getBBox() : {},
    color: point.isNull ? new Highcharts.Color(color$9).setOpacity(0).get() : color$9,
    lowerSeriesOptions: ddOptions,
    pointOptions: oldSeries.options.data[pointIndex],
    pointIndex: pointIndex,
    oldExtremes: {
      xMin: xAxis && xAxis.userMin,
      xMax: xAxis && xAxis.userMax,
      yMin: yAxis && yAxis.userMin,
      yMax: yAxis && yAxis.userMax
    },
    resetZoomButton: this.resetZoomButton
  }, colorProp); // Push it to the lookup array

  this.drilldownLevels.push(level); // Reset names to prevent extending (#6704)

  if (xAxis && xAxis.names) {
    xAxis.names.length = 0;
  }

  newSeries = level.lowerSeries = this.addSeries(ddOptions, false);
  newSeries.options._levelNumber = levelNumber + 1;

  if (xAxis) {
    xAxis.oldPos = xAxis.pos;
    xAxis.userMin = xAxis.userMax = null;
    yAxis.userMin = yAxis.userMax = null;
  } // Run fancy cross-animation on supported and equal types


  if (oldSeries.type === newSeries.type) {
    newSeries.animate = newSeries.animateDrilldown || noop$g;
    newSeries.options.animation = true;
  }
};

Chart$e.prototype.applyDrilldown = function () {
  var drilldownLevels = this.drilldownLevels,
      levelToRemove;

  if (drilldownLevels && drilldownLevels.length > 0) {
    // #3352, async loading
    levelToRemove = drilldownLevels[drilldownLevels.length - 1].levelNumber;
    each$Q(this.drilldownLevels, function (level) {
      if (level.levelNumber === levelToRemove) {
        each$Q(level.levelSeries, function (series) {
          // Not removed, not added as part of a multi-series
          // drilldown
          if (series.options && series.options._levelNumber === levelToRemove) {
            series.remove(false);
          }
        });
      }
    });
  } // We have a reset zoom button. Hide it and detatch it from the chart. It
  // is preserved to the layer config above.


  if (this.resetZoomButton) {
    this.resetZoomButton.hide();
    delete this.resetZoomButton;
  }

  this.pointer.reset();
  this.redraw();
  this.showDrillUpButton();
};

Chart$e.prototype.getDrilldownBackText = function () {
  var drilldownLevels = this.drilldownLevels,
      lastLevel;

  if (drilldownLevels && drilldownLevels.length > 0) {
    // #3352, async loading
    lastLevel = drilldownLevels[drilldownLevels.length - 1];
    lastLevel.series = lastLevel.seriesOptions;
    return format$7(this.options.lang.drillUpText, lastLevel);
  }
};

Chart$e.prototype.showDrillUpButton = function () {
  var chart = this,
      backText = this.getDrilldownBackText(),
      buttonOptions = chart.options.drilldown.drillUpButton,
      attr,
      states;

  if (!this.drillUpButton) {
    attr = buttonOptions.theme;
    states = attr && attr.states;
    this.drillUpButton = this.renderer.button(backText, null, null, function () {
      chart.drillUp();
    }, attr, states && states.hover, states && states.select).addClass('highcharts-drillup-button').attr({
      align: buttonOptions.position.align,
      zIndex: 7
    }).add().align(buttonOptions.position, false, buttonOptions.relativeTo || 'plotBox');
  } else {
    this.drillUpButton.attr({
      text: backText
    }).align();
  }
};
/**
 * When the chart is drilled down to a child series, calling `chart.drillUp()`
 * will drill up to the parent series. Requires the drilldown module.
 *
 * @function drillUp
 * @memberof Highcharts.Chart
 */


Chart$e.prototype.drillUp = function () {
  if (!this.drilldownLevels || this.drilldownLevels.length === 0) {
    return;
  }

  var chart = this,
      drilldownLevels = chart.drilldownLevels,
      levelNumber = drilldownLevels[drilldownLevels.length - 1].levelNumber,
      i = drilldownLevels.length,
      chartSeries = chart.series,
      seriesI,
      level,
      oldSeries,
      newSeries,
      oldExtremes,
      addSeries = function (seriesOptions) {
    var addedSeries;
    each$Q(chartSeries, function (series) {
      if (series.options._ddSeriesId === seriesOptions._ddSeriesId) {
        addedSeries = series;
      }
    });
    addedSeries = addedSeries || chart.addSeries(seriesOptions, false);

    if (addedSeries.type === oldSeries.type && addedSeries.animateDrillupTo) {
      addedSeries.animate = addedSeries.animateDrillupTo;
    }

    if (seriesOptions === level.seriesOptions) {
      newSeries = addedSeries;
    }
  };

  while (i--) {
    level = drilldownLevels[i];

    if (level.levelNumber === levelNumber) {
      drilldownLevels.pop(); // Get the lower series by reference or id

      oldSeries = level.lowerSeries;

      if (!oldSeries.chart) {
        // #2786
        seriesI = chartSeries.length; // #2919

        while (seriesI--) {
          if (chartSeries[seriesI].options.id === level.lowerSeriesOptions.id && chartSeries[seriesI].options._levelNumber === levelNumber + 1) {
            // #3867
            oldSeries = chartSeries[seriesI];
            break;
          }
        }
      }

      oldSeries.xData = []; // Overcome problems with minRange (#2898)

      each$Q(level.levelSeriesOptions, addSeries);
      fireEvent$e(chart, 'drillup', {
        seriesOptions: level.seriesOptions
      });

      if (newSeries.type === oldSeries.type) {
        newSeries.drilldownLevel = level;
        newSeries.options.animation = chart.options.drilldown.animation;

        if (oldSeries.animateDrillupFrom && oldSeries.chart) {
          // #2919
          oldSeries.animateDrillupFrom(level);
        }
      }

      newSeries.options._levelNumber = levelNumber;
      oldSeries.remove(false); // Reset the zoom level of the upper series

      if (newSeries.xAxis) {
        oldExtremes = level.oldExtremes;
        newSeries.xAxis.setExtremes(oldExtremes.xMin, oldExtremes.xMax, false);
        newSeries.yAxis.setExtremes(oldExtremes.yMin, oldExtremes.yMax, false);
      } // We have a resetZoomButton tucked away for this level. Attatch
      // it to the chart and show it.


      if (level.resetZoomButton) {
        chart.resetZoomButton = level.resetZoomButton;
        chart.resetZoomButton.show();
      }
    }
  } // Fire a once-off event after all series have been drilled up (#5158)


  fireEvent$e(chart, 'drillupall');
  this.redraw();

  if (this.drilldownLevels.length === 0) {
    this.drillUpButton = this.drillUpButton.destroy();
  } else {
    this.drillUpButton.attr({
      text: this.getDrilldownBackText()
    }).align();
  }

  this.ddDupes.length = []; // #3315
}; // Add update function to be called internally from Chart.update (#7600)


Chart$e.prototype.callbacks.push(function () {
  var chart = this;
  chart.drilldown = {
    update: function (options, redraw) {
      Highcharts.merge(true, chart.options.drilldown, options);

      if (pick$O(redraw, true)) {
        chart.redraw();
      }
    }
  };
}); // Don't show the reset button if we already are displaying the drillUp button.

Highcharts.addEvent(Chart$e, 'beforeShowResetZoom', function () {
  if (this.drillUpButton) {
    return false;
  }
});
Highcharts.addEvent(Chart$e, 'render', function setDDPoints() {
  each$Q(this.xAxis || [], function (axis) {
    axis.ddPoints = {};
    each$Q(axis.series, function (series) {
      var i,
          xData = series.xData || [],
          points = series.points,
          p;

      for (i = 0; i < xData.length; i++) {
        p = series.options.data[i]; // The `drilldown` property can only be set on an array or an
        // object

        if (typeof p !== 'number') {
          // Convert array to object (#8008)
          p = series.pointClass.prototype.optionsToObject.call({
            series: series
          }, p);

          if (p.drilldown) {
            if (!axis.ddPoints[xData[i]]) {
              axis.ddPoints[xData[i]] = [];
            }

            axis.ddPoints[xData[i]].push(points ? points[i] : true);
          }
        }
      }
    }); // Add drillability to ticks, and always keep it drillability updated
    // (#3951)

    objectEach$8(axis.ticks, Tick$3.prototype.drillable);
  });
});
/**
 * When drilling up, keep the upper series invisible until the lower series has
 * moved into place
 */

ColumnSeries.prototype.animateDrillupTo = function (init) {
  if (!init) {
    var newSeries = this,
        level = newSeries.drilldownLevel; // First hide all items before animating in again

    each$Q(this.points, function (point) {
      var dataLabel = point.dataLabel;

      if (point.graphic) {
        // #3407
        point.graphic.hide();
      }

      if (dataLabel) {
        // The data label is initially hidden, make sure it is not faded
        // in (#6127)
        dataLabel.hidden = dataLabel.attr('visibility') === 'hidden';

        if (!dataLabel.hidden) {
          dataLabel.hide();

          if (point.connector) {
            point.connector.hide();
          }
        }
      }
    }); // Do dummy animation on first point to get to complete

    Highcharts.syncTimeout(function () {
      if (newSeries.points) {
        // May be destroyed in the meantime, #3389
        each$Q(newSeries.points, function (point, i) {
          // Fade in other points
          var verb = i === (level && level.pointIndex) ? 'show' : 'fadeIn',
              inherit = verb === 'show' ? true : undefined,
              dataLabel = point.dataLabel;

          if (point.graphic) {
            // #3407
            point.graphic[verb](inherit);
          }

          if (dataLabel && !dataLabel.hidden) {
            // #6127
            dataLabel.fadeIn(); // #7384

            if (point.connector) {
              point.connector.fadeIn();
            }
          }
        });
      }
    }, Math.max(this.chart.options.drilldown.animation.duration - 50, 0)); // Reset

    this.animate = noop$g;
  }
};

ColumnSeries.prototype.animateDrilldown = function (init) {
  var series = this,
      drilldownLevels = this.chart.drilldownLevels,
      animateFrom,
      animationOptions = animObject$5(this.chart.options.drilldown.animation),
      xAxis = this.xAxis;

  if (!init) {
    each$Q(drilldownLevels, function (level) {
      if (series.options._ddSeriesId === level.lowerSeriesOptions._ddSeriesId) {
        animateFrom = level.shapeArgs;
      }
    });
    animateFrom.x += pick$O(xAxis.oldPos, xAxis.pos) - xAxis.pos;
    each$Q(this.points, function (point) {
      var animateTo = point.shapeArgs;

      if (point.graphic) {
        point.graphic.attr(animateFrom).animate(extend$q(point.shapeArgs, {
          fill: point.color || series.color
        }), animationOptions);
      }

      if (point.dataLabel) {
        point.dataLabel.fadeIn(animationOptions);
      }
    });
    this.animate = null;
  }
};
/**
 * When drilling up, pull out the individual point graphics from the lower
 * series and animate them into the origin point in the upper series.
 */


ColumnSeries.prototype.animateDrillupFrom = function (level) {
  var animationOptions = animObject$5(this.chart.options.drilldown.animation),
      group = this.group,
      // For 3d column series all columns are added to one group
  // so we should not delete the whole group. #5297
  removeGroup = group !== this.chart.columnGroup,
      series = this; // Cancel mouse events on the series group (#2787)

  each$Q(series.trackerGroups, function (key) {
    if (series[key]) {
      // we don't always have dataLabelsGroup
      series[key].on('mouseover');
    }
  });

  if (removeGroup) {
    delete this.group;
  }

  each$Q(this.points, function (point) {
    var graphic = point.graphic,
        animateTo = level.shapeArgs,
        complete = function () {
      graphic.destroy();

      if (group && removeGroup) {
        group = group.destroy();
      }
    };

    if (graphic) {
      delete point.graphic;

      if (animationOptions.duration) {
        graphic.animate(animateTo, Highcharts.merge(animationOptions, {
          complete: complete
        }));
      } else {
        graphic.attr(animateTo);
        complete();
      }
    }
  });
};

if (PieSeries) {
  extend$q(PieSeries.prototype, {
    animateDrillupTo: ColumnSeries.prototype.animateDrillupTo,
    animateDrillupFrom: ColumnSeries.prototype.animateDrillupFrom,
    animateDrilldown: function (init) {
      var level = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1],
          animationOptions = this.chart.options.drilldown.animation,
          animateFrom = level.shapeArgs,
          start = animateFrom.start,
          angle = animateFrom.end - start,
          startAngle = angle / this.points.length;

      if (!init) {
        each$Q(this.points, function (point, i) {
          var animateTo = point.shapeArgs;

          if (point.graphic) {
            point.graphic.attr(Highcharts.merge(animateFrom, {
              start: start + i * startAngle,
              end: start + (i + 1) * startAngle
            }))[animationOptions ? 'animate' : 'attr'](animateTo, animationOptions);
          }
        });
        this.animate = null;
      }
    }
  });
}

Highcharts.Point.prototype.doDrilldown = function (_holdRedraw, category, originalEvent) {
  var series = this.series,
      chart = series.chart,
      drilldown = chart.options.drilldown,
      i = (drilldown.series || []).length,
      seriesOptions;

  if (!chart.ddDupes) {
    chart.ddDupes = [];
  }

  while (i-- && !seriesOptions) {
    if (drilldown.series[i].id === this.drilldown && inArray$a(this.drilldown, chart.ddDupes) === -1) {
      seriesOptions = drilldown.series[i];
      chart.ddDupes.push(this.drilldown);
    }
  } // Fire the event. If seriesOptions is undefined, the implementer can check
  // for  seriesOptions, and call addSeriesAsDrilldown async if necessary.


  fireEvent$e(chart, 'drilldown', {
    point: this,
    seriesOptions: seriesOptions,
    category: category,
    originalEvent: originalEvent,
    points: category !== undefined && this.series.xAxis.getDDPoints(category).slice(0)
  }, function (e) {
    var chart = e.point.series && e.point.series.chart,
        seriesOptions = e.seriesOptions;

    if (chart && seriesOptions) {
      if (_holdRedraw) {
        chart.addSingleSeriesAsDrilldown(e.point, seriesOptions);
      } else {
        chart.addSeriesAsDrilldown(e.point, seriesOptions);
      }
    }
  });
};
/**
 * Drill down to a given category. This is the same as clicking on an axis
 * label.
 */


Highcharts.Axis.prototype.drilldownCategory = function (x, e) {
  objectEach$8(this.getDDPoints(x), function (point) {
    if (point && point.series && point.series.visible && point.doDrilldown) {
      // #3197
      point.doDrilldown(true, x, e);
    }
  });
  this.chart.applyDrilldown();
};
/**
 * Return drillable points for this specific X value
 */


Highcharts.Axis.prototype.getDDPoints = function (x) {
  return this.ddPoints && this.ddPoints[x];
};
/**
 * Make a tick label drillable, or remove drilling on update
 */


Tick$3.prototype.drillable = function () {
  var pos = this.pos,
      label = this.label,
      axis = this.axis,
      isDrillable = axis.coll === 'xAxis' && axis.getDDPoints,
      ddPointsX = isDrillable && axis.getDDPoints(pos);

  if (isDrillable) {
    if (label && ddPointsX && ddPointsX.length) {
      label.drillable = true;
      label.addClass('highcharts-drilldown-axis-label').on('click', function (e) {
        axis.drilldownCategory(pos, e);
      });
    } else if (label && label.drillable) {
      label.on('click', null); // #3806

      label.removeClass('highcharts-drilldown-axis-label');
    }
  }
};
/**
 * On initialization of each point, identify its label and make it clickable.
 * Also, provide a list of points associated to that label.
 */


Highcharts.addEvent(Highcharts.Point, 'afterInit', function () {
  var point = this,
      series = point.series;

  if (point.drilldown) {
    // Add the click event to the point
    Highcharts.addEvent(point, 'click', function (e) {
      if (series.xAxis && series.chart.options.drilldown.allowPointDrilldown === false) {
        series.xAxis.drilldownCategory(point.x, e); // #5822, x changed
      } else {
        point.doDrilldown(undefined, undefined, e);
      }
    });
  }

  return point;
});
Highcharts.addEvent(Highcharts.Series, 'afterDrawDataLabels', function () {
  var css = this.chart.options.drilldown.activeDataLabelStyle,
      renderer = this.chart.renderer;
  each$Q(this.points, function (point) {
    var dataLabelsOptions = point.options.dataLabels,
        pointCSS = pick$O(point.dlOptions, dataLabelsOptions && dataLabelsOptions.style, {});

    if (point.drilldown && point.dataLabel) {
      if (dataLabelsOptions && dataLabelsOptions.color) {
        pointCSS.color = dataLabelsOptions.color;
      }

      point.dataLabel.addClass('highcharts-drilldown-data-label');
    }
  }, this);
});

var applyCursorCSS = function (element, cursor, addClass) {
  element[addClass ? 'addClass' : 'removeClass']('highcharts-drilldown-point');
}; // Mark the trackers with a pointer


Highcharts.addEvent(Highcharts.Series, 'afterDrawTracker', function () {
  each$Q(this.points, function (point) {
    if (point.drilldown && point.graphic) {
      applyCursorCSS(point.graphic, 'pointer', true);
    }
  });
});
Highcharts.addEvent(Highcharts.Point, 'afterSetState', function () {
  if (this.drilldown && this.series.halo && this.state === 'hover') {
    applyCursorCSS(this.series.halo, 'pointer', true);
  } else if (this.series.halo) {
    applyCursorCSS(this.series.halo, 'auto', false);
  }
});

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 * Highcharts Drilldown module
 *
 * Author: Torstein Honsi
 * License: www.highcharts.com/license
 *
 */

/**
 * Exporting module
 *
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

var defaultOptions$9 = Highcharts.defaultOptions,
    doc$9 = Highcharts.doc,
    Chart$f = Highcharts.Chart,
    addEvent$t = Highcharts.addEvent,
    removeEvent$8 = Highcharts.removeEvent,
    fireEvent$f = Highcharts.fireEvent,
    createElement$6 = Highcharts.createElement,
    discardElement$3 = Highcharts.discardElement,
    css$a = Highcharts.css,
    merge$w = Highcharts.merge,
    pick$P = Highcharts.pick,
    each$R = Highcharts.each,
    objectEach$9 = Highcharts.objectEach,
    extend$r = Highcharts.extend,
    isTouchDevice$3 = Highcharts.isTouchDevice,
    win$c = Highcharts.win,
    userAgent$1 = win$c.navigator.userAgent,
    SVGRenderer$5 = Highcharts.SVGRenderer,
    symbols$1 = Highcharts.Renderer.prototype.symbols,
    isMSBrowser = /Edge\/|Trident\/|MSIE /.test(userAgent$1),
    isFirefoxBrowser = /firefox/i.test(userAgent$1); // Add language

extend$r(defaultOptions$9.lang, {
  /**
   * Exporting module only. The text for the menu item to print the chart.
   *
   * @type {String}
   * @default Print chart
   * @since 3.0.1
   * @apioption lang.printChart
   */
  printChart: 'Print chart',

  /**
   * Exporting module only. The text for the PNG download menu item.
   *
   * @type {String}
   * @default Download PNG image
   * @since 2.0
   * @apioption lang.downloadPNG
   */
  downloadPNG: 'Download PNG image',

  /**
   * Exporting module only. The text for the JPEG download menu item.
   *
   * @type {String}
   * @default Download JPEG image
   * @since 2.0
   * @apioption lang.downloadJPEG
   */
  downloadJPEG: 'Download JPEG image',

  /**
   * Exporting module only. The text for the PDF download menu item.
   *
   * @type {String}
   * @default Download PDF document
   * @since 2.0
   * @apioption lang.downloadPDF
   */
  downloadPDF: 'Download PDF document',

  /**
   * Exporting module only. The text for the SVG download menu item.
   *
   * @type {String}
   * @default Download SVG vector image
   * @since 2.0
   * @apioption lang.downloadSVG
   */
  downloadSVG: 'Download SVG vector image',

  /**
   * Exporting module menu. The tooltip title for the context menu holding
   * print and export menu items.
   *
   * @type {String}
   * @default Chart context menu
   * @since 3.0
   * @apioption lang.contextButtonTitle
   */
  contextButtonTitle: 'Chart context menu'
}); // Buttons and menus are collected in a separate config option set called
// 'navigation'. This can be extended later to add control buttons like zoom and
// pan right click menus.

defaultOptions$9.navigation = {
  buttonOptions: {
    theme: {},

    /**
     * Whether to enable buttons.
     *
     * @type {Boolean}
     * @sample highcharts/navigation/buttonoptions-enabled/
     *         Exporting module loaded but buttons disabled
     * @default true
     * @since 2.0
     * @apioption navigation.buttonOptions.enabled
     */

    /**
     * The pixel size of the symbol on the button.
     *
     * @type {Number}
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     * @default 14
     * @since 2.0
     * @apioption navigation.buttonOptions.symbolSize
     */
    symbolSize: 14,

    /**
     * The x position of the center of the symbol inside the button.
     *
     * @type {Number}
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     * @default 12.5
     * @since 2.0
     * @apioption navigation.buttonOptions.symbolX
     */
    symbolX: 12.5,

    /**
     * The y position of the center of the symbol inside the button.
     *
     * @type {Number}
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     * @default 10.5
     * @since 2.0
     * @apioption navigation.buttonOptions.symbolY
     */
    symbolY: 10.5,

    /**
     * Alignment for the buttons.
     *
     * @validvalue ["left", "center", "right"]
     * @type {String}
     * @sample highcharts/navigation/buttonoptions-align/
     *         Center aligned
     * @default right
     * @since 2.0
     * @apioption navigation.buttonOptions.align
     */
    align: 'right',

    /**
     * The pixel spacing between buttons.
     *
     * @type {Number}
     * @default 3
     * @since 2.0
     * @apioption navigation.buttonOptions.buttonSpacing
     */
    buttonSpacing: 3,

    /**
     * Pixel height of the buttons.
     *
     * @type {Number}
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     * @default 22
     * @since 2.0
     * @apioption navigation.buttonOptions.height
     */
    height: 22,

    /**
     * A text string to add to the individual button.
     *
     * @type {String}
     * @sample highcharts/exporting/buttons-text/
     *         Full text button
     * @sample highcharts/exporting/buttons-text-symbol/
     *         Combined symbol and text
     * @default null
     * @since 3.0
     * @apioption navigation.buttonOptions.text
     */

    /**
     * The vertical offset of the button's position relative to its
     * `verticalAlign`.
     *
     * @type {Number}
     * @sample highcharts/navigation/buttonoptions-verticalalign/
     *         Buttons at lower right
     * @default 0
     * @since 2.0
     * @apioption navigation.buttonOptions.y
     */

    /**
     * The vertical alignment of the buttons. Can be one of "top", "middle"
     * or "bottom".
     *
     * @validvalue ["top", "middle", "bottom"]
     * @type {String}
     * @sample highcharts/navigation/buttonoptions-verticalalign/
     *         Buttons at lower right
     * @default top
     * @since 2.0
     * @apioption navigation.buttonOptions.verticalAlign
     */
    verticalAlign: 'top',

    /**
     * The pixel width of the button.
     *
     * @type {Number}
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     * @default 24
     * @since 2.0
     * @apioption navigation.buttonOptions.width
     */
    width: 24
  }
}; // Add the export related options

/**
 * Options for the exporting module. For an overview on the matter, see
 * [the docs](https://www.highcharts.com/docs/export-module/export-module-overview).
 * @type {Object}
 * @optionparent exporting
 */

defaultOptions$9.exporting = {
  /**
   * Experimental setting to allow HTML inside the chart (added through
   * the `useHTML` options), directly in the exported image. This allows
   * you to preserve complicated HTML structures like tables or bi-directional
   * text in exported charts.
   *
   * Disclaimer: The HTML is rendered in a `foreignObject` tag in the
   * generated SVG. The official export server is based on PhantomJS,
   * which supports this, but other SVG clients, like Batik, does not
   * support it. This also applies to downloaded SVG that you want to
   * open in a desktop client.
   *
   * @type {Boolean}
   * @default false
   * @since 4.1.8
   * @apioption exporting.allowHTML
   */

  /**
   * Additional chart options to be merged into an exported chart. For
   * example, a common use case is to add data labels to improve readability
   * of the exported chart, or to add a printer-friendly color scheme.
   *
   * @type {Object}
   * @sample {highcharts} highcharts/exporting/chartoptions-data-labels/
   *         Added data labels
   * @sample {highstock} highcharts/exporting/chartoptions-data-labels/
   *         Added data labels
   * @default null
   * @apioption exporting.chartOptions
   */

  /**
   * Whether to enable the exporting module. Disabling the module will
   * hide the context button, but API methods will still be available.
   *
   * @type {Boolean}
   * @sample {highcharts} highcharts/exporting/enabled-false/
   *         Exporting module is loaded but disabled
   * @sample {highstock} highcharts/exporting/enabled-false/
   *         Exporting module is loaded but disabled
   * @default true
   * @since 2.0
   * @apioption exporting.enabled
   */

  /**
   * Function to call if the offline-exporting module fails to export
   * a chart on the client side, and [fallbackToExportServer](
   * #exporting.fallbackToExportServer) is disabled. If left undefined, an
   * exception is thrown instead. Receives two parameters, the exporting
   * options, and the error from the module.
   *
   * @type {Function}
   * @see [fallbackToExportServer](#exporting.fallbackToExportServer)
   * @default undefined
   * @since 5.0.0
   * @apioption exporting.error
   */

  /**
   * Whether or not to fall back to the export server if the offline-exporting
   * module is unable to export the chart on the client side. This happens for
   * certain browsers, and certain features (e.g.
   * [allowHTML](#exporting.allowHTML)), depending on the image type exporting
   * to. For very complex charts, it is possible that export can fail in
   * browsers that don't support Blob objects, due to data URL length limits.
   * It is recommended to define the [exporting.error](#exporting.error)
   * handler if disabling fallback, in order to notify users in case export
   * fails.
   *
   * @type {Boolean}
   * @default true
   * @since 4.1.8
   * @apioption exporting.fallbackToExportServer
   */

  /**
   * The filename, without extension, to use for the exported chart.
   *
   * @type {String}
   * @sample {highcharts} highcharts/exporting/filename/ Custom file name
   * @sample {highstock} highcharts/exporting/filename/ Custom file name
   * @default chart
   * @since 2.0
   * @apioption exporting.filename
   */

  /**
   * An object containing additional attributes for the POST form that
   * sends the SVG to the export server. For example, a `target` can be
   * set to make sure the generated image is received in another frame,
   *  or a custom `enctype` or `encoding` can be set.
   *
   * @type {Object}
   * @since 3.0.8
   * @apioption exporting.formAttributes
   */

  /**
   * Path where Highcharts will look for export module dependencies to
   * load on demand if they don't already exist on `window`. Should currently
   * point to location of [CanVG](https://github.com/canvg/canvg) library,
   * [RGBColor.js](https://github.com/canvg/canvg), [jsPDF](https://github.
   * com/yWorks/jsPDF) and [svg2pdf.js](https://github.com/yWorks/svg2pdf.
   * js), required for client side export in certain browsers.
   *
   * @type {String}
   * @default https://code.highcharts.com/{version}/lib
   * @since 5.0.0
   * @apioption exporting.libURL
   */

  /**
   * Analogous to [sourceWidth](#exporting.sourceWidth).
   *
   * @type {Number}
   * @since 3.0
   * @apioption exporting.sourceHeight
   */

  /**
   * The width of the original chart when exported, unless an explicit
   * [chart.width](#chart.width) is set. The width exported raster image
   * is then multiplied by [scale](#exporting.scale).
   *
   * @type {Number}
   * @sample {highcharts} highcharts/exporting/sourcewidth/ Source size demo
   * @sample {highstock} highcharts/exporting/sourcewidth/ Source size demo
   * @sample {highmaps} maps/exporting/sourcewidth/ Source size demo
   * @since 3.0
   * @apioption exporting.sourceWidth
   */

  /**
   * The pixel width of charts exported to PNG or JPG. As of Highcharts
   * 3.0, the default pixel width is a function of the [chart.width](
   * #chart.width) or [exporting.sourceWidth](#exporting.sourceWidth) and the
   * [exporting.scale](#exporting.scale).
   *
   * @type {Number}
   * @sample {highcharts} highcharts/exporting/width/
   *         Export to 200px wide images
   * @sample {highstock} highcharts/exporting/width/
   *         Export to 200px wide images
   * @default undefined
   * @since 2.0
   * @apioption exporting.width
   */

  /**
   * Default MIME type for exporting if `chart.exportChart()` is called
   * without specifying a `type` option. Possible values are `image/png`,
   *  `image/jpeg`, `application/pdf` and `image/svg+xml`.
   *
   * @validvalue ["image/png", "image/jpeg", "application/pdf", "image/svg+xml"]
   * @since 2.0
   */
  type: 'image/png',

  /**
   * The URL for the server module converting the SVG string to an image
   * format. By default this points to Highchart's free web service.
   *
   * @type {String}
   * @default https://export.highcharts.com
   * @since 2.0
   */
  url: 'https://export.highcharts.com/',

  /**
   * When printing the chart from the menu item in the burger menu, if
   * the on-screen chart exceeds this width, it is resized. After printing
   * or cancelled, it is restored. The default width makes the chart
   * fit into typical paper format. Note that this does not affect the
   * chart when printing the web page as a whole.
   *
   * @type {Number}
   * @default 780
   * @since 4.2.5
   */
  printMaxWidth: 780,

  /**
   * Defines the scale or zoom factor for the exported image compared
   * to the on-screen display. While for instance a 600px wide chart
   * may look good on a website, it will look bad in print. The default
   * scale of 2 makes this chart export to a 1200px PNG or JPG.
   *
   * @see    [chart.width](#chart.width),
   *         [exporting.sourceWidth](#exporting.sourceWidth)
   * @sample {highcharts} highcharts/exporting/scale/ Scale demonstrated
   * @sample {highstock} highcharts/exporting/scale/ Scale demonstrated
   * @sample {highmaps} maps/exporting/scale/ Scale demonstrated
   * @since 3.0
   */
  scale: 2,

  /**
   * Options for the export related buttons, print and export. In addition
   * to the default buttons listed here, custom buttons can be added.
   * See [navigation.buttonOptions](#navigation.buttonOptions) for general
   * options.
   *
   */
  buttons: {
    /**
     * Options for the export button.
     *
     * In styled mode, export button styles can be applied with the
     * `.highcharts-contextbutton` class.
     *
     * @extends navigation.buttonOptions
     */
    contextButton: {
      /**
       * A click handler callback to use on the button directly instead of
       * the popup menu.
       *
       * @type {Function}
       * @sample highcharts/exporting/buttons-contextbutton-onclick/
       *         Skip the menu and export the chart directly
       * @since 2.0
       * @apioption exporting.buttons.contextButton.onclick
       */

      /**
       * See [navigation.buttonOptions.symbolFill](
       * #navigation.buttonOptions.symbolFill).
       *
       * @type {Color}
       * @default #666666
       * @since 2.0
       * @apioption exporting.buttons.contextButton.symbolFill
       */

      /**
       * The horizontal position of the button relative to the `align`
       * option.
       *
       * @type {Number}
       * @default -10
       * @since 2.0
       * @apioption exporting.buttons.contextButton.x
       */

      /**
       * The class name of the context button.
       * @type {String}
       */
      className: 'highcharts-contextbutton',

      /**
       * The class name of the menu appearing from the button.
       * @type {String}
       */
      menuClassName: 'highcharts-contextmenu',

      /**
       * The symbol for the button. Points to a definition function in
       * the `Highcharts.Renderer.symbols` collection. The default
       * `exportIcon` function is part of the exporting module.
       *
       * @validvalue ["exportIcon", "circle", "square", "diamond", "triangle", "triangle-down", "menu"]
       * @type {String}
       * @sample highcharts/exporting/buttons-contextbutton-symbol/
       *         Use a circle for symbol
       * @sample highcharts/exporting/buttons-contextbutton-symbol-custom/
       *         Custom shape as symbol
       * @default menu
       * @since 2.0
       */
      symbol: 'menu',

      /**
       * The key to a [lang](#lang) option setting that is used for the
       * button's title tooltip. When the key is `contextButtonTitle`, it
       * refers to [lang.contextButtonTitle](#lang.contextButtonTitle)
       * that defaults to "Chart context menu".
       *
       * @since 6.1.4
       */
      titleKey: 'contextButtonTitle',

      /**
       * This option is deprecated, use
       * [titleKey](#exporting.buttons.contextButton.titleKey) instead.
       *
       * @deprecated
       * @type      {string}
       * @apioption exporting.buttons.contextButton._titleKey
       */

      /**
       * A collection of strings pointing to config options for the menu
       * items. The config options are defined in the
       * `menuItemDefinitions` option.
       *
       * By default, there is the "Print" menu item plus one menu item
       * for each of the available export types.
       *
       * Defaults to
       * <pre>
       * [
       *    'printChart',
       *    'separator',
       *    'downloadPNG',
       *    'downloadJPEG',
       *    'downloadPDF',
       *    'downloadSVG'
       * ]
       * </pre>
       *
       * @type {Array<String>|Array<Object>}
        * @sample {highcharts} highcharts/exporting/menuitemdefinitions/
        *         Menu item definitions
        * @sample {highstock} highcharts/exporting/menuitemdefinitions/
        *         Menu item definitions
        * @sample {highmaps} highcharts/exporting/menuitemdefinitions/
        *         Menu item definitions
       * @since 2.0
       */
      menuItems: ['printChart', 'separator', 'downloadPNG', 'downloadJPEG', 'downloadPDF', 'downloadSVG']
    }
  },

  /**
   * An object consisting of definitions for the menu items in the context
   * menu. Each key value pair has a `key` that is referenced in the
   * [menuItems](#exporting.buttons.contextButton.menuItems) setting,
   * and a `value`, which is an object with the following properties:
   *
   * <dl>
   *
   * <dt>onclick</dt>
   *
   * <dd>The click handler for the menu item</dd>
   *
   * <dt>text</dt>
   *
   * <dd>The text for the menu item</dd>
   *
   * <dt>textKey</dt>
   *
   * <dd>If internationalization is required, the key to a language string
   * </dd>
   *
   * </dl>
   *
   * @type {Object}
   * @sample {highcharts} highcharts/exporting/menuitemdefinitions/
   *         Menu item definitions
   * @sample {highstock} highcharts/exporting/menuitemdefinitions/
   *         Menu item definitions
   * @sample {highmaps} highcharts/exporting/menuitemdefinitions/
   *         Menu item definitions
   * @since 5.0.13
   */
  menuItemDefinitions: {
    /**
     * @ignore
     */
    printChart: {
      textKey: 'printChart',
      onclick: function () {
        this.print();
      }
    },

    /**
     * @ignore
     */
    separator: {
      separator: true
    },

    /**
     * @ignore
     */
    downloadPNG: {
      textKey: 'downloadPNG',
      onclick: function () {
        this.exportChart();
      }
    },

    /**
     * @ignore
     */
    downloadJPEG: {
      textKey: 'downloadJPEG',
      onclick: function () {
        this.exportChart({
          type: 'image/jpeg'
        });
      }
    },

    /**
     * @ignore
     */
    downloadPDF: {
      textKey: 'downloadPDF',
      onclick: function () {
        this.exportChart({
          type: 'application/pdf'
        });
      }
    },

    /**
     * @ignore
     */
    downloadSVG: {
      textKey: 'downloadSVG',
      onclick: function () {
        this.exportChart({
          type: 'image/svg+xml'
        });
      }
    }
  }
};
/**
 * Fires after a chart is printed through the context menu item or the
 * `Chart.print` method. Requires the exporting module.
 *
 * @type {Function}
 * @context Chart
 * @sample highcharts/chart/events-beforeprint-afterprint/
 *         Rescale the chart to print
 * @since 4.1.0
 * @apioption chart.events.afterPrint
 */

/**
 * Fires before a chart is printed through the context menu item or
 * the `Chart.print` method. Requires the exporting module.
 *
 * @type {Function}
 * @context Chart
 * @sample highcharts/chart/events-beforeprint-afterprint/
 *         Rescale the chart to print
 * @since 4.1.0
 * @apioption chart.events.beforePrint
 */
// Add the H.post utility

Highcharts.post = function (url, data, formAttributes) {
  // create the form
  var form = createElement$6('form', merge$w({
    method: 'post',
    action: url,
    enctype: 'multipart/form-data'
  }, formAttributes), {
    display: 'none'
  }, doc$9.body); // add the data

  objectEach$9(data, function (val, name) {
    createElement$6('input', {
      type: 'hidden',
      name: name,
      value: val
    }, null, form);
  }); // submit

  form.submit(); // clean up

  discardElement$3(form);
};

extend$r(Chart$f.prototype,
/** @lends Highcharts.Chart.prototype */
{
  /**
   * Exporting module only. A collection of fixes on the produced SVG to
   * account for expando properties, browser bugs, VML problems and other.
   * Returns a cleaned SVG.
   *
   * @private
   */
  sanitizeSVG: function (svg, options) {
    // Move HTML into a foreignObject
    if (options && options.exporting && options.exporting.allowHTML) {
      var html = svg.match(/<\/svg>(.*?$)/);

      if (html && html[1]) {
        html = '<foreignObject x="0" y="0" ' + 'width="' + options.chart.width + '" ' + 'height="' + options.chart.height + '">' + '<body xmlns="http://www.w3.org/1999/xhtml">' + html[1] + '</body>' + '</foreignObject>';
        svg = svg.replace('</svg>', html + '</svg>');
      }
    }

    svg = svg.replace(/zIndex="[^"]+"/g, '').replace(/symbolName="[^"]+"/g, '').replace(/jQuery[0-9]+="[^"]+"/g, '').replace(/url\(("|&quot;)(\S+)("|&quot;)\)/g, 'url($2)').replace(/url\([^#]+#/g, 'url(#').replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (|NS[0-9]+\:)href=/g, ' xlink:href=') // #3567
    .replace(/\n/, ' ') // Any HTML added to the container after the SVG (#894)
    .replace(/<\/svg>.*?$/, '</svg>') // Batik doesn't support rgba fills and strokes (#3095)
    .replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g, // eslint-disable-line max-len
    '$1="rgb($2)" $1-opacity="$3"') // Replace HTML entities, issue #347
    .replace(/&nbsp;/g, '\u00A0') // no-break space
    .replace(/&shy;/g, '\u00AD'); // soft hyphen

    return svg;
  },

  /**
   * Return the unfiltered innerHTML of the chart container. Used as hook for
   * plugins. In styled mode, it also takes care of inlining CSS style rules.
   *
   * @see  Chart#getSVG
   *
   * @returns {String}
   *          The unfiltered SVG of the chart.
   */
  getChartHTML: function () {
    this.inlineStyles();
    return this.container.innerHTML;
  },

  /**
   * Return an SVG representation of the chart.
   *
   * @param  chartOptions {Options}
   *         Additional chart options for the generated SVG representation.
   *         For collections like `xAxis`, `yAxis` or `series`, the additional
   *         options is either merged in to the orininal item of the same
   *         `id`, or to the first item if a common id is not found.
   * @return {String}
   *         The SVG representation of the rendered chart.
   * @sample highcharts/members/chart-getsvg/
   *         View the SVG from a button
   */
  getSVG: function (chartOptions) {
    var chart = this,
        chartCopy,
        sandbox,
        svg,
        seriesOptions,
        sourceWidth,
        sourceHeight,
        cssWidth,
        cssHeight,
        // Copy the options and add extra options
    options = merge$w(chart.options, chartOptions); // create a sandbox where a new chart will be generated

    sandbox = createElement$6('div', null, {
      position: 'absolute',
      top: '-9999em',
      width: chart.chartWidth + 'px',
      height: chart.chartHeight + 'px'
    }, doc$9.body); // get the source size

    cssWidth = chart.renderTo.style.width;
    cssHeight = chart.renderTo.style.height;
    sourceWidth = options.exporting.sourceWidth || options.chart.width || /px$/.test(cssWidth) && parseInt(cssWidth, 10) || 600;
    sourceHeight = options.exporting.sourceHeight || options.chart.height || /px$/.test(cssHeight) && parseInt(cssHeight, 10) || 400; // override some options

    extend$r(options.chart, {
      animation: false,
      renderTo: sandbox,
      forExport: true,
      renderer: 'SVGRenderer',
      width: sourceWidth,
      height: sourceHeight
    });
    options.exporting.enabled = false; // hide buttons in print

    delete options.data; // #3004
    // prepare for replicating the chart

    options.series = [];
    each$R(chart.series, function (serie) {
      seriesOptions = merge$w(serie.userOptions, {
        // #4912
        animation: false,
        // turn off animation
        enableMouseTracking: false,
        showCheckbox: false,
        visible: serie.visible
      }); // Used for the navigator series that has its own option set

      if (!seriesOptions.isInternal) {
        options.series.push(seriesOptions);
      }
    }); // Assign an internal key to ensure a one-to-one mapping (#5924)

    each$R(chart.axes, function (axis) {
      if (!axis.userOptions.internalKey) {
        // #6444
        axis.userOptions.internalKey = Highcharts.uniqueKey();
      }
    }); // generate the chart copy

    chartCopy = new Highcharts.Chart(options, chart.callback); // Axis options and series options  (#2022, #3900, #5982)

    if (chartOptions) {
      each$R(['xAxis', 'yAxis', 'series'], function (coll) {
        var collOptions = {};

        if (chartOptions[coll]) {
          collOptions[coll] = chartOptions[coll];
          chartCopy.update(collOptions);
        }
      });
    } // Reflect axis extremes in the export (#5924)


    each$R(chart.axes, function (axis) {
      var axisCopy = Highcharts.find(chartCopy.axes, function (copy) {
        return copy.options.internalKey === axis.userOptions.internalKey;
      }),
          extremes = axis.getExtremes(),
          userMin = extremes.userMin,
          userMax = extremes.userMax;

      if (axisCopy && (userMin !== undefined && userMin !== axisCopy.min || userMax !== undefined && userMax !== axisCopy.max)) {
        axisCopy.setExtremes(userMin, userMax, true, false);
      }
    }); // Get the SVG from the container's innerHTML

    svg = chartCopy.getChartHTML();
    fireEvent$f(this, 'getSVG', {
      chartCopy: chartCopy
    });
    svg = chart.sanitizeSVG(svg, options); // free up memory

    options = null;
    chartCopy.destroy();
    discardElement$3(sandbox);
    return svg;
  },
  getSVGForExport: function (options, chartOptions) {
    var chartExportingOptions = this.options.exporting;
    return this.getSVG(merge$w({
      chart: {
        borderRadius: 0
      }
    }, chartExportingOptions.chartOptions, chartOptions, {
      exporting: {
        sourceWidth: options && options.sourceWidth || chartExportingOptions.sourceWidth,
        sourceHeight: options && options.sourceHeight || chartExportingOptions.sourceHeight
      }
    }));
  },

  /**
   * Exporting module required. Submit an SVG version of the chart to a server
   * along with some parameters for conversion.
   * @param  {Object} exportingOptions
   *         Exporting options in addition to those defined in {@link
   *         https://api.highcharts.com/highcharts/exporting|exporting}.
   * @param  {String} exportingOptions.filename
   *         The file name for the export without extension.
   * @param  {String} exportingOptions.url
   *         The URL for the server module to do the conversion.
   * @param  {Number} exportingOptions.width
   *         The width of the PNG or JPG image generated on the server.
   * @param  {String} exportingOptions.type
   *         The MIME type of the converted image.
   * @param  {Number} exportingOptions.sourceWidth
   *         The pixel width of the source (in-page) chart.
   * @param  {Number} exportingOptions.sourceHeight
   *         The pixel height of the source (in-page) chart.
   * @param  {Options} chartOptions
   *         Additional chart options for the exported chart. For example a
   *         different background color can be added here, or `dataLabels`
   *         for export only.
   *
   * @sample highcharts/members/chart-exportchart/
   *         Export with no options
   * @sample highcharts/members/chart-exportchart-filename/
   *         PDF type and custom filename
   * @sample highcharts/members/chart-exportchart-custom-background/
   *         Different chart background in export
   * @sample stock/members/chart-exportchart/
   *         Export with Highstock
   */
  exportChart: function (exportingOptions, chartOptions) {
    var svg = this.getSVGForExport(exportingOptions, chartOptions); // merge the options

    exportingOptions = merge$w(this.options.exporting, exportingOptions); // do the post

    Highcharts.post(exportingOptions.url, {
      filename: exportingOptions.filename || 'chart',
      type: exportingOptions.type,
      // IE8 fails to post undefined correctly, so use 0
      width: exportingOptions.width || 0,
      scale: exportingOptions.scale,
      svg: svg
    }, exportingOptions.formAttributes);
  },

  /**
   * Exporting module required. Clears away other elements in the page and
   * prints the chart as it is displayed. By default, when the exporting
   * module is enabled, a context button with a drop down menu in the upper
   * right corner accesses this function.
   *
   * @sample highcharts/members/chart-print/
   *         Print from a HTML button
   */
  print: function () {
    var chart = this,
        container = chart.container,
        origDisplay = [],
        origParent = container.parentNode,
        body = doc$9.body,
        childNodes = body.childNodes,
        printMaxWidth = chart.options.exporting.printMaxWidth,
        resetParams,
        handleMaxWidth;

    if (chart.isPrinting) {
      // block the button while in printing mode
      return;
    }

    chart.isPrinting = true;
    chart.pointer.reset(null, 0);
    fireEvent$f(chart, 'beforePrint'); // Handle printMaxWidth

    handleMaxWidth = printMaxWidth && chart.chartWidth > printMaxWidth;

    if (handleMaxWidth) {
      resetParams = [chart.options.chart.width, undefined, false];
      chart.setSize(printMaxWidth, undefined, false);
    } // hide all body content


    each$R(childNodes, function (node, i) {
      if (node.nodeType === 1) {
        origDisplay[i] = node.style.display;
        node.style.display = 'none';
      }
    }); // pull out the chart

    body.appendChild(container); // Give the browser time to draw WebGL content, an issue that randomly
    // appears (at least) in Chrome ~67 on the Mac (#8708).

    setTimeout(function () {
      win$c.focus(); // #1510

      win$c.print(); // allow the browser to prepare before reverting

      setTimeout(function () {
        // put the chart back in
        origParent.appendChild(container); // restore all body content

        each$R(childNodes, function (node, i) {
          if (node.nodeType === 1) {
            node.style.display = origDisplay[i];
          }
        });
        chart.isPrinting = false; // Reset printMaxWidth

        if (handleMaxWidth) {
          chart.setSize.apply(chart, resetParams);
        }

        fireEvent$f(chart, 'afterPrint');
      }, 1000);
    }, 1);
  },

  /**
   * Display a popup menu for choosing the export type.
   *
   * @private
   *
   * @param {String} className An identifier for the menu
   * @param {Array} items A collection with text and onclicks for the items
   * @param {Number} x The x position of the opener button
   * @param {Number} y The y position of the opener button
   * @param {Number} width The width of the opener button
   * @param {Number} height The height of the opener button
   */
  contextMenu: function (className, items, x, y, width, height, button) {
    var chart = this,
        navOptions = chart.options.navigation,
        chartWidth = chart.chartWidth,
        chartHeight = chart.chartHeight,
        cacheName = 'cache-' + className,
        menu = chart[cacheName],
        menuPadding = Math.max(width, height),
        // for mouse leave detection
    innerMenu,
        menuStyle; // create the menu only the first time

    if (!menu) {
      // create a HTML element above the SVG
      chart.exportContextMenu = chart[cacheName] = menu = createElement$6('div', {
        className: className
      }, {
        position: 'absolute',
        zIndex: 1000,
        padding: menuPadding + 'px',
        pointerEvents: 'auto'
      }, chart.fixedDiv || chart.container);
      innerMenu = createElement$6('div', {
        className: 'highcharts-menu'
      }, null, menu); // hide on mouse out

      menu.hideMenu = function () {
        css$a(menu, {
          display: 'none'
        });

        if (button) {
          button.setState(0);
        }

        chart.openMenu = false;
        Highcharts.clearTimeout(menu.hideTimer);
      }; // Hide the menu some time after mouse leave (#1357)


      chart.exportEvents.push(addEvent$t(menu, 'mouseleave', function () {
        menu.hideTimer = setTimeout(menu.hideMenu, 500);
      }), addEvent$t(menu, 'mouseenter', function () {
        Highcharts.clearTimeout(menu.hideTimer);
      }), // Hide it on clicking or touching outside the menu (#2258,
      // #2335, #2407)
      addEvent$t(doc$9, 'mouseup', function (e) {
        if (!chart.pointer.inClass(e.target, className)) {
          menu.hideMenu();
        }
      }), addEvent$t(menu, 'click', function () {
        if (chart.openMenu) {
          menu.hideMenu();
        }
      })); // create the items

      each$R(items, function (item) {
        if (typeof item === 'string') {
          item = chart.options.exporting.menuItemDefinitions[item];
        }

        if (Highcharts.isObject(item, true)) {
          var element;

          if (item.separator) {
            element = createElement$6('hr', null, null, innerMenu);
          } else {
            element = createElement$6('div', {
              className: 'highcharts-menu-item',
              onclick: function (e) {
                if (e) {
                  // IE7
                  e.stopPropagation();
                }

                menu.hideMenu();

                if (item.onclick) {
                  item.onclick.apply(chart, arguments);
                }
              },
              innerHTML: item.text || chart.options.lang[item.textKey]
            }, null, innerMenu);
          } // Keep references to menu divs to be able to destroy them


          chart.exportDivElements.push(element);
        }
      }); // Keep references to menu and innerMenu div to be able to destroy
      // them

      chart.exportDivElements.push(innerMenu, menu);
      chart.exportMenuWidth = menu.offsetWidth;
      chart.exportMenuHeight = menu.offsetHeight;
    }

    menuStyle = {
      display: 'block'
    }; // if outside right, right align it

    if (x + chart.exportMenuWidth > chartWidth) {
      menuStyle.right = chartWidth - x - width - menuPadding + 'px';
    } else {
      menuStyle.left = x - menuPadding + 'px';
    } // if outside bottom, bottom align it


    if (y + height + chart.exportMenuHeight > chartHeight && button.alignOptions.verticalAlign !== 'top') {
      menuStyle.bottom = chartHeight - y - menuPadding + 'px';
    } else {
      menuStyle.top = y + height - menuPadding + 'px';
    }

    css$a(menu, menuStyle);
    chart.openMenu = true;
  },

  /**
   * Add the export button to the chart, with options.
   *
   * @private
   */
  addButton: function (options) {
    var chart = this,
        renderer = chart.renderer,
        btnOptions = merge$w(chart.options.navigation.buttonOptions, options),
        onclick = btnOptions.onclick,
        menuItems = btnOptions.menuItems,
        symbol,
        button,
        symbolSize = btnOptions.symbolSize || 12;

    if (!chart.btnCount) {
      chart.btnCount = 0;
    } // Keeps references to the button elements


    if (!chart.exportDivElements) {
      chart.exportDivElements = [];
      chart.exportSVGElements = [];
    }

    if (btnOptions.enabled === false) {
      return;
    }

    var attr = btnOptions.theme,
        states = attr.states,
        hover = states && states.hover,
        select = states && states.select,
        callback;
    delete attr.states;

    if (onclick) {
      callback = function (e) {
        if (e) {
          e.stopPropagation();
        }

        onclick.call(chart, e);
      };
    } else if (menuItems) {
      callback = function (e) {
        // consistent with onclick call (#3495)
        if (e) {
          e.stopPropagation();
        }

        chart.contextMenu(button.menuClassName, menuItems, button.translateX, button.translateY, button.width, button.height, button);
        button.setState(2);
      };
    }

    if (btnOptions.text && btnOptions.symbol) {
      attr.paddingLeft = pick$P(attr.paddingLeft, 25);
    } else if (!btnOptions.text) {
      extend$r(attr, {
        width: btnOptions.width,
        height: btnOptions.height,
        padding: 0
      });
    }

    button = renderer.button(btnOptions.text, 0, 0, callback, attr, hover, select).addClass(options.className).attr({
      title: pick$P(chart.options.lang[btnOptions._titleKey || btnOptions.titleKey], '')
    });
    button.menuClassName = options.menuClassName || 'highcharts-menu-' + chart.btnCount++;

    if (btnOptions.symbol) {
      symbol = renderer.symbol(btnOptions.symbol, btnOptions.symbolX - symbolSize / 2, btnOptions.symbolY - symbolSize / 2, symbolSize, symbolSize, // If symbol is an image, scale it (#7957)
      {
        width: symbolSize,
        height: symbolSize
      }).addClass('highcharts-button-symbol').attr({
        zIndex: 1
      }).add(button);
    }

    button.add(chart.exportingGroup).align(extend$r(btnOptions, {
      width: button.width,
      x: pick$P(btnOptions.x, chart.buttonOffset) // #1654

    }), true, 'spacingBox');
    chart.buttonOffset += (button.width + btnOptions.buttonSpacing) * (btnOptions.align === 'right' ? -1 : 1);
    chart.exportSVGElements.push(button, symbol);
  },

  /**
   * Destroy the export buttons.
   *
   * @private
   */
  destroyExport: function (e) {
    var chart = e ? e.target : this,
        exportSVGElements = chart.exportSVGElements,
        exportDivElements = chart.exportDivElements,
        exportEvents = chart.exportEvents,
        cacheName; // Destroy the extra buttons added

    if (exportSVGElements) {
      each$R(exportSVGElements, function (elem, i) {
        // Destroy and null the svg elements
        if (elem) {
          // #1822
          elem.onclick = elem.ontouchstart = null;
          cacheName = 'cache-' + elem.menuClassName;

          if (chart[cacheName]) {
            delete chart[cacheName];
          }

          chart.exportSVGElements[i] = elem.destroy();
        }
      });
      exportSVGElements.length = 0;
    } // Destroy the exporting group


    if (chart.exportingGroup) {
      chart.exportingGroup.destroy();
      delete chart.exportingGroup;
    } // Destroy the divs for the menu


    if (exportDivElements) {
      each$R(exportDivElements, function (elem, i) {
        // Remove the event handler
        Highcharts.clearTimeout(elem.hideTimer); // #5427

        removeEvent$8(elem, 'mouseleave'); // Remove inline events

        chart.exportDivElements[i] = elem.onmouseout = elem.onmouseover = elem.ontouchstart = elem.onclick = null; // Destroy the div by moving to garbage bin

        discardElement$3(elem);
      });
      exportDivElements.length = 0;
    }

    if (exportEvents) {
      each$R(exportEvents, function (unbind) {
        unbind();
      });
      exportEvents.length = 0;
    }
  }
}); // These ones are translated to attributes rather than styles

SVGRenderer$5.prototype.inlineToAttributes = ['fill', 'stroke', 'strokeLinecap', 'strokeLinejoin', 'strokeWidth', 'textAnchor', 'x', 'y']; // These CSS properties are not inlined. Remember camelCase.

SVGRenderer$5.prototype.inlineBlacklist = [/-/, // In Firefox, both hyphened and camelCased names are listed
/^(clipPath|cssText|d|height|width)$/, // Full words
/^font$/, // more specific props are set
/[lL]ogical(Width|Height)$/, /perspective/, /TapHighlightColor/, /^transition/, /^length$/ // #7700
// /^text (border|color|cursor|height|webkitBorder)/
];
SVGRenderer$5.prototype.unstyledElements = ['clipPath', 'defs', 'desc'];
/**
 * Analyze inherited styles from stylesheets and add them inline
 *
 * @todo: What are the border styles for text about? In general, text has a lot
 * of properties.
 * @todo: Make it work with IE9 and IE10.
 */

Chart$f.prototype.inlineStyles = function () {
  var renderer = this.renderer,
      inlineToAttributes = renderer.inlineToAttributes,
      blacklist = renderer.inlineBlacklist,
      whitelist = renderer.inlineWhitelist,
      // For IE
  unstyledElements = renderer.unstyledElements,
      defaultStyles = {},
      dummySVG,
      iframe,
      iframeDoc; // Create an iframe where we read default styles without pollution from this
  // body

  iframe = doc$9.createElement('iframe');
  css$a(iframe, {
    width: '1px',
    height: '1px',
    visibility: 'hidden'
  });
  doc$9.body.appendChild(iframe);
  iframeDoc = iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write('<svg xmlns="http://www.w3.org/2000/svg"></svg>');
  iframeDoc.close();
  /**
   * Make hyphenated property names out of camelCase
   */

  function hyphenate(prop) {
    return prop.replace(/([A-Z])/g, function (a, b) {
      return '-' + b.toLowerCase();
    });
  }
  /**
   * Call this on all elements and recurse to children
   */


  function recurse(node) {
    var styles,
        parentStyles,
        cssText = '',
        dummy,
        styleAttr,
        blacklisted,
        whitelisted,
        i; // Check computed styles and whether they are in the white/blacklist for
    // styles or atttributes

    function filterStyles(val, prop) {
      // Check against whitelist & blacklist
      blacklisted = whitelisted = false;

      if (whitelist) {
        // Styled mode in IE has a whitelist instead.
        // Exclude all props not in this list.
        i = whitelist.length;

        while (i-- && !whitelisted) {
          whitelisted = whitelist[i].test(prop);
        }

        blacklisted = !whitelisted;
      } // Explicitly remove empty transforms


      if (prop === 'transform' && val === 'none') {
        blacklisted = true;
      }

      i = blacklist.length;

      while (i-- && !blacklisted) {
        blacklisted = blacklist[i].test(prop) || typeof val === 'function';
      }

      if (!blacklisted) {
        // If parent node has the same style, it gets inherited, no need
        // to inline it. Top-level props should be diffed against parent
        // (#7687).
        if ((parentStyles[prop] !== val || node.nodeName === 'svg') && defaultStyles[node.nodeName][prop] !== val) {
          // Attributes
          if (inlineToAttributes.indexOf(prop) !== -1) {
            node.setAttribute(hyphenate(prop), val); // Styles
          } else {
            cssText += hyphenate(prop) + ':' + val + ';';
          }
        }
      }
    }

    if (node.nodeType === 1 && unstyledElements.indexOf(node.nodeName) === -1) {
      styles = win$c.getComputedStyle(node, null);
      parentStyles = node.nodeName === 'svg' ? {} : win$c.getComputedStyle(node.parentNode, null); // Get default styles from the browser so that we don't have to add
      // these

      if (!defaultStyles[node.nodeName]) {
        /*
        if (!dummySVG) {
            dummySVG = doc.createElementNS(H.SVG_NS, 'svg');
            dummySVG.setAttribute('version', '1.1');
            doc.body.appendChild(dummySVG);
        }
        */
        dummySVG = iframeDoc.getElementsByTagName('svg')[0];
        dummy = iframeDoc.createElementNS(node.namespaceURI, node.nodeName);
        dummySVG.appendChild(dummy); // Copy, so we can remove the node

        defaultStyles[node.nodeName] = merge$w(win$c.getComputedStyle(dummy, null)); // Remove default fill, otherwise text disappears when exported

        if (node.nodeName === 'text') {
          delete defaultStyles.text.fill;
        }

        dummySVG.removeChild(dummy);
      } // Loop through all styles and add them inline if they are ok


      if (isFirefoxBrowser || isMSBrowser) {
        // Some browsers put lots of styles on the prototype
        for (var p in styles) {
          filterStyles(styles[p], p);
        }
      } else {
        objectEach$9(styles, filterStyles);
      } // Apply styles


      if (cssText) {
        styleAttr = node.getAttribute('style');
        node.setAttribute('style', (styleAttr ? styleAttr + ';' : '') + cssText);
      } // Set default stroke width (needed at least for IE)


      if (node.nodeName === 'svg') {
        node.setAttribute('stroke-width', '1px');
      }

      if (node.nodeName === 'text') {
        return;
      } // Recurse


      each$R(node.children || node.childNodes, recurse);
    }
  }
  /**
   * Remove the dummy objects used to get defaults
   */


  function tearDown() {
    dummySVG.parentNode.removeChild(dummySVG);
  }

  recurse(this.container.querySelector('svg'));
  tearDown();
};

symbols$1.menu = function (x, y, width, height) {
  var arr = ['M', x, y + 2.5, 'L', x + width, y + 2.5, 'M', x, y + height / 2 + 0.5, 'L', x + width, y + height / 2 + 0.5, 'M', x, y + height - 1.5, 'L', x + width, y + height - 1.5];
  return arr;
}; // Add the buttons on chart load


Chart$f.prototype.renderExporting = function () {
  var chart = this,
      exportingOptions = chart.options.exporting,
      buttons = exportingOptions.buttons,
      isDirty = chart.isDirtyExporting || !chart.exportSVGElements;
  chart.buttonOffset = 0;

  if (chart.isDirtyExporting) {
    chart.destroyExport();
  }

  if (isDirty && exportingOptions.enabled !== false) {
    chart.exportEvents = [];
    chart.exportingGroup = chart.exportingGroup || chart.renderer.g('exporting-group').attr({
      zIndex: 3 // #4955, // #8392

    }).add();
    objectEach$9(buttons, function (button) {
      chart.addButton(button);
    });
    chart.isDirtyExporting = false;
  } // Destroy the export elements at chart destroy


  addEvent$t(chart, 'destroy', chart.destroyExport);
}; // Add update methods to handle chart.update and chart.exporting.update and
// chart.navigation.update. These must be added to the chart instance rather
// than the Chart prototype in order to use the chart instance inside the update
// function.


addEvent$t(Chart$f, 'init', function () {
  var chart = this;

  function update(prop, options, redraw) {
    chart.isDirtyExporting = true;
    merge$w(true, chart.options[prop], options);

    if (pick$P(redraw, true)) {
      chart.redraw();
    }
  }

  each$R(['exporting', 'navigation'], function (prop) {
    chart[prop] = {
      update: function (options, redraw) {
        update(prop, options, redraw);
      }
    };
  });
});
Chart$f.prototype.callbacks.push(function (chart) {
  chart.renderExporting();
  addEvent$t(chart, 'redraw', chart.renderExporting); // Uncomment this to see a button directly below the chart, for quick
  // testing of export

  /*
  var button, viewImage, viewSource;
  if (!chart.renderer.forExport) {
      viewImage = function () {
          var div = doc.createElement('div');
          div.innerHTML = chart.getSVGForExport();
          chart.renderTo.parentNode.appendChild(div);
      };
       viewSource = function () {
          var pre = doc.createElement('pre');
          pre.innerHTML = chart.getSVGForExport()
              .replace(/</g, '\n&lt;')
              .replace(/>/g, '&gt;');
          chart.renderTo.parentNode.appendChild(pre);
      };
       viewImage();
       // View SVG Image
      button = doc.createElement('button');
      button.innerHTML = 'View SVG Image';
      chart.renderTo.parentNode.appendChild(button);
      button.onclick = viewImage;
       // View SVG Source
      button = doc.createElement('button');
      button.innerHTML = 'View SVG Source';
      chart.renderTo.parentNode.appendChild(button);
      button.onclick = viewSource;
  }
  //*/
});

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 * Exporting module
 *
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

/**
 * Highcharts funnel module
 *
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

var seriesType$k = Highcharts.seriesType,
    seriesTypes$m = Highcharts.seriesTypes,
    noop$h = Highcharts.noop,
    pick$Q = Highcharts.pick,
    each$S = Highcharts.each;
seriesType$k('funnel', 'pie',
/**
 * Funnel charts are a type of chart often used to visualize stages in a sales
 * project, where the top are the initial stages with the most clients.
 * It requires that the modules/funnel.js file is loaded.
 *
 * @sample       highcharts/demo/funnel/ Funnel demo
 * @extends      {plotOptions.pie}
 * @excluding    size
 * @product      highcharts
 * @optionparent plotOptions.funnel
 */
{
  /**
   * Initial animation is by default disabled for the funnel chart.
   */
  animation: false,

  /**
   * The center of the series. By default, it is centered in the middle
   * of the plot area, so it fills the plot area height.
   *
   * @type    {Array<String|Number>}
   * @default ["50%", "50%"]
   * @since   3.0
   * @product highcharts
   */
  center: ['50%', '50%'],

  /**
   * The width of the funnel compared to the width of the plot area,
   * or the pixel width if it is a number.
   *
   * @type    {Number|String}
   * @since   3.0
   * @product highcharts
   */
  width: '90%',

  /**
   * The width of the neck, the lower part of the funnel. A number defines
   * pixel width, a percentage string defines a percentage of the plot
   * area width.
   *
   * @type    {Number|String}
   * @sample  {highcharts} highcharts/demo/funnel/ Funnel demo
   * @since   3.0
   * @product highcharts
   */
  neckWidth: '30%',

  /**
   * The height of the funnel or pyramid. If it is a number it defines
   * the pixel height, if it is a percentage string it is the percentage
   * of the plot area height.
   *
   * @type    {Number|String}
   * @sample  {highcharts} highcharts/demo/funnel/ Funnel demo
   * @since   3.0
   * @product highcharts
   */
  height: '100%',

  /**
   * The height of the neck, the lower part of the funnel. A number defines
   * pixel width, a percentage string defines a percentage of the plot
   * area height.
   *
   * @type    {Number|String}
   * @product highcharts
   */
  neckHeight: '25%',

  /**
   * A reversed funnel has the widest area down. A reversed funnel with
   * no neck width and neck height is a pyramid.
   *
   * @since   3.0.10
   * @product highcharts
   */
  reversed: false,

  /**
   * @ignore
   */
  size: true // to avoid adapting to data label size in Pie.drawDataLabels

}, // Properties
{
  animate: noop$h,

  /**
   * Overrides the pie translate method
   */
  translate: function () {
    var // Get positions - either an integer or a percentage string
    // must be given
    getLength = function (length, relativeTo) {
      return /%$/.test(length) ? relativeTo * parseInt(length, 10) / 100 : parseInt(length, 10);
    },
        sum = 0,
        series = this,
        chart = series.chart,
        options = series.options,
        reversed = options.reversed,
        ignoreHiddenPoint = options.ignoreHiddenPoint,
        plotWidth = chart.plotWidth,
        plotHeight = chart.plotHeight,
        cumulative = 0,
        // start at top
    center = options.center,
        centerX = getLength(center[0], plotWidth),
        centerY = getLength(center[1], plotHeight),
        width = getLength(options.width, plotWidth),
        tempWidth,
        getWidthAt,
        height = getLength(options.height, plotHeight),
        neckWidth = getLength(options.neckWidth, plotWidth),
        neckHeight = getLength(options.neckHeight, plotHeight),
        neckY = centerY - height / 2 + height - neckHeight,
        data = series.data,
        path,
        fraction,
        half = options.dataLabels.position === 'left' ? 1 : 0,
        x1,
        y1,
        x2,
        x3,
        y3,
        x4,
        y5; // Return the width at a specific y coordinate


    series.getWidthAt = getWidthAt = function (y) {
      var top = centerY - height / 2;
      return y > neckY || height === neckHeight ? neckWidth : neckWidth + (width - neckWidth) * (1 - (y - top) / (height - neckHeight));
    };

    series.getX = function (y, half, point) {
      return centerX + (half ? -1 : 1) * (getWidthAt(reversed ? 2 * centerY - y : y) / 2 + point.labelDistance);
    }; // Expose


    series.center = [centerX, centerY, height];
    series.centerX = centerX;
    /*
     * Individual point coordinate naming:
     *
     * x1,y1 _________________ x2,y1
     *  \                         /
     *   \                       /
     *    \                     /
     *     \                   /
     *      \                 /
     *     x3,y3 _________ x4,y3
     *
     * Additional for the base of the neck:
     *
     *       |               |
     *       |               |
     *       |               |
     *     x3,y5 _________ x4,y5
     */
    // get the total sum

    each$S(data, function (point) {
      if (!ignoreHiddenPoint || point.visible !== false) {
        sum += point.y;
      }
    });
    each$S(data, function (point) {
      // set start and end positions
      y5 = null;
      fraction = sum ? point.y / sum : 0;
      y1 = centerY - height / 2 + cumulative * height;
      y3 = y1 + fraction * height;
      tempWidth = getWidthAt(y1);
      x1 = centerX - tempWidth / 2;
      x2 = x1 + tempWidth;
      tempWidth = getWidthAt(y3);
      x3 = centerX - tempWidth / 2;
      x4 = x3 + tempWidth; // the entire point is within the neck

      if (y1 > neckY) {
        x1 = x3 = centerX - neckWidth / 2;
        x2 = x4 = centerX + neckWidth / 2; // the base of the neck
      } else if (y3 > neckY) {
        y5 = y3;
        tempWidth = getWidthAt(neckY);
        x3 = centerX - tempWidth / 2;
        x4 = x3 + tempWidth;
        y3 = neckY;
      }

      if (reversed) {
        y1 = 2 * centerY - y1;
        y3 = 2 * centerY - y3;

        if (y5 !== null) {
          y5 = 2 * centerY - y5;
        }
      } // save the path


      path = ['M', x1, y1, 'L', x2, y1, x4, y3];

      if (y5 !== null) {
        path.push(x4, y5, x3, y5);
      }

      path.push(x3, y3, 'Z'); // prepare for using shared dr

      point.shapeType = 'path';
      point.shapeArgs = {
        d: path
      }; // for tooltips and data labels

      point.percentage = fraction * 100;
      point.plotX = centerX;
      point.plotY = (y1 + (y5 || y3)) / 2; // Placement of tooltips and data labels

      point.tooltipPos = [centerX, point.plotY]; // Slice is a noop on funnel points

      point.slice = noop$h; // Mimicking pie data label placement logic

      point.half = half;

      if (!ignoreHiddenPoint || point.visible !== false) {
        cumulative += fraction;
      }
    });
  },

  /**
   * Funnel items don't have angles (#2289)
   */
  sortByAngle: function (points) {
    points.sort(function (a, b) {
      return a.plotY - b.plotY;
    });
  },

  /**
   * Extend the pie data label method
   */
  drawDataLabels: function () {
    var series = this,
        data = series.data,
        labelDistance = series.options.dataLabels.distance,
        leftSide,
        sign,
        point,
        i = data.length,
        x,
        y;
    /**
     * In the original pie label anticollision logic, the slots are
     * distributed from one labelDistance above to one labelDistance
     * below the pie. In funnels we don't want this.
     */

    series.center[2] -= 2 * labelDistance; // Set the label position array for each point.

    while (i--) {
      point = data[i];
      leftSide = point.half;
      sign = leftSide ? 1 : -1;
      y = point.plotY;
      point.labelDistance = pick$Q(point.options.dataLabels && point.options.dataLabels.distance, labelDistance);
      series.maxLabelDistance = Math.max(point.labelDistance, series.maxLabelDistance || 0);
      x = series.getX(y, leftSide, point); // set the anchor point for data labels

      point.labelPos = [// first break of connector
      0, y, // second break, right outside point shape
      x + (point.labelDistance - 5) * sign, y, // landing point for connector
      x + point.labelDistance * sign, y, // alignment
      leftSide ? 'right' : 'left', // center angle
      0];
    }

    seriesTypes$m.pie.prototype.drawDataLabels.call(this);
  }
});
/**
 * A `funnel` series. If the [type](#series.funnel.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.funnel
 * @excluding dataParser,dataURL,stack,xAxis,yAxis
 * @product   highcharts
 * @apioption series.funnel
 */

/**
 * An array of data points for the series. For the `funnel` series type,
 * points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.funnel.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         y: 3,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         y: 1,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Number>}
 * @extends   series.pie.data
 * @excluding sliced
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts
 * @apioption series.funnel.data
 */

/**
 * Pyramid series type.
 */

seriesType$k('pyramid', 'funnel',
/**
 * A pyramid series is a special type of funnel, without neck and reversed by
 * default.
 *
 * @sample       highcharts/demo/pyramid/
 *               Pyramid chart
 * @extends      plotOptions.funnel
 * @product      highcharts
 * @optionparent plotOptions.pyramid
 */
{
  /**
   * The pyramid neck width is zero by default, as opposed to the funnel,
   * which shares the same layout logic.
   *
   * @since 3.0.10
   * @product highcharts
   */
  neckWidth: '0%',

  /**
   * The pyramid neck width is zero by default, as opposed to the funnel,
   * which shares the same layout logic.
   *
   * @since 3.0.10
   * @product highcharts
   */
  neckHeight: '0%',

  /**
   * The pyramid is reversed by default, as opposed to the funnel, which
   * shares the layout engine, and is not reversed.
   *
   * @since 3.0.10
   * @product highcharts
   */
  reversed: true
});
/**
 * A `pyramid` series. If the [type](#series.pyramid.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 *
 * @type      {Object}
 * @extends   series,plotOptions.pyramid
 * @excluding dataParser,dataURL,stack,xAxis,yAxis
 * @product   highcharts
 * @apioption series.pyramid
 */

/**
 * An array of data points for the series. For the `pyramid` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.pyramid.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         y: 9,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         y: 6,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type      {Array<Object|Number>}
 * @extends   series.pie.data
 * @excluding sliced
 * @sample    {highcharts} highcharts/chart/reflow-true/
 *            Numerical values
 * @sample    {highcharts} highcharts/series/data-array-of-arrays/
 *            Arrays of numeric x and y
 * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *            Arrays of datetime x and y
 * @sample    {highcharts} highcharts/series/data-array-of-name-value/
 *            Arrays of point.name and y
 * @sample    {highcharts} highcharts/series/data-array-of-objects/
 *            Config objects
 * @product   highcharts
 * @apioption series.pyramid.data
 */

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 * Highcharts funnel module
 *
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent$u = Highcharts.addEvent,
    Axis$g = Highcharts.Axis,
    Chart$g = Highcharts.Chart,
    color$a = Highcharts.color,
    ColorAxis,
    each$T = Highcharts.each,
    extend$s = Highcharts.extend,
    isNumber$j = Highcharts.isNumber,
    Legend$2 = Highcharts.Legend,
    LegendSymbolMixin$6 = Highcharts.LegendSymbolMixin,
    noop$i = Highcharts.noop,
    merge$x = Highcharts.merge,
    pick$R = Highcharts.pick; // If ColorAxis already exists, we may be loading the heatmap module on top of
// Highmaps.

if (!Highcharts.ColorAxis) {
  /**
   * The ColorAxis object for inclusion in gradient legends
   */
  ColorAxis = Highcharts.ColorAxis = function () {
    this.init.apply(this, arguments);
  };

  extend$s(ColorAxis.prototype, Axis$g.prototype);
  extend$s(ColorAxis.prototype, {
    /**
     * A color axis for choropleth maps and heat maps. Visually, the color
     * axis will appear as a gradient or as separate items inside the
     * legend, depending on whether the axis is scalar or based on data
     * classes.
     *
     * For supported color formats, see the
     * [docs article about colors](https://www.highcharts.com/docs/chart-design-and-style/colors).
     *
     * A scalar color axis is represented by a gradient. The colors either
     * range between the [minColor](#colorAxis.minColor) and the
     * [maxColor](#colorAxis.maxColor), or for more fine grained control the
     * colors can be defined in [stops](#colorAxis.stops). Often times, the
     * color axis needs to be adjusted to get the right color spread for the
     * data. In addition to stops, consider using a logarithmic
     * [axis type](#colorAxis.type), or setting [min](#colorAxis.min) and
     * [max](#colorAxis.max) to avoid the colors being determined by
     * outliers.
     *
     * When [dataClasses](#colorAxis.dataClasses) are used, the ranges are
     * subdivided into separate classes like categories based on their
     * values. This can be used for ranges between two values, but also for
     * a true category. However, when your data is categorized, it may be as
     * convenient to add each category to a separate series.
     *
     * See [the Axis object](/class-reference/Highcharts.Axis) for
     * programmatic access to the axis.
     *
     * @extends xAxis
     * @excluding allowDecimals,alternateGridColor,breaks,categories,
     *            crosshair,dateTimeLabelFormats,lineWidth,linkedTo,maxZoom,
     *            minRange,minTickInterval,offset,opposite,plotBands,
     *            plotLines,showEmpty,title
     * @product highcharts highmaps
     * @optionparent colorAxis
     */
    defaultColorAxisOptions: {
      /**
       * Whether to allow decimals on the color axis.
       * @type {Boolean}
       * @default true
       * @product highcharts highmaps
       * @apioption colorAxis.allowDecimals
       */

      /**
       * Determines how to set each data class' color if no individual
       * color is set. The default value, `tween`, computes intermediate
       * colors between `minColor` and `maxColor`. The other possible
       * value, `category`, pulls colors from the global or chart specific
       * [colors](#colors) array.
       *
       * @validvalue ["tween", "category"]
       * @type {String}
       * @sample {highmaps} maps/coloraxis/dataclasscolor/ Category colors
       * @default tween
       * @product highcharts highmaps
       * @apioption colorAxis.dataClassColor
       */

      /**
       * An array of data classes or ranges for the choropleth map. If
       * none given, the color axis is scalar and values are distributed
       * as a gradient between the minimum and maximum colors.
       *
       * @type {Array<Object>}
       * @sample {highmaps} maps/demo/data-class-ranges/ Multiple ranges
       * @sample {highmaps} maps/demo/data-class-two-ranges/ Two ranges
       * @product highcharts highmaps
       * @apioption colorAxis.dataClasses
       */

      /**
       * The color of each data class. If not set, the color is pulled
       * from the global or chart-specific [colors](#colors) array. In
       * styled mode, this option is ignored. Instead, use colors defined
       * in CSS.
       *
       * @type {Color}
       * @sample {highmaps} maps/demo/data-class-two-ranges/
       *         Explicit colors
       * @product highcharts highmaps
       * @apioption colorAxis.dataClasses.color
       */

      /**
       * The start of the value range that the data class represents,
       * relating to the point value.
       *
       * The range of each `dataClass` is closed in both ends, but can be
       * overridden by the next `dataClass`.
       *
       * @type      {Number}
       * @product   highcharts highmaps
       * @apioption colorAxis.dataClasses.from
       */

      /**
       * The name of the data class as it appears in the legend.
       * If no name is given, it is automatically created based on the
       * `from` and `to` values. For full programmatic control,
       * [legend.labelFormatter](#legend.labelFormatter) can be used.
       * In the formatter, `this.from` and `this.to` can be accessed.
       *
       * @type      {String}
       * @sample    {highmaps} maps/coloraxis/dataclasses-name/
       *            Named data classes
       * @sample    {highmaps} maps/coloraxis/dataclasses-labelformatter/
       *            Formatted data classes
       * @product   highcharts highmaps
       * @apioption colorAxis.dataClasses.name
       */

      /**
       * The end of the value range that the data class represents,
       * relating to the point value.
       *
       * The range of each `dataClass` is closed in both ends, but can be
       * overridden by the next `dataClass`.
       *
       * @type      {Number}
       * @product   highcharts highmaps
       * @apioption colorAxis.dataClasses.to
       */

      /**
        * @ignore-option
        */
      lineWidth: 0,

      /**
       * Padding of the min value relative to the length of the axis. A
       * padding of 0.05 will make a 100px axis 5px longer.
       *
       * @type {Number}
       * @product highcharts highmaps
       */
      minPadding: 0,

      /**
       * The maximum value of the axis in terms of map point values. If
       * `null`, the max value is automatically calculated. If the
       * `endOnTick` option is true, the max value might be rounded up.
       *
       * @type {Number}
       * @sample {highmaps} maps/coloraxis/gridlines/
       *         Explicit min and max to reduce the effect of outliers
       * @product highcharts highmaps
       * @apioption colorAxis.max
       */

      /**
       * The minimum value of the axis in terms of map point values. If
       * `null`, the min value is automatically calculated. If the
       * `startOnTick` option is true, the min value might be rounded
       * down.
       *
       * @type {Number}
       * @sample {highmaps} maps/coloraxis/gridlines/
       *         Explicit min and max to reduce the effect of outliers
       * @product highcharts highmaps
       * @apioption colorAxis.min
       */

      /**
       * Padding of the max value relative to the length of the axis. A
       * padding of 0.05 will make a 100px axis 5px longer.
       *
       * @type {Number}
       * @product highcharts highmaps
       */
      maxPadding: 0,

      /**
       * Color of the grid lines extending from the axis across the
       * gradient.
       *
       * @type {Color}
       * @sample {highmaps} maps/coloraxis/gridlines/
       *         Grid lines demonstrated
       * @default #e6e6e6
       * @product highcharts highmaps
       * @apioption colorAxis.gridLineColor
       */

      /**
       * The width of the grid lines extending from the axis across the
       * gradient of a scalar color axis.
       *
       * @type {Number}
       * @sample {highmaps} maps/coloraxis/gridlines/
       *         Grid lines demonstrated
       * @default 1
       * @product highcharts highmaps
       */
      gridLineWidth: 1,

      /**
       * The interval of the tick marks in axis units. When `null`, the
       * tick interval is computed to approximately follow the
       * `tickPixelInterval`.
       *
       * @type {Number}
       * @product highcharts highmaps
       * @apioption colorAxis.tickInterval
       */

      /**
       * If [tickInterval](#colorAxis.tickInterval) is `null` this option
       * sets the approximate pixel interval of the tick marks.
       *
       * @type {Number}
       * @default 72
       * @product highcharts highmaps
       */
      tickPixelInterval: 72,

      /**
       * Whether to force the axis to start on a tick. Use this option
       * with the `maxPadding` option to control the axis start.
       *
       * @type {Boolean}
       * @default true
       * @product highcharts highmaps
       */
      startOnTick: true,

      /**
       * Whether to force the axis to end on a tick. Use this option with
       * the [maxPadding](#colorAxis.maxPadding) option to control the
       * axis end.
       *
       * @type {Boolean}
       * @default true
       * @product highcharts highmaps
       */
      endOnTick: true,

      /**    @ignore */
      offset: 0,

      /**
       * The triangular marker on a scalar color axis that points to the
       * value of the hovered area. To disable the marker, set
       * `marker: null`.
       *
       * @type {Object}
       * @sample {highmaps} maps/coloraxis/marker/ Black marker
       * @product highcharts highmaps
       */
      marker: {
        /**
         * Animation for the marker as it moves between values. Set to
         * `false` to disable animation. Defaults to `{ duration: 50 }`.
         *
         * @type {AnimationOptions|Boolean}
         * @product highcharts highmaps
         */
        animation: {
          duration: 50
        },

        /**
         * @ignore
         */
        width: 0.01
      },

      /**
       * The axis labels show the number for each tick.
       *
       * For more live examples on label options, see [xAxis.labels in the
       * Highcharts API.](/highcharts#xAxis.labels)
       *
       * @type {Object}
       * @extends xAxis.labels
       * @product highcharts highmaps
       */
      labels: {
        /**
         * How to handle overflowing labels on horizontal color axis.
         * Can be undefined or "justify". If "justify", labels will not
         * render outside the legend area. If there is room to move it,
         * it will be aligned to the edge, else it will be removed.
         *
         * @validvalue [null, "justify"]
         * @type {String}
         * @default justify
         * @product highcharts highmaps
         */
        overflow: 'justify',
        rotation: 0
      },

      /**
       * The color to represent the minimum of the color axis. Unless
       * [dataClasses](#colorAxis.dataClasses) or
       * [stops](#colorAxis.stops) are set, the gradient starts at this
       * value.
       *
       * If dataClasses are set, the color is based on minColor and
       * maxColor unless a color is set for each data class, or the
       * [dataClassColor](#colorAxis.dataClassColor) is set.
       *
       * @type {Color}
       * @sample {highmaps} maps/coloraxis/mincolor-maxcolor/
       *         Min and max colors on scalar (gradient) axis
       * @sample {highmaps} maps/coloraxis/mincolor-maxcolor-dataclasses/
       *         On data classes
       * @default #e6ebf5
       * @product highcharts highmaps
       */
      minColor: '#e6ebf5',

      /**
       * The color to represent the maximum of the color axis. Unless
       * [dataClasses](#colorAxis.dataClasses) or
       * [stops](#colorAxis.stops) are set, the gradient ends at this
       * value.
       *
       * If dataClasses are set, the color is based on minColor and
       * maxColor unless a color is set for each data class, or the
       * [dataClassColor](#colorAxis.dataClassColor) is set.
       *
       * @type {Color}
       * @sample {highmaps} maps/coloraxis/mincolor-maxcolor/
       *         Min and max colors on scalar (gradient) axis
       * @sample {highmaps} maps/coloraxis/mincolor-maxcolor-dataclasses/
       *         On data classes
       * @default #003399
       * @product highcharts highmaps
       */
      maxColor: '#003399',

      /**
       * Color stops for the gradient of a scalar color axis. Use this in
       * cases where a linear gradient between a `minColor` and `maxColor`
       * is not sufficient. The stops is an array of tuples, where the
       * first item is a float between 0 and 1 assigning the relative
       * position in the gradient, and the second item is the color.
       *
       * @type {Array<Array>}
       * @sample {highmaps} maps/demo/heatmap/
       *         Heatmap with three color stops
       * @product highcharts highmaps
       * @apioption colorAxis.stops
       */

      /**
       * The pixel length of the main tick marks on the color axis.
       */
      tickLength: 5,

      /**
       * The type of interpolation to use for the color axis. Can be
       * `linear` or `logarithmic`.
       *
       * @validvalue ["linear", "logarithmic"]
       * @type {String}
       * @default linear
       * @product highcharts highmaps
       * @apioption colorAxis.type
       */

      /**
       * Whether to reverse the axis so that the highest number is closest
       * to the origin. Defaults to `false` in a horizontal legend and
       * `true` in a vertical legend, where the smallest value starts on
       * top.
       *
       * @type {Boolean}
       * @product highcharts highmaps
       * @apioption colorAxis.reversed
       */

      /**
       * Fires when the legend item belonging to the colorAxis is clicked.
       * One parameter, `event`, is passed to the function.
       *
       * @type      {Function}
       * @product   highcharts highmaps
       * @apioption colorAxis.events.legendItemClick
       */

      /**
       * Whether to display the colorAxis in the legend.
       *
       * @type {Boolean}
       * @see [heatmap.showInLegend](#series.heatmap.showInLegend)
       * @default true
       * @since 4.2.7
       * @product highcharts highmaps
       */
      showInLegend: true
    },
    // Properties to preserve after destroy, for Axis.update (#5881, #6025)
    keepProps: ['legendGroup', 'legendItemHeight', 'legendItemWidth', 'legendItem', 'legendSymbol'].concat(Axis$g.prototype.keepProps),

    /**
     * Initialize the color axis
     */
    init: function (chart, userOptions) {
      var horiz = chart.options.legend.layout !== 'vertical',
          options;
      this.coll = 'colorAxis'; // Build the options

      options = merge$x(this.defaultColorAxisOptions, {
        side: horiz ? 2 : 1,
        reversed: !horiz
      }, userOptions, {
        opposite: !horiz,
        showEmpty: false,
        title: null,
        visible: chart.options.legend.enabled
      });
      Axis$g.prototype.init.call(this, chart, options); // Base init() pushes it to the xAxis array, now pop it again
      // chart[this.isXAxis ? 'xAxis' : 'yAxis'].pop();
      // Prepare data classes

      if (userOptions.dataClasses) {
        this.initDataClasses(userOptions);
      }

      this.initStops(); // Override original axis properties

      this.horiz = horiz;
      this.zoomEnabled = false; // Add default values

      this.defaultLegendLength = 200;
    },
    initDataClasses: function (userOptions) {
      var chart = this.chart,
          dataClasses,
          colorCounter = 0,
          colorCount = chart.options.chart.colorCount,
          options = this.options,
          len = userOptions.dataClasses.length;
      this.dataClasses = dataClasses = [];
      this.legendItems = [];
      each$T(userOptions.dataClasses, function (dataClass, i) {
        dataClass = merge$x(dataClass);
        dataClasses.push(dataClass);

        if (options.dataClassColor === 'category') {
          dataClass.colorIndex = colorCounter; // increase and loop back to zero

          colorCounter++;

          if (colorCounter === colorCount) {
            colorCounter = 0;
          }
        } else {
          dataClass.color = color$a(options.minColor).tweenTo(color$a(options.maxColor), len < 2 ? 0.5 : i / (len - 1) // #3219
          );
        }
      });
    },

    /**
     * Override so that ticks are not added in data class axes (#6914)
     */
    setTickPositions: function () {
      if (!this.dataClasses) {
        return Axis$g.prototype.setTickPositions.call(this);
      }
    },
    initStops: function () {
      this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]];
      each$T(this.stops, function (stop) {
        stop.color = color$a(stop[1]);
      });
    },

    /**
     * Extend the setOptions method to process extreme colors and color
     * stops.
     */
    setOptions: function (userOptions) {
      Axis$g.prototype.setOptions.call(this, userOptions);
      this.options.crosshair = this.options.marker;
    },
    setAxisSize: function () {
      var symbol = this.legendSymbol,
          chart = this.chart,
          legendOptions = chart.options.legend || {},
          x,
          y,
          width,
          height;

      if (symbol) {
        this.left = x = symbol.attr('x');
        this.top = y = symbol.attr('y');
        this.width = width = symbol.attr('width');
        this.height = height = symbol.attr('height');
        this.right = chart.chartWidth - x - width;
        this.bottom = chart.chartHeight - y - height;
        this.len = this.horiz ? width : height;
        this.pos = this.horiz ? x : y;
      } else {
        // Fake length for disabled legend to avoid tick issues
        // and such (#5205)
        this.len = (this.horiz ? legendOptions.symbolWidth : legendOptions.symbolHeight) || this.defaultLegendLength;
      }
    },
    normalizedValue: function (value) {
      if (this.isLog) {
        value = this.val2lin(value);
      }

      return 1 - (this.max - value) / (this.max - this.min || 1);
    },

    /**
     * Translate from a value to a color
     */
    toColor: function (value, point) {
      var pos,
          stops = this.stops,
          from,
          to,
          color,
          dataClasses = this.dataClasses,
          dataClass,
          i;

      if (dataClasses) {
        i = dataClasses.length;

        while (i--) {
          dataClass = dataClasses[i];
          from = dataClass.from;
          to = dataClass.to;

          if ((from === undefined || value >= from) && (to === undefined || value <= to)) {
            if (point) {
              point.dataClass = i;
              point.colorIndex = dataClass.colorIndex;
            }

            break;
          }
        }
      } else {
        pos = this.normalizedValue(value);
        i = stops.length;

        while (i--) {
          if (pos > stops[i][0]) {
            break;
          }
        }

        from = stops[i] || stops[i + 1];
        to = stops[i + 1] || from; // The position within the gradient

        pos = 1 - (to[0] - pos) / (to[0] - from[0] || 1);
        color = from.color.tweenTo(to.color, pos);
      }

      return color;
    },

    /**
     * Override the getOffset method to add the whole axis groups inside
     * the legend.
     */
    getOffset: function () {
      var group = this.legendGroup,
          sideOffset = this.chart.axisOffset[this.side];

      if (group) {
        // Hook for the getOffset method to add groups to this parent
        // group
        this.axisParent = group; // Call the base

        Axis$g.prototype.getOffset.call(this); // First time only

        if (!this.added) {
          this.added = true;
          this.labelLeft = 0;
          this.labelRight = this.width;
        } // Reset it to avoid color axis reserving space


        this.chart.axisOffset[this.side] = sideOffset;
      }
    },

    /**
     * Create the color gradient
     */
    setLegendColor: function () {
      var grad,
          horiz = this.horiz,
          reversed = this.reversed,
          one = reversed ? 1 : 0,
          zero = reversed ? 0 : 1;
      grad = horiz ? [one, 0, zero, 0] : [0, zero, 0, one]; // #3190

      this.legendColor = {
        linearGradient: {
          x1: grad[0],
          y1: grad[1],
          x2: grad[2],
          y2: grad[3]
        },
        stops: this.stops
      };
    },

    /**
     * The color axis appears inside the legend and has its own legend
     * symbol
     */
    drawLegendSymbol: function (legend, item) {
      var padding = legend.padding,
          legendOptions = legend.options,
          horiz = this.horiz,
          width = pick$R(legendOptions.symbolWidth, horiz ? this.defaultLegendLength : 12),
          height = pick$R(legendOptions.symbolHeight, horiz ? 12 : this.defaultLegendLength),
          labelPadding = pick$R(legendOptions.labelPadding, horiz ? 16 : 30),
          itemDistance = pick$R(legendOptions.itemDistance, 10);
      this.setLegendColor(); // Create the gradient

      item.legendSymbol = this.chart.renderer.rect(0, legend.baseline - 11, width, height).attr({
        zIndex: 1
      }).add(item.legendGroup); // Set how much space this legend item takes up

      this.legendItemWidth = width + padding + (horiz ? itemDistance : labelPadding);
      this.legendItemHeight = height + padding + (horiz ? labelPadding : 0);
    },

    /**
     * Fool the legend
     */
    setState: function (state) {
      each$T(this.series, function (series) {
        series.setState(state);
      });
    },
    visible: true,
    setVisible: noop$i,
    getSeriesExtremes: function () {
      var series = this.series,
          i = series.length;
      this.dataMin = Infinity;
      this.dataMax = -Infinity;

      while (i--) {
        series[i].getExtremes();

        if (series[i].valueMin !== undefined) {
          this.dataMin = Math.min(this.dataMin, series[i].valueMin);
          this.dataMax = Math.max(this.dataMax, series[i].valueMax);
        }
      }
    },
    drawCrosshair: function (e, point) {
      var plotX = point && point.plotX,
          plotY = point && point.plotY,
          crossPos,
          axisPos = this.pos,
          axisLen = this.len;

      if (point) {
        crossPos = this.toPixels(point[point.series.colorKey]);

        if (crossPos < axisPos) {
          crossPos = axisPos - 2;
        } else if (crossPos > axisPos + axisLen) {
          crossPos = axisPos + axisLen + 2;
        }

        point.plotX = crossPos;
        point.plotY = this.len - crossPos;
        Axis$g.prototype.drawCrosshair.call(this, e, point);
        point.plotX = plotX;
        point.plotY = plotY;

        if (this.cross && !this.cross.addedToColorAxis && this.legendGroup) {
          this.cross.addClass('highcharts-coloraxis-marker').add(this.legendGroup);
          this.cross.addedToColorAxis = true;
        }
      }
    },
    getPlotLinePath: function (a, b, c, d, pos) {
      // crosshairs only
      return isNumber$j(pos) ? // pos can be 0 (#3969)
      this.horiz ? ['M', pos - 4, this.top - 6, 'L', pos + 4, this.top - 6, pos, this.top, 'Z'] : ['M', this.left, pos, 'L', this.left - 6, pos + 6, this.left - 6, pos - 6, 'Z'] : Axis$g.prototype.getPlotLinePath.call(this, a, b, c, d);
    },
    update: function (newOptions, redraw) {
      var chart = this.chart,
          legend = chart.legend;
      each$T(this.series, function (series) {
        // Needed for Axis.update when choropleth colors change
        series.isDirtyData = true;
      }); // When updating data classes, destroy old items and make sure new
      // ones are created (#3207)

      if (newOptions.dataClasses && legend.allItems) {
        each$T(legend.allItems, function (item) {
          if (item.isDataClass && item.legendGroup) {
            item.legendGroup.destroy();
          }
        });
        chart.isDirtyLegend = true;
      } // Keep the options structure updated for export. Unlike xAxis and
      // yAxis, the colorAxis is not an array. (#3207)


      chart.options[this.coll] = merge$x(this.userOptions, newOptions);
      Axis$g.prototype.update.call(this, newOptions, redraw);

      if (this.legendItem) {
        this.setLegendColor();
        legend.colorizeItem(this, true);
      }
    },

    /**
     * Extend basic axis remove by also removing the legend item.
     */
    remove: function () {
      if (this.legendItem) {
        this.chart.legend.destroyItem(this);
      }

      Axis$g.prototype.remove.call(this);
    },

    /**
     * Get the legend item symbols for data classes
     */
    getDataClassLegendSymbols: function () {
      var axis = this,
          chart = this.chart,
          legendItems = this.legendItems,
          legendOptions = chart.options.legend,
          valueDecimals = legendOptions.valueDecimals,
          valueSuffix = legendOptions.valueSuffix || '',
          name;

      if (!legendItems.length) {
        each$T(this.dataClasses, function (dataClass, i) {
          var vis = true,
              from = dataClass.from,
              to = dataClass.to; // Assemble the default name. This can be overridden
          // by legend.options.labelFormatter

          name = '';

          if (from === undefined) {
            name = '< ';
          } else if (to === undefined) {
            name = '> ';
          }

          if (from !== undefined) {
            name += Highcharts.numberFormat(from, valueDecimals) + valueSuffix;
          }

          if (from !== undefined && to !== undefined) {
            name += ' - ';
          }

          if (to !== undefined) {
            name += Highcharts.numberFormat(to, valueDecimals) + valueSuffix;
          } // Add a mock object to the legend items


          legendItems.push(extend$s({
            chart: chart,
            name: name,
            options: {},
            drawLegendSymbol: LegendSymbolMixin$6.drawRectangle,
            visible: true,
            setState: noop$i,
            isDataClass: true,
            setVisible: function () {
              vis = this.visible = !vis;
              each$T(axis.series, function (series) {
                each$T(series.points, function (point) {
                  if (point.dataClass === i) {
                    point.setVisible(vis);
                  }
                });
              });
              chart.legend.colorizeItem(this, vis);
            }
          }, dataClass));
        });
      }

      return legendItems;
    },
    name: '' // Prevents 'undefined' in legend in IE8

  });
  /**
   * Handle animation of the color attributes directly
   */

  each$T(['fill', 'stroke'], function (prop) {
    Highcharts.Fx.prototype[prop + 'Setter'] = function () {
      this.elem.attr(prop, color$a(this.start).tweenTo(color$a(this.end), this.pos), null, true);
    };
  });
  /**
   * Extend the chart getAxes method to also get the color axis
   */

  addEvent$u(Chart$g, 'afterGetAxes', function () {
    var options = this.options,
        colorAxisOptions = options.colorAxis;
    this.colorAxis = [];

    if (colorAxisOptions) {
      new ColorAxis(this, colorAxisOptions); // eslint-disable-line no-new
    }
  });
  /**
   * Add the color axis. This also removes the axis' own series to prevent
   * them from showing up individually.
   */

  addEvent$u(Legend$2, 'afterGetAllItems', function (e) {
    var colorAxisItems = [],
        colorAxis = this.chart.colorAxis[0],
        i;

    if (colorAxis && colorAxis.options) {
      if (colorAxis.options.showInLegend) {
        // Data classes
        if (colorAxis.options.dataClasses) {
          colorAxisItems = colorAxis.getDataClassLegendSymbols(); // Gradient legend
        } else {
          // Add this axis on top
          colorAxisItems.push(colorAxis);
        } // Don't add the color axis' series


        each$T(colorAxis.series, function (series) {
          Highcharts.erase(e.allItems, series);
        });
      }
    }

    i = colorAxisItems.length;

    while (i--) {
      e.allItems.unshift(colorAxisItems[i]);
    }
  });
  addEvent$u(Legend$2, 'afterColorizeItem', function (e) {
    if (e.visible && e.item.legendColor) {
      e.item.legendSymbol.attr({
        fill: e.item.legendColor
      });
    }
  }); // Updates in the legend need to be reflected in the color axis (6888)

  addEvent$u(Legend$2, 'afterUpdate', function () {
    if (this.chart.colorAxis[0]) {
      this.chart.colorAxis[0].update({}, arguments[2]);
    }
  });
}

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var defined$n = Highcharts.defined,
    each$U = Highcharts.each,
    noop$j = Highcharts.noop,
    seriesTypes$n = Highcharts.seriesTypes;
/**
 * Mixin for maps and heatmaps
 */

Highcharts.colorPointMixin = {
  /**
   * Color points have a value option that determines whether or not it is
   * a null point
   */
  isValid: function () {
    // undefined is allowed
    return this.value !== null && this.value !== Infinity && this.value !== -Infinity;
  },

  /**
   * Set the visibility of a single point
   */
  setVisible: function (vis) {
    var point = this,
        method = vis ? 'show' : 'hide';
    point.visible = Boolean(vis); // Show and hide associated elements

    each$U(['graphic', 'dataLabel'], function (key) {
      if (point[key]) {
        point[key][method]();
      }
    });
  },
  setState: function (state) {
    Highcharts.Point.prototype.setState.call(this, state);

    if (this.graphic) {
      this.graphic.attr({
        zIndex: state === 'hover' ? 1 : 0
      });
    }
  }
};
Highcharts.colorSeriesMixin = {
  pointArrayMap: ['value'],
  axisTypes: ['xAxis', 'yAxis', 'colorAxis'],
  optionalAxis: 'colorAxis',
  trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
  getSymbol: noop$j,
  parallelArrays: ['x', 'y', 'value'],
  colorKey: 'value',

  /**
   * In choropleth maps, the color is a result of the value, so this needs
   * translation too
   */
  translateColors: function () {
    var series = this,
        nullColor = this.options.nullColor,
        colorAxis = this.colorAxis,
        colorKey = this.colorKey;
    each$U(this.data, function (point) {
      var value = point[colorKey],
          color;
      color = point.options.color || (point.isNull ? nullColor : colorAxis && value !== undefined ? colorAxis.toColor(value, point) : point.color || series.color);

      if (color) {
        point.color = color;
      }
    });
  },

  /**
   * Get the color attibutes to apply on the graphic
   */
  colorAttribs: function (point) {
    var ret = {};

    if (defined$n(point.color)) {
      ret[this.colorProp || 'fill'] = point.color;
    }

    return ret;
  }
};

/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var colorPointMixin = Highcharts.colorPointMixin,
    colorSeriesMixin = Highcharts.colorSeriesMixin,
    each$V = Highcharts.each,
    LegendSymbolMixin$7 = Highcharts.LegendSymbolMixin,
    merge$y = Highcharts.merge,
    noop$k = Highcharts.noop,
    pick$S = Highcharts.pick,
    Series$l = Highcharts.Series,
    seriesType$l = Highcharts.seriesType,
    seriesTypes$o = Highcharts.seriesTypes;
/**
 * A heatmap is a graphical representation of data where the individual values
 * contained in a matrix are represented as colors.
 *
 * @sample       highcharts/demo/heatmap/
 *               Simple heatmap
 * @sample       highcharts/demo/heatmap-canvas/
 *               Heavy heatmap
 * @extends      {plotOptions.scatter}
 * @excluding    animationLimit,connectEnds,connectNulls,dashStyle,
 *               findNearestPointBy,getExtremesFromAll,linecap,lineWidth,marker,
 *               pointInterval,pointIntervalUnit,pointRange,pointStart,shadow,
 *               softThreshold,stacking,step,threshold
 * @product      highcharts highmaps
 * @optionparent plotOptions.heatmap
 */

seriesType$l('heatmap', 'scatter', {
  /**
   * Animation is disabled by default on the heatmap series.
   *
   * @type {Boolean|Object}
   */
  animation: false,

  /**
   * The border width for each heat map item.
   */
  borderWidth: 0,

  /**
   * Padding between the points in the heatmap.
   *
   * @type {Number}
   * @default 0
   * @since 6.0
   * @apioption plotOptions.heatmap.pointPadding
   */

  /**
   * The main color of the series. In heat maps this color is rarely used,
   * as we mostly use the color to denote the value of each point. Unless
   * options are set in the [colorAxis](#colorAxis), the default value
   * is pulled from the [options.colors](#colors) array.
   *
   * @type {Color}
   * @default null
   * @since 4.0
   * @product highcharts
   * @apioption plotOptions.heatmap.color
   */

  /**
   * The column size - how many X axis units each column in the heatmap
   * should span.
   *
   * @type {Number}
   * @sample {highcharts} maps/demo/heatmap/ One day
   * @sample {highmaps} maps/demo/heatmap/ One day
   * @default 1
   * @since 4.0
   * @product highcharts highmaps
   * @apioption plotOptions.heatmap.colsize
   */

  /**
   * The row size - how many Y axis units each heatmap row should span.
   *
   * @type {Number}
   * @sample {highcharts} maps/demo/heatmap/ 1 by default
   * @sample {highmaps} maps/demo/heatmap/ 1 by default
   * @default 1
   * @since 4.0
   * @product highcharts highmaps
   * @apioption plotOptions.heatmap.rowsize
   */
  dataLabels: {
    formatter: function () {
      // #2945
      return this.point.value;
    },
    inside: true,
    verticalAlign: 'middle',
    crop: false,
    overflow: false,
    padding: 0 // #3837

  },

  /**
   * @ignore
   */
  marker: null,

  /**    @ignore */
  pointRange: null,
  // dynamically set to colsize by default
  tooltip: {
    pointFormat: '{point.x}, {point.y}: {point.value}<br/>'
  },
  states: {
    hover: {
      /**
       * @ignore
       */
      halo: false,
      // #3406, halo is disabled on heatmaps by default

      /**
       * How much to brighten the point on interaction. Requires the main
       * color to be defined in hex or rgb(a) format.
       *
       * In styled mode, the hover brightening is by default replaced
       * with a fill-opacity set in the `.highcharts-point:hover` rule.
       *
       * @type {Number}
       * @product highcharts highmaps
       */
      brightness: 0.2
    }
  }
}, merge$y(colorSeriesMixin, {
  pointArrayMap: ['y', 'value'],
  hasPointSpecificOptions: true,
  getExtremesFromAll: true,
  directTouch: true,

  /**
   * Override the init method to add point ranges on both axes.
   */
  init: function () {
    var options;
    seriesTypes$o.scatter.prototype.init.apply(this, arguments);
    options = this.options; // #3758, prevent resetting in setData

    options.pointRange = pick$S(options.pointRange, options.colsize || 1);
    this.yAxis.axisPointRange = options.rowsize || 1; // general point range
  },
  translate: function () {
    var series = this,
        options = series.options,
        xAxis = series.xAxis,
        yAxis = series.yAxis,
        seriesPointPadding = options.pointPadding || 0,
        between = function (x, a, b) {
      return Math.min(Math.max(a, x), b);
    };

    series.generatePoints();
    each$V(series.points, function (point) {
      var xPad = (options.colsize || 1) / 2,
          yPad = (options.rowsize || 1) / 2,
          x1 = between(Math.round(xAxis.len - xAxis.translate(point.x - xPad, 0, 1, 0, 1)), -xAxis.len, 2 * xAxis.len),
          x2 = between(Math.round(xAxis.len - xAxis.translate(point.x + xPad, 0, 1, 0, 1)), -xAxis.len, 2 * xAxis.len),
          y1 = between(Math.round(yAxis.translate(point.y - yPad, 0, 1, 0, 1)), -yAxis.len, 2 * yAxis.len),
          y2 = between(Math.round(yAxis.translate(point.y + yPad, 0, 1, 0, 1)), -yAxis.len, 2 * yAxis.len),
          pointPadding = pick$S(point.pointPadding, seriesPointPadding); // Set plotX and plotY for use in K-D-Tree and more

      point.plotX = point.clientX = (x1 + x2) / 2;
      point.plotY = (y1 + y2) / 2;
      point.shapeType = 'rect';
      point.shapeArgs = {
        x: Math.min(x1, x2) + pointPadding,
        y: Math.min(y1, y2) + pointPadding,
        width: Math.abs(x2 - x1) - pointPadding * 2,
        height: Math.abs(y2 - y1) - pointPadding * 2
      };
    });
    series.translateColors();
  },
  drawPoints: function () {
    seriesTypes$o.column.prototype.drawPoints.call(this);
    each$V(this.points, function (point) {
      // In styled mode, use CSS, otherwise the fill used in the style
      // sheet will take precedence over the fill attribute.
      point.graphic.css(this.colorAttribs(point));
    }, this);
  },
  animate: noop$k,
  getBox: noop$k,
  drawLegendSymbol: LegendSymbolMixin$7.drawRectangle,
  alignDataLabel: seriesTypes$o.column.prototype.alignDataLabel,
  getExtremes: function () {
    // Get the extremes from the value data
    Series$l.prototype.getExtremes.call(this, this.valueData);
    this.valueMin = this.dataMin;
    this.valueMax = this.dataMax; // Get the extremes from the y data

    Series$l.prototype.getExtremes.call(this);
  }
}), Highcharts.extend({
  haloPath: function (size) {
    if (!size) {
      return [];
    }

    var rect = this.shapeArgs;
    return ['M', rect.x - size, rect.y - size, 'L', rect.x - size, rect.y + rect.height + size, rect.x + rect.width + size, rect.y + rect.height + size, rect.x + rect.width + size, rect.y - size, 'Z'];
  }
}, colorPointMixin));
/**
 * A `heatmap` series. If the [type](#series.heatmap.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 *
 * @type {Object}
 * @extends series,plotOptions.heatmap
 * @excluding dataParser,dataURL,marker,pointRange,stack
 * @product highcharts highmaps
 * @apioption series.heatmap
 */

/**
 * An array of data points for the series. For the `heatmap` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of arrays with 3 or 2 values. In this case, the values
 * correspond to `x,y,value`. If the first value is a string, it is
 * applied as the name of the point, and the `x` value is inferred.
 * The `x` value can also be omitted, in which case the inner arrays
 * should be of length 2\. Then the `x` value is automatically calculated,
 * either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options.
 *
 *  ```js
 *     data: [
 *         [0, 9, 7],
 *         [1, 10, 4],
 *         [2, 6, 3]
 *     ]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.heatmap.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 3,
 *         value: 10,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 7,
 *         value: 10,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type {Array<Object|Array>}
 * @extends series.line.data
 * @excluding marker
 * @sample {highcharts} highcharts/chart/reflow-true/
 *         Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/
 *         Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *         Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/
 *         Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/
 *         Config objects
 * @product highcharts highmaps
 * @apioption series.heatmap.data
 */

/**
 * The color of the point. In heat maps the point color is rarely set
 * explicitly, as we use the color to denote the `value`. Options for
 * this are set in the [colorAxis](#colorAxis) configuration.
 *
 * @type {Color}
 * @product highcharts highmaps
 * @apioption series.heatmap.data.color
 */

/**
 * The value of the point, resulting in a color controled by options
 * as set in the [colorAxis](#colorAxis) configuration.
 *
 * @type {Number}
 * @product highcharts highmaps
 * @apioption series.heatmap.data.value
 */

/**
 * The x value of the point. For datetime axes,
 * the X value is the timestamp in milliseconds since 1970.
 *
 * @type {Number}
 * @product highcharts highmaps
 * @apioption series.heatmap.data.x
 */

/**
 * The y value of the point.
 *
 * @type {Number}
 * @product highcharts highmaps
 * @apioption series.heatmap.data.y
 */

/**
 * Point padding for a single point.
 *
 * @type {Number}
 * @sample maps/plotoptions/tilemap-pointpadding Point padding on tiles
 * @apioption series.heatmap.data.pointPadding
 */

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 *
 * (c) 2009-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

/**
 * Solid angular gauge module
 *
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var pInt$8 = Highcharts.pInt,
    pick$T = Highcharts.pick,
    each$W = Highcharts.each,
    isNumber$k = Highcharts.isNumber,
    wrap$i = Highcharts.wrap,
    Renderer$2 = Highcharts.Renderer,
    colorAxisMethods;
/**
 * Symbol definition of an arc with round edges.
 *
 * @param  {Number} x - The X coordinate for the top left position.
 * @param  {Number} y - The Y coordinate for the top left position.
 * @param  {Number} w - The pixel width.
 * @param  {Number} h - The pixel height.
 * @param  {Object} [options] - Additional options, depending on the actual
 *    symbol drawn.
 * @param {boolean} [options.rounded] - Whether to draw rounded edges.
 * @return {Array} Path of the created arc.
 */

wrap$i(Renderer$2.prototype.symbols, 'arc', function (proceed, x, y, w, h, options) {
  var arc = proceed,
      path = arc(x, y, w, h, options);

  if (options.rounded) {
    var r = options.r || w,
        smallR = (r - options.innerR) / 2,
        x1 = path[1],
        y1 = path[2],
        x2 = path[12],
        y2 = path[13],
        roundStart = ['A', smallR, smallR, 0, 1, 1, x1, y1],
        roundEnd = ['A', smallR, smallR, 0, 1, 1, x2, y2]; // Insert rounded edge on end, and remove line.

    path.splice.apply(path, [path.length - 1, 0].concat(roundStart)); // Insert rounded edge on end, and remove line.

    path.splice.apply(path, [11, 3].concat(roundEnd));
  }

  return path;
}); // These methods are defined in the ColorAxis object, and copied here.
// If we implement an AMD system we should make ColorAxis a dependency.

colorAxisMethods = {
  initDataClasses: function (userOptions) {
    var chart = this.chart,
        dataClasses,
        colorCounter = 0,
        options = this.options;
    this.dataClasses = dataClasses = [];
    each$W(userOptions.dataClasses, function (dataClass, i) {
      var colors;
      dataClass = Highcharts.merge(dataClass);
      dataClasses.push(dataClass);

      if (!dataClass.color) {
        if (options.dataClassColor === 'category') {
          colors = chart.options.colors;
          dataClass.color = colors[colorCounter++]; // loop back to zero

          if (colorCounter === colors.length) {
            colorCounter = 0;
          }
        } else {
          dataClass.color = Highcharts.color(options.minColor).tweenTo(Highcharts.color(options.maxColor), i / (userOptions.dataClasses.length - 1));
        }
      }
    });
  },
  initStops: function (userOptions) {
    this.stops = userOptions.stops || [[0, this.options.minColor], [1, this.options.maxColor]];
    each$W(this.stops, function (stop) {
      stop.color = Highcharts.color(stop[1]);
    });
  },

  /**
   * Translate from a value to a color
   */
  toColor: function (value, point) {
    var pos,
        stops = this.stops,
        from,
        to,
        color,
        dataClasses = this.dataClasses,
        dataClass,
        i;

    if (dataClasses) {
      i = dataClasses.length;

      while (i--) {
        dataClass = dataClasses[i];
        from = dataClass.from;
        to = dataClass.to;

        if ((from === undefined || value >= from) && (to === undefined || value <= to)) {
          color = dataClass.color;

          if (point) {
            point.dataClass = i;
          }

          break;
        }
      }
    } else {
      if (this.isLog) {
        value = this.val2lin(value);
      }

      pos = 1 - (this.max - value) / (this.max - this.min);
      i = stops.length;

      while (i--) {
        if (pos > stops[i][0]) {
          break;
        }
      }

      from = stops[i] || stops[i + 1];
      to = stops[i + 1] || from; // The position within the gradient

      pos = 1 - (to[0] - pos) / (to[0] - from[0] || 1);
      color = from.color.tweenTo(to.color, pos);
    }

    return color;
  }
};
/**
 * A solid gauge is a circular gauge where the value is indicated by a filled
 * arc, and the color of the arc may variate with the value.
 *
 * @sample highcharts/demo/gauge-solid/ Solid gauges
 * @extends plotOptions.gauge
 * @excluding dial,pivot,wrap
 * @product highcharts
 * @optionparent plotOptions.solidgauge
 */

var solidGaugeOptions = {
  /**
   * Whether the strokes of the solid gauge should be `round` or `square`.
   *
   * @validvalue ["square", "round"]
   * @type {String}
   * @sample {highcharts} highcharts/demo/gauge-activity/ Rounded gauge
   * @default round
   * @since 4.2.2
   * @product highcharts
   * @apioption plotOptions.solidgauge.linecap
   */

  /**
   * Allow the gauge to overshoot the end of the perimeter axis by this
   * many degrees. Say if the gauge axis goes from 0 to 60, a value of
   * 100, or 1000, will show 5 degrees beyond the end of the axis when this
   * option is set to 5.
   *
   * @type      {Number}
   * @default   0
   * @since     3.0.10
   * @product   highcharts
   * @apioption plotOptions.solidgauge.overshoot
   */

  /**
   * Wether to draw rounded edges on the gauge.
   *
   * @type {Boolean}
   * @sample {highcharts} highcharts/demo/gauge-activity/ Activity Gauge
   * @default false
   * @since 5.0.8
   * @product highcharts
   * @apioption plotOptions.solidgauge.rounded
   */

  /**
   * The threshold or base level for the gauge.
   *
   * @type {Number}
   * @sample {highcharts} highcharts/plotoptions/solidgauge-threshold/
   *         Zero threshold with negative and positive values
   * @default null
   * @since 5.0.3
   * @product highcharts
   * @apioption plotOptions.solidgauge.threshold
   */

  /**
   * Whether to give each point an individual color.
   */
  colorByPoint: true
}; // The solidgauge series type

Highcharts.seriesType('solidgauge', 'gauge', solidGaugeOptions, {
  /**
   * Extend the translate function to extend the Y axis with the necessary
   * decoration (#5895).
   */
  translate: function () {
    var axis = this.yAxis;
    Highcharts.extend(axis, colorAxisMethods); // Prepare data classes

    if (!axis.dataClasses && axis.options.dataClasses) {
      axis.initDataClasses(axis.options);
    }

    axis.initStops(axis.options); // Generate points and inherit data label position

    Highcharts.seriesTypes.gauge.prototype.translate.call(this);
  },

  /**
   * Draw the points where each point is one needle
   */
  drawPoints: function () {
    var series = this,
        yAxis = series.yAxis,
        center = yAxis.center,
        options = series.options,
        renderer = series.chart.renderer,
        overshoot = options.overshoot,
        overshootVal = isNumber$k(overshoot) ? overshoot / 180 * Math.PI : 0,
        thresholdAngleRad; // Handle the threshold option

    if (isNumber$k(options.threshold)) {
      thresholdAngleRad = yAxis.startAngleRad + yAxis.translate(options.threshold, null, null, null, true);
    }

    this.thresholdAngleRad = pick$T(thresholdAngleRad, yAxis.startAngleRad);
    each$W(series.points, function (point) {
      var graphic = point.graphic,
          rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true),
          radius = pInt$8(pick$T(point.options.radius, options.radius, 100)) * center[2] / 200,
          innerRadius = pInt$8(pick$T(point.options.innerRadius, options.innerRadius, 60)) * center[2] / 200,
          shapeArgs,
          d,
          toColor = yAxis.toColor(point.y, point),
          axisMinAngle = Math.min(yAxis.startAngleRad, yAxis.endAngleRad),
          axisMaxAngle = Math.max(yAxis.startAngleRad, yAxis.endAngleRad),
          minAngle,
          maxAngle;

      if (toColor === 'none') {
        // #3708
        toColor = point.color || series.color || 'none';
      }

      if (toColor !== 'none') {
        point.color = toColor;
      } // Handle overshoot and clipping to axis max/min


      rotation = Math.max(axisMinAngle - overshootVal, Math.min(axisMaxAngle + overshootVal, rotation)); // Handle the wrap option

      if (options.wrap === false) {
        rotation = Math.max(axisMinAngle, Math.min(axisMaxAngle, rotation));
      }

      minAngle = Math.min(rotation, series.thresholdAngleRad);
      maxAngle = Math.max(rotation, series.thresholdAngleRad);

      if (maxAngle - minAngle > 2 * Math.PI) {
        maxAngle = minAngle + 2 * Math.PI;
      }

      point.shapeArgs = shapeArgs = {
        x: center[0],
        y: center[1],
        r: radius,
        innerR: innerRadius,
        start: minAngle,
        end: maxAngle,
        rounded: options.rounded
      };
      point.startR = radius; // For PieSeries.animate

      if (graphic) {
        d = shapeArgs.d;
        graphic.animate(Highcharts.extend({
          fill: toColor
        }, shapeArgs));

        if (d) {
          shapeArgs.d = d; // animate alters it
        }
      } else {
        point.graphic = graphic = renderer.arc(shapeArgs).attr({
          fill: toColor,
          'sweep-flag': 0
        }).add(series.group);
      }

      if (graphic) {
        graphic.addClass(point.getClassName(), true);
      }
    });
  },

  /**
   * Extend the pie slice animation by animating from start angle and up
   */
  animate: function (init) {
    if (!init) {
      this.startAngleRad = this.thresholdAngleRad;
      Highcharts.seriesTypes.pie.prototype.animate.call(this, init);
    }
  }
});
/**
 * A `solidgauge` series. If the [type](#series.solidgauge.type) option
 * is not specified, it is inherited from [chart.type](#chart.type).
 *
 *
 * @type      {Object}
 * @extends   series,plotOptions.solidgauge
 * @excluding animationLimit,boostThreshold,connectEnds,connectNulls,
 *            cropThreshold,dashStyle,dataParser,dataURL,dial,
 *            findNearestPointBy,getExtremesFromAll,marker,negativeColor,
 *            pointPlacement,pivot,shadow,softThreshold,stack,stacking,states,
 *            step,threshold,turboThreshold,wrap,zoneAxis,zones
 * @product   highcharts
 * @apioption series.solidgauge
 */

/**
 * An array of data points for the series. For the `solidgauge` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](
 * #series.solidgauge.turboThreshold), this option is not available.
 *
 *  ```js
 *     data: [{
 *         y: 5,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         y: 7,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * The typical gauge only contains a single data value.
 *
 * @type {Array<Object|Number>}
 * @extends series.gauge.data
 * @sample {highcharts} highcharts/chart/reflow-true/
 *         Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/
 *         Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *         Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/
 *         Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/
 *         Config objects
 * @product highcharts
 * @apioption series.solidgauge.data
 */

/**
 * The inner radius of an individual point in a solid gauge. Can be
 * given as a number (pixels) or percentage string.
 *
 * @type {Number|String}
 * @sample {highcharts} highcharts/plotoptions/solidgauge-radius/ Individual radius and innerRadius
 * @since 4.1.6
 * @product highcharts
 * @apioption series.solidgauge.data.innerRadius
 */

/**
 * The outer radius of an individual point in a solid gauge. Can be
 * given as a number (pixels) or percentage string.
 *
 * @type {Number|String}
 * @sample {highcharts} highcharts/plotoptions/solidgauge-radius/ Individual radius and innerRadius
 * @since 4.1.6
 * @product highcharts
 * @apioption series.solidgauge.data.radius
 */

/**
 * @license  @product.name@ JS v@product.version@ (@product.date@)
 * Solid angular gauge module
 *
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

var each$X = Highcharts.each,
    extend$t = Highcharts.extend,
    isArray$8 = Highcharts.isArray,
    isBoolean = function (x) {
  return typeof x === 'boolean';
},
    isFn = function (x) {
  return typeof x === 'function';
},
    isObject$8 = Highcharts.isObject,
    isNumber$l = Highcharts.isNumber,
    merge$z = Highcharts.merge,
    pick$U = Highcharts.pick,
    reduce = Highcharts.reduce; // TODO Combine buildTree and buildNode with setTreeValues
// TODO Remove logic from Treemap and make it utilize this mixin.


var setTreeValues = function setTreeValues(tree, options) {
  var before = options.before,
      idRoot = options.idRoot,
      mapIdToNode = options.mapIdToNode,
      nodeRoot = mapIdToNode[idRoot],
      levelIsConstant = isBoolean(options.levelIsConstant) ? options.levelIsConstant : true,
      points = options.points,
      point = points[tree.i],
      optionsPoint = point && point.options || {},
      childrenTotal = 0,
      children = [],
      value;
  extend$t(tree, {
    levelDynamic: tree.level - (levelIsConstant ? 0 : nodeRoot.level),
    name: pick$U(point && point.name, ''),
    visible: idRoot === tree.id || (isBoolean(options.visible) ? options.visible : false)
  });

  if (isFn(before)) {
    tree = before(tree, options);
  } // First give the children some values


  each$X(tree.children, function (child, i) {
    var newOptions = extend$t({}, options);
    extend$t(newOptions, {
      index: i,
      siblings: tree.children.length,
      visible: tree.visible
    });
    child = setTreeValues(child, newOptions);
    children.push(child);

    if (child.visible) {
      childrenTotal += child.val;
    }
  });
  tree.visible = childrenTotal > 0 || tree.visible; // Set the values

  value = pick$U(optionsPoint.value, childrenTotal);
  extend$t(tree, {
    children: children,
    childrenTotal: childrenTotal,
    isLeaf: tree.visible && !childrenTotal,
    val: value
  });
  return tree;
};

var getColor = function getColor(node, options) {
  var index = options.index,
      mapOptionsToLevel = options.mapOptionsToLevel,
      parentColor = options.parentColor,
      parentColorIndex = options.parentColorIndex,
      series = options.series,
      colors = options.colors,
      siblings = options.siblings,
      points = series.points,
      getColorByPoint,
      point,
      level,
      colorByPoint,
      colorIndexByPoint,
      color,
      colorIndex;

  if (node) {
    point = points[node.i];
    level = mapOptionsToLevel[node.level] || {};
    getColorByPoint = point && level.colorByPoint;

    if (getColorByPoint) {
      colorIndexByPoint = point.index % (colors ? colors.length : series.chart.options.chart.colorCount);
      colorByPoint = colors && colors[colorIndexByPoint];
    }

    colorIndex = pick$U(point && point.options.colorIndex, level && level.colorIndex, colorIndexByPoint, parentColorIndex, options.colorIndex);
  }

  return {
    color: color,
    colorIndex: colorIndex
  };
};
/**
 * getLevelOptions - Creates a map from level number to its given options.
 * @param {Object} params Object containing parameters.
 * @param {Object} params.defaults Object containing default options. The
 * default options are merged with the userOptions to get the final options for
 * a specific level.
 * @param {Number} params.from The lowest level number.
 * @param {Array} params.levels User options from series.levels.
 * @param {Number} params.to The highest level number.
 * @return {null|Object} Returns a map from level number to its given options.
 * Returns null if invalid input parameters.
 */


var getLevelOptions = function getLevelOptions(params) {
  var result = null,
      defaults,
      converted,
      i,
      from,
      to,
      levels;

  if (isObject$8(params)) {
    result = {};
    from = isNumber$l(params.from) ? params.from : 1;
    levels = params.levels;
    converted = {};
    defaults = isObject$8(params.defaults) ? params.defaults : {};

    if (isArray$8(levels)) {
      converted = reduce(levels, function (obj, item) {
        var level, levelIsConstant, options;

        if (isObject$8(item) && isNumber$l(item.level)) {
          options = merge$z({}, item);
          levelIsConstant = isBoolean(options.levelIsConstant) ? options.levelIsConstant : defaults.levelIsConstant; // Delete redundant properties.

          delete options.levelIsConstant;
          delete options.level; // Calculate which level these options apply to.

          level = item.level + (levelIsConstant ? 0 : from - 1);

          if (isObject$8(obj[level])) {
            extend$t(obj[level], options);
          } else {
            obj[level] = options;
          }
        }

        return obj;
      }, {});
    }

    to = isNumber$l(params.to) ? params.to : 1;

    for (i = 0; i <= to; i++) {
      result[i] = merge$z({}, defaults, isObject$8(converted[i]) ? converted[i] : {});
    }
  }

  return result;
};
/**
 * Update the rootId property on the series. Also makes sure that it is
 * accessible to exporting.
 * @param {object} series The series to operate on.
 * @returns Returns the resulting rootId after update.
 */


var updateRootId = function (series) {
  var rootId, options;

  if (isObject$8(series)) {
    // Get the series options.
    options = isObject$8(series.options) ? series.options : {}; // Calculate the rootId.

    rootId = pick$U(series.rootNode, options.rootId, ''); // Set rootId on series.userOptions to pick it up in exporting.

    if (isObject$8(series.userOptions)) {
      series.userOptions.rootId = rootId;
    } // Set rootId on series to pick it up on next update.


    series.rootNode = rootId;
  }

  return rootId;
};

var result$1 = {
  getColor: getColor,
  getLevelOptions: getLevelOptions,
  setTreeValues: setTreeValues,
  updateRootId: updateRootId
};

/**
 * (c) 2014 Highsoft AS
 * Authors: Jon Arild Nygard / Oystein Moseng
 *
 * License: www.highcharts.com/license
 */

var seriesType$m = Highcharts.seriesType,
    seriesTypes$p = Highcharts.seriesTypes,
    map$a = Highcharts.map,
    merge$A = Highcharts.merge,
    extend$u = Highcharts.extend,
    noop$l = Highcharts.noop,
    each$Y = Highcharts.each,
    getColor$1 = result$1.getColor,
    getLevelOptions$1 = result$1.getLevelOptions,
    grep$6 = Highcharts.grep,
    isArray$9 = Highcharts.isArray,
    isBoolean$1 = function (x) {
  return typeof x === 'boolean';
},
    isNumber$m = Highcharts.isNumber,
    isObject$9 = Highcharts.isObject,
    isString$6 = Highcharts.isString,
    pick$V = Highcharts.pick,
    Series$m = Highcharts.Series,
    stableSort$3 = Highcharts.stableSort,
    color$b = Highcharts.Color,
    eachObject = function (list, func, context) {
  context = context || this;
  Highcharts.objectEach(list, function (val, key) {
    func.call(context, val, key, list);
  });
},
    reduce$1 = Highcharts.reduce,
    // @todo find correct name for this function.
// @todo Similar to reduce, this function is likely redundant
recursive = function (item, func, context) {
  var next;
  context = context || this;
  next = func.call(context, item);

  if (next !== false) {
    recursive(next, func, context);
  }
},
    updateRootId$1 = result$1.updateRootId;
/**
 * A treemap displays hierarchical data using nested rectangles. The data can be
 * laid out in varying ways depending on options.
 *
 * @sample highcharts/demo/treemap-large-dataset/ Treemap
 *
 * @extends plotOptions.scatter
 * @excluding marker
 * @product highcharts
 * @optionparent plotOptions.treemap
 */


seriesType$m('treemap', 'scatter', {
  /**
   * When enabled the user can click on a point which is a parent and
   * zoom in on its children.
   *
   * @type {Boolean}
   * @sample {highcharts} highcharts/plotoptions/treemap-allowdrilltonode/
   *         Enabled
   * @default false
   * @since 4.1.0
   * @product highcharts
   * @apioption plotOptions.treemap.allowDrillToNode
   */

  /**
   * When the series contains less points than the crop threshold, all
   * points are drawn, event if the points fall outside the visible plot
   * area at the current zoom. The advantage of drawing all points (including
   * markers and columns), is that animation is performed on updates.
   * On the other hand, when the series contains more points than the
   * crop threshold, the series data is cropped to only contain points
   * that fall within the plot area. The advantage of cropping away invisible
   * points is to increase performance on large series.
   *
   * @type {Number}
   * @default 300
   * @since 4.1.0
   * @product highcharts
   * @apioption plotOptions.treemap.cropThreshold
   */

  /**
   * This option decides if the user can interact with the parent nodes
   * or just the leaf nodes. When this option is undefined, it will be
   * true by default. However when allowDrillToNode is true, then it will
   * be false by default.
   *
   * @type {Boolean}
   * @sample {highcharts}
   *         highcharts/plotoptions/treemap-interactbyleaf-false/
   *         False
   * @sample {highcharts}
   *         highcharts/plotoptions/treemap-interactbyleaf-true-and-allowdrilltonode/
   *         InteractByLeaf and allowDrillToNode is true
   * @since 4.1.2
   * @product highcharts
   * @apioption plotOptions.treemap.interactByLeaf
   */

  /**
   * The sort index of the point inside the treemap level.
   *
   * @type {Number}
   * @sample {highcharts} highcharts/plotoptions/treemap-sortindex/
   *         Sort by years
   * @since 4.1.10
   * @product highcharts
   * @apioption plotOptions.treemap.sortIndex
   */

  /**
   * When using automatic point colors pulled from the `options.colors`
   * collection, this option determines whether the chart should receive
   * one color per series or one color per point.
   *
   * @type {Boolean}
   * @see [series colors](#plotOptions.treemap.colors)
   * @default false
   * @since 2.0
   * @apioption plotOptions.treemap.colorByPoint
   */

  /**
   * A series specific or series type specific color set to apply instead
   * of the global [colors](#colors) when [colorByPoint](
   * #plotOptions.treemap.colorByPoint) is true.
   *
   * @type {Array<Color>}
   * @since 3.0
   * @apioption plotOptions.treemap.colors
   */

  /**
   * Whether to display this series type or specific series item in the
   * legend.
   *
   * @type {Boolean}
   * @default false
   * @product highcharts
   */
  showInLegend: false,

  /**
   * @ignore
   */
  marker: false,
  colorByPoint: false,

  /**
   * @extends plotOptions.heatmap.dataLabels
   * @since 4.1.0
   * @product highcharts
   */
  dataLabels: {
    enabled: true,
    defer: false,
    verticalAlign: 'middle',
    formatter: function () {
      // #2945
      return this.point.name || this.point.id;
    },
    inside: true
  },
  tooltip: {
    headerFormat: '',
    pointFormat: '<b>{point.name}</b>: {point.value}<br/>'
  },

  /**
   * Whether to ignore hidden points when the layout algorithm runs.
   * If `false`, hidden points will leave open spaces.
   *
   * @type {Boolean}
   * @default true
   * @since 5.0.8
   * @product highcharts
   */
  ignoreHiddenPoint: true,

  /**
   * This option decides which algorithm is used for setting position
   * and dimensions of the points. Can be one of `sliceAndDice`, `stripes`,
   *  `squarified` or `strip`.
   *
   * @validvalue ["sliceAndDice", "stripes", "squarified", "strip"]
   * @type {String}
   * @see [How to write your own algorithm](
   * https://www.highcharts.com/docs/chart-and-series-types/treemap).
   *
   * @sample  {highcharts}
   *          highcharts/plotoptions/treemap-layoutalgorithm-sliceanddice/
   *          SliceAndDice by default
   * @sample  {highcharts}
   *          highcharts/plotoptions/treemap-layoutalgorithm-stripes/
   *          Stripes
   * @sample  {highcharts}
   *          highcharts/plotoptions/treemap-layoutalgorithm-squarified/
   *          Squarified
   * @sample  {highcharts}
   *          highcharts/plotoptions/treemap-layoutalgorithm-strip/
   *          Strip
   * @default sliceAndDice
   * @since 4.1.0
   * @product highcharts
   */
  layoutAlgorithm: 'sliceAndDice',

  /**
   * Defines which direction the layout algorithm will start drawing.
   *  Possible values are "vertical" and "horizontal".
   *
   * @validvalue ["vertical", "horizontal"]
   * @type {String}
   * @default vertical
   * @since 4.1.0
   * @product highcharts
   */
  layoutStartingDirection: 'vertical',

  /**
   * Enabling this option will make the treemap alternate the drawing
   * direction between vertical and horizontal. The next levels starting
   * direction will always be the opposite of the previous.
   *
   * @type {Boolean}
   * @sample  {highcharts}
   *          highcharts/plotoptions/treemap-alternatestartingdirection-true/
   *          Enabled
   * @default false
   * @since 4.1.0
   * @product highcharts
   */
  alternateStartingDirection: false,

  /**
   * Used together with the levels and allowDrillToNode options. When
   * set to false the first level visible when drilling is considered
   * to be level one. Otherwise the level will be the same as the tree
   * structure.
   *
   * @type {Boolean}
   * @default true
   * @since 4.1.0
   * @product highcharts
   */
  levelIsConstant: true,

  /**
   * Options for the button appearing when drilling down in a treemap.
   */
  drillUpButton: {
    /**
     * The position of the button.
     */
    position: {
      /**
       * Vertical alignment of the button.
       *
       * @default top
       * @validvalue ["top", "middle", "bottom"]
       * @apioption plotOptions.treemap.drillUpButton.position.verticalAlign
       */

      /**
       * Horizontal alignment of the button.
       * @validvalue ["left", "center", "right"]
       */
      align: 'right',

      /**
       * Horizontal offset of the button.
       * @default -10
       * @type {Number}
       */
      x: -10,

      /**
       * Vertical offset of the button.
       */
      y: 10
    }
  }
  /**
   * Set options on specific levels. Takes precedence over series options,
   * but not point options.
   *
   * @type {Array<Object>}
   * @sample {highcharts} highcharts/plotoptions/treemap-levels/
   *         Styling dataLabels and borders
   * @sample {highcharts} highcharts/demo/treemap-with-levels/
   *         Different layoutAlgorithm
   * @since 4.1.0
   * @product highcharts
   * @apioption plotOptions.treemap.levels
   */

  /**
   * Can set a `borderColor` on all points which lies on the same level.
   *
   * @type {Color}
   * @since 4.1.0
   * @product highcharts
   * @apioption plotOptions.treemap.levels.borderColor
   */

  /**
   * Set the dash style of the border of all the point which lies on the
   * level. See <a href"#plotoptions.scatter.dashstyle">
   * plotOptions.scatter.dashStyle</a> for possible options.
   *
   * @type {String}
   * @since 4.1.0
   * @product highcharts
   * @apioption plotOptions.treemap.levels.borderDashStyle
   */

  /**
   * Can set the borderWidth on all points which lies on the same level.
   *
   * @type {Number}
   * @since 4.1.0
   * @product highcharts
   * @apioption plotOptions.treemap.levels.borderWidth
   */

  /**
   * Can set a color on all points which lies on the same level.
   *
   * @type {Color}
   * @since 4.1.0
   * @product highcharts
   * @apioption plotOptions.treemap.levels.color
   */

  /**
   * A configuration object to define how the color of a child varies from the
   * parent's color. The variation is distributed among the children of node.
   * For example when setting brightness, the brightness change will range
   * from the parent's original brightness on the first child, to the amount
   * set in the `to` setting on the last node. This allows a gradient-like
   * color scheme that sets children out from each other while highlighting
   * the grouping on treemaps and sectors on sunburst charts.
   *
   * @type {Object}
   * @sample highcharts/demo/sunburst/ Sunburst with color variation
   * @since 6.0.0
   * @product highcharts
   * @apioption plotOptions.treemap.levels.colorVariation
   */

  /**
   * The key of a color variation. Currently supports `brightness` only.
   *
   * @type {String}
   * @validvalue ["brightness"]
   * @since 6.0.0
   * @product highcharts
   * @apioption plotOptions.treemap.levels.colorVariation.key
   */

  /**
   * The ending value of a color variation. The last sibling will receive this
   * value.
   *
   * @type {Number}
   * @since 6.0.0
   * @product highcharts
   * @apioption plotOptions.treemap.levels.colorVariation.to
   */

  /**
   * Can set the options of dataLabels on each point which lies on the
   * level. [plotOptions.treemap.dataLabels](#plotOptions.treemap.dataLabels)
   * for possible values.
   *
   * @type {Object}
   * @default undefined
   * @since 4.1.0
   * @product highcharts
   * @apioption plotOptions.treemap.levels.dataLabels
   */

  /**
   * Can set the layoutAlgorithm option on a specific level.
   *
   * @validvalue ["sliceAndDice", "stripes", "squarified", "strip"]
   * @type {String}
   * @since 4.1.0
   * @product highcharts
   * @apioption plotOptions.treemap.levels.layoutAlgorithm
   */

  /**
   * Can set the layoutStartingDirection option on a specific level.
   *
   * @validvalue ["vertical", "horizontal"]
   * @type {String}
   * @since 4.1.0
   * @product highcharts
   * @apioption plotOptions.treemap.levels.layoutStartingDirection
   */

  /**
   * Decides which level takes effect from the options set in the levels
   * object.
   *
   * @type {Number}
   * @sample {highcharts} highcharts/plotoptions/treemap-levels/
   *         Styling of both levels
   * @since 4.1.0
   * @product highcharts
   * @apioption plotOptions.treemap.levels.level
   */
  // Prototype members

}, {
  pointArrayMap: ['value'],
  directTouch: true,
  optionalAxis: 'colorAxis',
  getSymbol: noop$l,
  parallelArrays: ['x', 'y', 'value', 'colorValue'],
  colorKey: 'colorValue',
  // Point color option key
  trackerGroups: ['group', 'dataLabelsGroup'],

  /**
   * Creates an object map from parent id to childrens index.
   * @param {Array} data List of points set in options.
   * @param {string} data[].parent Parent id of point.
   * @param {Array} existingIds List of all point ids.
   * @return {Object} Map from parent id to children index in data.
   */
  getListOfParents: function (data, existingIds) {
    var arr = isArray$9(data) ? data : [],
        ids = isArray$9(existingIds) ? existingIds : [],
        listOfParents = reduce$1(arr, function (prev, curr, i) {
      var parent = pick$V(curr.parent, '');

      if (prev[parent] === undefined) {
        prev[parent] = [];
      }

      prev[parent].push(i);
      return prev;
    }, {
      '': [] // Root of tree

    }); // If parent does not exist, hoist parent to root of tree.

    eachObject(listOfParents, function (children, parent, list) {
      if (parent !== '' && Highcharts.inArray(parent, ids) === -1) {
        each$Y(children, function (child) {
          list[''].push(child);
        });
        delete list[parent];
      }
    });
    return listOfParents;
  },

  /**
  * Creates a tree structured object from the series points
  */
  getTree: function () {
    var series = this,
        allIds = map$a(this.data, function (d) {
      return d.id;
    }),
        parentList = series.getListOfParents(this.data, allIds);
    series.nodeMap = [];
    return series.buildNode('', -1, 0, parentList, null);
  },
  init: function (chart, options) {
    var series = this,
        colorSeriesMixin = Highcharts.colorSeriesMixin; // If color series logic is loaded, add some properties

    if (Highcharts.colorSeriesMixin) {
      this.translateColors = colorSeriesMixin.translateColors;
      this.colorAttribs = colorSeriesMixin.colorAttribs;
      this.axisTypes = colorSeriesMixin.axisTypes;
    }

    Series$m.prototype.init.call(series, chart, options);

    if (series.options.allowDrillToNode) {
      Highcharts.addEvent(series, 'click', series.onClickDrillToNode);
    }
  },
  buildNode: function (id, i, level, list, parent) {
    var series = this,
        children = [],
        point = series.points[i],
        height = 0,
        node,
        child; // Actions

    each$Y(list[id] || [], function (i) {
      child = series.buildNode(series.points[i].id, i, level + 1, list, id);
      height = Math.max(child.height + 1, height);
      children.push(child);
    });
    node = {
      id: id,
      i: i,
      children: children,
      height: height,
      level: level,
      parent: parent,
      visible: false // @todo move this to better location

    };
    series.nodeMap[node.id] = node;

    if (point) {
      point.node = node;
    }

    return node;
  },
  setTreeValues: function (tree) {
    var series = this,
        options = series.options,
        idRoot = series.rootNode,
        mapIdToNode = series.nodeMap,
        nodeRoot = mapIdToNode[idRoot],
        levelIsConstant = isBoolean$1(options.levelIsConstant) ? options.levelIsConstant : true,
        childrenTotal = 0,
        children = [],
        val,
        point = series.points[tree.i]; // First give the children some values

    each$Y(tree.children, function (child) {
      child = series.setTreeValues(child);
      children.push(child);

      if (!child.ignore) {
        childrenTotal += child.val;
      }
    }); // Sort the children

    stableSort$3(children, function (a, b) {
      return a.sortIndex - b.sortIndex;
    }); // Set the values

    val = pick$V(point && point.options.value, childrenTotal);

    if (point) {
      point.value = val;
    }

    extend$u(tree, {
      children: children,
      childrenTotal: childrenTotal,
      // Ignore this node if point is not visible
      ignore: !(pick$V(point && point.visible, true) && val > 0),
      isLeaf: tree.visible && !childrenTotal,
      levelDynamic: tree.level - (levelIsConstant ? 0 : nodeRoot.level),
      name: pick$V(point && point.name, ''),
      sortIndex: pick$V(point && point.sortIndex, -val),
      val: val
    });
    return tree;
  },

  /**
   * Recursive function which calculates the area for all children of a node.
   * @param {Object} node The node which is parent to the children.
   * @param {Object} area The rectangular area of the parent.
   */
  calculateChildrenAreas: function (parent, area) {
    var series = this,
        options = series.options,
        mapOptionsToLevel = series.mapOptionsToLevel,
        level = mapOptionsToLevel[parent.level + 1],
        algorithm = pick$V(series[level && level.layoutAlgorithm] && level.layoutAlgorithm, options.layoutAlgorithm),
        alternate = options.alternateStartingDirection,
        childrenValues = [],
        children; // Collect all children which should be included

    children = grep$6(parent.children, function (n) {
      return !n.ignore;
    });

    if (level && level.layoutStartingDirection) {
      area.direction = level.layoutStartingDirection === 'vertical' ? 0 : 1;
    }

    childrenValues = series[algorithm](area, children);
    each$Y(children, function (child, index) {
      var values = childrenValues[index];
      child.values = merge$A(values, {
        val: child.childrenTotal,
        direction: alternate ? 1 - area.direction : area.direction
      });
      child.pointValues = merge$A(values, {
        x: values.x / series.axisRatio,
        width: values.width / series.axisRatio
      }); // If node has children, then call method recursively

      if (child.children.length) {
        series.calculateChildrenAreas(child, child.values);
      }
    });
  },
  setPointValues: function () {
    var series = this,
        xAxis = series.xAxis,
        yAxis = series.yAxis;
    each$Y(series.points, function (point) {
      var node = point.node,
          values = node.pointValues,
          x1,
          x2,
          y1,
          y2,
          crispCorr = 0; // Points which is ignored, have no values.

      if (values && node.visible) {
        x1 = Math.round(xAxis.translate(values.x, 0, 0, 0, 1)) - crispCorr;
        x2 = Math.round(xAxis.translate(values.x + values.width, 0, 0, 0, 1)) - crispCorr;
        y1 = Math.round(yAxis.translate(values.y, 0, 0, 0, 1)) - crispCorr;
        y2 = Math.round(yAxis.translate(values.y + values.height, 0, 0, 0, 1)) - crispCorr; // Set point values

        point.shapeType = 'rect';
        point.shapeArgs = {
          x: Math.min(x1, x2),
          y: Math.min(y1, y2),
          width: Math.abs(x2 - x1),
          height: Math.abs(y2 - y1)
        };
        point.plotX = point.shapeArgs.x + point.shapeArgs.width / 2;
        point.plotY = point.shapeArgs.y + point.shapeArgs.height / 2;
      } else {
        // Reset visibility
        delete point.plotX;
        delete point.plotY;
      }
    });
  },

  /**
   * Set the node's color recursively, from the parent down.
   */
  setColorRecursive: function (node, parentColor, colorIndex, index, siblings) {
    var series = this,
        chart = series && series.chart,
        colors = chart && chart.options && chart.options.colors,
        colorInfo,
        point;

    if (node) {
      colorInfo = getColor$1(node, {
        colors: colors,
        index: index,
        mapOptionsToLevel: series.mapOptionsToLevel,
        parentColor: parentColor,
        parentColorIndex: colorIndex,
        series: series,
        siblings: siblings
      });
      point = series.points[node.i];

      if (point) {
        point.color = colorInfo.color;
        point.colorIndex = colorInfo.colorIndex;
      } // Do it all again with the children


      each$Y(node.children || [], function (child, i) {
        series.setColorRecursive(child, colorInfo.color, colorInfo.colorIndex, i, node.children.length);
      });
    }
  },
  algorithmGroup: function (h, w, d, p) {
    this.height = h;
    this.width = w;
    this.plot = p;
    this.direction = d;
    this.startDirection = d;
    this.total = 0;
    this.nW = 0;
    this.lW = 0;
    this.nH = 0;
    this.lH = 0;
    this.elArr = [];
    this.lP = {
      total: 0,
      lH: 0,
      nH: 0,
      lW: 0,
      nW: 0,
      nR: 0,
      lR: 0,
      aspectRatio: function (w, h) {
        return Math.max(w / h, h / w);
      }
    };

    this.addElement = function (el) {
      this.lP.total = this.elArr[this.elArr.length - 1];
      this.total = this.total + el;

      if (this.direction === 0) {
        // Calculate last point old aspect ratio
        this.lW = this.nW;
        this.lP.lH = this.lP.total / this.lW;
        this.lP.lR = this.lP.aspectRatio(this.lW, this.lP.lH); // Calculate last point new aspect ratio

        this.nW = this.total / this.height;
        this.lP.nH = this.lP.total / this.nW;
        this.lP.nR = this.lP.aspectRatio(this.nW, this.lP.nH);
      } else {
        // Calculate last point old aspect ratio
        this.lH = this.nH;
        this.lP.lW = this.lP.total / this.lH;
        this.lP.lR = this.lP.aspectRatio(this.lP.lW, this.lH); // Calculate last point new aspect ratio

        this.nH = this.total / this.width;
        this.lP.nW = this.lP.total / this.nH;
        this.lP.nR = this.lP.aspectRatio(this.lP.nW, this.nH);
      }

      this.elArr.push(el);
    };

    this.reset = function () {
      this.nW = 0;
      this.lW = 0;
      this.elArr = [];
      this.total = 0;
    };
  },
  algorithmCalcPoints: function (directionChange, last, group, childrenArea) {
    var pX,
        pY,
        pW,
        pH,
        gW = group.lW,
        gH = group.lH,
        plot = group.plot,
        keep,
        i = 0,
        end = group.elArr.length - 1;

    if (last) {
      gW = group.nW;
      gH = group.nH;
    } else {
      keep = group.elArr[group.elArr.length - 1];
    }

    each$Y(group.elArr, function (p) {
      if (last || i < end) {
        if (group.direction === 0) {
          pX = plot.x;
          pY = plot.y;
          pW = gW;
          pH = p / pW;
        } else {
          pX = plot.x;
          pY = plot.y;
          pH = gH;
          pW = p / pH;
        }

        childrenArea.push({
          x: pX,
          y: pY,
          width: pW,
          height: pH
        });

        if (group.direction === 0) {
          plot.y = plot.y + pH;
        } else {
          plot.x = plot.x + pW;
        }
      }

      i = i + 1;
    }); // Reset variables

    group.reset();

    if (group.direction === 0) {
      group.width = group.width - gW;
    } else {
      group.height = group.height - gH;
    }

    plot.y = plot.parent.y + (plot.parent.height - group.height);
    plot.x = plot.parent.x + (plot.parent.width - group.width);

    if (directionChange) {
      group.direction = 1 - group.direction;
    } // If not last, then add uncalculated element


    if (!last) {
      group.addElement(keep);
    }
  },
  algorithmLowAspectRatio: function (directionChange, parent, children) {
    var childrenArea = [],
        series = this,
        pTot,
        plot = {
      x: parent.x,
      y: parent.y,
      parent: parent
    },
        direction = parent.direction,
        i = 0,
        end = children.length - 1,
        group = new this.algorithmGroup( // eslint-disable-line new-cap
    parent.height, parent.width, direction, plot); // Loop through and calculate all areas

    each$Y(children, function (child) {
      pTot = parent.width * parent.height * (child.val / parent.val);
      group.addElement(pTot);

      if (group.lP.nR > group.lP.lR) {
        series.algorithmCalcPoints(directionChange, false, group, childrenArea, plot);
      } // If last child, then calculate all remaining areas


      if (i === end) {
        series.algorithmCalcPoints(directionChange, true, group, childrenArea, plot);
      }

      i = i + 1;
    });
    return childrenArea;
  },
  algorithmFill: function (directionChange, parent, children) {
    var childrenArea = [],
        pTot,
        direction = parent.direction,
        x = parent.x,
        y = parent.y,
        width = parent.width,
        height = parent.height,
        pX,
        pY,
        pW,
        pH;
    each$Y(children, function (child) {
      pTot = parent.width * parent.height * (child.val / parent.val);
      pX = x;
      pY = y;

      if (direction === 0) {
        pH = height;
        pW = pTot / pH;
        width = width - pW;
        x = x + pW;
      } else {
        pW = width;
        pH = pTot / pW;
        height = height - pH;
        y = y + pH;
      }

      childrenArea.push({
        x: pX,
        y: pY,
        width: pW,
        height: pH
      });

      if (directionChange) {
        direction = 1 - direction;
      }
    });
    return childrenArea;
  },
  strip: function (parent, children) {
    return this.algorithmLowAspectRatio(false, parent, children);
  },
  squarified: function (parent, children) {
    return this.algorithmLowAspectRatio(true, parent, children);
  },
  sliceAndDice: function (parent, children) {
    return this.algorithmFill(true, parent, children);
  },
  stripes: function (parent, children) {
    return this.algorithmFill(false, parent, children);
  },
  translate: function () {
    var series = this,
        options = series.options,
        // NOTE: updateRootId modifies series.
    rootId = updateRootId$1(series),
        rootNode,
        pointValues,
        seriesArea,
        tree,
        val; // Call prototype function

    Series$m.prototype.translate.call(series); // @todo Only if series.isDirtyData is true

    tree = series.tree = series.getTree();
    rootNode = series.nodeMap[rootId];
    series.mapOptionsToLevel = getLevelOptions$1({
      from: rootNode.level + 1,
      levels: options.levels,
      to: tree.height,
      defaults: {
        levelIsConstant: series.options.levelIsConstant,
        colorByPoint: options.colorByPoint
      }
    });

    if (rootId !== '' && (!rootNode || !rootNode.children.length)) {
      series.drillToNode('', false);
      rootId = series.rootNode;
      rootNode = series.nodeMap[rootId];
    } // Parents of the root node is by default visible


    recursive(series.nodeMap[series.rootNode], function (node) {
      var next = false,
          p = node.parent;
      node.visible = true;

      if (p || p === '') {
        next = series.nodeMap[p];
      }

      return next;
    }); // Children of the root node is by default visible

    recursive(series.nodeMap[series.rootNode].children, function (children) {
      var next = false;
      each$Y(children, function (child) {
        child.visible = true;

        if (child.children.length) {
          next = (next || []).concat(child.children);
        }
      });
      return next;
    });
    series.setTreeValues(tree); // Calculate plotting values.

    series.axisRatio = series.xAxis.len / series.yAxis.len;
    series.nodeMap[''].pointValues = pointValues = {
      x: 0,
      y: 0,
      width: 100,
      height: 100
    };
    series.nodeMap[''].values = seriesArea = merge$A(pointValues, {
      width: pointValues.width * series.axisRatio,
      direction: options.layoutStartingDirection === 'vertical' ? 0 : 1,
      val: tree.val
    });
    series.calculateChildrenAreas(tree, seriesArea); // Logic for point colors

    if (series.colorAxis) {
      series.translateColors();
    } else if (!options.colorByPoint) {
      series.setColorRecursive(series.tree);
    } // Update axis extremes according to the root node.


    if (options.allowDrillToNode) {
      val = rootNode.pointValues;
      series.xAxis.setExtremes(val.x, val.x + val.width, false);
      series.yAxis.setExtremes(val.y, val.y + val.height, false);
      series.xAxis.setScale();
      series.yAxis.setScale();
    } // Assign values to points.


    series.setPointValues();
  },

  /**
   * Extend drawDataLabels with logic to handle custom options related to the
   * treemap series:
   * - Points which is not a leaf node, has dataLabels disabled by default.
   * - Options set on series.levels is merged in.
   * - Width of the dataLabel is set to match the width of the point shape.
   */
  drawDataLabels: function () {
    var series = this,
        mapOptionsToLevel = series.mapOptionsToLevel,
        points = grep$6(series.points, function (n) {
      return n.node.visible;
    }),
        options,
        level;
    each$Y(points, function (point) {
      level = mapOptionsToLevel[point.node.level]; // Set options to new object to avoid problems with scope

      options = {
        style: {}
      }; // If not a leaf, then label should be disabled as default

      if (!point.node.isLeaf) {
        options.enabled = false;
      } // If options for level exists, include them as well


      if (level && level.dataLabels) {
        options = merge$A(options, level.dataLabels);
        series._hasPointLabels = true;
      } // Set dataLabel width to the width of the point shape.


      if (point.shapeArgs) {
        options.style.width = point.shapeArgs.width;

        if (point.dataLabel) {
          point.dataLabel.css({
            width: point.shapeArgs.width + 'px'
          });
        }
      } // Merge custom options with point options


      point.dlOptions = merge$A(options, point.options.dataLabels);
    });
    Series$m.prototype.drawDataLabels.call(this);
  },

  /**
   * Over the alignment method by setting z index
   */
  alignDataLabel: function (point) {
    seriesTypes$p.column.prototype.alignDataLabel.apply(this, arguments);

    if (point.dataLabel) {
      // point.node.zIndex could be undefined (#6956)
      point.dataLabel.attr({
        zIndex: (point.node.zIndex || 0) + 1
      });
    }
  },

  /**
  * Extending ColumnSeries drawPoints
  */
  drawPoints: function () {
    var series = this,
        points = grep$6(series.points, function (n) {
      return n.node.visible;
    });
    each$Y(points, function (point) {
      var groupKey = 'level-group-' + point.node.levelDynamic;

      if (!series[groupKey]) {
        series[groupKey] = series.chart.renderer.g(groupKey).attr({
          // @todo Set the zIndex based upon the number of levels,
          // instead of using 1000
          zIndex: 1000 - point.node.levelDynamic
        }).add(series.group);
      }

      point.group = series[groupKey];
    }); // Call standard drawPoints

    seriesTypes$p.column.prototype.drawPoints.call(this); // In styled mode apply point.color. Use CSS, otherwise the fill
    // used in the style sheet will take precedence over the fill
    // attribute.

    if (this.colorAttribs) {
      // Heatmap is loaded
      each$Y(this.points, function (point) {
        if (point.graphic) {
          point.graphic.css(this.colorAttribs(point));
        }
      }, this);
    } // If drillToNode is allowed, set a point cursor on clickables & add
    // drillId to point


    if (series.options.allowDrillToNode) {
      each$Y(points, function (point) {
        if (point.graphic) {
          point.drillId = series.options.interactByLeaf ? series.drillToByLeaf(point) : series.drillToByGroup(point);
        }
      });
    }
  },

  /**
  * Add drilling on the suitable points
  */
  onClickDrillToNode: function (event) {
    var series = this,
        point = event.point,
        drillId = point && point.drillId; // If a drill id is returned, add click event and cursor.

    if (isString$6(drillId)) {
      point.setState(''); // Remove hover

      series.drillToNode(drillId);
    }
  },

  /**
  * Finds the drill id for a parent node.
  * Returns false if point should not have a click event
  * @param {Object} point
  * @return {String|Boolean} Drill to id or false when point should not have a
  *         click event
  */
  drillToByGroup: function (point) {
    var series = this,
        drillId = false;

    if (point.node.level - series.nodeMap[series.rootNode].level === 1 && !point.node.isLeaf) {
      drillId = point.id;
    }

    return drillId;
  },

  /**
  * Finds the drill id for a leaf node.
  * Returns false if point should not have a click event
  * @param {Object} point
  * @return {String|Boolean} Drill to id or false when point should not have a
  *         click event
  */
  drillToByLeaf: function (point) {
    var series = this,
        drillId = false,
        nodeParent;

    if (point.node.parent !== series.rootNode && point.node.isLeaf) {
      nodeParent = point.node;

      while (!drillId) {
        nodeParent = series.nodeMap[nodeParent.parent];

        if (nodeParent.parent === series.rootNode) {
          drillId = nodeParent.id;
        }
      }
    }

    return drillId;
  },
  drillUp: function () {
    var series = this,
        node = series.nodeMap[series.rootNode];

    if (node && isString$6(node.parent)) {
      series.drillToNode(node.parent);
    }
  },
  drillToNode: function (id, redraw) {
    var series = this,
        nodeMap = series.nodeMap,
        node = nodeMap[id];
    series.idPreviousRoot = series.rootNode;
    series.rootNode = id;

    if (id === '') {
      series.drillUpButton = series.drillUpButton.destroy();
    } else {
      series.showDrillUpButton(node && node.name || id);
    }

    this.isDirty = true; // Force redraw

    if (pick$V(redraw, true)) {
      this.chart.redraw();
    }
  },
  showDrillUpButton: function (name) {
    var series = this,
        backText = name || '< Back',
        buttonOptions = series.options.drillUpButton,
        attr,
        states;

    if (buttonOptions.text) {
      backText = buttonOptions.text;
    }

    if (!this.drillUpButton) {
      attr = buttonOptions.theme;
      states = attr && attr.states;
      this.drillUpButton = this.chart.renderer.button(backText, null, null, function () {
        series.drillUp();
      }, attr, states && states.hover, states && states.select).addClass('highcharts-drillup-button').attr({
        align: buttonOptions.position.align,
        zIndex: 7
      }).add().align(buttonOptions.position, false, buttonOptions.relativeTo || 'plotBox');
    } else {
      this.drillUpButton.placed = false;
      this.drillUpButton.attr({
        text: backText
      }).align();
    }
  },
  buildKDTree: noop$l,
  drawLegendSymbol: Highcharts.LegendSymbolMixin.drawRectangle,
  getExtremes: function () {
    // Get the extremes from the value data
    Series$m.prototype.getExtremes.call(this, this.colorValueData);
    this.valueMin = this.dataMin;
    this.valueMax = this.dataMax; // Get the extremes from the y data

    Series$m.prototype.getExtremes.call(this);
  },
  getExtremesFromAll: true,
  bindAxes: function () {
    var treeAxis = {
      endOnTick: false,
      gridLineWidth: 0,
      lineWidth: 0,
      min: 0,
      dataMin: 0,
      minPadding: 0,
      max: 100,
      dataMax: 100,
      maxPadding: 0,
      startOnTick: false,
      title: null,
      tickPositions: []
    };
    Series$m.prototype.bindAxes.call(this);
    Highcharts.extend(this.yAxis.options, treeAxis);
    Highcharts.extend(this.xAxis.options, treeAxis);
  },
  utils: {
    recursive: recursive,
    reduce: reduce$1 // Point class

  }
}, {
  getClassName: function () {
    var className = Highcharts.Point.prototype.getClassName.call(this),
        series = this.series,
        options = series.options; // Above the current level

    if (this.node.level <= series.nodeMap[series.rootNode].level) {
      className += ' highcharts-above-level';
    } else if (!this.node.isLeaf && !pick$V(options.interactByLeaf, !options.allowDrillToNode)) {
      className += ' highcharts-internal-node-interactive';
    } else if (!this.node.isLeaf) {
      className += ' highcharts-internal-node';
    }

    return className;
  },

  /**
   * A tree point is valid if it has han id too, assume it may be a parent
   * item.
   */
  isValid: function () {
    return this.id || isNumber$m(this.value);
  },
  setState: function (state) {
    Highcharts.Point.prototype.setState.call(this, state); // Graphic does not exist when point is not visible.

    if (this.graphic) {
      this.graphic.attr({
        zIndex: state === 'hover' ? 1 : 0
      });
    }
  },
  setVisible: seriesTypes$p.pie.prototype.pointClass.prototype.setVisible
});
/**
 * A `treemap` series. If the [type](#series.treemap.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 *
 * @type {Object}
 * @extends series,plotOptions.treemap
 * @excluding dataParser,dataURL,stack
 * @product highcharts
 * @apioption series.treemap
 */

/**
 * An array of data points for the series. For the `treemap` series
 * type, points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `value` options. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of objects with named values. The following snippet shows only a
 * few settings, see the complete options set below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.treemap.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         value: 9,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         value: 6,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type {Array<Object|Number>}
 * @extends series.heatmap.data
 * @excluding x,y
 * @sample {highcharts} highcharts/chart/reflow-true/
 *         Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/
 *         Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *         Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/
 *         Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/
 *         Config objects
 * @product highcharts
 * @apioption series.treemap.data
 */

/**
 * The value of the point, resulting in a relative area of the point
 * in the treemap.
 *
 * @type {Number}
 * @product highcharts
 * @apioption series.treemap.data.value
 */

/**
 * Serves a purpose only if a `colorAxis` object is defined in the chart
 * options. This value will decide which color the point gets from the
 * scale of the colorAxis.
 *
 * @type {Number}
 * @default undefined
 * @since 4.1.0
 * @product highcharts
 * @apioption series.treemap.data.colorValue
 */

/**
 * Only for treemap. Use this option to build a tree structure. The
 * value should be the id of the point which is the parent. If no points
 * has a matching id, or this option is undefined, then the parent will
 * be set to the root.
 *
 * @type {String}
 * @sample {highcharts} highcharts/point/parent/ Point parent
 * @sample {highcharts} highcharts/demo/treemap-with-levels/ Example where parent id is not matching
 * @default undefined
 * @since 4.1.0
 * @product highcharts
 * @apioption series.treemap.data.parent
 */

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 *
 * (c) 2014 Highsoft AS
 * Authors: Jon Arild Nygard / Oystein Moseng
 *
 * License: www.highcharts.com/license
 */

/**
 * Plugin for displaying a message when there is no data visible in chart.
 *
 * (c) 2010-2017 Highsoft AS
 * Author: Oystein Moseng
 *
 * License: www.highcharts.com/license
 */
var seriesTypes$q = Highcharts.seriesTypes,
    chartPrototype = Highcharts.Chart.prototype,
    defaultOptions$a = Highcharts.getOptions(),
    extend$v = Highcharts.extend,
    each$Z = Highcharts.each; // Add language option

extend$v(defaultOptions$a.lang, {
  /**
   * The text to display when the chart contains no data. Requires the
   * no-data module, see [noData](#noData).
   *
   * @type {String}
   * @default No data to display
   * @since 3.0.8
   * @product highcharts highstock
   * @sample highcharts/no-data-to-display/no-data-line
   *         No-data text
   * @apioption lang.noData
   */
  noData: 'No data to display'
}); // Add default display options for message

/**
 * Options for displaying a message like "No data to display".
 * This feature requires the file no-data-to-display.js to be loaded in the
 * page. The actual text to display is set in the lang.noData option.
 * @type {Object}
 *
 * @sample highcharts/no-data-to-display/no-data-line
 *         Line chart with no-data module
 * @sample highcharts/no-data-to-display/no-data-pie
 *         Pie chart with no-data module
 * @optionparent noData
 */

defaultOptions$a.noData = {
  /**
   * An object of additional SVG attributes for the no-data label.
   *
   * @type {Object}
   * @since 3.0.8
   * @product highcharts highstock
   * @apioption noData.attr
   */

  /**
   * Whether to insert the label as HTML, or as pseudo-HTML rendered with
   * SVG.
   *
   * @type {Boolean}
   * @default false
   * @since 4.1.10
   * @product highcharts highstock
   * @apioption noData.useHTML
   */

  /**
   * The position of the no-data label, relative to the plot area.
   *
   * @type {Object}
   * @default { "x": 0, "y": 0, "align": "center", "verticalAlign": "middle" }
   * @since 3.0.8
   */
  position: {
    /**
     * Horizontal offset of the label, in pixels.
     *
     * @type {Number}
     * @default 0
     * @product highcharts highstock
     */
    x: 0,

    /**
     * Vertical offset of the label, in pixels.
     *
     * @type {Number}
     * @default 0
     * @product highcharts highstock
     */
    y: 0,

    /**
     * Horizontal alignment of the label.
     *
     * @validvalue ["left", "center", "right"]
     * @type {String}
     * @default center
     */
    align: 'center',

    /**
     * Vertical alignment of the label.
     *
     * @validvalue ["top", "middle", "bottom"]
     * @type {String}
     * @default middle
     * @product highcharts highstock
     */
    verticalAlign: 'middle'
  }
}; // Define hasData function for non-cartesian seris. Returns true if the series
// has points at all.

each$Z(['bubble', 'gauge', 'heatmap', 'pie', 'sankey', 'treemap', 'waterfall'], function (type) {
  if (seriesTypes$q[type]) {
    seriesTypes$q[type].prototype.hasData = function () {
      return !!this.points.length; // != 0
    };
  }
});
/**
 * Define hasData functions for series. These return true if there are data
 * points on this series within the plot area.
 */

Highcharts.Series.prototype.hasData = function () {
  return this.visible && this.dataMax !== undefined && this.dataMin !== undefined // #3703
  ;
};
/**
 * Display a no-data message.
 *
 * @param {String} str An optional message to show in place of the default one
 */


chartPrototype.showNoData = function (str) {
  var chart = this,
      options = chart.options,
      text = str || options && options.lang.noData,
      noDataOptions = options && options.noData;

  if (!chart.noDataLabel && chart.renderer) {
    chart.noDataLabel = chart.renderer.label(text, 0, 0, null, null, null, noDataOptions.useHTML, null, 'no-data');
    chart.noDataLabel.add();
    chart.noDataLabel.align(extend$v(chart.noDataLabel.getBBox(), noDataOptions.position), false, 'plotBox');
  }
};
/**
 * Hide no-data message
 */


chartPrototype.hideNoData = function () {
  var chart = this;

  if (chart.noDataLabel) {
    chart.noDataLabel = chart.noDataLabel.destroy();
  }
};
/**
 * Returns true if there are data points within the plot area now
 */


chartPrototype.hasData = function () {
  var chart = this,
      series = chart.series || [],
      i = series.length;

  while (i--) {
    if (series[i].hasData() && !series[i].options.isInternal) {
      return true;
    }
  }

  return chart.loadingShown; // #4588
};
/**
 * Add event listener to handle automatic show or hide no-data message
 */


Highcharts.addEvent(Highcharts.Chart, 'render', function handleNoData() {
  if (this.hasData()) {
    this.hideNoData();
  } else {
    this.showNoData();
  }
});

/**
 * @license @product.name@ JS v@product.version@ (@product.date@)
 * Plugin for displaying a message when there is no data visible in chart.
 *
 * (c) 2010-2017 Highsoft AS
 * Author: Oystein Moseng
 *
 * License: www.highcharts.com/license
 */

/**
@license
Vaadin Charts
Copyright (C) 2015 Vaadin Ltd
This program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).
See the file LICENSE.md distributed with this software for more information about licensing.
See <a href="https://vaadin.com/license/cval-3">the website</a> for the complete license.
*/
/** @private */
// eslint-disable-next-line no-unused-vars

const ChartDeepMerger = (() => class {
  static __isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
  }

  static __deepMerge(target, source) {
    if (this.__isObject(source) && this.__isObject(target)) {
      for (const key in source) {
        if (this.__isObject(source[key])) {
          if (!target[key]) {
            Object.assign(target, {
              [key]: {}
            });
          }

          this.__deepMerge(target[key], source[key]);
        } else {
          Object.assign(target, {
            [key]: source[key]
          });
        }
      }
    }

    return target;
  }

})();

if (Highcharts) {
  ['exportChart', 'exportChartLocal'].forEach(methodName => {
    Highcharts.wrap(Highcharts.Chart.prototype, methodName, function (proceed) {
      Highcharts.fireEvent(this, 'beforeExport');
      const result = proceed.apply(this, Array.prototype.slice.call(arguments, 1));
      Highcharts.fireEvent(this, 'afterExport');
      return result;
    });
  });
}

if (Highcharts) {
  Highcharts.wrap(Highcharts.seriesTypes.column.prototype, 'plotGroup', function (proceed, prop, name, visibility, zIndex, parent) {
    if (this.chart.is3d() && this[prop]) {
      delete this[prop];
    }

    return proceed.apply(this, Array.prototype.slice.call(arguments, 1));
  });
}

if (!PolymerElement) {
  throw new Error(`Unexpected Polymer version ${Polymer.version} is used, expected v2.0.0 or later.`);
}
/**
 * `<vaadin-chart>` is a Web Component for creating high quality charts.
 *
 * ### Quick Start
 *
 * #### Polymer 2 App
 *
 * 1. Create a Polymer application using [Polymer CLI](https://www.polymer-project.org/2.0/docs/tools/polymer-cli)
 * ```
 * mkdir my-app
 * cd my-app
 * polymer init
 * select `polymer-2-application`
 * ```
 * 1. Install Vaadin Charts
 * ```
 * bower install --save vaadin-charts#6.2.2
 * ```
 * 1. Import `<vaadin-chart>` to your app
 * Edit the file `src/my-app/my-app.html` and add the following snipped before the `<dom-module>` tag
 * ```html
 * <link rel="import" href="../../bower_components/vaadin-charts/vaadin-chart.html">
 * ```
 * 1. Add your first `<vaadin-chart>`
 * Also in `my-app.html` add the following snippet before the `</template>` closing tag
 * ```html
 * <vaadin-chart></vaadin-chart>
 * ```
 * 1. Run your app with:
 * ```
 * polymer serve --open
 * ```
 *
 * #### Polymer 3 App
 *
 * * 1. Create a Polymer application using [Polymer CLI](https://www.polymer-project.org/3.0/docs/tools/polymer-cli)
 * ```
 * mkdir my-app
 * cd my-app
 * polymer init
 * select `polymer-3-application`
 * ```
 * 1. Install Vaadin Charts
 * ```
 * npm i @vaadin/vaadin-charts@6.2.2 --save
 * ```
 * 1. Import `<vaadin-chart>` to your app
 * Edit the file `src/my-app/my-app.js` and add the following snipped on the top, after the first `import` declaration
 * ```js
 * import '@vaadin/vaadin-charts';
 * ```
 * 1. Add your first `<vaadin-chart>`
 * Also in `my-app.js`, at the template getter, add the following snippet after the `</h2>` closing tag
 * ```html
 * <vaadin-chart></vaadin-chart>
 * ```
 * 1. Run your app with:
 * ```
 * polymer serve --npm --open
 * ```
 *
 * Congratulations! You have your first Vaadin Chart setup.
 *
 * ### Basic use
 *
 * Now that we covered the basic steps to create an empty chart, let us show how you can configure it.
 *
 * There are two ways of configuring your `<vaadin-chart>` element: **HTML API**, **JS API** and **JSON API**.
 * Note that you can make use of all APIs in your element.
 *
 * #### Configuring your chart using HTML API
 *
 * `vaadin-chart` has a set of attributes to make it easier for you to customize your chart.
 * Using as a base the project created with in Quick Start:
 *
 * ```html
 *  <vaadin-chart title="The chart title" subtitle="The chart subtitle">
 *    <vaadin-chart-series
 *          type="column"
 *          title="The series title"
 *          values="[10,20,30]">
 *    </vaadin-chart-series>
 *  </vaadin-chart>
 * ```
 *
 * > Note that while you can set type for each series individually, for some types, such as `'bar'`, `'gauge'` and `'solidgauge'`, you
 * > have to set it as the default series type on `<vaadin-chart>` in order to work properly.
 *
 * #### Configuring your chart using JS API
 *
 * Using as a base the project created with in Quick Start
 *
 * Do the following changes in `my-app.html`
 *
 * 1. Set and id for the `<vaadin-chart>` in the template
 * ```html
 *     <vaadin-chart id="mychart"></vaadin-chart>
 * ```
 * 1. Add a function that uses `configuration` property (JS Api) to set chart title, categories and data
 * ```
 * initChartWithJSApi() {
 *     Polymer.RenderStatus.beforeNextRender(this, () => {
 *        const configuration = this.$.mychart.configuration;
 *        configuration.setTitle({ text: 'The chart title' });
 *        // By default there is one x axis, it is referenced by configuration.xAxis[0].
 *        configuration.xAxis[0].setCategories(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']);
 *        configuration.addSeries({
 *            type: 'column',
 *            data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4]
 *        });
 *     });
 * }
 * ```
 * 1. Call that function from connectedCallback (when the element is added to a document)
 * ```
 * connectedCallback() {
 *     super.connectedCallback();
 *     this.initChartWithJSApi();
 * }
 * ```
 * 1. And finally run your app with:
 * ```
 * polymer serve --open
 * ```
 *
 *
 * #### Configuring your chart using JS JSON API
 *
 * JS JSON API is a simple alternative to the JS API.
 *
 * Using as a base the project created with in Quick Start
 *
 * Do the following changes in `my-app.html`
 *
 * 1. Set and id for the `<vaadin-chart>` in the template
 * ```html
 *     <vaadin-chart id="mychart"></vaadin-chart>
 * ```
 * 1. Add a function that uses `update` method (JS JSON Api) to set chart title, categories and data
 * ```
 * initChartWithJSJSONApi() {
 *     this.$.mychart.update({
 *       title: {
 *         text: 'The chart title'
 *       },
 *       subtitle: {
 *         text: 'Subtitle'
 *       },
 *       xAxis: {
 *         categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
 *       },
 *       series: [{
 *         type: 'column',
 *         data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4]
 *       }]
 *     });
 * }
 * ```
 * 1. Call that function from connectedCallback (when the element is added to a document)
 * ```
 * connectedCallback() {
 *     super.connectedCallback();
 *     this.initChartWithJSJSONApi();
 * }
 * ```
 * 1. And finally run your app with:
 * ```
 * polymer serve --open
 * ```
 *
 * It should be noted that chart style customization cannot be done via the JS or JSON API.
 * Styling properties in the JSON configuration will be ignored. The following section discusses chart styling.
 *
 *
 * ### CSS Styling
 * Chart appearance is primarily controlled by CSS style rules.
 * A comprehensive list of the supported style classes can be found at
 * https://www.highcharts.com/docs/chart-design-and-style/style-by-css
 *
 *
 * ### Steps for styling a chart
 *
 * 1. Create a theme file (for example `shared-styles.html`). The theme's dom-module must declare `theme-for=vaadin-chart`.
 * 2. Import `vaadin-chart-default-theme.html` and declare `include="vaadin-chart-default-theme"`
 * on the theme module's style tag to customize Chart's default theme. If there are multiple theme
 * modules *only one* of them should declare this `include`.
 * 3. Specify the desired CSS rules in the theme file.
 * 4. If multiple charts are present, each one can be specifically targeted using the host selector e.g `:host(.my-chart-class)`.
 * 5. Import the theme file.
 *
 *
 * ### Example: Two Charts with a Red Title but only one with a Blue Subtitle
 *
 * ```
 * <link rel="import" href="shared-styles.html">
 * ...
 * <vaadin-chart title="Red Title" subtitle="Not Styled">
 *   <vaadin-chart-series values="[19,12,9,24,5]"></vaadin-chart-series>
 * </vaadin-chart>
 *
 * <vaadin-chart class="blue-subtitle" title="Red Title" subtitle="Blue Subtitle">
 *   <vaadin-chart-series values="[19,12,9,24,5]"></vaadin-chart-series>
 * </vaadin-chart>
 * ```
 *
 * shared-styles.html
 *
 * ```
 * <link rel="import" href="../bower_components/vaadin-charts/theme/vaadin-chart-default-theme.html">
 *
 * <dom-module id="css-style-example" theme-for="vaadin-chart">
 *    <template>
 *      <style include="vaadin-chart-default-theme">
 *        .highcharts-title {
 *          fill: red;
 *          font-size: xx-large;
 *        }
 *
 *        :host(.blue-subtitle) .highcharts-subtitle {
 *          fill: blue;
 *        }
 *      </style>
 *    </template>
 * </dom-module>
 * ```
 *
 * ### Setting colors
 *
 * Although charts can be styled as described above, there is a simpler way for setting colors.
 * Colors can be set using CSS custom properties `--vaadin-charts-color-{n}` (where `n` goes from `0 - 9`).
 *
 * For example `--vaadin-charts-color-0` sets the color of the first series on a chart.
 *
 * ### Validating your License
 * After one day using Vaadin Charts in a development environment you will see a pop-up that asks you
 * to validate your license by signing in to vaadin.com.
 *
 * @memberof Vaadin
 * @demo demo/index.html
 */


class ChartElement extends ElementMixin$1(ThemableMixin(PolymerElement)) {
  static get template() {
    return html$1`
    <style>
      :host {
        display: block;
        width: 100%;
        overflow: hidden;
      }

      :host([hidden]) {
        display: none !important;
      }
    </style>
    <div id="chart"></div>
    <slot id="slot"></slot>
`;
  }

  static get is() {
    return 'vaadin-chart';
  }

  static get version() {
    return '6.2.2';
  }

  static get properties() {
    return {
      /**
       * Configuration object that exposes the JS Api to configure the chart.
       *
       * Most important methods are:
       * - `addSeries (Object options, [Boolean redraw], [Mixed animation])`
       * - `addAxis (Object options, [Boolean isX], [Boolean redraw], [Mixed animation])`
       * - `setTitle (Object title, object subtitle, Boolean redraw)`
       *
       * Most important properties are:
       * - `configuration.series`: An array of the chart's series. Detailed API for Series object is
       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Series)
       * - `configuration.xAxis`: An array of the chart's x axes. Detailed API for Axis object is
       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)
       * - `configuration.yAxis`: An array of the chart's y axes. Detailed API for Axis object is
       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)
       * - `configuration.title`: The chart title.
       *
       * For detailed documentation of available API check the [API site](http://api.highcharts.com/class-reference/classes.list)
       * @readonly
       * @public
       * @type {Object}
       */
      configuration: Object,

      /**
       * If categories are present names are used instead of numbers for the category axis.
       * The format of categories can be an `Array` with a list of categories, such as `['2010', '2011', '2012']`
       * or a mapping `Object`, like `{0:'1',9:'Target (10)', 15: 'Max'}`.
       */
      categories: {
        type: Object,
        reflectToAttribute: true,
        observer: '__updateCategories'
      },

      /**
       * Category-axis maximum value. Defaults to `undefined`.
       */
      categoryMax: {
        type: Number,
        observer: '__updateCategoryMax',
        reflectToAttribute: true
      },

      /**
       * Category-axis minimum value. Defaults to `undefined`.
       */
      categoryMin: {
        type: Number,
        observer: '__updateCategoryMin',
        reflectToAttribute: true
      },

      /**
       * The position of the category axis. Acceptable values are `left`, `right`, `top` and `bottom`
       * except for bar charts which only accept `left` and `right`.
       * With the default value, charts appear as though they have `category-position="bottom"`
       * except for bar charts that appear as though they have `category-position="left"`.
       *
       * Defaults to `undefined`
       */
      categoryPosition: {
        type: String,
        observer: '__updateCategoryPosition',
        reflectToAttribute: true
      },

      /**
       * Specifies whether to hide legend or show.
       * Legend configuration can be set up via additionalOptions property
       */
      noLegend: {
        type: Boolean,
        observer: '__hideLegend',
        reflectToAttribute: true
      },

      /**
       * Specifies how series are stacked on top of each other.
       * Possible values are null, "normal" or "percent".
       * If "stack" property is not defined on the vaadin-chart-series elements, then series will be put into
       * the default stack.
       */
      stacking: {
        type: String,
        observer: '__stackingObserver',
        reflectToAttribute: true
      },

      /**
       * Specifies whether the chart is a normal chart or a timeline chart.
       */
      timeline: {
        type: Boolean,
        reflectToAttribute: true
      },

      /**
       * Represents the title of the chart.
       */
      title: {
        type: String,
        observer: '__updateTitle',
        reflectToAttribute: true
      },

      /**
       * Whether or not to show tooltip when hovering data points.
       */
      tooltip: {
        type: Boolean,
        observer: '__tooltipObserver',
        reflectToAttribute: true
      },

      /**
       * Sets the default series type of the chart.
       * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type.
       */
      type: {
        type: String,
        observer: '__updateType',
        reflectToAttribute: true
      },

      /**
       * Represents the subtitle of the chart.
       */
      subtitle: {
        type: String,
        observer: '__updateSubtitle',
        reflectToAttribute: true
      },

      /**
       * Specifies whether to show chart in 3 or in 2 dimensions.
       * Some display angles are added by default to the "chart.options3d" (`{alpha: 15, beta: 15, depth: 50}`).
       * 3D display options can be modified via `additionalOptions`.
       * The thickness of a Pie chart can be set on `additionalOptions` through `plotOptions.pie.depth`.
       * 3D is supported by Bar, Column, Pie and Scatter3D charts.
       * More info available at [Highcharts](https://www.highcharts.com/docs/chart-concepts/3d-charts).
       */
      chart3d: {
        type: Boolean,
        observer: '__chart3dObserver',
        reflectToAttribute: true
      },

      /**
       * Specifies the message displayed on a chart without displayable data.
       */
      emptyText: {
        type: String,
        value: ' ',
        observer: '__emptyTextObserver',
        reflectToAttribute: true
      },

      /**
       * Represents additional JSON configuration.
       */
      additionalOptions: {
        type: Object,
        reflectToAttribute: true
      },

      /**
       * When present, cartesian charts like line, spline, area and column are transformed
       * into the polar coordinate system.
       */
      polar: {
        type: Boolean,
        reflectToAttribute: true,
        observer: '__polarObserver'
      }
    };
  }

  static get observers() {
    return ['__updateAdditionalOptions(additionalOptions.*)'];
  }

  constructor() {
    super();
    /**
     * List of properties that will always be copied from the chart element to the container div
     **/

    this._copyStyleProperties = ['flex', '-webkit-flex', '-ms-flex'];
    this._baseConfig = {
      credits: {
        enabled: false
      },
      exporting: {
        enabled: false
      },
      title: {
        text: null
      },
      series: [],
      xAxis: {},
      yAxis: {
        axisGenerated: true
      }
    };
    this._baseChart3d = {
      enabled: true,
      alpha: 15,
      beta: 15,
      depth: 50
    };
    this.__mutationCallback = this.__mutationCallback.bind(this);
  }
  /** @private */


  connectedCallback() {
    super.connectedCallback();

    this.__updateStyles();

    beforeNextRender(this, () => {
      // Detect if the chart had already been initialized. This might happen in
      // environments where the chart is lazily attached (e.g Grid).
      if (this.configuration) {
        this.__reflow();

        return;
      }

      const options = Object.assign({}, this.options, this._jsonConfigurationBuffer);
      this._jsonConfigurationBuffer = null;

      this.__initChart(options);

      this.__addChildObserver();

      const config = {
        attributes: true,
        characterData: true
      };
      this.__mutationObserver = new MutationObserver(this.__mutationCallback);

      this.__mutationObserver.observe(this, config);
    });
  }

  get options() {
    const options = Object.assign({}, this._baseConfig);

    ChartDeepMerger.__deepMerge(options, this.additionalOptions);

    if (this.type) {
      options.chart = options.chart || {};
      options.chart.type = this.type;
    }

    if (this.polar) {
      options.chart = options.chart || {};
      options.chart.polar = true;
    }

    if (this.title) {
      options.title = {
        text: this.title
      };
    }

    if (!options.tooltip) {
      // Workaround for highcharts#7398 to make updating tooltip works
      options.tooltip = {};

      if (!this.tooltip) {
        options.tooltip.enabled = false;
      }
    }

    if (this.subtitle) {
      options.subtitle = {
        text: this.subtitle
      };
    }

    if (this.categories) {
      options.xAxis = options.xAxis || {};

      if (Array.isArray(options.xAxis)) {
        // Set categories on first x axis
        options.xAxis[0].categories = this.categories;
      } else {
        options.xAxis.categories = this.categories;
      }
    }

    if (isFinite(this.categoryMin)) {
      options.xAxis = options.xAxis || {};

      if (Array.isArray(options.xAxis)) {
        // Set category-min on first x axis
        options.xAxis[0].min = this.categoryMin;
      } else {
        options.xAxis.min = this.categoryMin;
      }
    }

    if (isFinite(this.categoryMax)) {
      options.xAxis = options.xAxis || {};

      if (Array.isArray(options.xAxis)) {
        // Set category-max on first x axis
        options.xAxis[0].max = this.categoryMax;
      } else {
        options.xAxis.max = this.categoryMax;
      }
    }

    if (this.noLegend) {
      options.legend = {
        enabled: false
      };
    }

    if (this.emptyText) {
      options.lang = options.lang || {};
      options.lang.noData = this.emptyText;
    }

    if (this.categoryPosition) {
      options.chart = options.chart || {};
      options.chart.inverted = this.__shouldInvert();

      if (Array.isArray(options.xAxis)) {
        options.xAxis.forEach(e => e.opposite = this.__shouldFlipOpposite());
      } else if (options.xAxis) {
        options.xAxis.opposite = this.__shouldFlipOpposite();
      }
    }

    if (this.stacking) {
      options.plotOptions = options.plotOptions || {};
      options.plotOptions.series = options.plotOptions.series || {};
      options.plotOptions.series.stacking = this.stacking;
    }

    if (this.chart3d) {
      options.chart = options.chart || {};
      options.chart.options3d = Object.assign({}, this._baseChart3d, options.chart.options3d);
    }

    return options;
  }
  /**
   *  Name of the chart events to add to the configuration and its corresponding event for the chart element
   **/


  get __chartEventNames() {
    return {
      /**
       *
       * @event chart-add-series  Fired when a new series is added
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      addSeries: 'chart-add-series',

      /**
       *
       * @event chart-after-export  Fired after a chart is exported
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      afterExport: 'chart-after-export',

      /**
       *
       * @event chart-after-print  Fired after a chart is printed
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      afterPrint: 'chart-after-print',

      /**
       *
       * @event chart-before-export  Fired before a chart is exported
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      beforeExport: 'chart-before-export',

      /**
       *
       * @event chart-before-print  Fired before a chart is printed
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      beforePrint: 'chart-before-print',

      /**
       *
       * @event chart-click  Fired when clicking on the plot background
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      click: 'chart-click',

      /**
       *
       * @event chart-drilldown  Fired when drilldown point is clicked
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      drilldown: 'chart-drilldown',

      /**
       *
       * @event chart-drillup  Fired when drilling up from a drilldown series
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      drillup: 'chart-drillup',

      /**
       *
       * @event chart-drillupall  Fired after all the series  has been drilled up
       *                          if chart has multiple drilldown series
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      drillupall: 'chart-drillupall',

      /**
       *
       * @event chart-load  Fired when the chart is finished loading
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      load: 'chart-load',

      /**
       *
       * @event chart-redraw  Fired when the chart is redraw. Can be called after a `Chart.configuration.redraw()`
       *                      or after an axis, series or point is modified with the `redraw` option set to `true`
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      redraw: 'chart-redraw',

      /**
       *
       * @event chart-selection  Fired when an area of the chart has been selected
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      selection: 'chart-selection'
    };
  }
  /**
   *  Name of the series events to add to the configuration and its corresponding event for the chart element
   **/


  get __seriesEventNames() {
    return {
      /**
       *
       * @event series-after-animate  Fired when the series has finished its initial animation
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      afterAnimate: 'series-after-animate',

      /**
       *
       * @event series-checkbox-click  Fired when the checkbox next to the series' name in the legend is clicked
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      checkboxClick: 'series-checkbox-click',

      /**
       *
       * @event series-click  Fired when the series is clicked
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      click: 'series-click',

      /**
       *
       * @event series-hide  Fired when the series is hidden after chart generation time
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      hide: 'series-hide',

      /**
       *
       * @event series-legend-item-click  Fired when the legend item belonging to the series is clicked
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      legendItemClick: 'series-legend-item-click',

      /**
       *
       * @event series-mouse-out  Fired when the mouses leave the graph
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      mouseOut: 'series-mouse-out',

      /**
       *
       * @event series-mouse-over  Fired when the mouse enters the graph
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      mouseOver: 'series-mouse-over',

      /**
       *
       * @event series-show  Fired when the series is show after chart generation time
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      show: 'series-show'
    };
  }
  /**
   *  Name of the point events to add to the configuration and its corresponding event for the chart element
   **/


  get __pointEventNames() {
    return {
      /**
       *
       * @event point-click  Fired when the point is clicked
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      click: 'point-click',

      /**
       *
       * @event point-legend-item-click  Fired when the legend item belonging to the point is clicked
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      legendItemClick: 'point-legend-item-click',

      /**
       *
       * @event point-mouse-out  Fired when the mouse leaves the area close to the point
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      mouseOut: 'point-mouse-out',

      /**
       *
       * @event point-mouse-over  Fired when the mouse enters the area close to the point
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      mouseOver: 'point-mouse-over',

      /**
       *
       * @event point-remove  Fired when the point is removed from the series
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      remove: 'point-remove',

      /**
       *
       * @event point-select  Fired when the point is selected etheir programmatically or by clicking on the point
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      select: 'point-select',

      /**
       *
       * @event point-unselect  Fired when the point is unselected etheir programmatically or by clicking on the point
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      unselect: 'point-unselect',

      /**
       *
       * @event point-update  Fired when the point is updated programmatically through `.update()` method
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      update: 'point-update'
    };
  }

  get __xAxesEventNames() {
    return {
      /**
       *
       * @event xaxes-extremes-set  Fired when when the minimum and maximum is set for the x axis
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} axis Point object where the event was sent from
       */
      afterSetExtremes: 'xaxes-extremes-set'
    };
  }

  get __yAxesEventNames() {
    return {
      /**
       *
       * @event yaxes-extremes-set  Fired when when the minimum and maximum is set for the y axis
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} axis Point object where the event was sent from
       */
      afterSetExtremes: 'yaxes-extremes-set'
    };
  }

  __reflow() {
    if (!this.configuration) {
      return;
    }

    beforeNextRender(this, () => {
      this.configuration.reflow();
    });
  }

  __mutationCallback() {
    const {
      height: componentHeight
    } = this.getBoundingClientRect();
    const {
      chartHeight
    } = this.configuration;

    if (componentHeight !== chartHeight) {
      this.__reflow();
    }
  }

  __addChildObserver() {
    beforeNextRender(this, () => {
      this._childObserver = new FlattenedNodesObserver(this.$.slot, info => {
        this.__addSeries(info.addedNodes.filter(this.__filterSeriesNodes));

        this.__cleanupAfterSeriesRemoved(info.removedNodes.filter(this.__filterSeriesNodes));
      });
    });
  }

  __filterSeriesNodes(node) {
    return node.nodeType === Node.ELEMENT_NODE && node instanceof ChartSeriesElement;
  }

  __addSeries(series) {
    if (this.__isSeriesEmpty(series)) {
      return;
    }

    const seriesNodes = Array.from(this.childNodes).filter(this.__filterSeriesNodes);
    const yAxes = this.configuration.yAxis.reduce((acc, axis, index) => {
      acc[axis.options.id || index] = axis;
      return acc;
    }, {});

    for (let i = 0, len = series.length; i < len; i++) {
      const seriesElement = series[i];
      const {
        yAxis: unit,
        yAxisValueMin: valueMin,
        yAxisValueMax: valueMax
      } = seriesElement.options;
      const idxOnChildList = seriesNodes.indexOf(seriesElement);

      if (!unit && !this.configuration.yAxis.some(e => e.userOptions.id === undefined)) {
        yAxes[unit] = this.__addAxis({
          axisGenerated: true
        });
      } else if (unit && !yAxes[unit]) {
        yAxes[unit] = this.__addAxis({
          id: unit,
          title: {
            text: unit
          },
          axisGenerated: true
        });
      }

      if (isFinite(valueMin)) {
        this.__setYAxisProps(yAxes, unit, {
          min: valueMin
        });
      }

      if (isFinite(valueMax)) {
        this.__setYAxisProps(yAxes, unit, {
          max: valueMax
        });
      }

      const seriesConfiguration = this.__updateOrAddSeriesInstance(seriesElement.options, idxOnChildList);

      seriesElement.setSeries(seriesConfiguration);
    }

    this.__removeAxisIfEmpty();
  }

  __setYAxisProps(yAxes, yAxisId, props) {
    if (yAxisId) {
      yAxes[yAxisId].update(props);
    } else {
      this.configuration.yAxis[0].update(props);
    }
  }

  __isSeriesEmpty(series) {
    return series === null || series.length === 0;
  }

  __cleanupAfterSeriesRemoved(series) {
    if (this.__isSeriesEmpty(series)) {
      return;
    }

    this.__removeAxisIfEmpty(); // Best effort to make chart display custom empty-text messages when series are removed.
    // This is needed because Highcharts currently doesn't react. A condition not catered for is
    // when all points are removed from all series without removing any series.


    const isEmpty = this.configuration.series.length === 0 || this.configuration.series.map(e => e.data.length === 0).reduce((e1, e2) => e1 && e2, true);

    if (isEmpty) {
      this.configuration.hideNoData();
      this.configuration.showNoData(this.emptyText);
    }
  }

  __initChart(options) {
    this.__initEventsListeners(options); // Workaround for https://github.com/highcharts/highcharts/issues/7523


    this.__ensureObjectPath(options, 'drilldown.activeDataLabelStyle');

    if (this.timeline) {
      this.configuration = Highcharts.stockChart(this.$.chart, options);
    } else {
      this.configuration = Highcharts.chart(this.$.chart, options);
    }
  }
  /** @private */


  disconnectedCallback() {
    super.disconnectedCallback();
    this.__mutationObserver && this.__mutationObserver.disconnect();
    this._childObserver && this._childObserver.disconnect();
  }
  /**
   * Search for axis with given `id`.
   *
   * @param {String} id contains the id that will be searched
   * @param {Boolean} isXAxis indicates if it will remove x or y axes. Defaults to `false`.
   */


  __getAxis(id, isXAxis) {
    id = Number.parseInt(id) || id;

    if (this.configuration) {
      return (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).find(axis => axis.options.id === id);
    }
  }
  /**
   * Add an axis with given options
   *
   * @param {Object} options axis options
   * @param {Boolean} isXAxis indicates if axis is X (`true`) or Y (`false`). Defaults to `false`.
   */


  __addAxis(options, isXAxis) {
    if (this.configuration) {
      this.__createEventListeners(isXAxis ? this.__xAxesEventNames : this.__yAxesEventNames, options, 'events', 'axis');

      return this.configuration.addAxis(options, isXAxis);
    }
  }
  /**
   * Iterates over axes (y or x) and removes whenever it doesn't contain any series and was created for unit
   *
   * @param {Boolean}  isXAxis indicates if it will remove x or y axes. Defaults to `false`.
   */


  __removeAxisIfEmpty(isXAxis) {
    if (this.configuration) {
      (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).forEach(axis => {
        if (axis.userOptions.axisGenerated && axis.series.length === 0) {
          axis.remove();
        }
      });
    }
  }
  /**
   * Update the chart configuration.
   * This JSON API provides a simple single-argument alternative to the configuration property.
   *
   * Styling properties specified in this configuration will be ignored. To learn about chart styling
   * please see the CSS Styling section above.
   *
   * @param {Object} jsonConfiguration Object chart configuration. Most important properties are:
   *
   * - chart `Object` with options regarding the chart area and plot area as well as general chart options.
   *    Detailed API for chart object is available in [API Site](http://api.highcharts.com/highcharts/chart)
   * - credits `Object` with options regarding the chart area and plot area as well as general chart options.
   *    Detailed API for credits object is available in [API Site](http://api.highcharts.com/highcharts/credits)
   * - labels `Object[]` with HTML labels that can be positioned anywhere in the chart area
   *    Detailed API for labels object is available in [API Site](http://api.highcharts.com/highcharts/labels)
   * - plotOptions `Object` wrapper for config objects for each series type.
   *    Detailed API for plotOptions object is available in [API Site](http://api.highcharts.com/highcharts/plotOptions)
   * - series `Object[]` the actual series to append to the chart.
   *    Detailed API for series object is available in [API Site](http://api.highcharts.com/highcharts/series)
   * - subtitle `Object` the chart's subtitle.
   *    Detailed API for subtitle object is available in [API Site](http://api.highcharts.com/highcharts/subtitle)
   * - title `Object` the chart's main title.
   *    Detailed API for title object is available in [API Site](http://api.highcharts.com/highcharts/title)
   * - tooltip `Object` Options for the tooltip that appears when the user hovers over a series or point.
   *    Detailed API for tooltip object is available in [API Site](http://api.highcharts.com/highcharts/tooltip)
   * - xAxis `Object[]` The X axis or category axis. Normally this is the horizontal axis.
   *    Detailed API for xAxis object is available in [API Site](http://api.highcharts.com/highcharts/xAxis)
   * - yAxis `Object[]` The Y axis or value axis. Normally this is the vertical axis.
   *    Detailed API for yAxis object is available in [API Site](http://api.highcharts.com/highcharts/yAxis)
   * - zAxis `Object[]` The Z axis or depth axis for 3D plots.
   *    Detailed API for zAxis object is available in [API Site](http://api.highcharts.com/highcharts/zAxis)
   *
   * @param {Boolean} resetConfiguration Optional boolean that should be set to true if no other chart configuration was set before or
   *    if existing configuration should be discarded.
   */


  update(jsonConfiguration, resetConfiguration) {
    if (resetConfiguration || !this._jsonConfigurationBuffer) {
      this._jsonConfigurationBuffer = {};
    }

    const configCopy = ChartDeepMerger.__deepMerge({}, jsonConfiguration);

    this.__inflateFunctions(configCopy);

    this._jsonConfigurationBuffer = this.__makeConfigurationBuffer(this._jsonConfigurationBuffer, configCopy);
    beforeNextRender(this, () => {
      if (!this.configuration || !this._jsonConfigurationBuffer) {
        return;
      }

      if (resetConfiguration) {
        const initialOptions = Object.assign({}, this.options, this._jsonConfigurationBuffer);

        this.__initChart(initialOptions);

        this._jsonConfigurationBuffer = null;
        return;
      }

      this.configuration.update(this._jsonConfigurationBuffer);

      if (this._jsonConfigurationBuffer.credits) {
        this.__updateOrAddCredits(this._jsonConfigurationBuffer.credits);
      }

      if (this._jsonConfigurationBuffer.xAxis) {
        this.__updateOrAddAxes(this._jsonConfigurationBuffer.xAxis, true);
      }

      if (this._jsonConfigurationBuffer.yAxis) {
        this.__updateOrAddAxes(this._jsonConfigurationBuffer.yAxis, false);
      }

      if (this._jsonConfigurationBuffer.series) {
        this.__updateOrAddSeries(this._jsonConfigurationBuffer.series);
      }

      this._jsonConfigurationBuffer = null;
    });
  }

  __makeConfigurationBuffer(target, source) {
    const _source = Highcharts.merge(source);

    const _target = Highcharts.merge(target);

    this.__mergeConfigurationArray(_target, _source, 'series');

    this.__mergeConfigurationArray(_target, _source, 'xAxis');

    this.__mergeConfigurationArray(_target, _source, 'yAxis');

    return Highcharts.merge(_target, _source);
  }

  __mergeConfigurationArray(target, configuration, entry) {
    if (!configuration || !configuration[entry] || !Array.isArray(configuration[entry])) {
      return;
    }

    if (!target[entry]) {
      target[entry] = Array.from(configuration[entry]);
      return;
    }

    const maxLength = Math.max(target[entry].length, configuration[entry].length);

    for (let i = 0; i < maxLength; i++) {
      target[entry][i] = Highcharts.merge(target[entry][i], configuration[entry][i]);
    }

    delete configuration[entry];
  }

  __inflateFunctions(jsonConfiguration) {
    for (const attr in jsonConfiguration) {
      if (jsonConfiguration.hasOwnProperty(attr)) {
        const targetProperty = jsonConfiguration[attr];

        if (attr.indexOf('_fn_') === 0 && (typeof targetProperty === 'string' || targetProperty instanceof String)) {
          try {
            jsonConfiguration[attr.substr(4)] = eval('(' + targetProperty + ')');
          } catch (e) {
            jsonConfiguration[attr.substr(4)] = eval('(function(){' + targetProperty + '})');
          }

          delete jsonConfiguration[attr];
        } else if (targetProperty instanceof Object) {
          this.__inflateFunctions(targetProperty);
        }
      }
    }
  }

  __initEventsListeners(configuration) {
    this.__initChartEventsListeners(configuration);

    this.__initSeriesEventsListeners(configuration);

    this.__initPointsEventsListeners(configuration);

    this.__initAxisEventsListeners(configuration, true);

    this.__initAxisEventsListeners(configuration, false);
  }

  __initChartEventsListeners(configuration) {
    this.__createEventListeners(this.__chartEventNames, configuration, 'chart.events', 'chart');
  }

  __initSeriesEventsListeners(configuration) {
    this.__createEventListeners(this.__seriesEventNames, configuration, 'plotOptions.series.events', 'series');
  }

  __initPointsEventsListeners(configuration) {
    this.__createEventListeners(this.__pointEventNames, configuration, 'plotOptions.series.point.events', 'point');
  }

  __initAxisEventsListeners(configuration, isXAxis) {
    let eventNames, axes;

    if (isXAxis) {
      eventNames = this.__xAxesEventNames;
      axes = configuration.xAxis;
    } else {
      eventNames = this.__yAxesEventNames;
      axes = configuration.yAxis;
    }

    if (Array.isArray(axes)) {
      axes.forEach(axis => this.__createEventListeners(eventNames, axis, 'events', 'axis'));
    } else {
      this.__createEventListeners(eventNames, axes, 'events', 'axis');
    }
  }

  __createEventListeners(eventList, configuration, pathToAdd, eventType) {
    const self = this;

    const eventObject = this.__ensureObjectPath(configuration, pathToAdd);

    for (let keys = Object.keys(eventList), i = 0; i < keys.length; i++) {
      const key = keys[i];

      if (!eventObject[key]) {
        const chart = this;

        eventObject[key] = function (event) {
          const customEvent = {
            bubbles: false,
            composed: true,
            detail: {
              originalEvent: event,
              [eventType]: this
            }
          };

          if (event.type === 'afterSetExtremes') {
            if (event.min == null || event.max == null) {
              return;
            }
          } // Workaround for vaadin-charts-flow because of https://github.com/vaadin/flow/issues/3102


          if (event.type === 'selection') {
            if (event.xAxis && event.xAxis[0]) {
              customEvent.detail.xAxisMin = event.xAxis[0].min;
              customEvent.detail.xAxisMax = event.xAxis[0].max;
            }

            if (event.yAxis && event.yAxis[0]) {
              customEvent.detail.yAxisMin = event.yAxis[0].min;
              customEvent.detail.yAxisMax = event.yAxis[0].max;
            }
          }

          if (event.type === 'click') {
            if (event.xAxis && event.xAxis[0]) {
              customEvent.detail.xValue = event.xAxis[0].value;
            }

            if (event.yAxis && event.yAxis[0]) {
              customEvent.detail.yValue = event.yAxis[0].value;
            }
          } // Workaround for https://github.com/vaadin/vaadin-charts/issues/389
          // Hook into beforePrint and beforeExport to ensure correct styling


          if (['beforePrint', 'beforeExport'].indexOf(event.type) >= 0) {
            // Guard against another print 'before print' event coming before
            // the 'after print' event.
            if (!this.tempBodyStyle) {
              let effectiveCss = '';

              if (nativeShadow) {
                const shadowStyles = self.shadowRoot.querySelectorAll('style');

                for (let i = 0; i < shadowStyles.length; i++) {
                  effectiveCss = effectiveCss + shadowStyles[i].textContent;
                } // Strip off host selectors that target individual instances


                effectiveCss = effectiveCss.replace(/:host\(.+?\)/g, match => {
                  const selector = match.substr(6, match.length - 7);
                  const matchesFn = self.matches || self.msMatchesSelector;
                  return matchesFn.call(self, selector) ? '' : match;
                });
              } else {
                effectiveCss = ScopingShim.prototype.styleAstToString(ScopingShim.prototype._styleInfoForNode(self)._getStyleRules()); // Remove the style scopes added by ShadyCSS
                // e.g. '.vaadin-chart-1 .highcharts-container.vaadin-chart'
                //   -> '.highcharts-container'
                // 1. Web Component instance scope

                const match = self.className.match(/\bvaadin-chart-\d+\b/);

                if (match) {
                  effectiveCss = effectiveCss.replace(new RegExp('\\.' + match[0], 'g'), '');
                } // 2. Web Component tag scope


                effectiveCss = effectiveCss.replace(/\.vaadin-chart/g, '');
              } // Zoom out a bit to avoid clipping the chart's edge on paper


              effectiveCss = effectiveCss + +'body {' + '    -moz-transform: scale(0.9, 0.9);' + // Mozilla
              '    zoom: 0.9;' + // Others
              '    zoom: 90%;' + // Webkit
              '}';
              this.tempBodyStyle = document.createElement('style');
              this.tempBodyStyle.textContent = effectiveCss;
              document.body.appendChild(this.tempBodyStyle);
            }
          } // Hook into afterPrint and afterExport to revert changes made before


          if (['afterPrint', 'afterExport'].indexOf(event.type) >= 0) {
            if (this.tempBodyStyle) {
              document.body.removeChild(this.tempBodyStyle);
              delete this.tempBodyStyle;
            }
          }

          self.dispatchEvent(new CustomEvent(eventList[key], customEvent));

          if (event.type === 'legendItemClick' && chart['_visibilityTogglingDisabled']) {
            return false;
          }
        };
      }
    }
  }

  __ensureObjectPath(object, path) {
    if (typeof path !== 'string') {
      return;
    }

    path = path.split('.');
    return path.reduce((obj, key) => {
      obj[key] = obj[key] || {};
      return obj[key];
    }, object);
  }

  __updateOrAddCredits(credits) {
    if (this.configuration.credits) {
      this.configuration.credits.update(credits);
    } else {
      this.configuration.addCredits(credits);
    }
  }

  __updateOrAddAxes(axes, isX) {
    if (!Array.isArray(axes)) {
      axes = [axes];
    }

    const confAxes = isX ? this.configuration.xAxis : this.configuration.yAxis;

    for (let i = 0; i < axes.length; i++) {
      const axis = axes[i];

      if (confAxes[i]) {
        confAxes[i].update(axis);
      } else {
        this.configuration.addAxis(axis, isX);
      }
    }
  }

  __updateOrAddSeries(series) {
    if (!Array.isArray(series)) {
      throw new Error('The type of jsonConfiguration.series should be Object[]');
    }

    for (let i = 0; i < series.length; i++) {
      const currentSeries = series[i];

      this.__updateOrAddSeriesInstance(currentSeries, i);
    }
  }

  __updateOrAddSeriesInstance(seriesOptions, position) {
    if (this.configuration.series[position]) {
      this.configuration.series[position].update(seriesOptions);
    } else {
      this.configuration.addSeries(seriesOptions);
    }

    return this.configuration.series[position];
  }

  __updateCategories() {
    if (!this.configuration) {
      return;
    }

    this.__updateOrAddAxes([{
      categories: this.categories
    }], true);
  }

  __updateCategoryMax() {
    if (!this.configuration) {
      return;
    }

    if (!isFinite(this.categoryMax)) {
      console.warn('<vaadin-chart> Acceptable value for "category-max" are Numbers or null');
      return;
    }

    this.__updateOrAddAxes([{
      max: this.categoryMax
    }], true);
  }

  __updateCategoryMin() {
    if (!this.configuration) {
      return;
    }

    if (!isFinite(this.categoryMin)) {
      console.warn('<vaadin-chart> Acceptable value for "category-min" are Numbers or null');
      return;
    }

    this.__updateOrAddAxes([{
      min: this.categoryMin
    }], true);
  }

  __shouldInvert() {
    // A bar chart will never be inverted, consider using a column chart.
    // See https://stackoverflow.com/questions/11235251#answer-21739793
    if (this.type === 'bar' && ['top', 'bottom'].indexOf(this.categoryPosition) >= 0) {
      console.warn(`<vaadin-chart> Acceptable "category-position" values for bar charts are
          "left" and "right". For "top" and "bottom" positions please consider using a column chart.`);
      return;
    }

    const inverted = ['left', 'right'];
    return inverted.indexOf(this.categoryPosition) >= 0;
  }

  __shouldFlipOpposite() {
    const opposite = ['top', 'right'];
    const oppositeBar = ['right'];
    return (this.type === 'bar' ? oppositeBar : opposite).indexOf(this.categoryPosition) >= 0;
  }

  __updateCategoryPosition() {
    if (!this.configuration) {
      return;
    }

    const validPositions = ['left', 'right', 'top', 'bottom'];

    if (validPositions.indexOf(this.categoryPosition) < 0) {
      console.warn(`<vaadin-chart> Acceptable "category-position" values are ${validPositions}`);
      return;
    }

    this.configuration.update({
      chart: {
        inverted: this.__shouldInvert()
      }
    });
    this.configuration.xAxis.forEach(e => e.update({
      opposite: this.__shouldFlipOpposite()
    }));
  }

  __hideLegend(newValue) {
    if (!this.configuration) {
      return;
    }

    if (this.configuration.legend) {
      this.configuration.legend.update({
        enabled: !newValue
      });
    } else {
      this.configuration.legend = {
        enabled: !newValue
      };
    }
  }

  __updateTitle(newValue) {
    if (!this.configuration) {
      return;
    }

    if (newValue && newValue.length > 0) {
      this.configuration.title.update({
        text: newValue
      });
    }
  }

  __tooltipObserver(newValue) {
    if (!this.configuration) {
      return;
    }

    this.configuration.tooltip.update({
      enabled: this.tooltip
    });
  }

  __updateType(newValue) {
    if (!this.configuration) {
      return;
    }

    if (newValue && newValue.length > 0) {
      this.configuration.update({
        chart: {
          type: newValue
        }
      });
    }
  }

  __updateSubtitle(newValue) {
    if (!this.configuration) {
      return;
    }

    if (newValue && newValue.length > 0) {
      if (!this.configuration.subtitle) {
        this.configuration.setSubtitle({
          text: newValue
        });
      } else {
        this.configuration.subtitle.update({
          text: newValue
        });
      }
    }
  }

  __updateAdditionalOptions() {
    if (this.configuration) {
      this.update(this.additionalOptions);
    }
  }

  __isStackingValid() {
    if (['normal', 'percent', null].indexOf(this.stacking) === -1) {
      this.__showWarn('stacking', '"normal", "percent" or null');

      return false;
    }

    return true;
  }

  __stackingObserver() {
    if (!this.configuration) {
      return;
    }

    if (!this.__isStackingValid()) {
      this.stacking = null;
      return;
    }

    this.configuration.update({
      plotOptions: {
        series: {
          stacking: this.stacking
        }
      }
    });
  }

  __chart3dObserver() {
    if (!this.configuration) {
      return;
    }

    if (this.chart3d) {
      this.configuration.update({
        chart: {
          options3d: Object.assign({}, this._baseChart3d, this.additionalOptions && this.additionalOptions.chart && this.additionalOptions.chart.options3d, {
            enabled: true
          })
        }
      });
    } else {
      this.configuration.update({
        chart: {
          options3d: {
            enabled: false
          }
        }
      });
    }
  }

  __polarObserver() {
    if (!this.configuration) {
      return;
    }

    this.configuration.update({
      chart: {
        polar: this.polar
      }
    });
  }

  __emptyTextObserver() {
    if (!this.configuration) {
      return;
    }

    this.configuration.update({
      lang: {
        noData: this.emptyText
      }
    });
    this.configuration.hideNoData();
    this.configuration.showNoData(this.emptyText);
  }

  __callChartFunction(functionName) {
    if (this.configuration) {
      const functionToCall = this.configuration[functionName];
      const argumentsForCall = Array.prototype.splice.call(arguments, 1);

      if (functionToCall && typeof functionToCall === 'function') {
        functionToCall.apply(this.configuration, argumentsForCall);
      }
    }
  }

  __callSeriesFunction(functionName, seriesIndex) {
    if (this.configuration && this.configuration.series[seriesIndex]) {
      const series = this.configuration.series[seriesIndex];
      const functionToCall = series[functionName];
      const argumentsForCall = Array.prototype.splice.call(arguments, 2);

      if (functionToCall && typeof functionToCall === 'function') {
        functionToCall.apply(series, argumentsForCall);
      }
    }
  }

  __callAxisFunction(functionName, axisCategory, axisIndex) {
    /*
     * axisCategory:
     * 0 - xAxis
     * 1 - yAxis
     * 2 - zAxis
     * 3 - colorAxis
     */
    if (this.configuration) {
      let axes;

      switch (axisCategory) {
        case 0:
          axes = this.configuration.xAxis;
          break;

        case 1:
          axes = this.configuration.yAxis;
          break;

        case 2:
          axes = this.configuration.zAxis;
          break;

        case 3:
          axes = this.configuration.colorAxis;
          break;
      }

      if (axes && axes[axisIndex]) {
        const axis = axes[axisIndex];
        const functionToCall = axis[functionName];
        const argumentsForCall = Array.prototype.splice.call(arguments, 3);

        if (functionToCall && typeof functionToCall === 'function') {
          functionToCall.apply(axis, argumentsForCall);
        }
      }
    }
  }

  __callPointFunction(functionName, seriesIndex, pointIndex) {
    if (this.configuration && this.configuration.series[seriesIndex] && this.configuration.series[seriesIndex].data[pointIndex]) {
      const point = this.configuration.series[seriesIndex].data[pointIndex];
      const functionToCall = point[functionName];
      const argumentsForCall = Array.prototype.splice.call(arguments, 3);

      if (functionToCall && typeof functionToCall === 'function') {
        functionToCall.apply(point, argumentsForCall);
      }
    }
  }
  /**
   * Updates chart container and current chart style property depending on flex status
   */


  __updateStyles() {
    // Chrome returns default value if property is not set
    // check if flex is defined for chart, and different than default value
    const isFlex = this._copyStyleProperties.some(property => getComputedStyle(this)[property] && getComputedStyle(this)[property] != '0 1 auto', this); // If chart element is a flexible item the chartContainer should be flex too


    if (isFlex) {
      this.$.chart.setAttribute('style', 'flex: 1; -webkit-flex: 1; -ms-flex: 1; ');
      let style = '';

      if (this.hasAttribute('style')) {
        style = this.getAttribute('style');

        if (style.charAt(style.length - 1) !== ';') {
          style += ';';
        }
      }

      style += 'display: -ms-flexbox; display: -webkit-flex; display: flex;';
      this.setAttribute('style', style);
    } else {
      this.$.chart.setAttribute('style', 'height:100%; width:100%;');
    }
  }

}

customElements.define(ChartElement.is, ChartElement);
const licenseChecker = window.Vaadin.developmentModeCallback && window.Vaadin.developmentModeCallback['vaadin-license-checker'];

if (typeof licenseChecker === 'function') {
  licenseChecker(ChartElement);
}

class StatsElement extends connect(store)(LitElement) {
  render() {
    return html`
      <div>
        <style>
          stats-element {
            display: block;
          }
        </style>

        <h2>Stats</h2>

        ${this.getChart()}
      </div>
    `;
  }

  static get properties() {
    return {
      type: {
        type: String
      },
      chartConfig: {
        type: Array
      }
    };
  }

  stateChanged(state) {
    if (state.films.length > 0) {
      this.chartConfig = [{
        name: 'Deleted',
        y: 10 - state.films.length
      }, {
        name: 'Active',
        y: state.films.length
      }];
    } // this.hasTodos = state.todos.length > 0; 

  }

  getChart() {
    return html`
        <vaadin-chart type="${this.type}">
          <vaadin-chart-series
            .values="${this.chartConfig}"
          ></vaadin-chart-series>
        </vaadin-chart>
      `;
  }

  constructor() {
    super();
    this.type = 'pie';
  }

}

customElements.define('stats-element', StatsElement);

window.addEventListener('load', () => {
  initRouter();
});

function initRouter() {
  const router = new Router(document.querySelector('main'));
  router.setRoutes([{
    path: '/',
    component: 'fetcher-element'
  }, {
    path: '/stats',
    component: 'stats-element'
  }, {
    path: '(.*)',
    component: 'not-found-view'
  }]);
}
//# sourceMappingURL=index.js.map
